(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["vendors~absences~adm.absences~adm.etudiants~adm.personnels~datatable~sadm.personnels"],{

/***/ "./node_modules/core-js/internals/array-last-index-of.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/internals/array-last-index-of.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var toInteger = __webpack_require__(/*! ../internals/to-integer */ "./node_modules/core-js/internals/to-integer.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");
var arrayMethodIsStrict = __webpack_require__(/*! ../internals/array-method-is-strict */ "./node_modules/core-js/internals/array-method-is-strict.js");
var arrayMethodUsesToLength = __webpack_require__(/*! ../internals/array-method-uses-to-length */ "./node_modules/core-js/internals/array-method-uses-to-length.js");

var min = Math.min;
var nativeLastIndexOf = [].lastIndexOf;
var NEGATIVE_ZERO = !!nativeLastIndexOf && 1 / [1].lastIndexOf(1, -0) < 0;
var STRICT_METHOD = arrayMethodIsStrict('lastIndexOf');
// For preventing possible almost infinite loop in non-standard implementations, test the forward version of the method
var USES_TO_LENGTH = arrayMethodUsesToLength('indexOf', { ACCESSORS: true, 1: 0 });
var FORCED = NEGATIVE_ZERO || !STRICT_METHOD || !USES_TO_LENGTH;

// `Array.prototype.lastIndexOf` method implementation
// https://tc39.github.io/ecma262/#sec-array.prototype.lastindexof
module.exports = FORCED ? function lastIndexOf(searchElement /* , fromIndex = @[*-1] */) {
  // convert -0 to +0
  if (NEGATIVE_ZERO) return nativeLastIndexOf.apply(this, arguments) || 0;
  var O = toIndexedObject(this);
  var length = toLength(O.length);
  var index = length - 1;
  if (arguments.length > 1) index = min(index, toInteger(arguments[1]));
  if (index < 0) index = length + index;
  for (;index >= 0; index--) if (index in O && O[index] === searchElement) return index || 0;
  return -1;
} : nativeLastIndexOf;


/***/ }),

/***/ "./node_modules/core-js/internals/array-reduce.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/array-reduce.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var aFunction = __webpack_require__(/*! ../internals/a-function */ "./node_modules/core-js/internals/a-function.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var IndexedObject = __webpack_require__(/*! ../internals/indexed-object */ "./node_modules/core-js/internals/indexed-object.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");

// `Array.prototype.{ reduce, reduceRight }` methods implementation
var createMethod = function (IS_RIGHT) {
  return function (that, callbackfn, argumentsLength, memo) {
    aFunction(callbackfn);
    var O = toObject(that);
    var self = IndexedObject(O);
    var length = toLength(O.length);
    var index = IS_RIGHT ? length - 1 : 0;
    var i = IS_RIGHT ? -1 : 1;
    if (argumentsLength < 2) while (true) {
      if (index in self) {
        memo = self[index];
        index += i;
        break;
      }
      index += i;
      if (IS_RIGHT ? index < 0 : length <= index) {
        throw TypeError('Reduce of empty array with no initial value');
      }
    }
    for (;IS_RIGHT ? index >= 0 : length > index; index += i) if (index in self) {
      memo = callbackfn(memo, self[index], index, O);
    }
    return memo;
  };
};

module.exports = {
  // `Array.prototype.reduce` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.reduce
  left: createMethod(false),
  // `Array.prototype.reduceRight` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.reduceright
  right: createMethod(true)
};


/***/ }),

/***/ "./node_modules/core-js/internals/number-parse-float.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/internals/number-parse-float.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var trim = __webpack_require__(/*! ../internals/string-trim */ "./node_modules/core-js/internals/string-trim.js").trim;
var whitespaces = __webpack_require__(/*! ../internals/whitespaces */ "./node_modules/core-js/internals/whitespaces.js");

var $parseFloat = global.parseFloat;
var FORCED = 1 / $parseFloat(whitespaces + '-0') !== -Infinity;

// `parseFloat` method
// https://tc39.github.io/ecma262/#sec-parsefloat-string
module.exports = FORCED ? function parseFloat(string) {
  var trimmedString = trim(String(string));
  var result = $parseFloat(trimmedString);
  return result === 0 && trimmedString.charAt(0) == '-' ? -0 : result;
} : $parseFloat;


/***/ }),

/***/ "./node_modules/core-js/internals/same-value.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/same-value.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// `SameValue` abstract operation
// https://tc39.github.io/ecma262/#sec-samevalue
module.exports = Object.is || function is(x, y) {
  // eslint-disable-next-line no-self-compare
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};


/***/ }),

/***/ "./node_modules/core-js/internals/string-repeat.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/string-repeat.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toInteger = __webpack_require__(/*! ../internals/to-integer */ "./node_modules/core-js/internals/to-integer.js");
var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");

// `String.prototype.repeat` method implementation
// https://tc39.github.io/ecma262/#sec-string.prototype.repeat
module.exports = ''.repeat || function repeat(count) {
  var str = String(requireObjectCoercible(this));
  var result = '';
  var n = toInteger(count);
  if (n < 0 || n == Infinity) throw RangeError('Wrong number of repetitions');
  for (;n > 0; (n >>>= 1) && (str += str)) if (n & 1) result += str;
  return result;
};


/***/ }),

/***/ "./node_modules/core-js/internals/this-number-value.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/this-number-value.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");

// `thisNumberValue` abstract operation
// https://tc39.github.io/ecma262/#sec-thisnumbervalue
module.exports = function (value) {
  if (typeof value != 'number' && classof(value) != 'Number') {
    throw TypeError('Incorrect invocation');
  }
  return +value;
};


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.last-index-of.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.last-index-of.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var lastIndexOf = __webpack_require__(/*! ../internals/array-last-index-of */ "./node_modules/core-js/internals/array-last-index-of.js");

// `Array.prototype.lastIndexOf` method
// https://tc39.github.io/ecma262/#sec-array.prototype.lastindexof
$({ target: 'Array', proto: true, forced: lastIndexOf !== [].lastIndexOf }, {
  lastIndexOf: lastIndexOf
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.reduce-right.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.reduce-right.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var $reduceRight = __webpack_require__(/*! ../internals/array-reduce */ "./node_modules/core-js/internals/array-reduce.js").right;
var arrayMethodIsStrict = __webpack_require__(/*! ../internals/array-method-is-strict */ "./node_modules/core-js/internals/array-method-is-strict.js");
var arrayMethodUsesToLength = __webpack_require__(/*! ../internals/array-method-uses-to-length */ "./node_modules/core-js/internals/array-method-uses-to-length.js");

var STRICT_METHOD = arrayMethodIsStrict('reduceRight');
// For preventing possible almost infinite loop in non-standard implementations, test the forward version of the method
var USES_TO_LENGTH = arrayMethodUsesToLength('reduce', { 1: 0 });

// `Array.prototype.reduceRight` method
// https://tc39.github.io/ecma262/#sec-array.prototype.reduceright
$({ target: 'Array', proto: true, forced: !STRICT_METHOD || !USES_TO_LENGTH }, {
  reduceRight: function reduceRight(callbackfn /* , initialValue */) {
    return $reduceRight(this, callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.reduce.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.reduce.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var $reduce = __webpack_require__(/*! ../internals/array-reduce */ "./node_modules/core-js/internals/array-reduce.js").left;
var arrayMethodIsStrict = __webpack_require__(/*! ../internals/array-method-is-strict */ "./node_modules/core-js/internals/array-method-is-strict.js");
var arrayMethodUsesToLength = __webpack_require__(/*! ../internals/array-method-uses-to-length */ "./node_modules/core-js/internals/array-method-uses-to-length.js");

var STRICT_METHOD = arrayMethodIsStrict('reduce');
var USES_TO_LENGTH = arrayMethodUsesToLength('reduce', { 1: 0 });

// `Array.prototype.reduce` method
// https://tc39.github.io/ecma262/#sec-array.prototype.reduce
$({ target: 'Array', proto: true, forced: !STRICT_METHOD || !USES_TO_LENGTH }, {
  reduce: function reduce(callbackfn /* , initialValue */) {
    return $reduce(this, callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.reverse.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.reverse.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var isArray = __webpack_require__(/*! ../internals/is-array */ "./node_modules/core-js/internals/is-array.js");

var nativeReverse = [].reverse;
var test = [1, 2];

// `Array.prototype.reverse` method
// https://tc39.github.io/ecma262/#sec-array.prototype.reverse
// fix for Safari 12.0 bug
// https://bugs.webkit.org/show_bug.cgi?id=188794
$({ target: 'Array', proto: true, forced: String(test) === String(test.reverse()) }, {
  reverse: function reverse() {
    // eslint-disable-next-line no-self-assign
    if (isArray(this)) this.length = this.length;
    return nativeReverse.call(this);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.sort.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.sort.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var aFunction = __webpack_require__(/*! ../internals/a-function */ "./node_modules/core-js/internals/a-function.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var arrayMethodIsStrict = __webpack_require__(/*! ../internals/array-method-is-strict */ "./node_modules/core-js/internals/array-method-is-strict.js");

var test = [];
var nativeSort = test.sort;

// IE8-
var FAILS_ON_UNDEFINED = fails(function () {
  test.sort(undefined);
});
// V8 bug
var FAILS_ON_NULL = fails(function () {
  test.sort(null);
});
// Old WebKit
var STRICT_METHOD = arrayMethodIsStrict('sort');

var FORCED = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD;

// `Array.prototype.sort` method
// https://tc39.github.io/ecma262/#sec-array.prototype.sort
$({ target: 'Array', proto: true, forced: FORCED }, {
  sort: function sort(comparefn) {
    return comparefn === undefined
      ? nativeSort.call(toObject(this))
      : nativeSort.call(toObject(this), aFunction(comparefn));
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.number.to-fixed.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es.number.to-fixed.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var toInteger = __webpack_require__(/*! ../internals/to-integer */ "./node_modules/core-js/internals/to-integer.js");
var thisNumberValue = __webpack_require__(/*! ../internals/this-number-value */ "./node_modules/core-js/internals/this-number-value.js");
var repeat = __webpack_require__(/*! ../internals/string-repeat */ "./node_modules/core-js/internals/string-repeat.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

var nativeToFixed = 1.0.toFixed;
var floor = Math.floor;

var pow = function (x, n, acc) {
  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
};

var log = function (x) {
  var n = 0;
  var x2 = x;
  while (x2 >= 4096) {
    n += 12;
    x2 /= 4096;
  }
  while (x2 >= 2) {
    n += 1;
    x2 /= 2;
  } return n;
};

var FORCED = nativeToFixed && (
  0.00008.toFixed(3) !== '0.000' ||
  0.9.toFixed(0) !== '1' ||
  1.255.toFixed(2) !== '1.25' ||
  1000000000000000128.0.toFixed(0) !== '1000000000000000128'
) || !fails(function () {
  // V8 ~ Android 4.3-
  nativeToFixed.call({});
});

// `Number.prototype.toFixed` method
// https://tc39.github.io/ecma262/#sec-number.prototype.tofixed
$({ target: 'Number', proto: true, forced: FORCED }, {
  // eslint-disable-next-line max-statements
  toFixed: function toFixed(fractionDigits) {
    var number = thisNumberValue(this);
    var fractDigits = toInteger(fractionDigits);
    var data = [0, 0, 0, 0, 0, 0];
    var sign = '';
    var result = '0';
    var e, z, j, k;

    var multiply = function (n, c) {
      var index = -1;
      var c2 = c;
      while (++index < 6) {
        c2 += n * data[index];
        data[index] = c2 % 1e7;
        c2 = floor(c2 / 1e7);
      }
    };

    var divide = function (n) {
      var index = 6;
      var c = 0;
      while (--index >= 0) {
        c += data[index];
        data[index] = floor(c / n);
        c = (c % n) * 1e7;
      }
    };

    var dataToString = function () {
      var index = 6;
      var s = '';
      while (--index >= 0) {
        if (s !== '' || index === 0 || data[index] !== 0) {
          var t = String(data[index]);
          s = s === '' ? t : s + repeat.call('0', 7 - t.length) + t;
        }
      } return s;
    };

    if (fractDigits < 0 || fractDigits > 20) throw RangeError('Incorrect fraction digits');
    // eslint-disable-next-line no-self-compare
    if (number != number) return 'NaN';
    if (number <= -1e21 || number >= 1e21) return String(number);
    if (number < 0) {
      sign = '-';
      number = -number;
    }
    if (number > 1e-21) {
      e = log(number * pow(2, 69, 1)) - 69;
      z = e < 0 ? number * pow(2, -e, 1) : number / pow(2, e, 1);
      z *= 0x10000000000000;
      e = 52 - e;
      if (e > 0) {
        multiply(0, z);
        j = fractDigits;
        while (j >= 7) {
          multiply(1e7, 0);
          j -= 7;
        }
        multiply(pow(10, j, 1), 0);
        j = e - 1;
        while (j >= 23) {
          divide(1 << 23);
          j -= 23;
        }
        divide(1 << j);
        multiply(1, 1);
        divide(2);
        result = dataToString();
      } else {
        multiply(0, z);
        multiply(1 << -e, 0);
        result = dataToString() + repeat.call('0', fractDigits);
      }
    }
    if (fractDigits > 0) {
      k = result.length;
      result = sign + (k <= fractDigits
        ? '0.' + repeat.call('0', fractDigits - k) + result
        : result.slice(0, k - fractDigits) + '.' + result.slice(k - fractDigits));
    } else {
      result = sign + result;
    } return result;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.parse-float.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es.parse-float.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var parseFloatImplementation = __webpack_require__(/*! ../internals/number-parse-float */ "./node_modules/core-js/internals/number-parse-float.js");

// `parseFloat` method
// https://tc39.github.io/ecma262/#sec-parsefloat-string
$({ global: true, forced: parseFloat != parseFloatImplementation }, {
  parseFloat: parseFloatImplementation
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.string.search.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es.string.search.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var fixRegExpWellKnownSymbolLogic = __webpack_require__(/*! ../internals/fix-regexp-well-known-symbol-logic */ "./node_modules/core-js/internals/fix-regexp-well-known-symbol-logic.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");
var sameValue = __webpack_require__(/*! ../internals/same-value */ "./node_modules/core-js/internals/same-value.js");
var regExpExec = __webpack_require__(/*! ../internals/regexp-exec-abstract */ "./node_modules/core-js/internals/regexp-exec-abstract.js");

// @@search logic
fixRegExpWellKnownSymbolLogic('search', 1, function (SEARCH, nativeSearch, maybeCallNative) {
  return [
    // `String.prototype.search` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.search
    function search(regexp) {
      var O = requireObjectCoercible(this);
      var searcher = regexp == undefined ? undefined : regexp[SEARCH];
      return searcher !== undefined ? searcher.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
    },
    // `RegExp.prototype[@@search]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@search
    function (regexp) {
      var res = maybeCallNative(nativeSearch, regexp, this);
      if (res.done) return res.value;

      var rx = anObject(regexp);
      var S = String(this);

      var previousLastIndex = rx.lastIndex;
      if (!sameValue(previousLastIndex, 0)) rx.lastIndex = 0;
      var result = regExpExec(rx, S);
      if (!sameValue(rx.lastIndex, previousLastIndex)) rx.lastIndex = previousLastIndex;
      return result === null ? -1 : result.index;
    }
  ];
});


/***/ }),

/***/ "./node_modules/datatables.net/js/jquery.dataTables.js":
/*!*************************************************************!*\
  !*** ./node_modules/datatables.net/js/jquery.dataTables.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! DataTables 1.10.21
 * ©2008-2020 SpryMedia Ltd - datatables.net/license
 */

/**
 * @summary     DataTables
 * @description Paginate, search and order HTML tables
 * @version     1.10.21
 * @file        jquery.dataTables.js
 * @author      SpryMedia Ltd
 * @contact     www.datatables.net
 * @copyright   Copyright 2008-2020 SpryMedia Ltd.
 *
 * This source file is free software, available under the following license:
 *   MIT license - http://datatables.net/license
 *
 * This source file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.
 *
 * For details please refer to: http://www.datatables.net
 */

/*jslint evil: true, undef: true, browser: true */
/*globals $,require,jQuery,define,_selector_run,_selector_opts,_selector_first,_selector_row_indexes,_ext,_Api,_api_register,_api_registerPlural,_re_new_lines,_re_html,_re_formatted_numeric,_re_escape_regex,_empty,_intVal,_numToDecimal,_isNumber,_isHtml,_htmlNumeric,_pluck,_pluck_order,_range,_stripHtml,_unique,_fnBuildAjax,_fnAjaxUpdate,_fnAjaxParameters,_fnAjaxUpdateDraw,_fnAjaxDataSrc,_fnAddColumn,_fnColumnOptions,_fnAdjustColumnSizing,_fnVisibleToColumnIndex,_fnColumnIndexToVisible,_fnVisbleColumns,_fnGetColumns,_fnColumnTypes,_fnApplyColumnDefs,_fnHungarianMap,_fnCamelToHungarian,_fnLanguageCompat,_fnBrowserDetect,_fnAddData,_fnAddTr,_fnNodeToDataIndex,_fnNodeToColumnIndex,_fnGetCellData,_fnSetCellData,_fnSplitObjNotation,_fnGetObjectDataFn,_fnSetObjectDataFn,_fnGetDataMaster,_fnClearTable,_fnDeleteIndex,_fnInvalidate,_fnGetRowElements,_fnCreateTr,_fnBuildHead,_fnDrawHead,_fnDraw,_fnReDraw,_fnAddOptionsHtml,_fnDetectHeader,_fnGetUniqueThs,_fnFeatureHtmlFilter,_fnFilterComplete,_fnFilterCustom,_fnFilterColumn,_fnFilter,_fnFilterCreateSearch,_fnEscapeRegex,_fnFilterData,_fnFeatureHtmlInfo,_fnUpdateInfo,_fnInfoMacros,_fnInitialise,_fnInitComplete,_fnLengthChange,_fnFeatureHtmlLength,_fnFeatureHtmlPaginate,_fnPageChange,_fnFeatureHtmlProcessing,_fnProcessingDisplay,_fnFeatureHtmlTable,_fnScrollDraw,_fnApplyToChildren,_fnCalculateColumnWidths,_fnThrottle,_fnConvertToWidth,_fnGetWidestNode,_fnGetMaxLenString,_fnStringToCss,_fnSortFlatten,_fnSort,_fnSortAria,_fnSortListener,_fnSortAttachListener,_fnSortingClasses,_fnSortData,_fnSaveState,_fnLoadState,_fnSettingsFromNode,_fnLog,_fnMap,_fnBindAction,_fnCallbackReg,_fnCallbackFire,_fnLengthOverflow,_fnRenderer,_fnDataSource,_fnRowAttributes*/

(function( factory ) {
	"use strict";

	if ( true ) {
		// AMD
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function ( $ ) {
			return factory( $, window, document );
		}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}
	else {}
}
(function( $, window, document, undefined ) {
	"use strict";

	/**
	 * DataTables is a plug-in for the jQuery Javascript library. It is a highly
	 * flexible tool, based upon the foundations of progressive enhancement,
	 * which will add advanced interaction controls to any HTML table. For a
	 * full list of features please refer to
	 * [DataTables.net](href="http://datatables.net).
	 *
	 * Note that the `DataTable` object is not a global variable but is aliased
	 * to `jQuery.fn.DataTable` and `jQuery.fn.dataTable` through which it may
	 * be  accessed.
	 *
	 *  @class
	 *  @param {object} [init={}] Configuration object for DataTables. Options
	 *    are defined by {@link DataTable.defaults}
	 *  @requires jQuery 1.7+
	 *
	 *  @example
	 *    // Basic initialisation
	 *    $(document).ready( function {
	 *      $('#example').dataTable();
	 *    } );
	 *
	 *  @example
	 *    // Initialisation with configuration options - in this case, disable
	 *    // pagination and sorting.
	 *    $(document).ready( function {
	 *      $('#example').dataTable( {
	 *        "paginate": false,
	 *        "sort": false
	 *      } );
	 *    } );
	 */
	var DataTable = function ( options )
	{
		/**
		 * Perform a jQuery selector action on the table's TR elements (from the tbody) and
		 * return the resulting jQuery object.
		 *  @param {string|node|jQuery} sSelector jQuery selector or node collection to act on
		 *  @param {object} [oOpts] Optional parameters for modifying the rows to be included
		 *  @param {string} [oOpts.filter=none] Select TR elements that meet the current filter
		 *    criterion ("applied") or all TR elements (i.e. no filter).
		 *  @param {string} [oOpts.order=current] Order of the TR elements in the processed array.
		 *    Can be either 'current', whereby the current sorting of the table is used, or
		 *    'original' whereby the original order the data was read into the table is used.
		 *  @param {string} [oOpts.page=all] Limit the selection to the currently displayed page
		 *    ("current") or not ("all"). If 'current' is given, then order is assumed to be
		 *    'current' and filter is 'applied', regardless of what they might be given as.
		 *  @returns {object} jQuery object, filtered by the given selector.
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *
		 *      // Highlight every second row
		 *      oTable.$('tr:odd').css('backgroundColor', 'blue');
		 *    } );
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *
		 *      // Filter to rows with 'Webkit' in them, add a background colour and then
		 *      // remove the filter, thus highlighting the 'Webkit' rows only.
		 *      oTable.fnFilter('Webkit');
		 *      oTable.$('tr', {"search": "applied"}).css('backgroundColor', 'blue');
		 *      oTable.fnFilter('');
		 *    } );
		 */
		this.$ = function ( sSelector, oOpts )
		{
			return this.api(true).$( sSelector, oOpts );
		};
		
		
		/**
		 * Almost identical to $ in operation, but in this case returns the data for the matched
		 * rows - as such, the jQuery selector used should match TR row nodes or TD/TH cell nodes
		 * rather than any descendants, so the data can be obtained for the row/cell. If matching
		 * rows are found, the data returned is the original data array/object that was used to
		 * create the row (or a generated array if from a DOM source).
		 *
		 * This method is often useful in-combination with $ where both functions are given the
		 * same parameters and the array indexes will match identically.
		 *  @param {string|node|jQuery} sSelector jQuery selector or node collection to act on
		 *  @param {object} [oOpts] Optional parameters for modifying the rows to be included
		 *  @param {string} [oOpts.filter=none] Select elements that meet the current filter
		 *    criterion ("applied") or all elements (i.e. no filter).
		 *  @param {string} [oOpts.order=current] Order of the data in the processed array.
		 *    Can be either 'current', whereby the current sorting of the table is used, or
		 *    'original' whereby the original order the data was read into the table is used.
		 *  @param {string} [oOpts.page=all] Limit the selection to the currently displayed page
		 *    ("current") or not ("all"). If 'current' is given, then order is assumed to be
		 *    'current' and filter is 'applied', regardless of what they might be given as.
		 *  @returns {array} Data for the matched elements. If any elements, as a result of the
		 *    selector, were not TR, TD or TH elements in the DataTable, they will have a null
		 *    entry in the array.
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *
		 *      // Get the data from the first row in the table
		 *      var data = oTable._('tr:first');
		 *
		 *      // Do something useful with the data
		 *      alert( "First cell is: "+data[0] );
		 *    } );
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *
		 *      // Filter to 'Webkit' and get all data for
		 *      oTable.fnFilter('Webkit');
		 *      var data = oTable._('tr', {"search": "applied"});
		 *
		 *      // Do something with the data
		 *      alert( data.length+" rows matched the search" );
		 *    } );
		 */
		this._ = function ( sSelector, oOpts )
		{
			return this.api(true).rows( sSelector, oOpts ).data();
		};
		
		
		/**
		 * Create a DataTables Api instance, with the currently selected tables for
		 * the Api's context.
		 * @param {boolean} [traditional=false] Set the API instance's context to be
		 *   only the table referred to by the `DataTable.ext.iApiIndex` option, as was
		 *   used in the API presented by DataTables 1.9- (i.e. the traditional mode),
		 *   or if all tables captured in the jQuery object should be used.
		 * @return {DataTables.Api}
		 */
		this.api = function ( traditional )
		{
			return traditional ?
				new _Api(
					_fnSettingsFromNode( this[ _ext.iApiIndex ] )
				) :
				new _Api( this );
		};
		
		
		/**
		 * Add a single new row or multiple rows of data to the table. Please note
		 * that this is suitable for client-side processing only - if you are using
		 * server-side processing (i.e. "bServerSide": true), then to add data, you
		 * must add it to the data source, i.e. the server-side, through an Ajax call.
		 *  @param {array|object} data The data to be added to the table. This can be:
		 *    <ul>
		 *      <li>1D array of data - add a single row with the data provided</li>
		 *      <li>2D array of arrays - add multiple rows in a single call</li>
		 *      <li>object - data object when using <i>mData</i></li>
		 *      <li>array of objects - multiple data objects when using <i>mData</i></li>
		 *    </ul>
		 *  @param {bool} [redraw=true] redraw the table or not
		 *  @returns {array} An array of integers, representing the list of indexes in
		 *    <i>aoData</i> ({@link DataTable.models.oSettings}) that have been added to
		 *    the table.
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    // Global var for counter
		 *    var giCount = 2;
		 *
		 *    $(document).ready(function() {
		 *      $('#example').dataTable();
		 *    } );
		 *
		 *    function fnClickAddRow() {
		 *      $('#example').dataTable().fnAddData( [
		 *        giCount+".1",
		 *        giCount+".2",
		 *        giCount+".3",
		 *        giCount+".4" ]
		 *      );
		 *
		 *      giCount++;
		 *    }
		 */
		this.fnAddData = function( data, redraw )
		{
			var api = this.api( true );
		
			/* Check if we want to add multiple rows or not */
			var rows = $.isArray(data) && ( $.isArray(data[0]) || $.isPlainObject(data[0]) ) ?
				api.rows.add( data ) :
				api.row.add( data );
		
			if ( redraw === undefined || redraw ) {
				api.draw();
			}
		
			return rows.flatten().toArray();
		};
		
		
		/**
		 * This function will make DataTables recalculate the column sizes, based on the data
		 * contained in the table and the sizes applied to the columns (in the DOM, CSS or
		 * through the sWidth parameter). This can be useful when the width of the table's
		 * parent element changes (for example a window resize).
		 *  @param {boolean} [bRedraw=true] Redraw the table or not, you will typically want to
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable( {
		 *        "sScrollY": "200px",
		 *        "bPaginate": false
		 *      } );
		 *
		 *      $(window).on('resize', function () {
		 *        oTable.fnAdjustColumnSizing();
		 *      } );
		 *    } );
		 */
		this.fnAdjustColumnSizing = function ( bRedraw )
		{
			var api = this.api( true ).columns.adjust();
			var settings = api.settings()[0];
			var scroll = settings.oScroll;
		
			if ( bRedraw === undefined || bRedraw ) {
				api.draw( false );
			}
			else if ( scroll.sX !== "" || scroll.sY !== "" ) {
				/* If not redrawing, but scrolling, we want to apply the new column sizes anyway */
				_fnScrollDraw( settings );
			}
		};
		
		
		/**
		 * Quickly and simply clear a table
		 *  @param {bool} [bRedraw=true] redraw the table or not
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *
		 *      // Immediately 'nuke' the current rows (perhaps waiting for an Ajax callback...)
		 *      oTable.fnClearTable();
		 *    } );
		 */
		this.fnClearTable = function( bRedraw )
		{
			var api = this.api( true ).clear();
		
			if ( bRedraw === undefined || bRedraw ) {
				api.draw();
			}
		};
		
		
		/**
		 * The exact opposite of 'opening' a row, this function will close any rows which
		 * are currently 'open'.
		 *  @param {node} nTr the table row to 'close'
		 *  @returns {int} 0 on success, or 1 if failed (can't find the row)
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable;
		 *
		 *      // 'open' an information row when a row is clicked on
		 *      $('#example tbody tr').click( function () {
		 *        if ( oTable.fnIsOpen(this) ) {
		 *          oTable.fnClose( this );
		 *        } else {
		 *          oTable.fnOpen( this, "Temporary row opened", "info_row" );
		 *        }
		 *      } );
		 *
		 *      oTable = $('#example').dataTable();
		 *    } );
		 */
		this.fnClose = function( nTr )
		{
			this.api( true ).row( nTr ).child.hide();
		};
		
		
		/**
		 * Remove a row for the table
		 *  @param {mixed} target The index of the row from aoData to be deleted, or
		 *    the TR element you want to delete
		 *  @param {function|null} [callBack] Callback function
		 *  @param {bool} [redraw=true] Redraw the table or not
		 *  @returns {array} The row that was deleted
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *
		 *      // Immediately remove the first row
		 *      oTable.fnDeleteRow( 0 );
		 *    } );
		 */
		this.fnDeleteRow = function( target, callback, redraw )
		{
			var api = this.api( true );
			var rows = api.rows( target );
			var settings = rows.settings()[0];
			var data = settings.aoData[ rows[0][0] ];
		
			rows.remove();
		
			if ( callback ) {
				callback.call( this, settings, data );
			}
		
			if ( redraw === undefined || redraw ) {
				api.draw();
			}
		
			return data;
		};
		
		
		/**
		 * Restore the table to it's original state in the DOM by removing all of DataTables
		 * enhancements, alterations to the DOM structure of the table and event listeners.
		 *  @param {boolean} [remove=false] Completely remove the table from the DOM
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      // This example is fairly pointless in reality, but shows how fnDestroy can be used
		 *      var oTable = $('#example').dataTable();
		 *      oTable.fnDestroy();
		 *    } );
		 */
		this.fnDestroy = function ( remove )
		{
			this.api( true ).destroy( remove );
		};
		
		
		/**
		 * Redraw the table
		 *  @param {bool} [complete=true] Re-filter and resort (if enabled) the table before the draw.
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *
		 *      // Re-draw the table - you wouldn't want to do it here, but it's an example :-)
		 *      oTable.fnDraw();
		 *    } );
		 */
		this.fnDraw = function( complete )
		{
			// Note that this isn't an exact match to the old call to _fnDraw - it takes
			// into account the new data, but can hold position.
			this.api( true ).draw( complete );
		};
		
		
		/**
		 * Filter the input based on data
		 *  @param {string} sInput String to filter the table on
		 *  @param {int|null} [iColumn] Column to limit filtering to
		 *  @param {bool} [bRegex=false] Treat as regular expression or not
		 *  @param {bool} [bSmart=true] Perform smart filtering or not
		 *  @param {bool} [bShowGlobal=true] Show the input global filter in it's input box(es)
		 *  @param {bool} [bCaseInsensitive=true] Do case-insensitive matching (true) or not (false)
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *
		 *      // Sometime later - filter...
		 *      oTable.fnFilter( 'test string' );
		 *    } );
		 */
		this.fnFilter = function( sInput, iColumn, bRegex, bSmart, bShowGlobal, bCaseInsensitive )
		{
			var api = this.api( true );
		
			if ( iColumn === null || iColumn === undefined ) {
				api.search( sInput, bRegex, bSmart, bCaseInsensitive );
			}
			else {
				api.column( iColumn ).search( sInput, bRegex, bSmart, bCaseInsensitive );
			}
		
			api.draw();
		};
		
		
		/**
		 * Get the data for the whole table, an individual row or an individual cell based on the
		 * provided parameters.
		 *  @param {int|node} [src] A TR row node, TD/TH cell node or an integer. If given as
		 *    a TR node then the data source for the whole row will be returned. If given as a
		 *    TD/TH cell node then iCol will be automatically calculated and the data for the
		 *    cell returned. If given as an integer, then this is treated as the aoData internal
		 *    data index for the row (see fnGetPosition) and the data for that row used.
		 *  @param {int} [col] Optional column index that you want the data of.
		 *  @returns {array|object|string} If mRow is undefined, then the data for all rows is
		 *    returned. If mRow is defined, just data for that row, and is iCol is
		 *    defined, only data for the designated cell is returned.
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    // Row data
		 *    $(document).ready(function() {
		 *      oTable = $('#example').dataTable();
		 *
		 *      oTable.$('tr').click( function () {
		 *        var data = oTable.fnGetData( this );
		 *        // ... do something with the array / object of data for the row
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Individual cell data
		 *    $(document).ready(function() {
		 *      oTable = $('#example').dataTable();
		 *
		 *      oTable.$('td').click( function () {
		 *        var sData = oTable.fnGetData( this );
		 *        alert( 'The cell clicked on had the value of '+sData );
		 *      } );
		 *    } );
		 */
		this.fnGetData = function( src, col )
		{
			var api = this.api( true );
		
			if ( src !== undefined ) {
				var type = src.nodeName ? src.nodeName.toLowerCase() : '';
		
				return col !== undefined || type == 'td' || type == 'th' ?
					api.cell( src, col ).data() :
					api.row( src ).data() || null;
			}
		
			return api.data().toArray();
		};
		
		
		/**
		 * Get an array of the TR nodes that are used in the table's body. Note that you will
		 * typically want to use the '$' API method in preference to this as it is more
		 * flexible.
		 *  @param {int} [iRow] Optional row index for the TR element you want
		 *  @returns {array|node} If iRow is undefined, returns an array of all TR elements
		 *    in the table's body, or iRow is defined, just the TR element requested.
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *
		 *      // Get the nodes from the table
		 *      var nNodes = oTable.fnGetNodes( );
		 *    } );
		 */
		this.fnGetNodes = function( iRow )
		{
			var api = this.api( true );
		
			return iRow !== undefined ?
				api.row( iRow ).node() :
				api.rows().nodes().flatten().toArray();
		};
		
		
		/**
		 * Get the array indexes of a particular cell from it's DOM element
		 * and column index including hidden columns
		 *  @param {node} node this can either be a TR, TD or TH in the table's body
		 *  @returns {int} If nNode is given as a TR, then a single index is returned, or
		 *    if given as a cell, an array of [row index, column index (visible),
		 *    column index (all)] is given.
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      $('#example tbody td').click( function () {
		 *        // Get the position of the current data from the node
		 *        var aPos = oTable.fnGetPosition( this );
		 *
		 *        // Get the data array for this row
		 *        var aData = oTable.fnGetData( aPos[0] );
		 *
		 *        // Update the data array and return the value
		 *        aData[ aPos[1] ] = 'clicked';
		 *        this.innerHTML = 'clicked';
		 *      } );
		 *
		 *      // Init DataTables
		 *      oTable = $('#example').dataTable();
		 *    } );
		 */
		this.fnGetPosition = function( node )
		{
			var api = this.api( true );
			var nodeName = node.nodeName.toUpperCase();
		
			if ( nodeName == 'TR' ) {
				return api.row( node ).index();
			}
			else if ( nodeName == 'TD' || nodeName == 'TH' ) {
				var cell = api.cell( node ).index();
		
				return [
					cell.row,
					cell.columnVisible,
					cell.column
				];
			}
			return null;
		};
		
		
		/**
		 * Check to see if a row is 'open' or not.
		 *  @param {node} nTr the table row to check
		 *  @returns {boolean} true if the row is currently open, false otherwise
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable;
		 *
		 *      // 'open' an information row when a row is clicked on
		 *      $('#example tbody tr').click( function () {
		 *        if ( oTable.fnIsOpen(this) ) {
		 *          oTable.fnClose( this );
		 *        } else {
		 *          oTable.fnOpen( this, "Temporary row opened", "info_row" );
		 *        }
		 *      } );
		 *
		 *      oTable = $('#example').dataTable();
		 *    } );
		 */
		this.fnIsOpen = function( nTr )
		{
			return this.api( true ).row( nTr ).child.isShown();
		};
		
		
		/**
		 * This function will place a new row directly after a row which is currently
		 * on display on the page, with the HTML contents that is passed into the
		 * function. This can be used, for example, to ask for confirmation that a
		 * particular record should be deleted.
		 *  @param {node} nTr The table row to 'open'
		 *  @param {string|node|jQuery} mHtml The HTML to put into the row
		 *  @param {string} sClass Class to give the new TD cell
		 *  @returns {node} The row opened. Note that if the table row passed in as the
		 *    first parameter, is not found in the table, this method will silently
		 *    return.
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable;
		 *
		 *      // 'open' an information row when a row is clicked on
		 *      $('#example tbody tr').click( function () {
		 *        if ( oTable.fnIsOpen(this) ) {
		 *          oTable.fnClose( this );
		 *        } else {
		 *          oTable.fnOpen( this, "Temporary row opened", "info_row" );
		 *        }
		 *      } );
		 *
		 *      oTable = $('#example').dataTable();
		 *    } );
		 */
		this.fnOpen = function( nTr, mHtml, sClass )
		{
			return this.api( true )
				.row( nTr )
				.child( mHtml, sClass )
				.show()
				.child()[0];
		};
		
		
		/**
		 * Change the pagination - provides the internal logic for pagination in a simple API
		 * function. With this function you can have a DataTables table go to the next,
		 * previous, first or last pages.
		 *  @param {string|int} mAction Paging action to take: "first", "previous", "next" or "last"
		 *    or page number to jump to (integer), note that page 0 is the first page.
		 *  @param {bool} [bRedraw=true] Redraw the table or not
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *      oTable.fnPageChange( 'next' );
		 *    } );
		 */
		this.fnPageChange = function ( mAction, bRedraw )
		{
			var api = this.api( true ).page( mAction );
		
			if ( bRedraw === undefined || bRedraw ) {
				api.draw(false);
			}
		};
		
		
		/**
		 * Show a particular column
		 *  @param {int} iCol The column whose display should be changed
		 *  @param {bool} bShow Show (true) or hide (false) the column
		 *  @param {bool} [bRedraw=true] Redraw the table or not
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *
		 *      // Hide the second column after initialisation
		 *      oTable.fnSetColumnVis( 1, false );
		 *    } );
		 */
		this.fnSetColumnVis = function ( iCol, bShow, bRedraw )
		{
			var api = this.api( true ).column( iCol ).visible( bShow );
		
			if ( bRedraw === undefined || bRedraw ) {
				api.columns.adjust().draw();
			}
		};
		
		
		/**
		 * Get the settings for a particular table for external manipulation
		 *  @returns {object} DataTables settings object. See
		 *    {@link DataTable.models.oSettings}
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *      var oSettings = oTable.fnSettings();
		 *
		 *      // Show an example parameter from the settings
		 *      alert( oSettings._iDisplayStart );
		 *    } );
		 */
		this.fnSettings = function()
		{
			return _fnSettingsFromNode( this[_ext.iApiIndex] );
		};
		
		
		/**
		 * Sort the table by a particular column
		 *  @param {int} iCol the data index to sort on. Note that this will not match the
		 *    'display index' if you have hidden data entries
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *
		 *      // Sort immediately with columns 0 and 1
		 *      oTable.fnSort( [ [0,'asc'], [1,'asc'] ] );
		 *    } );
		 */
		this.fnSort = function( aaSort )
		{
			this.api( true ).order( aaSort ).draw();
		};
		
		
		/**
		 * Attach a sort listener to an element for a given column
		 *  @param {node} nNode the element to attach the sort listener to
		 *  @param {int} iColumn the column that a click on this node will sort on
		 *  @param {function} [fnCallback] callback function when sort is run
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *
		 *      // Sort on column 1, when 'sorter' is clicked on
		 *      oTable.fnSortListener( document.getElementById('sorter'), 1 );
		 *    } );
		 */
		this.fnSortListener = function( nNode, iColumn, fnCallback )
		{
			this.api( true ).order.listener( nNode, iColumn, fnCallback );
		};
		
		
		/**
		 * Update a table cell or row - this method will accept either a single value to
		 * update the cell with, an array of values with one element for each column or
		 * an object in the same format as the original data source. The function is
		 * self-referencing in order to make the multi column updates easier.
		 *  @param {object|array|string} mData Data to update the cell/row with
		 *  @param {node|int} mRow TR element you want to update or the aoData index
		 *  @param {int} [iColumn] The column to update, give as null or undefined to
		 *    update a whole row.
		 *  @param {bool} [bRedraw=true] Redraw the table or not
		 *  @param {bool} [bAction=true] Perform pre-draw actions or not
		 *  @returns {int} 0 on success, 1 on error
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *      oTable.fnUpdate( 'Example update', 0, 0 ); // Single cell
		 *      oTable.fnUpdate( ['a', 'b', 'c', 'd', 'e'], $('tbody tr')[0] ); // Row
		 *    } );
		 */
		this.fnUpdate = function( mData, mRow, iColumn, bRedraw, bAction )
		{
			var api = this.api( true );
		
			if ( iColumn === undefined || iColumn === null ) {
				api.row( mRow ).data( mData );
			}
			else {
				api.cell( mRow, iColumn ).data( mData );
			}
		
			if ( bAction === undefined || bAction ) {
				api.columns.adjust();
			}
		
			if ( bRedraw === undefined || bRedraw ) {
				api.draw();
			}
			return 0;
		};
		
		
		/**
		 * Provide a common method for plug-ins to check the version of DataTables being used, in order
		 * to ensure compatibility.
		 *  @param {string} sVersion Version string to check for, in the format "X.Y.Z". Note that the
		 *    formats "X" and "X.Y" are also acceptable.
		 *  @returns {boolean} true if this version of DataTables is greater or equal to the required
		 *    version, or false if this version of DataTales is not suitable
		 *  @method
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *      alert( oTable.fnVersionCheck( '1.9.0' ) );
		 *    } );
		 */
		this.fnVersionCheck = _ext.fnVersionCheck;
		

		var _that = this;
		var emptyInit = options === undefined;
		var len = this.length;

		if ( emptyInit ) {
			options = {};
		}

		this.oApi = this.internal = _ext.internal;

		// Extend with old style plug-in API methods
		for ( var fn in DataTable.ext.internal ) {
			if ( fn ) {
				this[fn] = _fnExternApiFunc(fn);
			}
		}

		this.each(function() {
			// For each initialisation we want to give it a clean initialisation
			// object that can be bashed around
			var o = {};
			var oInit = len > 1 ? // optimisation for single table case
				_fnExtend( o, options, true ) :
				options;

			/*global oInit,_that,emptyInit*/
			var i=0, iLen, j, jLen, k, kLen;
			var sId = this.getAttribute( 'id' );
			var bInitHandedOff = false;
			var defaults = DataTable.defaults;
			var $this = $(this);
			
			
			/* Sanity check */
			if ( this.nodeName.toLowerCase() != 'table' )
			{
				_fnLog( null, 0, 'Non-table node initialisation ('+this.nodeName+')', 2 );
				return;
			}
			
			/* Backwards compatibility for the defaults */
			_fnCompatOpts( defaults );
			_fnCompatCols( defaults.column );
			
			/* Convert the camel-case defaults to Hungarian */
			_fnCamelToHungarian( defaults, defaults, true );
			_fnCamelToHungarian( defaults.column, defaults.column, true );
			
			/* Setting up the initialisation object */
			_fnCamelToHungarian( defaults, $.extend( oInit, $this.data() ), true );
			
			
			
			/* Check to see if we are re-initialising a table */
			var allSettings = DataTable.settings;
			for ( i=0, iLen=allSettings.length ; i<iLen ; i++ )
			{
				var s = allSettings[i];
			
				/* Base check on table node */
				if (
					s.nTable == this ||
					(s.nTHead && s.nTHead.parentNode == this) ||
					(s.nTFoot && s.nTFoot.parentNode == this)
				) {
					var bRetrieve = oInit.bRetrieve !== undefined ? oInit.bRetrieve : defaults.bRetrieve;
					var bDestroy = oInit.bDestroy !== undefined ? oInit.bDestroy : defaults.bDestroy;
			
					if ( emptyInit || bRetrieve )
					{
						return s.oInstance;
					}
					else if ( bDestroy )
					{
						s.oInstance.fnDestroy();
						break;
					}
					else
					{
						_fnLog( s, 0, 'Cannot reinitialise DataTable', 3 );
						return;
					}
				}
			
				/* If the element we are initialising has the same ID as a table which was previously
				 * initialised, but the table nodes don't match (from before) then we destroy the old
				 * instance by simply deleting it. This is under the assumption that the table has been
				 * destroyed by other methods. Anyone using non-id selectors will need to do this manually
				 */
				if ( s.sTableId == this.id )
				{
					allSettings.splice( i, 1 );
					break;
				}
			}
			
			/* Ensure the table has an ID - required for accessibility */
			if ( sId === null || sId === "" )
			{
				sId = "DataTables_Table_"+(DataTable.ext._unique++);
				this.id = sId;
			}
			
			/* Create the settings object for this table and set some of the default parameters */
			var oSettings = $.extend( true, {}, DataTable.models.oSettings, {
				"sDestroyWidth": $this[0].style.width,
				"sInstance":     sId,
				"sTableId":      sId
			} );
			oSettings.nTable = this;
			oSettings.oApi   = _that.internal;
			oSettings.oInit  = oInit;
			
			allSettings.push( oSettings );
			
			// Need to add the instance after the instance after the settings object has been added
			// to the settings array, so we can self reference the table instance if more than one
			oSettings.oInstance = (_that.length===1) ? _that : $this.dataTable();
			
			// Backwards compatibility, before we apply all the defaults
			_fnCompatOpts( oInit );
			_fnLanguageCompat( oInit.oLanguage );
			
			// If the length menu is given, but the init display length is not, use the length menu
			if ( oInit.aLengthMenu && ! oInit.iDisplayLength )
			{
				oInit.iDisplayLength = $.isArray( oInit.aLengthMenu[0] ) ?
					oInit.aLengthMenu[0][0] : oInit.aLengthMenu[0];
			}
			
			// Apply the defaults and init options to make a single init object will all
			// options defined from defaults and instance options.
			oInit = _fnExtend( $.extend( true, {}, defaults ), oInit );
			
			
			// Map the initialisation options onto the settings object
			_fnMap( oSettings.oFeatures, oInit, [
				"bPaginate",
				"bLengthChange",
				"bFilter",
				"bSort",
				"bSortMulti",
				"bInfo",
				"bProcessing",
				"bAutoWidth",
				"bSortClasses",
				"bServerSide",
				"bDeferRender"
			] );
			_fnMap( oSettings, oInit, [
				"asStripeClasses",
				"ajax",
				"fnServerData",
				"fnFormatNumber",
				"sServerMethod",
				"aaSorting",
				"aaSortingFixed",
				"aLengthMenu",
				"sPaginationType",
				"sAjaxSource",
				"sAjaxDataProp",
				"iStateDuration",
				"sDom",
				"bSortCellsTop",
				"iTabIndex",
				"fnStateLoadCallback",
				"fnStateSaveCallback",
				"renderer",
				"searchDelay",
				"rowId",
				[ "iCookieDuration", "iStateDuration" ], // backwards compat
				[ "oSearch", "oPreviousSearch" ],
				[ "aoSearchCols", "aoPreSearchCols" ],
				[ "iDisplayLength", "_iDisplayLength" ]
			] );
			_fnMap( oSettings.oScroll, oInit, [
				[ "sScrollX", "sX" ],
				[ "sScrollXInner", "sXInner" ],
				[ "sScrollY", "sY" ],
				[ "bScrollCollapse", "bCollapse" ]
			] );
			_fnMap( oSettings.oLanguage, oInit, "fnInfoCallback" );
			
			/* Callback functions which are array driven */
			_fnCallbackReg( oSettings, 'aoDrawCallback',       oInit.fnDrawCallback,      'user' );
			_fnCallbackReg( oSettings, 'aoServerParams',       oInit.fnServerParams,      'user' );
			_fnCallbackReg( oSettings, 'aoStateSaveParams',    oInit.fnStateSaveParams,   'user' );
			_fnCallbackReg( oSettings, 'aoStateLoadParams',    oInit.fnStateLoadParams,   'user' );
			_fnCallbackReg( oSettings, 'aoStateLoaded',        oInit.fnStateLoaded,       'user' );
			_fnCallbackReg( oSettings, 'aoRowCallback',        oInit.fnRowCallback,       'user' );
			_fnCallbackReg( oSettings, 'aoRowCreatedCallback', oInit.fnCreatedRow,        'user' );
			_fnCallbackReg( oSettings, 'aoHeaderCallback',     oInit.fnHeaderCallback,    'user' );
			_fnCallbackReg( oSettings, 'aoFooterCallback',     oInit.fnFooterCallback,    'user' );
			_fnCallbackReg( oSettings, 'aoInitComplete',       oInit.fnInitComplete,      'user' );
			_fnCallbackReg( oSettings, 'aoPreDrawCallback',    oInit.fnPreDrawCallback,   'user' );
			
			oSettings.rowIdFn = _fnGetObjectDataFn( oInit.rowId );
			
			/* Browser support detection */
			_fnBrowserDetect( oSettings );
			
			var oClasses = oSettings.oClasses;
			
			$.extend( oClasses, DataTable.ext.classes, oInit.oClasses );
			$this.addClass( oClasses.sTable );
			
			
			if ( oSettings.iInitDisplayStart === undefined )
			{
				/* Display start point, taking into account the save saving */
				oSettings.iInitDisplayStart = oInit.iDisplayStart;
				oSettings._iDisplayStart = oInit.iDisplayStart;
			}
			
			if ( oInit.iDeferLoading !== null )
			{
				oSettings.bDeferLoading = true;
				var tmp = $.isArray( oInit.iDeferLoading );
				oSettings._iRecordsDisplay = tmp ? oInit.iDeferLoading[0] : oInit.iDeferLoading;
				oSettings._iRecordsTotal = tmp ? oInit.iDeferLoading[1] : oInit.iDeferLoading;
			}
			
			/* Language definitions */
			var oLanguage = oSettings.oLanguage;
			$.extend( true, oLanguage, oInit.oLanguage );
			
			if ( oLanguage.sUrl )
			{
				/* Get the language definitions from a file - because this Ajax call makes the language
				 * get async to the remainder of this function we use bInitHandedOff to indicate that
				 * _fnInitialise will be fired by the returned Ajax handler, rather than the constructor
				 */
				$.ajax( {
					dataType: 'json',
					url: oLanguage.sUrl,
					success: function ( json ) {
						_fnLanguageCompat( json );
						_fnCamelToHungarian( defaults.oLanguage, json );
						$.extend( true, oLanguage, json );
						_fnInitialise( oSettings );
					},
					error: function () {
						// Error occurred loading language file, continue on as best we can
						_fnInitialise( oSettings );
					}
				} );
				bInitHandedOff = true;
			}
			
			/*
			 * Stripes
			 */
			if ( oInit.asStripeClasses === null )
			{
				oSettings.asStripeClasses =[
					oClasses.sStripeOdd,
					oClasses.sStripeEven
				];
			}
			
			/* Remove row stripe classes if they are already on the table row */
			var stripeClasses = oSettings.asStripeClasses;
			var rowOne = $this.children('tbody').find('tr').eq(0);
			if ( $.inArray( true, $.map( stripeClasses, function(el, i) {
				return rowOne.hasClass(el);
			} ) ) !== -1 ) {
				$('tbody tr', this).removeClass( stripeClasses.join(' ') );
				oSettings.asDestroyStripes = stripeClasses.slice();
			}
			
			/*
			 * Columns
			 * See if we should load columns automatically or use defined ones
			 */
			var anThs = [];
			var aoColumnsInit;
			var nThead = this.getElementsByTagName('thead');
			if ( nThead.length !== 0 )
			{
				_fnDetectHeader( oSettings.aoHeader, nThead[0] );
				anThs = _fnGetUniqueThs( oSettings );
			}
			
			/* If not given a column array, generate one with nulls */
			if ( oInit.aoColumns === null )
			{
				aoColumnsInit = [];
				for ( i=0, iLen=anThs.length ; i<iLen ; i++ )
				{
					aoColumnsInit.push( null );
				}
			}
			else
			{
				aoColumnsInit = oInit.aoColumns;
			}
			
			/* Add the columns */
			for ( i=0, iLen=aoColumnsInit.length ; i<iLen ; i++ )
			{
				_fnAddColumn( oSettings, anThs ? anThs[i] : null );
			}
			
			/* Apply the column definitions */
			_fnApplyColumnDefs( oSettings, oInit.aoColumnDefs, aoColumnsInit, function (iCol, oDef) {
				_fnColumnOptions( oSettings, iCol, oDef );
			} );
			
			/* HTML5 attribute detection - build an mData object automatically if the
			 * attributes are found
			 */
			if ( rowOne.length ) {
				var a = function ( cell, name ) {
					return cell.getAttribute( 'data-'+name ) !== null ? name : null;
				};
			
				$( rowOne[0] ).children('th, td').each( function (i, cell) {
					var col = oSettings.aoColumns[i];
			
					if ( col.mData === i ) {
						var sort = a( cell, 'sort' ) || a( cell, 'order' );
						var filter = a( cell, 'filter' ) || a( cell, 'search' );
			
						if ( sort !== null || filter !== null ) {
							col.mData = {
								_:      i+'.display',
								sort:   sort !== null   ? i+'.@data-'+sort   : undefined,
								type:   sort !== null   ? i+'.@data-'+sort   : undefined,
								filter: filter !== null ? i+'.@data-'+filter : undefined
							};
			
							_fnColumnOptions( oSettings, i );
						}
					}
				} );
			}
			
			var features = oSettings.oFeatures;
			var loadedInit = function () {
				/*
				 * Sorting
				 * @todo For modularisation (1.11) this needs to do into a sort start up handler
				 */
			
				// If aaSorting is not defined, then we use the first indicator in asSorting
				// in case that has been altered, so the default sort reflects that option
				if ( oInit.aaSorting === undefined ) {
					var sorting = oSettings.aaSorting;
					for ( i=0, iLen=sorting.length ; i<iLen ; i++ ) {
						sorting[i][1] = oSettings.aoColumns[ i ].asSorting[0];
					}
				}
			
				/* Do a first pass on the sorting classes (allows any size changes to be taken into
				 * account, and also will apply sorting disabled classes if disabled
				 */
				_fnSortingClasses( oSettings );
			
				if ( features.bSort ) {
					_fnCallbackReg( oSettings, 'aoDrawCallback', function () {
						if ( oSettings.bSorted ) {
							var aSort = _fnSortFlatten( oSettings );
							var sortedColumns = {};
			
							$.each( aSort, function (i, val) {
								sortedColumns[ val.src ] = val.dir;
							} );
			
							_fnCallbackFire( oSettings, null, 'order', [oSettings, aSort, sortedColumns] );
							_fnSortAria( oSettings );
						}
					} );
				}
			
				_fnCallbackReg( oSettings, 'aoDrawCallback', function () {
					if ( oSettings.bSorted || _fnDataSource( oSettings ) === 'ssp' || features.bDeferRender ) {
						_fnSortingClasses( oSettings );
					}
				}, 'sc' );
			
			
				/*
				 * Final init
				 * Cache the header, body and footer as required, creating them if needed
				 */
			
				// Work around for Webkit bug 83867 - store the caption-side before removing from doc
				var captions = $this.children('caption').each( function () {
					this._captionSide = $(this).css('caption-side');
				} );
			
				var thead = $this.children('thead');
				if ( thead.length === 0 ) {
					thead = $('<thead/>').appendTo($this);
				}
				oSettings.nTHead = thead[0];
			
				var tbody = $this.children('tbody');
				if ( tbody.length === 0 ) {
					tbody = $('<tbody/>').appendTo($this);
				}
				oSettings.nTBody = tbody[0];
			
				var tfoot = $this.children('tfoot');
				if ( tfoot.length === 0 && captions.length > 0 && (oSettings.oScroll.sX !== "" || oSettings.oScroll.sY !== "") ) {
					// If we are a scrolling table, and no footer has been given, then we need to create
					// a tfoot element for the caption element to be appended to
					tfoot = $('<tfoot/>').appendTo($this);
				}
			
				if ( tfoot.length === 0 || tfoot.children().length === 0 ) {
					$this.addClass( oClasses.sNoFooter );
				}
				else if ( tfoot.length > 0 ) {
					oSettings.nTFoot = tfoot[0];
					_fnDetectHeader( oSettings.aoFooter, oSettings.nTFoot );
				}
			
				/* Check if there is data passing into the constructor */
				if ( oInit.aaData ) {
					for ( i=0 ; i<oInit.aaData.length ; i++ ) {
						_fnAddData( oSettings, oInit.aaData[ i ] );
					}
				}
				else if ( oSettings.bDeferLoading || _fnDataSource( oSettings ) == 'dom' ) {
					/* Grab the data from the page - only do this when deferred loading or no Ajax
					 * source since there is no point in reading the DOM data if we are then going
					 * to replace it with Ajax data
					 */
					_fnAddTr( oSettings, $(oSettings.nTBody).children('tr') );
				}
			
				/* Copy the data index array */
				oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();
			
				/* Initialisation complete - table can be drawn */
				oSettings.bInitialised = true;
			
				/* Check if we need to initialise the table (it might not have been handed off to the
				 * language processor)
				 */
				if ( bInitHandedOff === false ) {
					_fnInitialise( oSettings );
				}
			};
			
			/* Must be done after everything which can be overridden by the state saving! */
			if ( oInit.bStateSave )
			{
				features.bStateSave = true;
				_fnCallbackReg( oSettings, 'aoDrawCallback', _fnSaveState, 'state_save' );
				_fnLoadState( oSettings, oInit, loadedInit );
			}
			else {
				loadedInit();
			}
			
		} );
		_that = null;
		return this;
	};

	
	/*
	 * It is useful to have variables which are scoped locally so only the
	 * DataTables functions can access them and they don't leak into global space.
	 * At the same time these functions are often useful over multiple files in the
	 * core and API, so we list, or at least document, all variables which are used
	 * by DataTables as private variables here. This also ensures that there is no
	 * clashing of variable names and that they can easily referenced for reuse.
	 */
	
	
	// Defined else where
	//  _selector_run
	//  _selector_opts
	//  _selector_first
	//  _selector_row_indexes
	
	var _ext; // DataTable.ext
	var _Api; // DataTable.Api
	var _api_register; // DataTable.Api.register
	var _api_registerPlural; // DataTable.Api.registerPlural
	
	var _re_dic = {};
	var _re_new_lines = /[\r\n\u2028]/g;
	var _re_html = /<.*?>/g;
	
	// This is not strict ISO8601 - Date.parse() is quite lax, although
	// implementations differ between browsers.
	var _re_date = /^\d{2,4}[\.\/\-]\d{1,2}[\.\/\-]\d{1,2}([T ]{1}\d{1,2}[:\.]\d{2}([\.:]\d{2})?)?$/;
	
	// Escape regular expression special characters
	var _re_escape_regex = new RegExp( '(\\' + [ '/', '.', '*', '+', '?', '|', '(', ')', '[', ']', '{', '}', '\\', '$', '^', '-' ].join('|\\') + ')', 'g' );
	
	// http://en.wikipedia.org/wiki/Foreign_exchange_market
	// - \u20BD - Russian ruble.
	// - \u20a9 - South Korean Won
	// - \u20BA - Turkish Lira
	// - \u20B9 - Indian Rupee
	// - R - Brazil (R$) and South Africa
	// - fr - Swiss Franc
	// - kr - Swedish krona, Norwegian krone and Danish krone
	// - \u2009 is thin space and \u202F is narrow no-break space, both used in many
	// - Ƀ - Bitcoin
	// - Ξ - Ethereum
	//   standards as thousands separators.
	var _re_formatted_numeric = /[',$£€¥%\u2009\u202F\u20BD\u20a9\u20BArfkɃΞ]/gi;
	
	
	var _empty = function ( d ) {
		return !d || d === true || d === '-' ? true : false;
	};
	
	
	var _intVal = function ( s ) {
		var integer = parseInt( s, 10 );
		return !isNaN(integer) && isFinite(s) ? integer : null;
	};
	
	// Convert from a formatted number with characters other than `.` as the
	// decimal place, to a Javascript number
	var _numToDecimal = function ( num, decimalPoint ) {
		// Cache created regular expressions for speed as this function is called often
		if ( ! _re_dic[ decimalPoint ] ) {
			_re_dic[ decimalPoint ] = new RegExp( _fnEscapeRegex( decimalPoint ), 'g' );
		}
		return typeof num === 'string' && decimalPoint !== '.' ?
			num.replace( /\./g, '' ).replace( _re_dic[ decimalPoint ], '.' ) :
			num;
	};
	
	
	var _isNumber = function ( d, decimalPoint, formatted ) {
		var strType = typeof d === 'string';
	
		// If empty return immediately so there must be a number if it is a
		// formatted string (this stops the string "k", or "kr", etc being detected
		// as a formatted number for currency
		if ( _empty( d ) ) {
			return true;
		}
	
		if ( decimalPoint && strType ) {
			d = _numToDecimal( d, decimalPoint );
		}
	
		if ( formatted && strType ) {
			d = d.replace( _re_formatted_numeric, '' );
		}
	
		return !isNaN( parseFloat(d) ) && isFinite( d );
	};
	
	
	// A string without HTML in it can be considered to be HTML still
	var _isHtml = function ( d ) {
		return _empty( d ) || typeof d === 'string';
	};
	
	
	var _htmlNumeric = function ( d, decimalPoint, formatted ) {
		if ( _empty( d ) ) {
			return true;
		}
	
		var html = _isHtml( d );
		return ! html ?
			null :
			_isNumber( _stripHtml( d ), decimalPoint, formatted ) ?
				true :
				null;
	};
	
	
	var _pluck = function ( a, prop, prop2 ) {
		var out = [];
		var i=0, ien=a.length;
	
		// Could have the test in the loop for slightly smaller code, but speed
		// is essential here
		if ( prop2 !== undefined ) {
			for ( ; i<ien ; i++ ) {
				if ( a[i] && a[i][ prop ] ) {
					out.push( a[i][ prop ][ prop2 ] );
				}
			}
		}
		else {
			for ( ; i<ien ; i++ ) {
				if ( a[i] ) {
					out.push( a[i][ prop ] );
				}
			}
		}
	
		return out;
	};
	
	
	// Basically the same as _pluck, but rather than looping over `a` we use `order`
	// as the indexes to pick from `a`
	var _pluck_order = function ( a, order, prop, prop2 )
	{
		var out = [];
		var i=0, ien=order.length;
	
		// Could have the test in the loop for slightly smaller code, but speed
		// is essential here
		if ( prop2 !== undefined ) {
			for ( ; i<ien ; i++ ) {
				if ( a[ order[i] ][ prop ] ) {
					out.push( a[ order[i] ][ prop ][ prop2 ] );
				}
			}
		}
		else {
			for ( ; i<ien ; i++ ) {
				out.push( a[ order[i] ][ prop ] );
			}
		}
	
		return out;
	};
	
	
	var _range = function ( len, start )
	{
		var out = [];
		var end;
	
		if ( start === undefined ) {
			start = 0;
			end = len;
		}
		else {
			end = start;
			start = len;
		}
	
		for ( var i=start ; i<end ; i++ ) {
			out.push( i );
		}
	
		return out;
	};
	
	
	var _removeEmpty = function ( a )
	{
		var out = [];
	
		for ( var i=0, ien=a.length ; i<ien ; i++ ) {
			if ( a[i] ) { // careful - will remove all falsy values!
				out.push( a[i] );
			}
		}
	
		return out;
	};
	
	
	var _stripHtml = function ( d ) {
		return d.replace( _re_html, '' );
	};
	
	
	/**
	 * Determine if all values in the array are unique. This means we can short
	 * cut the _unique method at the cost of a single loop. A sorted array is used
	 * to easily check the values.
	 *
	 * @param  {array} src Source array
	 * @return {boolean} true if all unique, false otherwise
	 * @ignore
	 */
	var _areAllUnique = function ( src ) {
		if ( src.length < 2 ) {
			return true;
		}
	
		var sorted = src.slice().sort();
		var last = sorted[0];
	
		for ( var i=1, ien=sorted.length ; i<ien ; i++ ) {
			if ( sorted[i] === last ) {
				return false;
			}
	
			last = sorted[i];
		}
	
		return true;
	};
	
	
	/**
	 * Find the unique elements in a source array.
	 *
	 * @param  {array} src Source array
	 * @return {array} Array of unique items
	 * @ignore
	 */
	var _unique = function ( src )
	{
		if ( _areAllUnique( src ) ) {
			return src.slice();
		}
	
		// A faster unique method is to use object keys to identify used values,
		// but this doesn't work with arrays or objects, which we must also
		// consider. See jsperf.com/compare-array-unique-versions/4 for more
		// information.
		var
			out = [],
			val,
			i, ien=src.length,
			j, k=0;
	
		again: for ( i=0 ; i<ien ; i++ ) {
			val = src[i];
	
			for ( j=0 ; j<k ; j++ ) {
				if ( out[j] === val ) {
					continue again;
				}
			}
	
			out.push( val );
			k++;
		}
	
		return out;
	};
	
	
	/**
	 * DataTables utility methods
	 * 
	 * This namespace provides helper methods that DataTables uses internally to
	 * create a DataTable, but which are not exclusively used only for DataTables.
	 * These methods can be used by extension authors to save the duplication of
	 * code.
	 *
	 *  @namespace
	 */
	DataTable.util = {
		/**
		 * Throttle the calls to a function. Arguments and context are maintained
		 * for the throttled function.
		 *
		 * @param {function} fn Function to be called
		 * @param {integer} freq Call frequency in mS
		 * @return {function} Wrapped function
		 */
		throttle: function ( fn, freq ) {
			var
				frequency = freq !== undefined ? freq : 200,
				last,
				timer;
	
			return function () {
				var
					that = this,
					now  = +new Date(),
					args = arguments;
	
				if ( last && now < last + frequency ) {
					clearTimeout( timer );
	
					timer = setTimeout( function () {
						last = undefined;
						fn.apply( that, args );
					}, frequency );
				}
				else {
					last = now;
					fn.apply( that, args );
				}
			};
		},
	
	
		/**
		 * Escape a string such that it can be used in a regular expression
		 *
		 *  @param {string} val string to escape
		 *  @returns {string} escaped string
		 */
		escapeRegex: function ( val ) {
			return val.replace( _re_escape_regex, '\\$1' );
		}
	};
	
	
	
	/**
	 * Create a mapping object that allows camel case parameters to be looked up
	 * for their Hungarian counterparts. The mapping is stored in a private
	 * parameter called `_hungarianMap` which can be accessed on the source object.
	 *  @param {object} o
	 *  @memberof DataTable#oApi
	 */
	function _fnHungarianMap ( o )
	{
		var
			hungarian = 'a aa ai ao as b fn i m o s ',
			match,
			newKey,
			map = {};
	
		$.each( o, function (key, val) {
			match = key.match(/^([^A-Z]+?)([A-Z])/);
	
			if ( match && hungarian.indexOf(match[1]+' ') !== -1 )
			{
				newKey = key.replace( match[0], match[2].toLowerCase() );
				map[ newKey ] = key;
	
				if ( match[1] === 'o' )
				{
					_fnHungarianMap( o[key] );
				}
			}
		} );
	
		o._hungarianMap = map;
	}
	
	
	/**
	 * Convert from camel case parameters to Hungarian, based on a Hungarian map
	 * created by _fnHungarianMap.
	 *  @param {object} src The model object which holds all parameters that can be
	 *    mapped.
	 *  @param {object} user The object to convert from camel case to Hungarian.
	 *  @param {boolean} force When set to `true`, properties which already have a
	 *    Hungarian value in the `user` object will be overwritten. Otherwise they
	 *    won't be.
	 *  @memberof DataTable#oApi
	 */
	function _fnCamelToHungarian ( src, user, force )
	{
		if ( ! src._hungarianMap ) {
			_fnHungarianMap( src );
		}
	
		var hungarianKey;
	
		$.each( user, function (key, val) {
			hungarianKey = src._hungarianMap[ key ];
	
			if ( hungarianKey !== undefined && (force || user[hungarianKey] === undefined) )
			{
				// For objects, we need to buzz down into the object to copy parameters
				if ( hungarianKey.charAt(0) === 'o' )
				{
					// Copy the camelCase options over to the hungarian
					if ( ! user[ hungarianKey ] ) {
						user[ hungarianKey ] = {};
					}
					$.extend( true, user[hungarianKey], user[key] );
	
					_fnCamelToHungarian( src[hungarianKey], user[hungarianKey], force );
				}
				else {
					user[hungarianKey] = user[ key ];
				}
			}
		} );
	}
	
	
	/**
	 * Language compatibility - when certain options are given, and others aren't, we
	 * need to duplicate the values over, in order to provide backwards compatibility
	 * with older language files.
	 *  @param {object} oSettings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnLanguageCompat( lang )
	{
		// Note the use of the Hungarian notation for the parameters in this method as
		// this is called after the mapping of camelCase to Hungarian
		var defaults = DataTable.defaults.oLanguage;
	
		// Default mapping
		var defaultDecimal = defaults.sDecimal;
		if ( defaultDecimal ) {
			_addNumericSort( defaultDecimal );
		}
	
		if ( lang ) {
			var zeroRecords = lang.sZeroRecords;
	
			// Backwards compatibility - if there is no sEmptyTable given, then use the same as
			// sZeroRecords - assuming that is given.
			if ( ! lang.sEmptyTable && zeroRecords &&
				defaults.sEmptyTable === "No data available in table" )
			{
				_fnMap( lang, lang, 'sZeroRecords', 'sEmptyTable' );
			}
	
			// Likewise with loading records
			if ( ! lang.sLoadingRecords && zeroRecords &&
				defaults.sLoadingRecords === "Loading..." )
			{
				_fnMap( lang, lang, 'sZeroRecords', 'sLoadingRecords' );
			}
	
			// Old parameter name of the thousands separator mapped onto the new
			if ( lang.sInfoThousands ) {
				lang.sThousands = lang.sInfoThousands;
			}
	
			var decimal = lang.sDecimal;
			if ( decimal && defaultDecimal !== decimal ) {
				_addNumericSort( decimal );
			}
		}
	}
	
	
	/**
	 * Map one parameter onto another
	 *  @param {object} o Object to map
	 *  @param {*} knew The new parameter name
	 *  @param {*} old The old parameter name
	 */
	var _fnCompatMap = function ( o, knew, old ) {
		if ( o[ knew ] !== undefined ) {
			o[ old ] = o[ knew ];
		}
	};
	
	
	/**
	 * Provide backwards compatibility for the main DT options. Note that the new
	 * options are mapped onto the old parameters, so this is an external interface
	 * change only.
	 *  @param {object} init Object to map
	 */
	function _fnCompatOpts ( init )
	{
		_fnCompatMap( init, 'ordering',      'bSort' );
		_fnCompatMap( init, 'orderMulti',    'bSortMulti' );
		_fnCompatMap( init, 'orderClasses',  'bSortClasses' );
		_fnCompatMap( init, 'orderCellsTop', 'bSortCellsTop' );
		_fnCompatMap( init, 'order',         'aaSorting' );
		_fnCompatMap( init, 'orderFixed',    'aaSortingFixed' );
		_fnCompatMap( init, 'paging',        'bPaginate' );
		_fnCompatMap( init, 'pagingType',    'sPaginationType' );
		_fnCompatMap( init, 'pageLength',    'iDisplayLength' );
		_fnCompatMap( init, 'searching',     'bFilter' );
	
		// Boolean initialisation of x-scrolling
		if ( typeof init.sScrollX === 'boolean' ) {
			init.sScrollX = init.sScrollX ? '100%' : '';
		}
		if ( typeof init.scrollX === 'boolean' ) {
			init.scrollX = init.scrollX ? '100%' : '';
		}
	
		// Column search objects are in an array, so it needs to be converted
		// element by element
		var searchCols = init.aoSearchCols;
	
		if ( searchCols ) {
			for ( var i=0, ien=searchCols.length ; i<ien ; i++ ) {
				if ( searchCols[i] ) {
					_fnCamelToHungarian( DataTable.models.oSearch, searchCols[i] );
				}
			}
		}
	}
	
	
	/**
	 * Provide backwards compatibility for column options. Note that the new options
	 * are mapped onto the old parameters, so this is an external interface change
	 * only.
	 *  @param {object} init Object to map
	 */
	function _fnCompatCols ( init )
	{
		_fnCompatMap( init, 'orderable',     'bSortable' );
		_fnCompatMap( init, 'orderData',     'aDataSort' );
		_fnCompatMap( init, 'orderSequence', 'asSorting' );
		_fnCompatMap( init, 'orderDataType', 'sortDataType' );
	
		// orderData can be given as an integer
		var dataSort = init.aDataSort;
		if ( typeof dataSort === 'number' && ! $.isArray( dataSort ) ) {
			init.aDataSort = [ dataSort ];
		}
	}
	
	
	/**
	 * Browser feature detection for capabilities, quirks
	 *  @param {object} settings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnBrowserDetect( settings )
	{
		// We don't need to do this every time DataTables is constructed, the values
		// calculated are specific to the browser and OS configuration which we
		// don't expect to change between initialisations
		if ( ! DataTable.__browser ) {
			var browser = {};
			DataTable.__browser = browser;
	
			// Scrolling feature / quirks detection
			var n = $('<div/>')
				.css( {
					position: 'fixed',
					top: 0,
					left: $(window).scrollLeft()*-1, // allow for scrolling
					height: 1,
					width: 1,
					overflow: 'hidden'
				} )
				.append(
					$('<div/>')
						.css( {
							position: 'absolute',
							top: 1,
							left: 1,
							width: 100,
							overflow: 'scroll'
						} )
						.append(
							$('<div/>')
								.css( {
									width: '100%',
									height: 10
								} )
						)
				)
				.appendTo( 'body' );
	
			var outer = n.children();
			var inner = outer.children();
	
			// Numbers below, in order, are:
			// inner.offsetWidth, inner.clientWidth, outer.offsetWidth, outer.clientWidth
			//
			// IE6 XP:                           100 100 100  83
			// IE7 Vista:                        100 100 100  83
			// IE 8+ Windows:                     83  83 100  83
			// Evergreen Windows:                 83  83 100  83
			// Evergreen Mac with scrollbars:     85  85 100  85
			// Evergreen Mac without scrollbars: 100 100 100 100
	
			// Get scrollbar width
			browser.barWidth = outer[0].offsetWidth - outer[0].clientWidth;
	
			// IE6/7 will oversize a width 100% element inside a scrolling element, to
			// include the width of the scrollbar, while other browsers ensure the inner
			// element is contained without forcing scrolling
			browser.bScrollOversize = inner[0].offsetWidth === 100 && outer[0].clientWidth !== 100;
	
			// In rtl text layout, some browsers (most, but not all) will place the
			// scrollbar on the left, rather than the right.
			browser.bScrollbarLeft = Math.round( inner.offset().left ) !== 1;
	
			// IE8- don't provide height and width for getBoundingClientRect
			browser.bBounding = n[0].getBoundingClientRect().width ? true : false;
	
			n.remove();
		}
	
		$.extend( settings.oBrowser, DataTable.__browser );
		settings.oScroll.iBarWidth = DataTable.__browser.barWidth;
	}
	
	
	/**
	 * Array.prototype reduce[Right] method, used for browsers which don't support
	 * JS 1.6. Done this way to reduce code size, since we iterate either way
	 *  @param {object} settings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnReduce ( that, fn, init, start, end, inc )
	{
		var
			i = start,
			value,
			isSet = false;
	
		if ( init !== undefined ) {
			value = init;
			isSet = true;
		}
	
		while ( i !== end ) {
			if ( ! that.hasOwnProperty(i) ) {
				continue;
			}
	
			value = isSet ?
				fn( value, that[i], i, that ) :
				that[i];
	
			isSet = true;
			i += inc;
		}
	
		return value;
	}
	
	/**
	 * Add a column to the list used for the table with default values
	 *  @param {object} oSettings dataTables settings object
	 *  @param {node} nTh The th element for this column
	 *  @memberof DataTable#oApi
	 */
	function _fnAddColumn( oSettings, nTh )
	{
		// Add column to aoColumns array
		var oDefaults = DataTable.defaults.column;
		var iCol = oSettings.aoColumns.length;
		var oCol = $.extend( {}, DataTable.models.oColumn, oDefaults, {
			"nTh": nTh ? nTh : document.createElement('th'),
			"sTitle":    oDefaults.sTitle    ? oDefaults.sTitle    : nTh ? nTh.innerHTML : '',
			"aDataSort": oDefaults.aDataSort ? oDefaults.aDataSort : [iCol],
			"mData": oDefaults.mData ? oDefaults.mData : iCol,
			idx: iCol
		} );
		oSettings.aoColumns.push( oCol );
	
		// Add search object for column specific search. Note that the `searchCols[ iCol ]`
		// passed into extend can be undefined. This allows the user to give a default
		// with only some of the parameters defined, and also not give a default
		var searchCols = oSettings.aoPreSearchCols;
		searchCols[ iCol ] = $.extend( {}, DataTable.models.oSearch, searchCols[ iCol ] );
	
		// Use the default column options function to initialise classes etc
		_fnColumnOptions( oSettings, iCol, $(nTh).data() );
	}
	
	
	/**
	 * Apply options for a column
	 *  @param {object} oSettings dataTables settings object
	 *  @param {int} iCol column index to consider
	 *  @param {object} oOptions object with sType, bVisible and bSearchable etc
	 *  @memberof DataTable#oApi
	 */
	function _fnColumnOptions( oSettings, iCol, oOptions )
	{
		var oCol = oSettings.aoColumns[ iCol ];
		var oClasses = oSettings.oClasses;
		var th = $(oCol.nTh);
	
		// Try to get width information from the DOM. We can't get it from CSS
		// as we'd need to parse the CSS stylesheet. `width` option can override
		if ( ! oCol.sWidthOrig ) {
			// Width attribute
			oCol.sWidthOrig = th.attr('width') || null;
	
			// Style attribute
			var t = (th.attr('style') || '').match(/width:\s*(\d+[pxem%]+)/);
			if ( t ) {
				oCol.sWidthOrig = t[1];
			}
		}
	
		/* User specified column options */
		if ( oOptions !== undefined && oOptions !== null )
		{
			// Backwards compatibility
			_fnCompatCols( oOptions );
	
			// Map camel case parameters to their Hungarian counterparts
			_fnCamelToHungarian( DataTable.defaults.column, oOptions, true );
	
			/* Backwards compatibility for mDataProp */
			if ( oOptions.mDataProp !== undefined && !oOptions.mData )
			{
				oOptions.mData = oOptions.mDataProp;
			}
	
			if ( oOptions.sType )
			{
				oCol._sManualType = oOptions.sType;
			}
	
			// `class` is a reserved word in Javascript, so we need to provide
			// the ability to use a valid name for the camel case input
			if ( oOptions.className && ! oOptions.sClass )
			{
				oOptions.sClass = oOptions.className;
			}
			if ( oOptions.sClass ) {
				th.addClass( oOptions.sClass );
			}
	
			$.extend( oCol, oOptions );
			_fnMap( oCol, oOptions, "sWidth", "sWidthOrig" );
	
			/* iDataSort to be applied (backwards compatibility), but aDataSort will take
			 * priority if defined
			 */
			if ( oOptions.iDataSort !== undefined )
			{
				oCol.aDataSort = [ oOptions.iDataSort ];
			}
			_fnMap( oCol, oOptions, "aDataSort" );
		}
	
		/* Cache the data get and set functions for speed */
		var mDataSrc = oCol.mData;
		var mData = _fnGetObjectDataFn( mDataSrc );
		var mRender = oCol.mRender ? _fnGetObjectDataFn( oCol.mRender ) : null;
	
		var attrTest = function( src ) {
			return typeof src === 'string' && src.indexOf('@') !== -1;
		};
		oCol._bAttrSrc = $.isPlainObject( mDataSrc ) && (
			attrTest(mDataSrc.sort) || attrTest(mDataSrc.type) || attrTest(mDataSrc.filter)
		);
		oCol._setter = null;
	
		oCol.fnGetData = function (rowData, type, meta) {
			var innerData = mData( rowData, type, undefined, meta );
	
			return mRender && type ?
				mRender( innerData, type, rowData, meta ) :
				innerData;
		};
		oCol.fnSetData = function ( rowData, val, meta ) {
			return _fnSetObjectDataFn( mDataSrc )( rowData, val, meta );
		};
	
		// Indicate if DataTables should read DOM data as an object or array
		// Used in _fnGetRowElements
		if ( typeof mDataSrc !== 'number' ) {
			oSettings._rowReadObject = true;
		}
	
		/* Feature sorting overrides column specific when off */
		if ( !oSettings.oFeatures.bSort )
		{
			oCol.bSortable = false;
			th.addClass( oClasses.sSortableNone ); // Have to add class here as order event isn't called
		}
	
		/* Check that the class assignment is correct for sorting */
		var bAsc = $.inArray('asc', oCol.asSorting) !== -1;
		var bDesc = $.inArray('desc', oCol.asSorting) !== -1;
		if ( !oCol.bSortable || (!bAsc && !bDesc) )
		{
			oCol.sSortingClass = oClasses.sSortableNone;
			oCol.sSortingClassJUI = "";
		}
		else if ( bAsc && !bDesc )
		{
			oCol.sSortingClass = oClasses.sSortableAsc;
			oCol.sSortingClassJUI = oClasses.sSortJUIAscAllowed;
		}
		else if ( !bAsc && bDesc )
		{
			oCol.sSortingClass = oClasses.sSortableDesc;
			oCol.sSortingClassJUI = oClasses.sSortJUIDescAllowed;
		}
		else
		{
			oCol.sSortingClass = oClasses.sSortable;
			oCol.sSortingClassJUI = oClasses.sSortJUI;
		}
	}
	
	
	/**
	 * Adjust the table column widths for new data. Note: you would probably want to
	 * do a redraw after calling this function!
	 *  @param {object} settings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnAdjustColumnSizing ( settings )
	{
		/* Not interested in doing column width calculation if auto-width is disabled */
		if ( settings.oFeatures.bAutoWidth !== false )
		{
			var columns = settings.aoColumns;
	
			_fnCalculateColumnWidths( settings );
			for ( var i=0 , iLen=columns.length ; i<iLen ; i++ )
			{
				columns[i].nTh.style.width = columns[i].sWidth;
			}
		}
	
		var scroll = settings.oScroll;
		if ( scroll.sY !== '' || scroll.sX !== '')
		{
			_fnScrollDraw( settings );
		}
	
		_fnCallbackFire( settings, null, 'column-sizing', [settings] );
	}
	
	
	/**
	 * Covert the index of a visible column to the index in the data array (take account
	 * of hidden columns)
	 *  @param {object} oSettings dataTables settings object
	 *  @param {int} iMatch Visible column index to lookup
	 *  @returns {int} i the data index
	 *  @memberof DataTable#oApi
	 */
	function _fnVisibleToColumnIndex( oSettings, iMatch )
	{
		var aiVis = _fnGetColumns( oSettings, 'bVisible' );
	
		return typeof aiVis[iMatch] === 'number' ?
			aiVis[iMatch] :
			null;
	}
	
	
	/**
	 * Covert the index of an index in the data array and convert it to the visible
	 *   column index (take account of hidden columns)
	 *  @param {int} iMatch Column index to lookup
	 *  @param {object} oSettings dataTables settings object
	 *  @returns {int} i the data index
	 *  @memberof DataTable#oApi
	 */
	function _fnColumnIndexToVisible( oSettings, iMatch )
	{
		var aiVis = _fnGetColumns( oSettings, 'bVisible' );
		var iPos = $.inArray( iMatch, aiVis );
	
		return iPos !== -1 ? iPos : null;
	}
	
	
	/**
	 * Get the number of visible columns
	 *  @param {object} oSettings dataTables settings object
	 *  @returns {int} i the number of visible columns
	 *  @memberof DataTable#oApi
	 */
	function _fnVisbleColumns( oSettings )
	{
		var vis = 0;
	
		// No reduce in IE8, use a loop for now
		$.each( oSettings.aoColumns, function ( i, col ) {
			if ( col.bVisible && $(col.nTh).css('display') !== 'none' ) {
				vis++;
			}
		} );
	
		return vis;
	}
	
	
	/**
	 * Get an array of column indexes that match a given property
	 *  @param {object} oSettings dataTables settings object
	 *  @param {string} sParam Parameter in aoColumns to look for - typically
	 *    bVisible or bSearchable
	 *  @returns {array} Array of indexes with matched properties
	 *  @memberof DataTable#oApi
	 */
	function _fnGetColumns( oSettings, sParam )
	{
		var a = [];
	
		$.map( oSettings.aoColumns, function(val, i) {
			if ( val[sParam] ) {
				a.push( i );
			}
		} );
	
		return a;
	}
	
	
	/**
	 * Calculate the 'type' of a column
	 *  @param {object} settings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnColumnTypes ( settings )
	{
		var columns = settings.aoColumns;
		var data = settings.aoData;
		var types = DataTable.ext.type.detect;
		var i, ien, j, jen, k, ken;
		var col, cell, detectedType, cache;
	
		// For each column, spin over the 
		for ( i=0, ien=columns.length ; i<ien ; i++ ) {
			col = columns[i];
			cache = [];
	
			if ( ! col.sType && col._sManualType ) {
				col.sType = col._sManualType;
			}
			else if ( ! col.sType ) {
				for ( j=0, jen=types.length ; j<jen ; j++ ) {
					for ( k=0, ken=data.length ; k<ken ; k++ ) {
						// Use a cache array so we only need to get the type data
						// from the formatter once (when using multiple detectors)
						if ( cache[k] === undefined ) {
							cache[k] = _fnGetCellData( settings, k, i, 'type' );
						}
	
						detectedType = types[j]( cache[k], settings );
	
						// If null, then this type can't apply to this column, so
						// rather than testing all cells, break out. There is an
						// exception for the last type which is `html`. We need to
						// scan all rows since it is possible to mix string and HTML
						// types
						if ( ! detectedType && j !== types.length-1 ) {
							break;
						}
	
						// Only a single match is needed for html type since it is
						// bottom of the pile and very similar to string
						if ( detectedType === 'html' ) {
							break;
						}
					}
	
					// Type is valid for all data points in the column - use this
					// type
					if ( detectedType ) {
						col.sType = detectedType;
						break;
					}
				}
	
				// Fall back - if no type was detected, always use string
				if ( ! col.sType ) {
					col.sType = 'string';
				}
			}
		}
	}
	
	
	/**
	 * Take the column definitions and static columns arrays and calculate how
	 * they relate to column indexes. The callback function will then apply the
	 * definition found for a column to a suitable configuration object.
	 *  @param {object} oSettings dataTables settings object
	 *  @param {array} aoColDefs The aoColumnDefs array that is to be applied
	 *  @param {array} aoCols The aoColumns array that defines columns individually
	 *  @param {function} fn Callback function - takes two parameters, the calculated
	 *    column index and the definition for that column.
	 *  @memberof DataTable#oApi
	 */
	function _fnApplyColumnDefs( oSettings, aoColDefs, aoCols, fn )
	{
		var i, iLen, j, jLen, k, kLen, def;
		var columns = oSettings.aoColumns;
	
		// Column definitions with aTargets
		if ( aoColDefs )
		{
			/* Loop over the definitions array - loop in reverse so first instance has priority */
			for ( i=aoColDefs.length-1 ; i>=0 ; i-- )
			{
				def = aoColDefs[i];
	
				/* Each definition can target multiple columns, as it is an array */
				var aTargets = def.targets !== undefined ?
					def.targets :
					def.aTargets;
	
				if ( ! $.isArray( aTargets ) )
				{
					aTargets = [ aTargets ];
				}
	
				for ( j=0, jLen=aTargets.length ; j<jLen ; j++ )
				{
					if ( typeof aTargets[j] === 'number' && aTargets[j] >= 0 )
					{
						/* Add columns that we don't yet know about */
						while( columns.length <= aTargets[j] )
						{
							_fnAddColumn( oSettings );
						}
	
						/* Integer, basic index */
						fn( aTargets[j], def );
					}
					else if ( typeof aTargets[j] === 'number' && aTargets[j] < 0 )
					{
						/* Negative integer, right to left column counting */
						fn( columns.length+aTargets[j], def );
					}
					else if ( typeof aTargets[j] === 'string' )
					{
						/* Class name matching on TH element */
						for ( k=0, kLen=columns.length ; k<kLen ; k++ )
						{
							if ( aTargets[j] == "_all" ||
							     $(columns[k].nTh).hasClass( aTargets[j] ) )
							{
								fn( k, def );
							}
						}
					}
				}
			}
		}
	
		// Statically defined columns array
		if ( aoCols )
		{
			for ( i=0, iLen=aoCols.length ; i<iLen ; i++ )
			{
				fn( i, aoCols[i] );
			}
		}
	}
	
	/**
	 * Add a data array to the table, creating DOM node etc. This is the parallel to
	 * _fnGatherData, but for adding rows from a Javascript source, rather than a
	 * DOM source.
	 *  @param {object} oSettings dataTables settings object
	 *  @param {array} aData data array to be added
	 *  @param {node} [nTr] TR element to add to the table - optional. If not given,
	 *    DataTables will create a row automatically
	 *  @param {array} [anTds] Array of TD|TH elements for the row - must be given
	 *    if nTr is.
	 *  @returns {int} >=0 if successful (index of new aoData entry), -1 if failed
	 *  @memberof DataTable#oApi
	 */
	function _fnAddData ( oSettings, aDataIn, nTr, anTds )
	{
		/* Create the object for storing information about this new row */
		var iRow = oSettings.aoData.length;
		var oData = $.extend( true, {}, DataTable.models.oRow, {
			src: nTr ? 'dom' : 'data',
			idx: iRow
		} );
	
		oData._aData = aDataIn;
		oSettings.aoData.push( oData );
	
		/* Create the cells */
		var nTd, sThisType;
		var columns = oSettings.aoColumns;
	
		// Invalidate the column types as the new data needs to be revalidated
		for ( var i=0, iLen=columns.length ; i<iLen ; i++ )
		{
			columns[i].sType = null;
		}
	
		/* Add to the display array */
		oSettings.aiDisplayMaster.push( iRow );
	
		var id = oSettings.rowIdFn( aDataIn );
		if ( id !== undefined ) {
			oSettings.aIds[ id ] = oData;
		}
	
		/* Create the DOM information, or register it if already present */
		if ( nTr || ! oSettings.oFeatures.bDeferRender )
		{
			_fnCreateTr( oSettings, iRow, nTr, anTds );
		}
	
		return iRow;
	}
	
	
	/**
	 * Add one or more TR elements to the table. Generally we'd expect to
	 * use this for reading data from a DOM sourced table, but it could be
	 * used for an TR element. Note that if a TR is given, it is used (i.e.
	 * it is not cloned).
	 *  @param {object} settings dataTables settings object
	 *  @param {array|node|jQuery} trs The TR element(s) to add to the table
	 *  @returns {array} Array of indexes for the added rows
	 *  @memberof DataTable#oApi
	 */
	function _fnAddTr( settings, trs )
	{
		var row;
	
		// Allow an individual node to be passed in
		if ( ! (trs instanceof $) ) {
			trs = $(trs);
		}
	
		return trs.map( function (i, el) {
			row = _fnGetRowElements( settings, el );
			return _fnAddData( settings, row.data, el, row.cells );
		} );
	}
	
	
	/**
	 * Take a TR element and convert it to an index in aoData
	 *  @param {object} oSettings dataTables settings object
	 *  @param {node} n the TR element to find
	 *  @returns {int} index if the node is found, null if not
	 *  @memberof DataTable#oApi
	 */
	function _fnNodeToDataIndex( oSettings, n )
	{
		return (n._DT_RowIndex!==undefined) ? n._DT_RowIndex : null;
	}
	
	
	/**
	 * Take a TD element and convert it into a column data index (not the visible index)
	 *  @param {object} oSettings dataTables settings object
	 *  @param {int} iRow The row number the TD/TH can be found in
	 *  @param {node} n The TD/TH element to find
	 *  @returns {int} index if the node is found, -1 if not
	 *  @memberof DataTable#oApi
	 */
	function _fnNodeToColumnIndex( oSettings, iRow, n )
	{
		return $.inArray( n, oSettings.aoData[ iRow ].anCells );
	}
	
	
	/**
	 * Get the data for a given cell from the internal cache, taking into account data mapping
	 *  @param {object} settings dataTables settings object
	 *  @param {int} rowIdx aoData row id
	 *  @param {int} colIdx Column index
	 *  @param {string} type data get type ('display', 'type' 'filter' 'sort')
	 *  @returns {*} Cell data
	 *  @memberof DataTable#oApi
	 */
	function _fnGetCellData( settings, rowIdx, colIdx, type )
	{
		var draw           = settings.iDraw;
		var col            = settings.aoColumns[colIdx];
		var rowData        = settings.aoData[rowIdx]._aData;
		var defaultContent = col.sDefaultContent;
		var cellData       = col.fnGetData( rowData, type, {
			settings: settings,
			row:      rowIdx,
			col:      colIdx
		} );
	
		if ( cellData === undefined ) {
			if ( settings.iDrawError != draw && defaultContent === null ) {
				_fnLog( settings, 0, "Requested unknown parameter "+
					(typeof col.mData=='function' ? '{function}' : "'"+col.mData+"'")+
					" for row "+rowIdx+", column "+colIdx, 4 );
				settings.iDrawError = draw;
			}
			return defaultContent;
		}
	
		// When the data source is null and a specific data type is requested (i.e.
		// not the original data), we can use default column data
		if ( (cellData === rowData || cellData === null) && defaultContent !== null && type !== undefined ) {
			cellData = defaultContent;
		}
		else if ( typeof cellData === 'function' ) {
			// If the data source is a function, then we run it and use the return,
			// executing in the scope of the data object (for instances)
			return cellData.call( rowData );
		}
	
		if ( cellData === null && type == 'display' ) {
			return '';
		}
		return cellData;
	}
	
	
	/**
	 * Set the value for a specific cell, into the internal data cache
	 *  @param {object} settings dataTables settings object
	 *  @param {int} rowIdx aoData row id
	 *  @param {int} colIdx Column index
	 *  @param {*} val Value to set
	 *  @memberof DataTable#oApi
	 */
	function _fnSetCellData( settings, rowIdx, colIdx, val )
	{
		var col     = settings.aoColumns[colIdx];
		var rowData = settings.aoData[rowIdx]._aData;
	
		col.fnSetData( rowData, val, {
			settings: settings,
			row:      rowIdx,
			col:      colIdx
		}  );
	}
	
	
	// Private variable that is used to match action syntax in the data property object
	var __reArray = /\[.*?\]$/;
	var __reFn = /\(\)$/;
	
	/**
	 * Split string on periods, taking into account escaped periods
	 * @param  {string} str String to split
	 * @return {array} Split string
	 */
	function _fnSplitObjNotation( str )
	{
		return $.map( str.match(/(\\.|[^\.])+/g) || [''], function ( s ) {
			return s.replace(/\\\./g, '.');
		} );
	}
	
	
	/**
	 * Return a function that can be used to get data from a source object, taking
	 * into account the ability to use nested objects as a source
	 *  @param {string|int|function} mSource The data source for the object
	 *  @returns {function} Data get function
	 *  @memberof DataTable#oApi
	 */
	function _fnGetObjectDataFn( mSource )
	{
		if ( $.isPlainObject( mSource ) )
		{
			/* Build an object of get functions, and wrap them in a single call */
			var o = {};
			$.each( mSource, function (key, val) {
				if ( val ) {
					o[key] = _fnGetObjectDataFn( val );
				}
			} );
	
			return function (data, type, row, meta) {
				var t = o[type] || o._;
				return t !== undefined ?
					t(data, type, row, meta) :
					data;
			};
		}
		else if ( mSource === null )
		{
			/* Give an empty string for rendering / sorting etc */
			return function (data) { // type, row and meta also passed, but not used
				return data;
			};
		}
		else if ( typeof mSource === 'function' )
		{
			return function (data, type, row, meta) {
				return mSource( data, type, row, meta );
			};
		}
		else if ( typeof mSource === 'string' && (mSource.indexOf('.') !== -1 ||
			      mSource.indexOf('[') !== -1 || mSource.indexOf('(') !== -1) )
		{
			/* If there is a . in the source string then the data source is in a
			 * nested object so we loop over the data for each level to get the next
			 * level down. On each loop we test for undefined, and if found immediately
			 * return. This allows entire objects to be missing and sDefaultContent to
			 * be used if defined, rather than throwing an error
			 */
			var fetchData = function (data, type, src) {
				var arrayNotation, funcNotation, out, innerSrc;
	
				if ( src !== "" )
				{
					var a = _fnSplitObjNotation( src );
	
					for ( var i=0, iLen=a.length ; i<iLen ; i++ )
					{
						// Check if we are dealing with special notation
						arrayNotation = a[i].match(__reArray);
						funcNotation = a[i].match(__reFn);
	
						if ( arrayNotation )
						{
							// Array notation
							a[i] = a[i].replace(__reArray, '');
	
							// Condition allows simply [] to be passed in
							if ( a[i] !== "" ) {
								data = data[ a[i] ];
							}
							out = [];
	
							// Get the remainder of the nested object to get
							a.splice( 0, i+1 );
							innerSrc = a.join('.');
	
							// Traverse each entry in the array getting the properties requested
							if ( $.isArray( data ) ) {
								for ( var j=0, jLen=data.length ; j<jLen ; j++ ) {
									out.push( fetchData( data[j], type, innerSrc ) );
								}
							}
	
							// If a string is given in between the array notation indicators, that
							// is used to join the strings together, otherwise an array is returned
							var join = arrayNotation[0].substring(1, arrayNotation[0].length-1);
							data = (join==="") ? out : out.join(join);
	
							// The inner call to fetchData has already traversed through the remainder
							// of the source requested, so we exit from the loop
							break;
						}
						else if ( funcNotation )
						{
							// Function call
							a[i] = a[i].replace(__reFn, '');
							data = data[ a[i] ]();
							continue;
						}
	
						if ( data === null || data[ a[i] ] === undefined )
						{
							return undefined;
						}
						data = data[ a[i] ];
					}
				}
	
				return data;
			};
	
			return function (data, type) { // row and meta also passed, but not used
				return fetchData( data, type, mSource );
			};
		}
		else
		{
			/* Array or flat object mapping */
			return function (data, type) { // row and meta also passed, but not used
				return data[mSource];
			};
		}
	}
	
	
	/**
	 * Return a function that can be used to set data from a source object, taking
	 * into account the ability to use nested objects as a source
	 *  @param {string|int|function} mSource The data source for the object
	 *  @returns {function} Data set function
	 *  @memberof DataTable#oApi
	 */
	function _fnSetObjectDataFn( mSource )
	{
		if ( $.isPlainObject( mSource ) )
		{
			/* Unlike get, only the underscore (global) option is used for for
			 * setting data since we don't know the type here. This is why an object
			 * option is not documented for `mData` (which is read/write), but it is
			 * for `mRender` which is read only.
			 */
			return _fnSetObjectDataFn( mSource._ );
		}
		else if ( mSource === null )
		{
			/* Nothing to do when the data source is null */
			return function () {};
		}
		else if ( typeof mSource === 'function' )
		{
			return function (data, val, meta) {
				mSource( data, 'set', val, meta );
			};
		}
		else if ( typeof mSource === 'string' && (mSource.indexOf('.') !== -1 ||
			      mSource.indexOf('[') !== -1 || mSource.indexOf('(') !== -1) )
		{
			/* Like the get, we need to get data from a nested object */
			var setData = function (data, val, src) {
				var a = _fnSplitObjNotation( src ), b;
				var aLast = a[a.length-1];
				var arrayNotation, funcNotation, o, innerSrc;
	
				for ( var i=0, iLen=a.length-1 ; i<iLen ; i++ )
				{
					// Check if we are dealing with an array notation request
					arrayNotation = a[i].match(__reArray);
					funcNotation = a[i].match(__reFn);
	
					if ( arrayNotation )
					{
						a[i] = a[i].replace(__reArray, '');
						data[ a[i] ] = [];
	
						// Get the remainder of the nested object to set so we can recurse
						b = a.slice();
						b.splice( 0, i+1 );
						innerSrc = b.join('.');
	
						// Traverse each entry in the array setting the properties requested
						if ( $.isArray( val ) )
						{
							for ( var j=0, jLen=val.length ; j<jLen ; j++ )
							{
								o = {};
								setData( o, val[j], innerSrc );
								data[ a[i] ].push( o );
							}
						}
						else
						{
							// We've been asked to save data to an array, but it
							// isn't array data to be saved. Best that can be done
							// is to just save the value.
							data[ a[i] ] = val;
						}
	
						// The inner call to setData has already traversed through the remainder
						// of the source and has set the data, thus we can exit here
						return;
					}
					else if ( funcNotation )
					{
						// Function call
						a[i] = a[i].replace(__reFn, '');
						data = data[ a[i] ]( val );
					}
	
					// If the nested object doesn't currently exist - since we are
					// trying to set the value - create it
					if ( data[ a[i] ] === null || data[ a[i] ] === undefined )
					{
						data[ a[i] ] = {};
					}
					data = data[ a[i] ];
				}
	
				// Last item in the input - i.e, the actual set
				if ( aLast.match(__reFn ) )
				{
					// Function call
					data = data[ aLast.replace(__reFn, '') ]( val );
				}
				else
				{
					// If array notation is used, we just want to strip it and use the property name
					// and assign the value. If it isn't used, then we get the result we want anyway
					data[ aLast.replace(__reArray, '') ] = val;
				}
			};
	
			return function (data, val) { // meta is also passed in, but not used
				return setData( data, val, mSource );
			};
		}
		else
		{
			/* Array or flat object mapping */
			return function (data, val) { // meta is also passed in, but not used
				data[mSource] = val;
			};
		}
	}
	
	
	/**
	 * Return an array with the full table data
	 *  @param {object} oSettings dataTables settings object
	 *  @returns array {array} aData Master data array
	 *  @memberof DataTable#oApi
	 */
	function _fnGetDataMaster ( settings )
	{
		return _pluck( settings.aoData, '_aData' );
	}
	
	
	/**
	 * Nuke the table
	 *  @param {object} oSettings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnClearTable( settings )
	{
		settings.aoData.length = 0;
		settings.aiDisplayMaster.length = 0;
		settings.aiDisplay.length = 0;
		settings.aIds = {};
	}
	
	
	 /**
	 * Take an array of integers (index array) and remove a target integer (value - not
	 * the key!)
	 *  @param {array} a Index array to target
	 *  @param {int} iTarget value to find
	 *  @memberof DataTable#oApi
	 */
	function _fnDeleteIndex( a, iTarget, splice )
	{
		var iTargetIndex = -1;
	
		for ( var i=0, iLen=a.length ; i<iLen ; i++ )
		{
			if ( a[i] == iTarget )
			{
				iTargetIndex = i;
			}
			else if ( a[i] > iTarget )
			{
				a[i]--;
			}
		}
	
		if ( iTargetIndex != -1 && splice === undefined )
		{
			a.splice( iTargetIndex, 1 );
		}
	}
	
	
	/**
	 * Mark cached data as invalid such that a re-read of the data will occur when
	 * the cached data is next requested. Also update from the data source object.
	 *
	 * @param {object} settings DataTables settings object
	 * @param {int}    rowIdx   Row index to invalidate
	 * @param {string} [src]    Source to invalidate from: undefined, 'auto', 'dom'
	 *     or 'data'
	 * @param {int}    [colIdx] Column index to invalidate. If undefined the whole
	 *     row will be invalidated
	 * @memberof DataTable#oApi
	 *
	 * @todo For the modularisation of v1.11 this will need to become a callback, so
	 *   the sort and filter methods can subscribe to it. That will required
	 *   initialisation options for sorting, which is why it is not already baked in
	 */
	function _fnInvalidate( settings, rowIdx, src, colIdx )
	{
		var row = settings.aoData[ rowIdx ];
		var i, ien;
		var cellWrite = function ( cell, col ) {
			// This is very frustrating, but in IE if you just write directly
			// to innerHTML, and elements that are overwritten are GC'ed,
			// even if there is a reference to them elsewhere
			while ( cell.childNodes.length ) {
				cell.removeChild( cell.firstChild );
			}
	
			cell.innerHTML = _fnGetCellData( settings, rowIdx, col, 'display' );
		};
	
		// Are we reading last data from DOM or the data object?
		if ( src === 'dom' || ((! src || src === 'auto') && row.src === 'dom') ) {
			// Read the data from the DOM
			row._aData = _fnGetRowElements(
					settings, row, colIdx, colIdx === undefined ? undefined : row._aData
				)
				.data;
		}
		else {
			// Reading from data object, update the DOM
			var cells = row.anCells;
	
			if ( cells ) {
				if ( colIdx !== undefined ) {
					cellWrite( cells[colIdx], colIdx );
				}
				else {
					for ( i=0, ien=cells.length ; i<ien ; i++ ) {
						cellWrite( cells[i], i );
					}
				}
			}
		}
	
		// For both row and cell invalidation, the cached data for sorting and
		// filtering is nulled out
		row._aSortData = null;
		row._aFilterData = null;
	
		// Invalidate the type for a specific column (if given) or all columns since
		// the data might have changed
		var cols = settings.aoColumns;
		if ( colIdx !== undefined ) {
			cols[ colIdx ].sType = null;
		}
		else {
			for ( i=0, ien=cols.length ; i<ien ; i++ ) {
				cols[i].sType = null;
			}
	
			// Update DataTables special `DT_*` attributes for the row
			_fnRowAttributes( settings, row );
		}
	}
	
	
	/**
	 * Build a data source object from an HTML row, reading the contents of the
	 * cells that are in the row.
	 *
	 * @param {object} settings DataTables settings object
	 * @param {node|object} TR element from which to read data or existing row
	 *   object from which to re-read the data from the cells
	 * @param {int} [colIdx] Optional column index
	 * @param {array|object} [d] Data source object. If `colIdx` is given then this
	 *   parameter should also be given and will be used to write the data into.
	 *   Only the column in question will be written
	 * @returns {object} Object with two parameters: `data` the data read, in
	 *   document order, and `cells` and array of nodes (they can be useful to the
	 *   caller, so rather than needing a second traversal to get them, just return
	 *   them from here).
	 * @memberof DataTable#oApi
	 */
	function _fnGetRowElements( settings, row, colIdx, d )
	{
		var
			tds = [],
			td = row.firstChild,
			name, col, o, i=0, contents,
			columns = settings.aoColumns,
			objectRead = settings._rowReadObject;
	
		// Allow the data object to be passed in, or construct
		d = d !== undefined ?
			d :
			objectRead ?
				{} :
				[];
	
		var attr = function ( str, td  ) {
			if ( typeof str === 'string' ) {
				var idx = str.indexOf('@');
	
				if ( idx !== -1 ) {
					var attr = str.substring( idx+1 );
					var setter = _fnSetObjectDataFn( str );
					setter( d, td.getAttribute( attr ) );
				}
			}
		};
	
		// Read data from a cell and store into the data object
		var cellProcess = function ( cell ) {
			if ( colIdx === undefined || colIdx === i ) {
				col = columns[i];
				contents = $.trim(cell.innerHTML);
	
				if ( col && col._bAttrSrc ) {
					var setter = _fnSetObjectDataFn( col.mData._ );
					setter( d, contents );
	
					attr( col.mData.sort, cell );
					attr( col.mData.type, cell );
					attr( col.mData.filter, cell );
				}
				else {
					// Depending on the `data` option for the columns the data can
					// be read to either an object or an array.
					if ( objectRead ) {
						if ( ! col._setter ) {
							// Cache the setter function
							col._setter = _fnSetObjectDataFn( col.mData );
						}
						col._setter( d, contents );
					}
					else {
						d[i] = contents;
					}
				}
			}
	
			i++;
		};
	
		if ( td ) {
			// `tr` element was passed in
			while ( td ) {
				name = td.nodeName.toUpperCase();
	
				if ( name == "TD" || name == "TH" ) {
					cellProcess( td );
					tds.push( td );
				}
	
				td = td.nextSibling;
			}
		}
		else {
			// Existing row object passed in
			tds = row.anCells;
	
			for ( var j=0, jen=tds.length ; j<jen ; j++ ) {
				cellProcess( tds[j] );
			}
		}
	
		// Read the ID from the DOM if present
		var rowNode = row.firstChild ? row : row.nTr;
	
		if ( rowNode ) {
			var id = rowNode.getAttribute( 'id' );
	
			if ( id ) {
				_fnSetObjectDataFn( settings.rowId )( d, id );
			}
		}
	
		return {
			data: d,
			cells: tds
		};
	}
	/**
	 * Create a new TR element (and it's TD children) for a row
	 *  @param {object} oSettings dataTables settings object
	 *  @param {int} iRow Row to consider
	 *  @param {node} [nTrIn] TR element to add to the table - optional. If not given,
	 *    DataTables will create a row automatically
	 *  @param {array} [anTds] Array of TD|TH elements for the row - must be given
	 *    if nTr is.
	 *  @memberof DataTable#oApi
	 */
	function _fnCreateTr ( oSettings, iRow, nTrIn, anTds )
	{
		var
			row = oSettings.aoData[iRow],
			rowData = row._aData,
			cells = [],
			nTr, nTd, oCol,
			i, iLen, create;
	
		if ( row.nTr === null )
		{
			nTr = nTrIn || document.createElement('tr');
	
			row.nTr = nTr;
			row.anCells = cells;
	
			/* Use a private property on the node to allow reserve mapping from the node
			 * to the aoData array for fast look up
			 */
			nTr._DT_RowIndex = iRow;
	
			/* Special parameters can be given by the data source to be used on the row */
			_fnRowAttributes( oSettings, row );
	
			/* Process each column */
			for ( i=0, iLen=oSettings.aoColumns.length ; i<iLen ; i++ )
			{
				oCol = oSettings.aoColumns[i];
				create = nTrIn ? false : true;
	
				nTd = create ? document.createElement( oCol.sCellType ) : anTds[i];
				nTd._DT_CellIndex = {
					row: iRow,
					column: i
				};
				
				cells.push( nTd );
	
				// Need to create the HTML if new, or if a rendering function is defined
				if ( create || ((!nTrIn || oCol.mRender || oCol.mData !== i) &&
					 (!$.isPlainObject(oCol.mData) || oCol.mData._ !== i+'.display')
				)) {
					nTd.innerHTML = _fnGetCellData( oSettings, iRow, i, 'display' );
				}
	
				/* Add user defined class */
				if ( oCol.sClass )
				{
					nTd.className += ' '+oCol.sClass;
				}
	
				// Visibility - add or remove as required
				if ( oCol.bVisible && ! nTrIn )
				{
					nTr.appendChild( nTd );
				}
				else if ( ! oCol.bVisible && nTrIn )
				{
					nTd.parentNode.removeChild( nTd );
				}
	
				if ( oCol.fnCreatedCell )
				{
					oCol.fnCreatedCell.call( oSettings.oInstance,
						nTd, _fnGetCellData( oSettings, iRow, i ), rowData, iRow, i
					);
				}
			}
	
			_fnCallbackFire( oSettings, 'aoRowCreatedCallback', null, [nTr, rowData, iRow, cells] );
		}
	
		// Remove once webkit bug 131819 and Chromium bug 365619 have been resolved
		// and deployed
		row.nTr.setAttribute( 'role', 'row' );
	}
	
	
	/**
	 * Add attributes to a row based on the special `DT_*` parameters in a data
	 * source object.
	 *  @param {object} settings DataTables settings object
	 *  @param {object} DataTables row object for the row to be modified
	 *  @memberof DataTable#oApi
	 */
	function _fnRowAttributes( settings, row )
	{
		var tr = row.nTr;
		var data = row._aData;
	
		if ( tr ) {
			var id = settings.rowIdFn( data );
	
			if ( id ) {
				tr.id = id;
			}
	
			if ( data.DT_RowClass ) {
				// Remove any classes added by DT_RowClass before
				var a = data.DT_RowClass.split(' ');
				row.__rowc = row.__rowc ?
					_unique( row.__rowc.concat( a ) ) :
					a;
	
				$(tr)
					.removeClass( row.__rowc.join(' ') )
					.addClass( data.DT_RowClass );
			}
	
			if ( data.DT_RowAttr ) {
				$(tr).attr( data.DT_RowAttr );
			}
	
			if ( data.DT_RowData ) {
				$(tr).data( data.DT_RowData );
			}
		}
	}
	
	
	/**
	 * Create the HTML header for the table
	 *  @param {object} oSettings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnBuildHead( oSettings )
	{
		var i, ien, cell, row, column;
		var thead = oSettings.nTHead;
		var tfoot = oSettings.nTFoot;
		var createHeader = $('th, td', thead).length === 0;
		var classes = oSettings.oClasses;
		var columns = oSettings.aoColumns;
	
		if ( createHeader ) {
			row = $('<tr/>').appendTo( thead );
		}
	
		for ( i=0, ien=columns.length ; i<ien ; i++ ) {
			column = columns[i];
			cell = $( column.nTh ).addClass( column.sClass );
	
			if ( createHeader ) {
				cell.appendTo( row );
			}
	
			// 1.11 move into sorting
			if ( oSettings.oFeatures.bSort ) {
				cell.addClass( column.sSortingClass );
	
				if ( column.bSortable !== false ) {
					cell
						.attr( 'tabindex', oSettings.iTabIndex )
						.attr( 'aria-controls', oSettings.sTableId );
	
					_fnSortAttachListener( oSettings, column.nTh, i );
				}
			}
	
			if ( column.sTitle != cell[0].innerHTML ) {
				cell.html( column.sTitle );
			}
	
			_fnRenderer( oSettings, 'header' )(
				oSettings, cell, column, classes
			);
		}
	
		if ( createHeader ) {
			_fnDetectHeader( oSettings.aoHeader, thead );
		}
		
		/* ARIA role for the rows */
	 	$(thead).find('>tr').attr('role', 'row');
	
		/* Deal with the footer - add classes if required */
		$(thead).find('>tr>th, >tr>td').addClass( classes.sHeaderTH );
		$(tfoot).find('>tr>th, >tr>td').addClass( classes.sFooterTH );
	
		// Cache the footer cells. Note that we only take the cells from the first
		// row in the footer. If there is more than one row the user wants to
		// interact with, they need to use the table().foot() method. Note also this
		// allows cells to be used for multiple columns using colspan
		if ( tfoot !== null ) {
			var cells = oSettings.aoFooter[0];
	
			for ( i=0, ien=cells.length ; i<ien ; i++ ) {
				column = columns[i];
				column.nTf = cells[i].cell;
	
				if ( column.sClass ) {
					$(column.nTf).addClass( column.sClass );
				}
			}
		}
	}
	
	
	/**
	 * Draw the header (or footer) element based on the column visibility states. The
	 * methodology here is to use the layout array from _fnDetectHeader, modified for
	 * the instantaneous column visibility, to construct the new layout. The grid is
	 * traversed over cell at a time in a rows x columns grid fashion, although each
	 * cell insert can cover multiple elements in the grid - which is tracks using the
	 * aApplied array. Cell inserts in the grid will only occur where there isn't
	 * already a cell in that position.
	 *  @param {object} oSettings dataTables settings object
	 *  @param array {objects} aoSource Layout array from _fnDetectHeader
	 *  @param {boolean} [bIncludeHidden=false] If true then include the hidden columns in the calc,
	 *  @memberof DataTable#oApi
	 */
	function _fnDrawHead( oSettings, aoSource, bIncludeHidden )
	{
		var i, iLen, j, jLen, k, kLen, n, nLocalTr;
		var aoLocal = [];
		var aApplied = [];
		var iColumns = oSettings.aoColumns.length;
		var iRowspan, iColspan;
	
		if ( ! aoSource )
		{
			return;
		}
	
		if (  bIncludeHidden === undefined )
		{
			bIncludeHidden = false;
		}
	
		/* Make a copy of the master layout array, but without the visible columns in it */
		for ( i=0, iLen=aoSource.length ; i<iLen ; i++ )
		{
			aoLocal[i] = aoSource[i].slice();
			aoLocal[i].nTr = aoSource[i].nTr;
	
			/* Remove any columns which are currently hidden */
			for ( j=iColumns-1 ; j>=0 ; j-- )
			{
				if ( !oSettings.aoColumns[j].bVisible && !bIncludeHidden )
				{
					aoLocal[i].splice( j, 1 );
				}
			}
	
			/* Prep the applied array - it needs an element for each row */
			aApplied.push( [] );
		}
	
		for ( i=0, iLen=aoLocal.length ; i<iLen ; i++ )
		{
			nLocalTr = aoLocal[i].nTr;
	
			/* All cells are going to be replaced, so empty out the row */
			if ( nLocalTr )
			{
				while( (n = nLocalTr.firstChild) )
				{
					nLocalTr.removeChild( n );
				}
			}
	
			for ( j=0, jLen=aoLocal[i].length ; j<jLen ; j++ )
			{
				iRowspan = 1;
				iColspan = 1;
	
				/* Check to see if there is already a cell (row/colspan) covering our target
				 * insert point. If there is, then there is nothing to do.
				 */
				if ( aApplied[i][j] === undefined )
				{
					nLocalTr.appendChild( aoLocal[i][j].cell );
					aApplied[i][j] = 1;
	
					/* Expand the cell to cover as many rows as needed */
					while ( aoLocal[i+iRowspan] !== undefined &&
					        aoLocal[i][j].cell == aoLocal[i+iRowspan][j].cell )
					{
						aApplied[i+iRowspan][j] = 1;
						iRowspan++;
					}
	
					/* Expand the cell to cover as many columns as needed */
					while ( aoLocal[i][j+iColspan] !== undefined &&
					        aoLocal[i][j].cell == aoLocal[i][j+iColspan].cell )
					{
						/* Must update the applied array over the rows for the columns */
						for ( k=0 ; k<iRowspan ; k++ )
						{
							aApplied[i+k][j+iColspan] = 1;
						}
						iColspan++;
					}
	
					/* Do the actual expansion in the DOM */
					$(aoLocal[i][j].cell)
						.attr('rowspan', iRowspan)
						.attr('colspan', iColspan);
				}
			}
		}
	}
	
	
	/**
	 * Insert the required TR nodes into the table for display
	 *  @param {object} oSettings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnDraw( oSettings )
	{
		/* Provide a pre-callback function which can be used to cancel the draw is false is returned */
		var aPreDraw = _fnCallbackFire( oSettings, 'aoPreDrawCallback', 'preDraw', [oSettings] );
		if ( $.inArray( false, aPreDraw ) !== -1 )
		{
			_fnProcessingDisplay( oSettings, false );
			return;
		}
	
		var i, iLen, n;
		var anRows = [];
		var iRowCount = 0;
		var asStripeClasses = oSettings.asStripeClasses;
		var iStripes = asStripeClasses.length;
		var iOpenRows = oSettings.aoOpenRows.length;
		var oLang = oSettings.oLanguage;
		var iInitDisplayStart = oSettings.iInitDisplayStart;
		var bServerSide = _fnDataSource( oSettings ) == 'ssp';
		var aiDisplay = oSettings.aiDisplay;
	
		oSettings.bDrawing = true;
	
		/* Check and see if we have an initial draw position from state saving */
		if ( iInitDisplayStart !== undefined && iInitDisplayStart !== -1 )
		{
			oSettings._iDisplayStart = bServerSide ?
				iInitDisplayStart :
				iInitDisplayStart >= oSettings.fnRecordsDisplay() ?
					0 :
					iInitDisplayStart;
	
			oSettings.iInitDisplayStart = -1;
		}
	
		var iDisplayStart = oSettings._iDisplayStart;
		var iDisplayEnd = oSettings.fnDisplayEnd();
	
		/* Server-side processing draw intercept */
		if ( oSettings.bDeferLoading )
		{
			oSettings.bDeferLoading = false;
			oSettings.iDraw++;
			_fnProcessingDisplay( oSettings, false );
		}
		else if ( !bServerSide )
		{
			oSettings.iDraw++;
		}
		else if ( !oSettings.bDestroying && !_fnAjaxUpdate( oSettings ) )
		{
			return;
		}
	
		if ( aiDisplay.length !== 0 )
		{
			var iStart = bServerSide ? 0 : iDisplayStart;
			var iEnd = bServerSide ? oSettings.aoData.length : iDisplayEnd;
	
			for ( var j=iStart ; j<iEnd ; j++ )
			{
				var iDataIndex = aiDisplay[j];
				var aoData = oSettings.aoData[ iDataIndex ];
				if ( aoData.nTr === null )
				{
					_fnCreateTr( oSettings, iDataIndex );
				}
	
				var nRow = aoData.nTr;
	
				/* Remove the old striping classes and then add the new one */
				if ( iStripes !== 0 )
				{
					var sStripe = asStripeClasses[ iRowCount % iStripes ];
					if ( aoData._sRowStripe != sStripe )
					{
						$(nRow).removeClass( aoData._sRowStripe ).addClass( sStripe );
						aoData._sRowStripe = sStripe;
					}
				}
	
				// Row callback functions - might want to manipulate the row
				// iRowCount and j are not currently documented. Are they at all
				// useful?
				_fnCallbackFire( oSettings, 'aoRowCallback', null,
					[nRow, aoData._aData, iRowCount, j, iDataIndex] );
	
				anRows.push( nRow );
				iRowCount++;
			}
		}
		else
		{
			/* Table is empty - create a row with an empty message in it */
			var sZero = oLang.sZeroRecords;
			if ( oSettings.iDraw == 1 &&  _fnDataSource( oSettings ) == 'ajax' )
			{
				sZero = oLang.sLoadingRecords;
			}
			else if ( oLang.sEmptyTable && oSettings.fnRecordsTotal() === 0 )
			{
				sZero = oLang.sEmptyTable;
			}
	
			anRows[ 0 ] = $( '<tr/>', { 'class': iStripes ? asStripeClasses[0] : '' } )
				.append( $('<td />', {
					'valign':  'top',
					'colSpan': _fnVisbleColumns( oSettings ),
					'class':   oSettings.oClasses.sRowEmpty
				} ).html( sZero ) )[0];
		}
	
		/* Header and footer callbacks */
		_fnCallbackFire( oSettings, 'aoHeaderCallback', 'header', [ $(oSettings.nTHead).children('tr')[0],
			_fnGetDataMaster( oSettings ), iDisplayStart, iDisplayEnd, aiDisplay ] );
	
		_fnCallbackFire( oSettings, 'aoFooterCallback', 'footer', [ $(oSettings.nTFoot).children('tr')[0],
			_fnGetDataMaster( oSettings ), iDisplayStart, iDisplayEnd, aiDisplay ] );
	
		var body = $(oSettings.nTBody);
	
		body.children().detach();
		body.append( $(anRows) );
	
		/* Call all required callback functions for the end of a draw */
		_fnCallbackFire( oSettings, 'aoDrawCallback', 'draw', [oSettings] );
	
		/* Draw is complete, sorting and filtering must be as well */
		oSettings.bSorted = false;
		oSettings.bFiltered = false;
		oSettings.bDrawing = false;
	}
	
	
	/**
	 * Redraw the table - taking account of the various features which are enabled
	 *  @param {object} oSettings dataTables settings object
	 *  @param {boolean} [holdPosition] Keep the current paging position. By default
	 *    the paging is reset to the first page
	 *  @memberof DataTable#oApi
	 */
	function _fnReDraw( settings, holdPosition )
	{
		var
			features = settings.oFeatures,
			sort     = features.bSort,
			filter   = features.bFilter;
	
		if ( sort ) {
			_fnSort( settings );
		}
	
		if ( filter ) {
			_fnFilterComplete( settings, settings.oPreviousSearch );
		}
		else {
			// No filtering, so we want to just use the display master
			settings.aiDisplay = settings.aiDisplayMaster.slice();
		}
	
		if ( holdPosition !== true ) {
			settings._iDisplayStart = 0;
		}
	
		// Let any modules know about the draw hold position state (used by
		// scrolling internally)
		settings._drawHold = holdPosition;
	
		_fnDraw( settings );
	
		settings._drawHold = false;
	}
	
	
	/**
	 * Add the options to the page HTML for the table
	 *  @param {object} oSettings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnAddOptionsHtml ( oSettings )
	{
		var classes = oSettings.oClasses;
		var table = $(oSettings.nTable);
		var holding = $('<div/>').insertBefore( table ); // Holding element for speed
		var features = oSettings.oFeatures;
	
		// All DataTables are wrapped in a div
		var insert = $('<div/>', {
			id:      oSettings.sTableId+'_wrapper',
			'class': classes.sWrapper + (oSettings.nTFoot ? '' : ' '+classes.sNoFooter)
		} );
	
		oSettings.nHolding = holding[0];
		oSettings.nTableWrapper = insert[0];
		oSettings.nTableReinsertBefore = oSettings.nTable.nextSibling;
	
		/* Loop over the user set positioning and place the elements as needed */
		var aDom = oSettings.sDom.split('');
		var featureNode, cOption, nNewNode, cNext, sAttr, j;
		for ( var i=0 ; i<aDom.length ; i++ )
		{
			featureNode = null;
			cOption = aDom[i];
	
			if ( cOption == '<' )
			{
				/* New container div */
				nNewNode = $('<div/>')[0];
	
				/* Check to see if we should append an id and/or a class name to the container */
				cNext = aDom[i+1];
				if ( cNext == "'" || cNext == '"' )
				{
					sAttr = "";
					j = 2;
					while ( aDom[i+j] != cNext )
					{
						sAttr += aDom[i+j];
						j++;
					}
	
					/* Replace jQuery UI constants @todo depreciated */
					if ( sAttr == "H" )
					{
						sAttr = classes.sJUIHeader;
					}
					else if ( sAttr == "F" )
					{
						sAttr = classes.sJUIFooter;
					}
	
					/* The attribute can be in the format of "#id.class", "#id" or "class" This logic
					 * breaks the string into parts and applies them as needed
					 */
					if ( sAttr.indexOf('.') != -1 )
					{
						var aSplit = sAttr.split('.');
						nNewNode.id = aSplit[0].substr(1, aSplit[0].length-1);
						nNewNode.className = aSplit[1];
					}
					else if ( sAttr.charAt(0) == "#" )
					{
						nNewNode.id = sAttr.substr(1, sAttr.length-1);
					}
					else
					{
						nNewNode.className = sAttr;
					}
	
					i += j; /* Move along the position array */
				}
	
				insert.append( nNewNode );
				insert = $(nNewNode);
			}
			else if ( cOption == '>' )
			{
				/* End container div */
				insert = insert.parent();
			}
			// @todo Move options into their own plugins?
			else if ( cOption == 'l' && features.bPaginate && features.bLengthChange )
			{
				/* Length */
				featureNode = _fnFeatureHtmlLength( oSettings );
			}
			else if ( cOption == 'f' && features.bFilter )
			{
				/* Filter */
				featureNode = _fnFeatureHtmlFilter( oSettings );
			}
			else if ( cOption == 'r' && features.bProcessing )
			{
				/* pRocessing */
				featureNode = _fnFeatureHtmlProcessing( oSettings );
			}
			else if ( cOption == 't' )
			{
				/* Table */
				featureNode = _fnFeatureHtmlTable( oSettings );
			}
			else if ( cOption ==  'i' && features.bInfo )
			{
				/* Info */
				featureNode = _fnFeatureHtmlInfo( oSettings );
			}
			else if ( cOption == 'p' && features.bPaginate )
			{
				/* Pagination */
				featureNode = _fnFeatureHtmlPaginate( oSettings );
			}
			else if ( DataTable.ext.feature.length !== 0 )
			{
				/* Plug-in features */
				var aoFeatures = DataTable.ext.feature;
				for ( var k=0, kLen=aoFeatures.length ; k<kLen ; k++ )
				{
					if ( cOption == aoFeatures[k].cFeature )
					{
						featureNode = aoFeatures[k].fnInit( oSettings );
						break;
					}
				}
			}
	
			/* Add to the 2D features array */
			if ( featureNode )
			{
				var aanFeatures = oSettings.aanFeatures;
	
				if ( ! aanFeatures[cOption] )
				{
					aanFeatures[cOption] = [];
				}
	
				aanFeatures[cOption].push( featureNode );
				insert.append( featureNode );
			}
		}
	
		/* Built our DOM structure - replace the holding div with what we want */
		holding.replaceWith( insert );
		oSettings.nHolding = null;
	}
	
	
	/**
	 * Use the DOM source to create up an array of header cells. The idea here is to
	 * create a layout grid (array) of rows x columns, which contains a reference
	 * to the cell that that point in the grid (regardless of col/rowspan), such that
	 * any column / row could be removed and the new grid constructed
	 *  @param array {object} aLayout Array to store the calculated layout in
	 *  @param {node} nThead The header/footer element for the table
	 *  @memberof DataTable#oApi
	 */
	function _fnDetectHeader ( aLayout, nThead )
	{
		var nTrs = $(nThead).children('tr');
		var nTr, nCell;
		var i, k, l, iLen, jLen, iColShifted, iColumn, iColspan, iRowspan;
		var bUnique;
		var fnShiftCol = function ( a, i, j ) {
			var k = a[i];
	                while ( k[j] ) {
				j++;
			}
			return j;
		};
	
		aLayout.splice( 0, aLayout.length );
	
		/* We know how many rows there are in the layout - so prep it */
		for ( i=0, iLen=nTrs.length ; i<iLen ; i++ )
		{
			aLayout.push( [] );
		}
	
		/* Calculate a layout array */
		for ( i=0, iLen=nTrs.length ; i<iLen ; i++ )
		{
			nTr = nTrs[i];
			iColumn = 0;
	
			/* For every cell in the row... */
			nCell = nTr.firstChild;
			while ( nCell ) {
				if ( nCell.nodeName.toUpperCase() == "TD" ||
				     nCell.nodeName.toUpperCase() == "TH" )
				{
					/* Get the col and rowspan attributes from the DOM and sanitise them */
					iColspan = nCell.getAttribute('colspan') * 1;
					iRowspan = nCell.getAttribute('rowspan') * 1;
					iColspan = (!iColspan || iColspan===0 || iColspan===1) ? 1 : iColspan;
					iRowspan = (!iRowspan || iRowspan===0 || iRowspan===1) ? 1 : iRowspan;
	
					/* There might be colspan cells already in this row, so shift our target
					 * accordingly
					 */
					iColShifted = fnShiftCol( aLayout, i, iColumn );
	
					/* Cache calculation for unique columns */
					bUnique = iColspan === 1 ? true : false;
	
					/* If there is col / rowspan, copy the information into the layout grid */
					for ( l=0 ; l<iColspan ; l++ )
					{
						for ( k=0 ; k<iRowspan ; k++ )
						{
							aLayout[i+k][iColShifted+l] = {
								"cell": nCell,
								"unique": bUnique
							};
							aLayout[i+k].nTr = nTr;
						}
					}
				}
				nCell = nCell.nextSibling;
			}
		}
	}
	
	
	/**
	 * Get an array of unique th elements, one for each column
	 *  @param {object} oSettings dataTables settings object
	 *  @param {node} nHeader automatically detect the layout from this node - optional
	 *  @param {array} aLayout thead/tfoot layout from _fnDetectHeader - optional
	 *  @returns array {node} aReturn list of unique th's
	 *  @memberof DataTable#oApi
	 */
	function _fnGetUniqueThs ( oSettings, nHeader, aLayout )
	{
		var aReturn = [];
		if ( !aLayout )
		{
			aLayout = oSettings.aoHeader;
			if ( nHeader )
			{
				aLayout = [];
				_fnDetectHeader( aLayout, nHeader );
			}
		}
	
		for ( var i=0, iLen=aLayout.length ; i<iLen ; i++ )
		{
			for ( var j=0, jLen=aLayout[i].length ; j<jLen ; j++ )
			{
				if ( aLayout[i][j].unique &&
					 (!aReturn[j] || !oSettings.bSortCellsTop) )
				{
					aReturn[j] = aLayout[i][j].cell;
				}
			}
		}
	
		return aReturn;
	}
	
	/**
	 * Create an Ajax call based on the table's settings, taking into account that
	 * parameters can have multiple forms, and backwards compatibility.
	 *
	 * @param {object} oSettings dataTables settings object
	 * @param {array} data Data to send to the server, required by
	 *     DataTables - may be augmented by developer callbacks
	 * @param {function} fn Callback function to run when data is obtained
	 */
	function _fnBuildAjax( oSettings, data, fn )
	{
		// Compatibility with 1.9-, allow fnServerData and event to manipulate
		_fnCallbackFire( oSettings, 'aoServerParams', 'serverParams', [data] );
	
		// Convert to object based for 1.10+ if using the old array scheme which can
		// come from server-side processing or serverParams
		if ( data && $.isArray(data) ) {
			var tmp = {};
			var rbracket = /(.*?)\[\]$/;
	
			$.each( data, function (key, val) {
				var match = val.name.match(rbracket);
	
				if ( match ) {
					// Support for arrays
					var name = match[0];
	
					if ( ! tmp[ name ] ) {
						tmp[ name ] = [];
					}
					tmp[ name ].push( val.value );
				}
				else {
					tmp[val.name] = val.value;
				}
			} );
			data = tmp;
		}
	
		var ajaxData;
		var ajax = oSettings.ajax;
		var instance = oSettings.oInstance;
		var callback = function ( json ) {
			_fnCallbackFire( oSettings, null, 'xhr', [oSettings, json, oSettings.jqXHR] );
			fn( json );
		};
	
		if ( $.isPlainObject( ajax ) && ajax.data )
		{
			ajaxData = ajax.data;
	
			var newData = typeof ajaxData === 'function' ?
				ajaxData( data, oSettings ) :  // fn can manipulate data or return
				ajaxData;                      // an object object or array to merge
	
			// If the function returned something, use that alone
			data = typeof ajaxData === 'function' && newData ?
				newData :
				$.extend( true, data, newData );
	
			// Remove the data property as we've resolved it already and don't want
			// jQuery to do it again (it is restored at the end of the function)
			delete ajax.data;
		}
	
		var baseAjax = {
			"data": data,
			"success": function (json) {
				var error = json.error || json.sError;
				if ( error ) {
					_fnLog( oSettings, 0, error );
				}
	
				oSettings.json = json;
				callback( json );
			},
			"dataType": "json",
			"cache": false,
			"type": oSettings.sServerMethod,
			"error": function (xhr, error, thrown) {
				var ret = _fnCallbackFire( oSettings, null, 'xhr', [oSettings, null, oSettings.jqXHR] );
	
				if ( $.inArray( true, ret ) === -1 ) {
					if ( error == "parsererror" ) {
						_fnLog( oSettings, 0, 'Invalid JSON response', 1 );
					}
					else if ( xhr.readyState === 4 ) {
						_fnLog( oSettings, 0, 'Ajax error', 7 );
					}
				}
	
				_fnProcessingDisplay( oSettings, false );
			}
		};
	
		// Store the data submitted for the API
		oSettings.oAjaxData = data;
	
		// Allow plug-ins and external processes to modify the data
		_fnCallbackFire( oSettings, null, 'preXhr', [oSettings, data] );
	
		if ( oSettings.fnServerData )
		{
			// DataTables 1.9- compatibility
			oSettings.fnServerData.call( instance,
				oSettings.sAjaxSource,
				$.map( data, function (val, key) { // Need to convert back to 1.9 trad format
					return { name: key, value: val };
				} ),
				callback,
				oSettings
			);
		}
		else if ( oSettings.sAjaxSource || typeof ajax === 'string' )
		{
			// DataTables 1.9- compatibility
			oSettings.jqXHR = $.ajax( $.extend( baseAjax, {
				url: ajax || oSettings.sAjaxSource
			} ) );
		}
		else if ( typeof ajax === 'function' )
		{
			// Is a function - let the caller define what needs to be done
			oSettings.jqXHR = ajax.call( instance, data, callback, oSettings );
		}
		else
		{
			// Object to extend the base settings
			oSettings.jqXHR = $.ajax( $.extend( baseAjax, ajax ) );
	
			// Restore for next time around
			ajax.data = ajaxData;
		}
	}
	
	
	/**
	 * Update the table using an Ajax call
	 *  @param {object} settings dataTables settings object
	 *  @returns {boolean} Block the table drawing or not
	 *  @memberof DataTable#oApi
	 */
	function _fnAjaxUpdate( settings )
	{
		if ( settings.bAjaxDataGet ) {
			settings.iDraw++;
			_fnProcessingDisplay( settings, true );
	
			_fnBuildAjax(
				settings,
				_fnAjaxParameters( settings ),
				function(json) {
					_fnAjaxUpdateDraw( settings, json );
				}
			);
	
			return false;
		}
		return true;
	}
	
	
	/**
	 * Build up the parameters in an object needed for a server-side processing
	 * request. Note that this is basically done twice, is different ways - a modern
	 * method which is used by default in DataTables 1.10 which uses objects and
	 * arrays, or the 1.9- method with is name / value pairs. 1.9 method is used if
	 * the sAjaxSource option is used in the initialisation, or the legacyAjax
	 * option is set.
	 *  @param {object} oSettings dataTables settings object
	 *  @returns {bool} block the table drawing or not
	 *  @memberof DataTable#oApi
	 */
	function _fnAjaxParameters( settings )
	{
		var
			columns = settings.aoColumns,
			columnCount = columns.length,
			features = settings.oFeatures,
			preSearch = settings.oPreviousSearch,
			preColSearch = settings.aoPreSearchCols,
			i, data = [], dataProp, column, columnSearch,
			sort = _fnSortFlatten( settings ),
			displayStart = settings._iDisplayStart,
			displayLength = features.bPaginate !== false ?
				settings._iDisplayLength :
				-1;
	
		var param = function ( name, value ) {
			data.push( { 'name': name, 'value': value } );
		};
	
		// DataTables 1.9- compatible method
		param( 'sEcho',          settings.iDraw );
		param( 'iColumns',       columnCount );
		param( 'sColumns',       _pluck( columns, 'sName' ).join(',') );
		param( 'iDisplayStart',  displayStart );
		param( 'iDisplayLength', displayLength );
	
		// DataTables 1.10+ method
		var d = {
			draw:    settings.iDraw,
			columns: [],
			order:   [],
			start:   displayStart,
			length:  displayLength,
			search:  {
				value: preSearch.sSearch,
				regex: preSearch.bRegex
			}
		};
	
		for ( i=0 ; i<columnCount ; i++ ) {
			column = columns[i];
			columnSearch = preColSearch[i];
			dataProp = typeof column.mData=="function" ? 'function' : column.mData ;
	
			d.columns.push( {
				data:       dataProp,
				name:       column.sName,
				searchable: column.bSearchable,
				orderable:  column.bSortable,
				search:     {
					value: columnSearch.sSearch,
					regex: columnSearch.bRegex
				}
			} );
	
			param( "mDataProp_"+i, dataProp );
	
			if ( features.bFilter ) {
				param( 'sSearch_'+i,     columnSearch.sSearch );
				param( 'bRegex_'+i,      columnSearch.bRegex );
				param( 'bSearchable_'+i, column.bSearchable );
			}
	
			if ( features.bSort ) {
				param( 'bSortable_'+i, column.bSortable );
			}
		}
	
		if ( features.bFilter ) {
			param( 'sSearch', preSearch.sSearch );
			param( 'bRegex', preSearch.bRegex );
		}
	
		if ( features.bSort ) {
			$.each( sort, function ( i, val ) {
				d.order.push( { column: val.col, dir: val.dir } );
	
				param( 'iSortCol_'+i, val.col );
				param( 'sSortDir_'+i, val.dir );
			} );
	
			param( 'iSortingCols', sort.length );
		}
	
		// If the legacy.ajax parameter is null, then we automatically decide which
		// form to use, based on sAjaxSource
		var legacy = DataTable.ext.legacy.ajax;
		if ( legacy === null ) {
			return settings.sAjaxSource ? data : d;
		}
	
		// Otherwise, if legacy has been specified then we use that to decide on the
		// form
		return legacy ? data : d;
	}
	
	
	/**
	 * Data the data from the server (nuking the old) and redraw the table
	 *  @param {object} oSettings dataTables settings object
	 *  @param {object} json json data return from the server.
	 *  @param {string} json.sEcho Tracking flag for DataTables to match requests
	 *  @param {int} json.iTotalRecords Number of records in the data set, not accounting for filtering
	 *  @param {int} json.iTotalDisplayRecords Number of records in the data set, accounting for filtering
	 *  @param {array} json.aaData The data to display on this page
	 *  @param {string} [json.sColumns] Column ordering (sName, comma separated)
	 *  @memberof DataTable#oApi
	 */
	function _fnAjaxUpdateDraw ( settings, json )
	{
		// v1.10 uses camelCase variables, while 1.9 uses Hungarian notation.
		// Support both
		var compat = function ( old, modern ) {
			return json[old] !== undefined ? json[old] : json[modern];
		};
	
		var data = _fnAjaxDataSrc( settings, json );
		var draw            = compat( 'sEcho',                'draw' );
		var recordsTotal    = compat( 'iTotalRecords',        'recordsTotal' );
		var recordsFiltered = compat( 'iTotalDisplayRecords', 'recordsFiltered' );
	
		if ( draw !== undefined ) {
			// Protect against out of sequence returns
			if ( draw*1 < settings.iDraw ) {
				return;
			}
			settings.iDraw = draw * 1;
		}
	
		_fnClearTable( settings );
		settings._iRecordsTotal   = parseInt(recordsTotal, 10);
		settings._iRecordsDisplay = parseInt(recordsFiltered, 10);
	
		for ( var i=0, ien=data.length ; i<ien ; i++ ) {
			_fnAddData( settings, data[i] );
		}
		settings.aiDisplay = settings.aiDisplayMaster.slice();
	
		settings.bAjaxDataGet = false;
		_fnDraw( settings );
	
		if ( ! settings._bInitComplete ) {
			_fnInitComplete( settings, json );
		}
	
		settings.bAjaxDataGet = true;
		_fnProcessingDisplay( settings, false );
	}
	
	
	/**
	 * Get the data from the JSON data source to use for drawing a table. Using
	 * `_fnGetObjectDataFn` allows the data to be sourced from a property of the
	 * source object, or from a processing function.
	 *  @param {object} oSettings dataTables settings object
	 *  @param  {object} json Data source object / array from the server
	 *  @return {array} Array of data to use
	 */
	function _fnAjaxDataSrc ( oSettings, json )
	{
		var dataSrc = $.isPlainObject( oSettings.ajax ) && oSettings.ajax.dataSrc !== undefined ?
			oSettings.ajax.dataSrc :
			oSettings.sAjaxDataProp; // Compatibility with 1.9-.
	
		// Compatibility with 1.9-. In order to read from aaData, check if the
		// default has been changed, if not, check for aaData
		if ( dataSrc === 'data' ) {
			return json.aaData || json[dataSrc];
		}
	
		return dataSrc !== "" ?
			_fnGetObjectDataFn( dataSrc )( json ) :
			json;
	}
	
	/**
	 * Generate the node required for filtering text
	 *  @returns {node} Filter control element
	 *  @param {object} oSettings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnFeatureHtmlFilter ( settings )
	{
		var classes = settings.oClasses;
		var tableId = settings.sTableId;
		var language = settings.oLanguage;
		var previousSearch = settings.oPreviousSearch;
		var features = settings.aanFeatures;
		var input = '<input type="search" class="'+classes.sFilterInput+'"/>';
	
		var str = language.sSearch;
		str = str.match(/_INPUT_/) ?
			str.replace('_INPUT_', input) :
			str+input;
	
		var filter = $('<div/>', {
				'id': ! features.f ? tableId+'_filter' : null,
				'class': classes.sFilter
			} )
			.append( $('<label/>' ).append( str ) );
	
		var searchFn = function() {
			/* Update all other filter input elements for the new display */
			var n = features.f;
			var val = !this.value ? "" : this.value; // mental IE8 fix :-(
	
			/* Now do the filter */
			if ( val != previousSearch.sSearch ) {
				_fnFilterComplete( settings, {
					"sSearch": val,
					"bRegex": previousSearch.bRegex,
					"bSmart": previousSearch.bSmart ,
					"bCaseInsensitive": previousSearch.bCaseInsensitive
				} );
	
				// Need to redraw, without resorting
				settings._iDisplayStart = 0;
				_fnDraw( settings );
			}
		};
	
		var searchDelay = settings.searchDelay !== null ?
			settings.searchDelay :
			_fnDataSource( settings ) === 'ssp' ?
				400 :
				0;
	
		var jqFilter = $('input', filter)
			.val( previousSearch.sSearch )
			.attr( 'placeholder', language.sSearchPlaceholder )
			.on(
				'keyup.DT search.DT input.DT paste.DT cut.DT',
				searchDelay ?
					_fnThrottle( searchFn, searchDelay ) :
					searchFn
			)
			.on( 'mouseup', function(e) {
				// Edge fix! Edge 17 does not trigger anything other than mouse events when clicking
				// on the clear icon (Edge bug 17584515). This is safe in other browsers as `searchFn`
				// checks the value to see if it has changed. In other browsers it won't have.
				setTimeout( function () {
					searchFn.call(jqFilter[0]);
				}, 10);
			} )
			.on( 'keypress.DT', function(e) {
				/* Prevent form submission */
				if ( e.keyCode == 13 ) {
					return false;
				}
			} )
			.attr('aria-controls', tableId);
	
		// Update the input elements whenever the table is filtered
		$(settings.nTable).on( 'search.dt.DT', function ( ev, s ) {
			if ( settings === s ) {
				// IE9 throws an 'unknown error' if document.activeElement is used
				// inside an iframe or frame...
				try {
					if ( jqFilter[0] !== document.activeElement ) {
						jqFilter.val( previousSearch.sSearch );
					}
				}
				catch ( e ) {}
			}
		} );
	
		return filter[0];
	}
	
	
	/**
	 * Filter the table using both the global filter and column based filtering
	 *  @param {object} oSettings dataTables settings object
	 *  @param {object} oSearch search information
	 *  @param {int} [iForce] force a research of the master array (1) or not (undefined or 0)
	 *  @memberof DataTable#oApi
	 */
	function _fnFilterComplete ( oSettings, oInput, iForce )
	{
		var oPrevSearch = oSettings.oPreviousSearch;
		var aoPrevSearch = oSettings.aoPreSearchCols;
		var fnSaveFilter = function ( oFilter ) {
			/* Save the filtering values */
			oPrevSearch.sSearch = oFilter.sSearch;
			oPrevSearch.bRegex = oFilter.bRegex;
			oPrevSearch.bSmart = oFilter.bSmart;
			oPrevSearch.bCaseInsensitive = oFilter.bCaseInsensitive;
		};
		var fnRegex = function ( o ) {
			// Backwards compatibility with the bEscapeRegex option
			return o.bEscapeRegex !== undefined ? !o.bEscapeRegex : o.bRegex;
		};
	
		// Resolve any column types that are unknown due to addition or invalidation
		// @todo As per sort - can this be moved into an event handler?
		_fnColumnTypes( oSettings );
	
		/* In server-side processing all filtering is done by the server, so no point hanging around here */
		if ( _fnDataSource( oSettings ) != 'ssp' )
		{
			/* Global filter */
			_fnFilter( oSettings, oInput.sSearch, iForce, fnRegex(oInput), oInput.bSmart, oInput.bCaseInsensitive );
			fnSaveFilter( oInput );
	
			/* Now do the individual column filter */
			for ( var i=0 ; i<aoPrevSearch.length ; i++ )
			{
				_fnFilterColumn( oSettings, aoPrevSearch[i].sSearch, i, fnRegex(aoPrevSearch[i]),
					aoPrevSearch[i].bSmart, aoPrevSearch[i].bCaseInsensitive );
			}
	
			/* Custom filtering */
			_fnFilterCustom( oSettings );
		}
		else
		{
			fnSaveFilter( oInput );
		}
	
		/* Tell the draw function we have been filtering */
		oSettings.bFiltered = true;
		_fnCallbackFire( oSettings, null, 'search', [oSettings] );
	}
	
	
	/**
	 * Apply custom filtering functions
	 *  @param {object} oSettings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnFilterCustom( settings )
	{
		var filters = DataTable.ext.search;
		var displayRows = settings.aiDisplay;
		var row, rowIdx;
	
		for ( var i=0, ien=filters.length ; i<ien ; i++ ) {
			var rows = [];
	
			// Loop over each row and see if it should be included
			for ( var j=0, jen=displayRows.length ; j<jen ; j++ ) {
				rowIdx = displayRows[ j ];
				row = settings.aoData[ rowIdx ];
	
				if ( filters[i]( settings, row._aFilterData, rowIdx, row._aData, j ) ) {
					rows.push( rowIdx );
				}
			}
	
			// So the array reference doesn't break set the results into the
			// existing array
			displayRows.length = 0;
			$.merge( displayRows, rows );
		}
	}
	
	
	/**
	 * Filter the table on a per-column basis
	 *  @param {object} oSettings dataTables settings object
	 *  @param {string} sInput string to filter on
	 *  @param {int} iColumn column to filter
	 *  @param {bool} bRegex treat search string as a regular expression or not
	 *  @param {bool} bSmart use smart filtering or not
	 *  @param {bool} bCaseInsensitive Do case insenstive matching or not
	 *  @memberof DataTable#oApi
	 */
	function _fnFilterColumn ( settings, searchStr, colIdx, regex, smart, caseInsensitive )
	{
		if ( searchStr === '' ) {
			return;
		}
	
		var data;
		var out = [];
		var display = settings.aiDisplay;
		var rpSearch = _fnFilterCreateSearch( searchStr, regex, smart, caseInsensitive );
	
		for ( var i=0 ; i<display.length ; i++ ) {
			data = settings.aoData[ display[i] ]._aFilterData[ colIdx ];
	
			if ( rpSearch.test( data ) ) {
				out.push( display[i] );
			}
		}
	
		settings.aiDisplay = out;
	}
	
	
	/**
	 * Filter the data table based on user input and draw the table
	 *  @param {object} settings dataTables settings object
	 *  @param {string} input string to filter on
	 *  @param {int} force optional - force a research of the master array (1) or not (undefined or 0)
	 *  @param {bool} regex treat as a regular expression or not
	 *  @param {bool} smart perform smart filtering or not
	 *  @param {bool} caseInsensitive Do case insenstive matching or not
	 *  @memberof DataTable#oApi
	 */
	function _fnFilter( settings, input, force, regex, smart, caseInsensitive )
	{
		var rpSearch = _fnFilterCreateSearch( input, regex, smart, caseInsensitive );
		var prevSearch = settings.oPreviousSearch.sSearch;
		var displayMaster = settings.aiDisplayMaster;
		var display, invalidated, i;
		var filtered = [];
	
		// Need to take account of custom filtering functions - always filter
		if ( DataTable.ext.search.length !== 0 ) {
			force = true;
		}
	
		// Check if any of the rows were invalidated
		invalidated = _fnFilterData( settings );
	
		// If the input is blank - we just want the full data set
		if ( input.length <= 0 ) {
			settings.aiDisplay = displayMaster.slice();
		}
		else {
			// New search - start from the master array
			if ( invalidated ||
				 force ||
				 regex ||
				 prevSearch.length > input.length ||
				 input.indexOf(prevSearch) !== 0 ||
				 settings.bSorted // On resort, the display master needs to be
				                  // re-filtered since indexes will have changed
			) {
				settings.aiDisplay = displayMaster.slice();
			}
	
			// Search the display array
			display = settings.aiDisplay;
	
			for ( i=0 ; i<display.length ; i++ ) {
				if ( rpSearch.test( settings.aoData[ display[i] ]._sFilterRow ) ) {
					filtered.push( display[i] );
				}
			}
	
			settings.aiDisplay = filtered;
		}
	}
	
	
	/**
	 * Build a regular expression object suitable for searching a table
	 *  @param {string} sSearch string to search for
	 *  @param {bool} bRegex treat as a regular expression or not
	 *  @param {bool} bSmart perform smart filtering or not
	 *  @param {bool} bCaseInsensitive Do case insensitive matching or not
	 *  @returns {RegExp} constructed object
	 *  @memberof DataTable#oApi
	 */
	function _fnFilterCreateSearch( search, regex, smart, caseInsensitive )
	{
		search = regex ?
			search :
			_fnEscapeRegex( search );
		
		if ( smart ) {
			/* For smart filtering we want to allow the search to work regardless of
			 * word order. We also want double quoted text to be preserved, so word
			 * order is important - a la google. So this is what we want to
			 * generate:
			 * 
			 * ^(?=.*?\bone\b)(?=.*?\btwo three\b)(?=.*?\bfour\b).*$
			 */
			var a = $.map( search.match( /"[^"]+"|[^ ]+/g ) || [''], function ( word ) {
				if ( word.charAt(0) === '"' ) {
					var m = word.match( /^"(.*)"$/ );
					word = m ? m[1] : word;
				}
	
				return word.replace('"', '');
			} );
	
			search = '^(?=.*?'+a.join( ')(?=.*?' )+').*$';
		}
	
		return new RegExp( search, caseInsensitive ? 'i' : '' );
	}
	
	
	/**
	 * Escape a string such that it can be used in a regular expression
	 *  @param {string} sVal string to escape
	 *  @returns {string} escaped string
	 *  @memberof DataTable#oApi
	 */
	var _fnEscapeRegex = DataTable.util.escapeRegex;
	
	var __filter_div = $('<div>')[0];
	var __filter_div_textContent = __filter_div.textContent !== undefined;
	
	// Update the filtering data for each row if needed (by invalidation or first run)
	function _fnFilterData ( settings )
	{
		var columns = settings.aoColumns;
		var column;
		var i, j, ien, jen, filterData, cellData, row;
		var fomatters = DataTable.ext.type.search;
		var wasInvalidated = false;
	
		for ( i=0, ien=settings.aoData.length ; i<ien ; i++ ) {
			row = settings.aoData[i];
	
			if ( ! row._aFilterData ) {
				filterData = [];
	
				for ( j=0, jen=columns.length ; j<jen ; j++ ) {
					column = columns[j];
	
					if ( column.bSearchable ) {
						cellData = _fnGetCellData( settings, i, j, 'filter' );
	
						if ( fomatters[ column.sType ] ) {
							cellData = fomatters[ column.sType ]( cellData );
						}
	
						// Search in DataTables 1.10 is string based. In 1.11 this
						// should be altered to also allow strict type checking.
						if ( cellData === null ) {
							cellData = '';
						}
	
						if ( typeof cellData !== 'string' && cellData.toString ) {
							cellData = cellData.toString();
						}
					}
					else {
						cellData = '';
					}
	
					// If it looks like there is an HTML entity in the string,
					// attempt to decode it so sorting works as expected. Note that
					// we could use a single line of jQuery to do this, but the DOM
					// method used here is much faster http://jsperf.com/html-decode
					if ( cellData.indexOf && cellData.indexOf('&') !== -1 ) {
						__filter_div.innerHTML = cellData;
						cellData = __filter_div_textContent ?
							__filter_div.textContent :
							__filter_div.innerText;
					}
	
					if ( cellData.replace ) {
						cellData = cellData.replace(/[\r\n\u2028]/g, '');
					}
	
					filterData.push( cellData );
				}
	
				row._aFilterData = filterData;
				row._sFilterRow = filterData.join('  ');
				wasInvalidated = true;
			}
		}
	
		return wasInvalidated;
	}
	
	
	/**
	 * Convert from the internal Hungarian notation to camelCase for external
	 * interaction
	 *  @param {object} obj Object to convert
	 *  @returns {object} Inverted object
	 *  @memberof DataTable#oApi
	 */
	function _fnSearchToCamel ( obj )
	{
		return {
			search:          obj.sSearch,
			smart:           obj.bSmart,
			regex:           obj.bRegex,
			caseInsensitive: obj.bCaseInsensitive
		};
	}
	
	
	
	/**
	 * Convert from camelCase notation to the internal Hungarian. We could use the
	 * Hungarian convert function here, but this is cleaner
	 *  @param {object} obj Object to convert
	 *  @returns {object} Inverted object
	 *  @memberof DataTable#oApi
	 */
	function _fnSearchToHung ( obj )
	{
		return {
			sSearch:          obj.search,
			bSmart:           obj.smart,
			bRegex:           obj.regex,
			bCaseInsensitive: obj.caseInsensitive
		};
	}
	
	/**
	 * Generate the node required for the info display
	 *  @param {object} oSettings dataTables settings object
	 *  @returns {node} Information element
	 *  @memberof DataTable#oApi
	 */
	function _fnFeatureHtmlInfo ( settings )
	{
		var
			tid = settings.sTableId,
			nodes = settings.aanFeatures.i,
			n = $('<div/>', {
				'class': settings.oClasses.sInfo,
				'id': ! nodes ? tid+'_info' : null
			} );
	
		if ( ! nodes ) {
			// Update display on each draw
			settings.aoDrawCallback.push( {
				"fn": _fnUpdateInfo,
				"sName": "information"
			} );
	
			n
				.attr( 'role', 'status' )
				.attr( 'aria-live', 'polite' );
	
			// Table is described by our info div
			$(settings.nTable).attr( 'aria-describedby', tid+'_info' );
		}
	
		return n[0];
	}
	
	
	/**
	 * Update the information elements in the display
	 *  @param {object} settings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnUpdateInfo ( settings )
	{
		/* Show information about the table */
		var nodes = settings.aanFeatures.i;
		if ( nodes.length === 0 ) {
			return;
		}
	
		var
			lang  = settings.oLanguage,
			start = settings._iDisplayStart+1,
			end   = settings.fnDisplayEnd(),
			max   = settings.fnRecordsTotal(),
			total = settings.fnRecordsDisplay(),
			out   = total ?
				lang.sInfo :
				lang.sInfoEmpty;
	
		if ( total !== max ) {
			/* Record set after filtering */
			out += ' ' + lang.sInfoFiltered;
		}
	
		// Convert the macros
		out += lang.sInfoPostFix;
		out = _fnInfoMacros( settings, out );
	
		var callback = lang.fnInfoCallback;
		if ( callback !== null ) {
			out = callback.call( settings.oInstance,
				settings, start, end, max, total, out
			);
		}
	
		$(nodes).html( out );
	}
	
	
	function _fnInfoMacros ( settings, str )
	{
		// When infinite scrolling, we are always starting at 1. _iDisplayStart is used only
		// internally
		var
			formatter  = settings.fnFormatNumber,
			start      = settings._iDisplayStart+1,
			len        = settings._iDisplayLength,
			vis        = settings.fnRecordsDisplay(),
			all        = len === -1;
	
		return str.
			replace(/_START_/g, formatter.call( settings, start ) ).
			replace(/_END_/g,   formatter.call( settings, settings.fnDisplayEnd() ) ).
			replace(/_MAX_/g,   formatter.call( settings, settings.fnRecordsTotal() ) ).
			replace(/_TOTAL_/g, formatter.call( settings, vis ) ).
			replace(/_PAGE_/g,  formatter.call( settings, all ? 1 : Math.ceil( start / len ) ) ).
			replace(/_PAGES_/g, formatter.call( settings, all ? 1 : Math.ceil( vis / len ) ) );
	}
	
	
	
	/**
	 * Draw the table for the first time, adding all required features
	 *  @param {object} settings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnInitialise ( settings )
	{
		var i, iLen, iAjaxStart=settings.iInitDisplayStart;
		var columns = settings.aoColumns, column;
		var features = settings.oFeatures;
		var deferLoading = settings.bDeferLoading; // value modified by the draw
	
		/* Ensure that the table data is fully initialised */
		if ( ! settings.bInitialised ) {
			setTimeout( function(){ _fnInitialise( settings ); }, 200 );
			return;
		}
	
		/* Show the display HTML options */
		_fnAddOptionsHtml( settings );
	
		/* Build and draw the header / footer for the table */
		_fnBuildHead( settings );
		_fnDrawHead( settings, settings.aoHeader );
		_fnDrawHead( settings, settings.aoFooter );
	
		/* Okay to show that something is going on now */
		_fnProcessingDisplay( settings, true );
	
		/* Calculate sizes for columns */
		if ( features.bAutoWidth ) {
			_fnCalculateColumnWidths( settings );
		}
	
		for ( i=0, iLen=columns.length ; i<iLen ; i++ ) {
			column = columns[i];
	
			if ( column.sWidth ) {
				column.nTh.style.width = _fnStringToCss( column.sWidth );
			}
		}
	
		_fnCallbackFire( settings, null, 'preInit', [settings] );
	
		// If there is default sorting required - let's do it. The sort function
		// will do the drawing for us. Otherwise we draw the table regardless of the
		// Ajax source - this allows the table to look initialised for Ajax sourcing
		// data (show 'loading' message possibly)
		_fnReDraw( settings );
	
		// Server-side processing init complete is done by _fnAjaxUpdateDraw
		var dataSrc = _fnDataSource( settings );
		if ( dataSrc != 'ssp' || deferLoading ) {
			// if there is an ajax source load the data
			if ( dataSrc == 'ajax' ) {
				_fnBuildAjax( settings, [], function(json) {
					var aData = _fnAjaxDataSrc( settings, json );
	
					// Got the data - add it to the table
					for ( i=0 ; i<aData.length ; i++ ) {
						_fnAddData( settings, aData[i] );
					}
	
					// Reset the init display for cookie saving. We've already done
					// a filter, and therefore cleared it before. So we need to make
					// it appear 'fresh'
					settings.iInitDisplayStart = iAjaxStart;
	
					_fnReDraw( settings );
	
					_fnProcessingDisplay( settings, false );
					_fnInitComplete( settings, json );
				}, settings );
			}
			else {
				_fnProcessingDisplay( settings, false );
				_fnInitComplete( settings );
			}
		}
	}
	
	
	/**
	 * Draw the table for the first time, adding all required features
	 *  @param {object} oSettings dataTables settings object
	 *  @param {object} [json] JSON from the server that completed the table, if using Ajax source
	 *    with client-side processing (optional)
	 *  @memberof DataTable#oApi
	 */
	function _fnInitComplete ( settings, json )
	{
		settings._bInitComplete = true;
	
		// When data was added after the initialisation (data or Ajax) we need to
		// calculate the column sizing
		if ( json || settings.oInit.aaData ) {
			_fnAdjustColumnSizing( settings );
		}
	
		_fnCallbackFire( settings, null, 'plugin-init', [settings, json] );
		_fnCallbackFire( settings, 'aoInitComplete', 'init', [settings, json] );
	}
	
	
	function _fnLengthChange ( settings, val )
	{
		var len = parseInt( val, 10 );
		settings._iDisplayLength = len;
	
		_fnLengthOverflow( settings );
	
		// Fire length change event
		_fnCallbackFire( settings, null, 'length', [settings, len] );
	}
	
	
	/**
	 * Generate the node required for user display length changing
	 *  @param {object} settings dataTables settings object
	 *  @returns {node} Display length feature node
	 *  @memberof DataTable#oApi
	 */
	function _fnFeatureHtmlLength ( settings )
	{
		var
			classes  = settings.oClasses,
			tableId  = settings.sTableId,
			menu     = settings.aLengthMenu,
			d2       = $.isArray( menu[0] ),
			lengths  = d2 ? menu[0] : menu,
			language = d2 ? menu[1] : menu;
	
		var select = $('<select/>', {
			'name':          tableId+'_length',
			'aria-controls': tableId,
			'class':         classes.sLengthSelect
		} );
	
		for ( var i=0, ien=lengths.length ; i<ien ; i++ ) {
			select[0][ i ] = new Option(
				typeof language[i] === 'number' ?
					settings.fnFormatNumber( language[i] ) :
					language[i],
				lengths[i]
			);
		}
	
		var div = $('<div><label/></div>').addClass( classes.sLength );
		if ( ! settings.aanFeatures.l ) {
			div[0].id = tableId+'_length';
		}
	
		div.children().append(
			settings.oLanguage.sLengthMenu.replace( '_MENU_', select[0].outerHTML )
		);
	
		// Can't use `select` variable as user might provide their own and the
		// reference is broken by the use of outerHTML
		$('select', div)
			.val( settings._iDisplayLength )
			.on( 'change.DT', function(e) {
				_fnLengthChange( settings, $(this).val() );
				_fnDraw( settings );
			} );
	
		// Update node value whenever anything changes the table's length
		$(settings.nTable).on( 'length.dt.DT', function (e, s, len) {
			if ( settings === s ) {
				$('select', div).val( len );
			}
		} );
	
		return div[0];
	}
	
	
	
	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Note that most of the paging logic is done in
	 * DataTable.ext.pager
	 */
	
	/**
	 * Generate the node required for default pagination
	 *  @param {object} oSettings dataTables settings object
	 *  @returns {node} Pagination feature node
	 *  @memberof DataTable#oApi
	 */
	function _fnFeatureHtmlPaginate ( settings )
	{
		var
			type   = settings.sPaginationType,
			plugin = DataTable.ext.pager[ type ],
			modern = typeof plugin === 'function',
			redraw = function( settings ) {
				_fnDraw( settings );
			},
			node = $('<div/>').addClass( settings.oClasses.sPaging + type )[0],
			features = settings.aanFeatures;
	
		if ( ! modern ) {
			plugin.fnInit( settings, node, redraw );
		}
	
		/* Add a draw callback for the pagination on first instance, to update the paging display */
		if ( ! features.p )
		{
			node.id = settings.sTableId+'_paginate';
	
			settings.aoDrawCallback.push( {
				"fn": function( settings ) {
					if ( modern ) {
						var
							start      = settings._iDisplayStart,
							len        = settings._iDisplayLength,
							visRecords = settings.fnRecordsDisplay(),
							all        = len === -1,
							page = all ? 0 : Math.ceil( start / len ),
							pages = all ? 1 : Math.ceil( visRecords / len ),
							buttons = plugin(page, pages),
							i, ien;
	
						for ( i=0, ien=features.p.length ; i<ien ; i++ ) {
							_fnRenderer( settings, 'pageButton' )(
								settings, features.p[i], i, buttons, page, pages
							);
						}
					}
					else {
						plugin.fnUpdate( settings, redraw );
					}
				},
				"sName": "pagination"
			} );
		}
	
		return node;
	}
	
	
	/**
	 * Alter the display settings to change the page
	 *  @param {object} settings DataTables settings object
	 *  @param {string|int} action Paging action to take: "first", "previous",
	 *    "next" or "last" or page number to jump to (integer)
	 *  @param [bool] redraw Automatically draw the update or not
	 *  @returns {bool} true page has changed, false - no change
	 *  @memberof DataTable#oApi
	 */
	function _fnPageChange ( settings, action, redraw )
	{
		var
			start     = settings._iDisplayStart,
			len       = settings._iDisplayLength,
			records   = settings.fnRecordsDisplay();
	
		if ( records === 0 || len === -1 )
		{
			start = 0;
		}
		else if ( typeof action === "number" )
		{
			start = action * len;
	
			if ( start > records )
			{
				start = 0;
			}
		}
		else if ( action == "first" )
		{
			start = 0;
		}
		else if ( action == "previous" )
		{
			start = len >= 0 ?
				start - len :
				0;
	
			if ( start < 0 )
			{
			  start = 0;
			}
		}
		else if ( action == "next" )
		{
			if ( start + len < records )
			{
				start += len;
			}
		}
		else if ( action == "last" )
		{
			start = Math.floor( (records-1) / len) * len;
		}
		else
		{
			_fnLog( settings, 0, "Unknown paging action: "+action, 5 );
		}
	
		var changed = settings._iDisplayStart !== start;
		settings._iDisplayStart = start;
	
		if ( changed ) {
			_fnCallbackFire( settings, null, 'page', [settings] );
	
			if ( redraw ) {
				_fnDraw( settings );
			}
		}
	
		return changed;
	}
	
	
	
	/**
	 * Generate the node required for the processing node
	 *  @param {object} settings dataTables settings object
	 *  @returns {node} Processing element
	 *  @memberof DataTable#oApi
	 */
	function _fnFeatureHtmlProcessing ( settings )
	{
		return $('<div/>', {
				'id': ! settings.aanFeatures.r ? settings.sTableId+'_processing' : null,
				'class': settings.oClasses.sProcessing
			} )
			.html( settings.oLanguage.sProcessing )
			.insertBefore( settings.nTable )[0];
	}
	
	
	/**
	 * Display or hide the processing indicator
	 *  @param {object} settings dataTables settings object
	 *  @param {bool} show Show the processing indicator (true) or not (false)
	 *  @memberof DataTable#oApi
	 */
	function _fnProcessingDisplay ( settings, show )
	{
		if ( settings.oFeatures.bProcessing ) {
			$(settings.aanFeatures.r).css( 'display', show ? 'block' : 'none' );
		}
	
		_fnCallbackFire( settings, null, 'processing', [settings, show] );
	}
	
	/**
	 * Add any control elements for the table - specifically scrolling
	 *  @param {object} settings dataTables settings object
	 *  @returns {node} Node to add to the DOM
	 *  @memberof DataTable#oApi
	 */
	function _fnFeatureHtmlTable ( settings )
	{
		var table = $(settings.nTable);
	
		// Add the ARIA grid role to the table
		table.attr( 'role', 'grid' );
	
		// Scrolling from here on in
		var scroll = settings.oScroll;
	
		if ( scroll.sX === '' && scroll.sY === '' ) {
			return settings.nTable;
		}
	
		var scrollX = scroll.sX;
		var scrollY = scroll.sY;
		var classes = settings.oClasses;
		var caption = table.children('caption');
		var captionSide = caption.length ? caption[0]._captionSide : null;
		var headerClone = $( table[0].cloneNode(false) );
		var footerClone = $( table[0].cloneNode(false) );
		var footer = table.children('tfoot');
		var _div = '<div/>';
		var size = function ( s ) {
			return !s ? null : _fnStringToCss( s );
		};
	
		if ( ! footer.length ) {
			footer = null;
		}
	
		/*
		 * The HTML structure that we want to generate in this function is:
		 *  div - scroller
		 *    div - scroll head
		 *      div - scroll head inner
		 *        table - scroll head table
		 *          thead - thead
		 *    div - scroll body
		 *      table - table (master table)
		 *        thead - thead clone for sizing
		 *        tbody - tbody
		 *    div - scroll foot
		 *      div - scroll foot inner
		 *        table - scroll foot table
		 *          tfoot - tfoot
		 */
		var scroller = $( _div, { 'class': classes.sScrollWrapper } )
			.append(
				$(_div, { 'class': classes.sScrollHead } )
					.css( {
						overflow: 'hidden',
						position: 'relative',
						border: 0,
						width: scrollX ? size(scrollX) : '100%'
					} )
					.append(
						$(_div, { 'class': classes.sScrollHeadInner } )
							.css( {
								'box-sizing': 'content-box',
								width: scroll.sXInner || '100%'
							} )
							.append(
								headerClone
									.removeAttr('id')
									.css( 'margin-left', 0 )
									.append( captionSide === 'top' ? caption : null )
									.append(
										table.children('thead')
									)
							)
					)
			)
			.append(
				$(_div, { 'class': classes.sScrollBody } )
					.css( {
						position: 'relative',
						overflow: 'auto',
						width: size( scrollX )
					} )
					.append( table )
			);
	
		if ( footer ) {
			scroller.append(
				$(_div, { 'class': classes.sScrollFoot } )
					.css( {
						overflow: 'hidden',
						border: 0,
						width: scrollX ? size(scrollX) : '100%'
					} )
					.append(
						$(_div, { 'class': classes.sScrollFootInner } )
							.append(
								footerClone
									.removeAttr('id')
									.css( 'margin-left', 0 )
									.append( captionSide === 'bottom' ? caption : null )
									.append(
										table.children('tfoot')
									)
							)
					)
			);
		}
	
		var children = scroller.children();
		var scrollHead = children[0];
		var scrollBody = children[1];
		var scrollFoot = footer ? children[2] : null;
	
		// When the body is scrolled, then we also want to scroll the headers
		if ( scrollX ) {
			$(scrollBody).on( 'scroll.DT', function (e) {
				var scrollLeft = this.scrollLeft;
	
				scrollHead.scrollLeft = scrollLeft;
	
				if ( footer ) {
					scrollFoot.scrollLeft = scrollLeft;
				}
			} );
		}
	
		$(scrollBody).css('max-height', scrollY);
		if (! scroll.bCollapse) {
			$(scrollBody).css('height', scrollY);
		}
	
		settings.nScrollHead = scrollHead;
		settings.nScrollBody = scrollBody;
		settings.nScrollFoot = scrollFoot;
	
		// On redraw - align columns
		settings.aoDrawCallback.push( {
			"fn": _fnScrollDraw,
			"sName": "scrolling"
		} );
	
		return scroller[0];
	}
	
	
	
	/**
	 * Update the header, footer and body tables for resizing - i.e. column
	 * alignment.
	 *
	 * Welcome to the most horrible function DataTables. The process that this
	 * function follows is basically:
	 *   1. Re-create the table inside the scrolling div
	 *   2. Take live measurements from the DOM
	 *   3. Apply the measurements to align the columns
	 *   4. Clean up
	 *
	 *  @param {object} settings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnScrollDraw ( settings )
	{
		// Given that this is such a monster function, a lot of variables are use
		// to try and keep the minimised size as small as possible
		var
			scroll         = settings.oScroll,
			scrollX        = scroll.sX,
			scrollXInner   = scroll.sXInner,
			scrollY        = scroll.sY,
			barWidth       = scroll.iBarWidth,
			divHeader      = $(settings.nScrollHead),
			divHeaderStyle = divHeader[0].style,
			divHeaderInner = divHeader.children('div'),
			divHeaderInnerStyle = divHeaderInner[0].style,
			divHeaderTable = divHeaderInner.children('table'),
			divBodyEl      = settings.nScrollBody,
			divBody        = $(divBodyEl),
			divBodyStyle   = divBodyEl.style,
			divFooter      = $(settings.nScrollFoot),
			divFooterInner = divFooter.children('div'),
			divFooterTable = divFooterInner.children('table'),
			header         = $(settings.nTHead),
			table          = $(settings.nTable),
			tableEl        = table[0],
			tableStyle     = tableEl.style,
			footer         = settings.nTFoot ? $(settings.nTFoot) : null,
			browser        = settings.oBrowser,
			ie67           = browser.bScrollOversize,
			dtHeaderCells  = _pluck( settings.aoColumns, 'nTh' ),
			headerTrgEls, footerTrgEls,
			headerSrcEls, footerSrcEls,
			headerCopy, footerCopy,
			headerWidths=[], footerWidths=[],
			headerContent=[], footerContent=[],
			idx, correction, sanityWidth,
			zeroOut = function(nSizer) {
				var style = nSizer.style;
				style.paddingTop = "0";
				style.paddingBottom = "0";
				style.borderTopWidth = "0";
				style.borderBottomWidth = "0";
				style.height = 0;
			};
	
		// If the scrollbar visibility has changed from the last draw, we need to
		// adjust the column sizes as the table width will have changed to account
		// for the scrollbar
		var scrollBarVis = divBodyEl.scrollHeight > divBodyEl.clientHeight;
		
		if ( settings.scrollBarVis !== scrollBarVis && settings.scrollBarVis !== undefined ) {
			settings.scrollBarVis = scrollBarVis;
			_fnAdjustColumnSizing( settings );
			return; // adjust column sizing will call this function again
		}
		else {
			settings.scrollBarVis = scrollBarVis;
		}
	
		/*
		 * 1. Re-create the table inside the scrolling div
		 */
	
		// Remove the old minimised thead and tfoot elements in the inner table
		table.children('thead, tfoot').remove();
	
		if ( footer ) {
			footerCopy = footer.clone().prependTo( table );
			footerTrgEls = footer.find('tr'); // the original tfoot is in its own table and must be sized
			footerSrcEls = footerCopy.find('tr');
		}
	
		// Clone the current header and footer elements and then place it into the inner table
		headerCopy = header.clone().prependTo( table );
		headerTrgEls = header.find('tr'); // original header is in its own table
		headerSrcEls = headerCopy.find('tr');
		headerCopy.find('th, td').removeAttr('tabindex');
	
	
		/*
		 * 2. Take live measurements from the DOM - do not alter the DOM itself!
		 */
	
		// Remove old sizing and apply the calculated column widths
		// Get the unique column headers in the newly created (cloned) header. We want to apply the
		// calculated sizes to this header
		if ( ! scrollX )
		{
			divBodyStyle.width = '100%';
			divHeader[0].style.width = '100%';
		}
	
		$.each( _fnGetUniqueThs( settings, headerCopy ), function ( i, el ) {
			idx = _fnVisibleToColumnIndex( settings, i );
			el.style.width = settings.aoColumns[idx].sWidth;
		} );
	
		if ( footer ) {
			_fnApplyToChildren( function(n) {
				n.style.width = "";
			}, footerSrcEls );
		}
	
		// Size the table as a whole
		sanityWidth = table.outerWidth();
		if ( scrollX === "" ) {
			// No x scrolling
			tableStyle.width = "100%";
	
			// IE7 will make the width of the table when 100% include the scrollbar
			// - which is shouldn't. When there is a scrollbar we need to take this
			// into account.
			if ( ie67 && (table.find('tbody').height() > divBodyEl.offsetHeight ||
				divBody.css('overflow-y') == "scroll")
			) {
				tableStyle.width = _fnStringToCss( table.outerWidth() - barWidth);
			}
	
			// Recalculate the sanity width
			sanityWidth = table.outerWidth();
		}
		else if ( scrollXInner !== "" ) {
			// legacy x scroll inner has been given - use it
			tableStyle.width = _fnStringToCss(scrollXInner);
	
			// Recalculate the sanity width
			sanityWidth = table.outerWidth();
		}
	
		// Hidden header should have zero height, so remove padding and borders. Then
		// set the width based on the real headers
	
		// Apply all styles in one pass
		_fnApplyToChildren( zeroOut, headerSrcEls );
	
		// Read all widths in next pass
		_fnApplyToChildren( function(nSizer) {
			headerContent.push( nSizer.innerHTML );
			headerWidths.push( _fnStringToCss( $(nSizer).css('width') ) );
		}, headerSrcEls );
	
		// Apply all widths in final pass
		_fnApplyToChildren( function(nToSize, i) {
			// Only apply widths to the DataTables detected header cells - this
			// prevents complex headers from having contradictory sizes applied
			if ( $.inArray( nToSize, dtHeaderCells ) !== -1 ) {
				nToSize.style.width = headerWidths[i];
			}
		}, headerTrgEls );
	
		$(headerSrcEls).height(0);
	
		/* Same again with the footer if we have one */
		if ( footer )
		{
			_fnApplyToChildren( zeroOut, footerSrcEls );
	
			_fnApplyToChildren( function(nSizer) {
				footerContent.push( nSizer.innerHTML );
				footerWidths.push( _fnStringToCss( $(nSizer).css('width') ) );
			}, footerSrcEls );
	
			_fnApplyToChildren( function(nToSize, i) {
				nToSize.style.width = footerWidths[i];
			}, footerTrgEls );
	
			$(footerSrcEls).height(0);
		}
	
	
		/*
		 * 3. Apply the measurements
		 */
	
		// "Hide" the header and footer that we used for the sizing. We need to keep
		// the content of the cell so that the width applied to the header and body
		// both match, but we want to hide it completely. We want to also fix their
		// width to what they currently are
		_fnApplyToChildren( function(nSizer, i) {
			nSizer.innerHTML = '<div class="dataTables_sizing">'+headerContent[i]+'</div>';
			nSizer.childNodes[0].style.height = "0";
			nSizer.childNodes[0].style.overflow = "hidden";
			nSizer.style.width = headerWidths[i];
		}, headerSrcEls );
	
		if ( footer )
		{
			_fnApplyToChildren( function(nSizer, i) {
				nSizer.innerHTML = '<div class="dataTables_sizing">'+footerContent[i]+'</div>';
				nSizer.childNodes[0].style.height = "0";
				nSizer.childNodes[0].style.overflow = "hidden";
				nSizer.style.width = footerWidths[i];
			}, footerSrcEls );
		}
	
		// Sanity check that the table is of a sensible width. If not then we are going to get
		// misalignment - try to prevent this by not allowing the table to shrink below its min width
		if ( table.outerWidth() < sanityWidth )
		{
			// The min width depends upon if we have a vertical scrollbar visible or not */
			correction = ((divBodyEl.scrollHeight > divBodyEl.offsetHeight ||
				divBody.css('overflow-y') == "scroll")) ?
					sanityWidth+barWidth :
					sanityWidth;
	
			// IE6/7 are a law unto themselves...
			if ( ie67 && (divBodyEl.scrollHeight >
				divBodyEl.offsetHeight || divBody.css('overflow-y') == "scroll")
			) {
				tableStyle.width = _fnStringToCss( correction-barWidth );
			}
	
			// And give the user a warning that we've stopped the table getting too small
			if ( scrollX === "" || scrollXInner !== "" ) {
				_fnLog( settings, 1, 'Possible column misalignment', 6 );
			}
		}
		else
		{
			correction = '100%';
		}
	
		// Apply to the container elements
		divBodyStyle.width = _fnStringToCss( correction );
		divHeaderStyle.width = _fnStringToCss( correction );
	
		if ( footer ) {
			settings.nScrollFoot.style.width = _fnStringToCss( correction );
		}
	
	
		/*
		 * 4. Clean up
		 */
		if ( ! scrollY ) {
			/* IE7< puts a vertical scrollbar in place (when it shouldn't be) due to subtracting
			 * the scrollbar height from the visible display, rather than adding it on. We need to
			 * set the height in order to sort this. Don't want to do it in any other browsers.
			 */
			if ( ie67 ) {
				divBodyStyle.height = _fnStringToCss( tableEl.offsetHeight+barWidth );
			}
		}
	
		/* Finally set the width's of the header and footer tables */
		var iOuterWidth = table.outerWidth();
		divHeaderTable[0].style.width = _fnStringToCss( iOuterWidth );
		divHeaderInnerStyle.width = _fnStringToCss( iOuterWidth );
	
		// Figure out if there are scrollbar present - if so then we need a the header and footer to
		// provide a bit more space to allow "overflow" scrolling (i.e. past the scrollbar)
		var bScrolling = table.height() > divBodyEl.clientHeight || divBody.css('overflow-y') == "scroll";
		var padding = 'padding' + (browser.bScrollbarLeft ? 'Left' : 'Right' );
		divHeaderInnerStyle[ padding ] = bScrolling ? barWidth+"px" : "0px";
	
		if ( footer ) {
			divFooterTable[0].style.width = _fnStringToCss( iOuterWidth );
			divFooterInner[0].style.width = _fnStringToCss( iOuterWidth );
			divFooterInner[0].style[padding] = bScrolling ? barWidth+"px" : "0px";
		}
	
		// Correct DOM ordering for colgroup - comes before the thead
		table.children('colgroup').insertBefore( table.children('thead') );
	
		/* Adjust the position of the header in case we loose the y-scrollbar */
		divBody.trigger('scroll');
	
		// If sorting or filtering has occurred, jump the scrolling back to the top
		// only if we aren't holding the position
		if ( (settings.bSorted || settings.bFiltered) && ! settings._drawHold ) {
			divBodyEl.scrollTop = 0;
		}
	}
	
	
	
	/**
	 * Apply a given function to the display child nodes of an element array (typically
	 * TD children of TR rows
	 *  @param {function} fn Method to apply to the objects
	 *  @param array {nodes} an1 List of elements to look through for display children
	 *  @param array {nodes} an2 Another list (identical structure to the first) - optional
	 *  @memberof DataTable#oApi
	 */
	function _fnApplyToChildren( fn, an1, an2 )
	{
		var index=0, i=0, iLen=an1.length;
		var nNode1, nNode2;
	
		while ( i < iLen ) {
			nNode1 = an1[i].firstChild;
			nNode2 = an2 ? an2[i].firstChild : null;
	
			while ( nNode1 ) {
				if ( nNode1.nodeType === 1 ) {
					if ( an2 ) {
						fn( nNode1, nNode2, index );
					}
					else {
						fn( nNode1, index );
					}
	
					index++;
				}
	
				nNode1 = nNode1.nextSibling;
				nNode2 = an2 ? nNode2.nextSibling : null;
			}
	
			i++;
		}
	}
	
	
	
	var __re_html_remove = /<.*?>/g;
	
	
	/**
	 * Calculate the width of columns for the table
	 *  @param {object} oSettings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnCalculateColumnWidths ( oSettings )
	{
		var
			table = oSettings.nTable,
			columns = oSettings.aoColumns,
			scroll = oSettings.oScroll,
			scrollY = scroll.sY,
			scrollX = scroll.sX,
			scrollXInner = scroll.sXInner,
			columnCount = columns.length,
			visibleColumns = _fnGetColumns( oSettings, 'bVisible' ),
			headerCells = $('th', oSettings.nTHead),
			tableWidthAttr = table.getAttribute('width'), // from DOM element
			tableContainer = table.parentNode,
			userInputs = false,
			i, column, columnIdx, width, outerWidth,
			browser = oSettings.oBrowser,
			ie67 = browser.bScrollOversize;
	
		var styleWidth = table.style.width;
		if ( styleWidth && styleWidth.indexOf('%') !== -1 ) {
			tableWidthAttr = styleWidth;
		}
	
		/* Convert any user input sizes into pixel sizes */
		for ( i=0 ; i<visibleColumns.length ; i++ ) {
			column = columns[ visibleColumns[i] ];
	
			if ( column.sWidth !== null ) {
				column.sWidth = _fnConvertToWidth( column.sWidthOrig, tableContainer );
	
				userInputs = true;
			}
		}
	
		/* If the number of columns in the DOM equals the number that we have to
		 * process in DataTables, then we can use the offsets that are created by
		 * the web- browser. No custom sizes can be set in order for this to happen,
		 * nor scrolling used
		 */
		if ( ie67 || ! userInputs && ! scrollX && ! scrollY &&
		     columnCount == _fnVisbleColumns( oSettings ) &&
		     columnCount == headerCells.length
		) {
			for ( i=0 ; i<columnCount ; i++ ) {
				var colIdx = _fnVisibleToColumnIndex( oSettings, i );
	
				if ( colIdx !== null ) {
					columns[ colIdx ].sWidth = _fnStringToCss( headerCells.eq(i).width() );
				}
			}
		}
		else
		{
			// Otherwise construct a single row, worst case, table with the widest
			// node in the data, assign any user defined widths, then insert it into
			// the DOM and allow the browser to do all the hard work of calculating
			// table widths
			var tmpTable = $(table).clone() // don't use cloneNode - IE8 will remove events on the main table
				.css( 'visibility', 'hidden' )
				.removeAttr( 'id' );
	
			// Clean up the table body
			tmpTable.find('tbody tr').remove();
			var tr = $('<tr/>').appendTo( tmpTable.find('tbody') );
	
			// Clone the table header and footer - we can't use the header / footer
			// from the cloned table, since if scrolling is active, the table's
			// real header and footer are contained in different table tags
			tmpTable.find('thead, tfoot').remove();
			tmpTable
				.append( $(oSettings.nTHead).clone() )
				.append( $(oSettings.nTFoot).clone() );
	
			// Remove any assigned widths from the footer (from scrolling)
			tmpTable.find('tfoot th, tfoot td').css('width', '');
	
			// Apply custom sizing to the cloned header
			headerCells = _fnGetUniqueThs( oSettings, tmpTable.find('thead')[0] );
	
			for ( i=0 ; i<visibleColumns.length ; i++ ) {
				column = columns[ visibleColumns[i] ];
	
				headerCells[i].style.width = column.sWidthOrig !== null && column.sWidthOrig !== '' ?
					_fnStringToCss( column.sWidthOrig ) :
					'';
	
				// For scrollX we need to force the column width otherwise the
				// browser will collapse it. If this width is smaller than the
				// width the column requires, then it will have no effect
				if ( column.sWidthOrig && scrollX ) {
					$( headerCells[i] ).append( $('<div/>').css( {
						width: column.sWidthOrig,
						margin: 0,
						padding: 0,
						border: 0,
						height: 1
					} ) );
				}
			}
	
			// Find the widest cell for each column and put it into the table
			if ( oSettings.aoData.length ) {
				for ( i=0 ; i<visibleColumns.length ; i++ ) {
					columnIdx = visibleColumns[i];
					column = columns[ columnIdx ];
	
					$( _fnGetWidestNode( oSettings, columnIdx ) )
						.clone( false )
						.append( column.sContentPadding )
						.appendTo( tr );
				}
			}
	
			// Tidy the temporary table - remove name attributes so there aren't
			// duplicated in the dom (radio elements for example)
			$('[name]', tmpTable).removeAttr('name');
	
			// Table has been built, attach to the document so we can work with it.
			// A holding element is used, positioned at the top of the container
			// with minimal height, so it has no effect on if the container scrolls
			// or not. Otherwise it might trigger scrolling when it actually isn't
			// needed
			var holder = $('<div/>').css( scrollX || scrollY ?
					{
						position: 'absolute',
						top: 0,
						left: 0,
						height: 1,
						right: 0,
						overflow: 'hidden'
					} :
					{}
				)
				.append( tmpTable )
				.appendTo( tableContainer );
	
			// When scrolling (X or Y) we want to set the width of the table as 
			// appropriate. However, when not scrolling leave the table width as it
			// is. This results in slightly different, but I think correct behaviour
			if ( scrollX && scrollXInner ) {
				tmpTable.width( scrollXInner );
			}
			else if ( scrollX ) {
				tmpTable.css( 'width', 'auto' );
				tmpTable.removeAttr('width');
	
				// If there is no width attribute or style, then allow the table to
				// collapse
				if ( tmpTable.width() < tableContainer.clientWidth && tableWidthAttr ) {
					tmpTable.width( tableContainer.clientWidth );
				}
			}
			else if ( scrollY ) {
				tmpTable.width( tableContainer.clientWidth );
			}
			else if ( tableWidthAttr ) {
				tmpTable.width( tableWidthAttr );
			}
	
			// Get the width of each column in the constructed table - we need to
			// know the inner width (so it can be assigned to the other table's
			// cells) and the outer width so we can calculate the full width of the
			// table. This is safe since DataTables requires a unique cell for each
			// column, but if ever a header can span multiple columns, this will
			// need to be modified.
			var total = 0;
			for ( i=0 ; i<visibleColumns.length ; i++ ) {
				var cell = $(headerCells[i]);
				var border = cell.outerWidth() - cell.width();
	
				// Use getBounding... where possible (not IE8-) because it can give
				// sub-pixel accuracy, which we then want to round up!
				var bounding = browser.bBounding ?
					Math.ceil( headerCells[i].getBoundingClientRect().width ) :
					cell.outerWidth();
	
				// Total is tracked to remove any sub-pixel errors as the outerWidth
				// of the table might not equal the total given here (IE!).
				total += bounding;
	
				// Width for each column to use
				columns[ visibleColumns[i] ].sWidth = _fnStringToCss( bounding - border );
			}
	
			table.style.width = _fnStringToCss( total );
	
			// Finished with the table - ditch it
			holder.remove();
		}
	
		// If there is a width attr, we want to attach an event listener which
		// allows the table sizing to automatically adjust when the window is
		// resized. Use the width attr rather than CSS, since we can't know if the
		// CSS is a relative value or absolute - DOM read is always px.
		if ( tableWidthAttr ) {
			table.style.width = _fnStringToCss( tableWidthAttr );
		}
	
		if ( (tableWidthAttr || scrollX) && ! oSettings._reszEvt ) {
			var bindResize = function () {
				$(window).on('resize.DT-'+oSettings.sInstance, _fnThrottle( function () {
					_fnAdjustColumnSizing( oSettings );
				} ) );
			};
	
			// IE6/7 will crash if we bind a resize event handler on page load.
			// To be removed in 1.11 which drops IE6/7 support
			if ( ie67 ) {
				setTimeout( bindResize, 1000 );
			}
			else {
				bindResize();
			}
	
			oSettings._reszEvt = true;
		}
	}
	
	
	/**
	 * Throttle the calls to a function. Arguments and context are maintained for
	 * the throttled function
	 *  @param {function} fn Function to be called
	 *  @param {int} [freq=200] call frequency in mS
	 *  @returns {function} wrapped function
	 *  @memberof DataTable#oApi
	 */
	var _fnThrottle = DataTable.util.throttle;
	
	
	/**
	 * Convert a CSS unit width to pixels (e.g. 2em)
	 *  @param {string} width width to be converted
	 *  @param {node} parent parent to get the with for (required for relative widths) - optional
	 *  @returns {int} width in pixels
	 *  @memberof DataTable#oApi
	 */
	function _fnConvertToWidth ( width, parent )
	{
		if ( ! width ) {
			return 0;
		}
	
		var n = $('<div/>')
			.css( 'width', _fnStringToCss( width ) )
			.appendTo( parent || document.body );
	
		var val = n[0].offsetWidth;
		n.remove();
	
		return val;
	}
	
	
	/**
	 * Get the widest node
	 *  @param {object} settings dataTables settings object
	 *  @param {int} colIdx column of interest
	 *  @returns {node} widest table node
	 *  @memberof DataTable#oApi
	 */
	function _fnGetWidestNode( settings, colIdx )
	{
		var idx = _fnGetMaxLenString( settings, colIdx );
		if ( idx < 0 ) {
			return null;
		}
	
		var data = settings.aoData[ idx ];
		return ! data.nTr ? // Might not have been created when deferred rendering
			$('<td/>').html( _fnGetCellData( settings, idx, colIdx, 'display' ) )[0] :
			data.anCells[ colIdx ];
	}
	
	
	/**
	 * Get the maximum strlen for each data column
	 *  @param {object} settings dataTables settings object
	 *  @param {int} colIdx column of interest
	 *  @returns {string} max string length for each column
	 *  @memberof DataTable#oApi
	 */
	function _fnGetMaxLenString( settings, colIdx )
	{
		var s, max=-1, maxIdx = -1;
	
		for ( var i=0, ien=settings.aoData.length ; i<ien ; i++ ) {
			s = _fnGetCellData( settings, i, colIdx, 'display' )+'';
			s = s.replace( __re_html_remove, '' );
			s = s.replace( /&nbsp;/g, ' ' );
	
			if ( s.length > max ) {
				max = s.length;
				maxIdx = i;
			}
		}
	
		return maxIdx;
	}
	
	
	/**
	 * Append a CSS unit (only if required) to a string
	 *  @param {string} value to css-ify
	 *  @returns {string} value with css unit
	 *  @memberof DataTable#oApi
	 */
	function _fnStringToCss( s )
	{
		if ( s === null ) {
			return '0px';
		}
	
		if ( typeof s == 'number' ) {
			return s < 0 ?
				'0px' :
				s+'px';
		}
	
		// Check it has a unit character already
		return s.match(/\d$/) ?
			s+'px' :
			s;
	}
	
	
	
	function _fnSortFlatten ( settings )
	{
		var
			i, iLen, k, kLen,
			aSort = [],
			aiOrig = [],
			aoColumns = settings.aoColumns,
			aDataSort, iCol, sType, srcCol,
			fixed = settings.aaSortingFixed,
			fixedObj = $.isPlainObject( fixed ),
			nestedSort = [],
			add = function ( a ) {
				if ( a.length && ! $.isArray( a[0] ) ) {
					// 1D array
					nestedSort.push( a );
				}
				else {
					// 2D array
					$.merge( nestedSort, a );
				}
			};
	
		// Build the sort array, with pre-fix and post-fix options if they have been
		// specified
		if ( $.isArray( fixed ) ) {
			add( fixed );
		}
	
		if ( fixedObj && fixed.pre ) {
			add( fixed.pre );
		}
	
		add( settings.aaSorting );
	
		if (fixedObj && fixed.post ) {
			add( fixed.post );
		}
	
		for ( i=0 ; i<nestedSort.length ; i++ )
		{
			srcCol = nestedSort[i][0];
			aDataSort = aoColumns[ srcCol ].aDataSort;
	
			for ( k=0, kLen=aDataSort.length ; k<kLen ; k++ )
			{
				iCol = aDataSort[k];
				sType = aoColumns[ iCol ].sType || 'string';
	
				if ( nestedSort[i]._idx === undefined ) {
					nestedSort[i]._idx = $.inArray( nestedSort[i][1], aoColumns[iCol].asSorting );
				}
	
				aSort.push( {
					src:       srcCol,
					col:       iCol,
					dir:       nestedSort[i][1],
					index:     nestedSort[i]._idx,
					type:      sType,
					formatter: DataTable.ext.type.order[ sType+"-pre" ]
				} );
			}
		}
	
		return aSort;
	}
	
	/**
	 * Change the order of the table
	 *  @param {object} oSettings dataTables settings object
	 *  @memberof DataTable#oApi
	 *  @todo This really needs split up!
	 */
	function _fnSort ( oSettings )
	{
		var
			i, ien, iLen, j, jLen, k, kLen,
			sDataType, nTh,
			aiOrig = [],
			oExtSort = DataTable.ext.type.order,
			aoData = oSettings.aoData,
			aoColumns = oSettings.aoColumns,
			aDataSort, data, iCol, sType, oSort,
			formatters = 0,
			sortCol,
			displayMaster = oSettings.aiDisplayMaster,
			aSort;
	
		// Resolve any column types that are unknown due to addition or invalidation
		// @todo Can this be moved into a 'data-ready' handler which is called when
		//   data is going to be used in the table?
		_fnColumnTypes( oSettings );
	
		aSort = _fnSortFlatten( oSettings );
	
		for ( i=0, ien=aSort.length ; i<ien ; i++ ) {
			sortCol = aSort[i];
	
			// Track if we can use the fast sort algorithm
			if ( sortCol.formatter ) {
				formatters++;
			}
	
			// Load the data needed for the sort, for each cell
			_fnSortData( oSettings, sortCol.col );
		}
	
		/* No sorting required if server-side or no sorting array */
		if ( _fnDataSource( oSettings ) != 'ssp' && aSort.length !== 0 )
		{
			// Create a value - key array of the current row positions such that we can use their
			// current position during the sort, if values match, in order to perform stable sorting
			for ( i=0, iLen=displayMaster.length ; i<iLen ; i++ ) {
				aiOrig[ displayMaster[i] ] = i;
			}
	
			/* Do the sort - here we want multi-column sorting based on a given data source (column)
			 * and sorting function (from oSort) in a certain direction. It's reasonably complex to
			 * follow on it's own, but this is what we want (example two column sorting):
			 *  fnLocalSorting = function(a,b){
			 *    var iTest;
			 *    iTest = oSort['string-asc']('data11', 'data12');
			 *      if (iTest !== 0)
			 *        return iTest;
			 *    iTest = oSort['numeric-desc']('data21', 'data22');
			 *    if (iTest !== 0)
			 *      return iTest;
			 *    return oSort['numeric-asc']( aiOrig[a], aiOrig[b] );
			 *  }
			 * Basically we have a test for each sorting column, if the data in that column is equal,
			 * test the next column. If all columns match, then we use a numeric sort on the row
			 * positions in the original data array to provide a stable sort.
			 *
			 * Note - I know it seems excessive to have two sorting methods, but the first is around
			 * 15% faster, so the second is only maintained for backwards compatibility with sorting
			 * methods which do not have a pre-sort formatting function.
			 */
			if ( formatters === aSort.length ) {
				// All sort types have formatting functions
				displayMaster.sort( function ( a, b ) {
					var
						x, y, k, test, sort,
						len=aSort.length,
						dataA = aoData[a]._aSortData,
						dataB = aoData[b]._aSortData;
	
					for ( k=0 ; k<len ; k++ ) {
						sort = aSort[k];
	
						x = dataA[ sort.col ];
						y = dataB[ sort.col ];
	
						test = x<y ? -1 : x>y ? 1 : 0;
						if ( test !== 0 ) {
							return sort.dir === 'asc' ? test : -test;
						}
					}
	
					x = aiOrig[a];
					y = aiOrig[b];
					return x<y ? -1 : x>y ? 1 : 0;
				} );
			}
			else {
				// Depreciated - remove in 1.11 (providing a plug-in option)
				// Not all sort types have formatting methods, so we have to call their sorting
				// methods.
				displayMaster.sort( function ( a, b ) {
					var
						x, y, k, l, test, sort, fn,
						len=aSort.length,
						dataA = aoData[a]._aSortData,
						dataB = aoData[b]._aSortData;
	
					for ( k=0 ; k<len ; k++ ) {
						sort = aSort[k];
	
						x = dataA[ sort.col ];
						y = dataB[ sort.col ];
	
						fn = oExtSort[ sort.type+"-"+sort.dir ] || oExtSort[ "string-"+sort.dir ];
						test = fn( x, y );
						if ( test !== 0 ) {
							return test;
						}
					}
	
					x = aiOrig[a];
					y = aiOrig[b];
					return x<y ? -1 : x>y ? 1 : 0;
				} );
			}
		}
	
		/* Tell the draw function that we have sorted the data */
		oSettings.bSorted = true;
	}
	
	
	function _fnSortAria ( settings )
	{
		var label;
		var nextSort;
		var columns = settings.aoColumns;
		var aSort = _fnSortFlatten( settings );
		var oAria = settings.oLanguage.oAria;
	
		// ARIA attributes - need to loop all columns, to update all (removing old
		// attributes as needed)
		for ( var i=0, iLen=columns.length ; i<iLen ; i++ )
		{
			var col = columns[i];
			var asSorting = col.asSorting;
			var sTitle = col.sTitle.replace( /<.*?>/g, "" );
			var th = col.nTh;
	
			// IE7 is throwing an error when setting these properties with jQuery's
			// attr() and removeAttr() methods...
			th.removeAttribute('aria-sort');
	
			/* In ARIA only the first sorting column can be marked as sorting - no multi-sort option */
			if ( col.bSortable ) {
				if ( aSort.length > 0 && aSort[0].col == i ) {
					th.setAttribute('aria-sort', aSort[0].dir=="asc" ? "ascending" : "descending" );
					nextSort = asSorting[ aSort[0].index+1 ] || asSorting[0];
				}
				else {
					nextSort = asSorting[0];
				}
	
				label = sTitle + ( nextSort === "asc" ?
					oAria.sSortAscending :
					oAria.sSortDescending
				);
			}
			else {
				label = sTitle;
			}
	
			th.setAttribute('aria-label', label);
		}
	}
	
	
	/**
	 * Function to run on user sort request
	 *  @param {object} settings dataTables settings object
	 *  @param {node} attachTo node to attach the handler to
	 *  @param {int} colIdx column sorting index
	 *  @param {boolean} [append=false] Append the requested sort to the existing
	 *    sort if true (i.e. multi-column sort)
	 *  @param {function} [callback] callback function
	 *  @memberof DataTable#oApi
	 */
	function _fnSortListener ( settings, colIdx, append, callback )
	{
		var col = settings.aoColumns[ colIdx ];
		var sorting = settings.aaSorting;
		var asSorting = col.asSorting;
		var nextSortIdx;
		var next = function ( a, overflow ) {
			var idx = a._idx;
			if ( idx === undefined ) {
				idx = $.inArray( a[1], asSorting );
			}
	
			return idx+1 < asSorting.length ?
				idx+1 :
				overflow ?
					null :
					0;
		};
	
		// Convert to 2D array if needed
		if ( typeof sorting[0] === 'number' ) {
			sorting = settings.aaSorting = [ sorting ];
		}
	
		// If appending the sort then we are multi-column sorting
		if ( append && settings.oFeatures.bSortMulti ) {
			// Are we already doing some kind of sort on this column?
			var sortIdx = $.inArray( colIdx, _pluck(sorting, '0') );
	
			if ( sortIdx !== -1 ) {
				// Yes, modify the sort
				nextSortIdx = next( sorting[sortIdx], true );
	
				if ( nextSortIdx === null && sorting.length === 1 ) {
					nextSortIdx = 0; // can't remove sorting completely
				}
	
				if ( nextSortIdx === null ) {
					sorting.splice( sortIdx, 1 );
				}
				else {
					sorting[sortIdx][1] = asSorting[ nextSortIdx ];
					sorting[sortIdx]._idx = nextSortIdx;
				}
			}
			else {
				// No sort on this column yet
				sorting.push( [ colIdx, asSorting[0], 0 ] );
				sorting[sorting.length-1]._idx = 0;
			}
		}
		else if ( sorting.length && sorting[0][0] == colIdx ) {
			// Single column - already sorting on this column, modify the sort
			nextSortIdx = next( sorting[0] );
	
			sorting.length = 1;
			sorting[0][1] = asSorting[ nextSortIdx ];
			sorting[0]._idx = nextSortIdx;
		}
		else {
			// Single column - sort only on this column
			sorting.length = 0;
			sorting.push( [ colIdx, asSorting[0] ] );
			sorting[0]._idx = 0;
		}
	
		// Run the sort by calling a full redraw
		_fnReDraw( settings );
	
		// callback used for async user interaction
		if ( typeof callback == 'function' ) {
			callback( settings );
		}
	}
	
	
	/**
	 * Attach a sort handler (click) to a node
	 *  @param {object} settings dataTables settings object
	 *  @param {node} attachTo node to attach the handler to
	 *  @param {int} colIdx column sorting index
	 *  @param {function} [callback] callback function
	 *  @memberof DataTable#oApi
	 */
	function _fnSortAttachListener ( settings, attachTo, colIdx, callback )
	{
		var col = settings.aoColumns[ colIdx ];
	
		_fnBindAction( attachTo, {}, function (e) {
			/* If the column is not sortable - don't to anything */
			if ( col.bSortable === false ) {
				return;
			}
	
			// If processing is enabled use a timeout to allow the processing
			// display to be shown - otherwise to it synchronously
			if ( settings.oFeatures.bProcessing ) {
				_fnProcessingDisplay( settings, true );
	
				setTimeout( function() {
					_fnSortListener( settings, colIdx, e.shiftKey, callback );
	
					// In server-side processing, the draw callback will remove the
					// processing display
					if ( _fnDataSource( settings ) !== 'ssp' ) {
						_fnProcessingDisplay( settings, false );
					}
				}, 0 );
			}
			else {
				_fnSortListener( settings, colIdx, e.shiftKey, callback );
			}
		} );
	}
	
	
	/**
	 * Set the sorting classes on table's body, Note: it is safe to call this function
	 * when bSort and bSortClasses are false
	 *  @param {object} oSettings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnSortingClasses( settings )
	{
		var oldSort = settings.aLastSort;
		var sortClass = settings.oClasses.sSortColumn;
		var sort = _fnSortFlatten( settings );
		var features = settings.oFeatures;
		var i, ien, colIdx;
	
		if ( features.bSort && features.bSortClasses ) {
			// Remove old sorting classes
			for ( i=0, ien=oldSort.length ; i<ien ; i++ ) {
				colIdx = oldSort[i].src;
	
				// Remove column sorting
				$( _pluck( settings.aoData, 'anCells', colIdx ) )
					.removeClass( sortClass + (i<2 ? i+1 : 3) );
			}
	
			// Add new column sorting
			for ( i=0, ien=sort.length ; i<ien ; i++ ) {
				colIdx = sort[i].src;
	
				$( _pluck( settings.aoData, 'anCells', colIdx ) )
					.addClass( sortClass + (i<2 ? i+1 : 3) );
			}
		}
	
		settings.aLastSort = sort;
	}
	
	
	// Get the data to sort a column, be it from cache, fresh (populating the
	// cache), or from a sort formatter
	function _fnSortData( settings, idx )
	{
		// Custom sorting function - provided by the sort data type
		var column = settings.aoColumns[ idx ];
		var customSort = DataTable.ext.order[ column.sSortDataType ];
		var customData;
	
		if ( customSort ) {
			customData = customSort.call( settings.oInstance, settings, idx,
				_fnColumnIndexToVisible( settings, idx )
			);
		}
	
		// Use / populate cache
		var row, cellData;
		var formatter = DataTable.ext.type.order[ column.sType+"-pre" ];
	
		for ( var i=0, ien=settings.aoData.length ; i<ien ; i++ ) {
			row = settings.aoData[i];
	
			if ( ! row._aSortData ) {
				row._aSortData = [];
			}
	
			if ( ! row._aSortData[idx] || customSort ) {
				cellData = customSort ?
					customData[i] : // If there was a custom sort function, use data from there
					_fnGetCellData( settings, i, idx, 'sort' );
	
				row._aSortData[ idx ] = formatter ?
					formatter( cellData ) :
					cellData;
			}
		}
	}
	
	
	
	/**
	 * Save the state of a table
	 *  @param {object} oSettings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnSaveState ( settings )
	{
		if ( !settings.oFeatures.bStateSave || settings.bDestroying )
		{
			return;
		}
	
		/* Store the interesting variables */
		var state = {
			time:    +new Date(),
			start:   settings._iDisplayStart,
			length:  settings._iDisplayLength,
			order:   $.extend( true, [], settings.aaSorting ),
			search:  _fnSearchToCamel( settings.oPreviousSearch ),
			columns: $.map( settings.aoColumns, function ( col, i ) {
				return {
					visible: col.bVisible,
					search: _fnSearchToCamel( settings.aoPreSearchCols[i] )
				};
			} )
		};
	
		_fnCallbackFire( settings, "aoStateSaveParams", 'stateSaveParams', [settings, state] );
	
		settings.oSavedState = state;
		settings.fnStateSaveCallback.call( settings.oInstance, settings, state );
	}
	
	
	/**
	 * Attempt to load a saved table state
	 *  @param {object} oSettings dataTables settings object
	 *  @param {object} oInit DataTables init object so we can override settings
	 *  @param {function} callback Callback to execute when the state has been loaded
	 *  @memberof DataTable#oApi
	 */
	function _fnLoadState ( settings, oInit, callback )
	{
		var i, ien;
		var columns = settings.aoColumns;
		var loaded = function ( s ) {
			if ( ! s || ! s.time ) {
				callback();
				return;
			}
	
			// Allow custom and plug-in manipulation functions to alter the saved data set and
			// cancelling of loading by returning false
			var abStateLoad = _fnCallbackFire( settings, 'aoStateLoadParams', 'stateLoadParams', [settings, s] );
			if ( $.inArray( false, abStateLoad ) !== -1 ) {
				callback();
				return;
			}
	
			// Reject old data
			var duration = settings.iStateDuration;
			if ( duration > 0 && s.time < +new Date() - (duration*1000) ) {
				callback();
				return;
			}
	
			// Number of columns have changed - all bets are off, no restore of settings
			if ( s.columns && columns.length !== s.columns.length ) {
				callback();
				return;
			}
	
			// Store the saved state so it might be accessed at any time
			settings.oLoadedState = $.extend( true, {}, s );
	
			// Restore key features - todo - for 1.11 this needs to be done by
			// subscribed events
			if ( s.start !== undefined ) {
				settings._iDisplayStart    = s.start;
				settings.iInitDisplayStart = s.start;
			}
			if ( s.length !== undefined ) {
				settings._iDisplayLength   = s.length;
			}
	
			// Order
			if ( s.order !== undefined ) {
				settings.aaSorting = [];
				$.each( s.order, function ( i, col ) {
					settings.aaSorting.push( col[0] >= columns.length ?
						[ 0, col[1] ] :
						col
					);
				} );
			}
	
			// Search
			if ( s.search !== undefined ) {
				$.extend( settings.oPreviousSearch, _fnSearchToHung( s.search ) );
			}
	
			// Columns
			//
			if ( s.columns ) {
				for ( i=0, ien=s.columns.length ; i<ien ; i++ ) {
					var col = s.columns[i];
	
					// Visibility
					if ( col.visible !== undefined ) {
						columns[i].bVisible = col.visible;
					}
	
					// Search
					if ( col.search !== undefined ) {
						$.extend( settings.aoPreSearchCols[i], _fnSearchToHung( col.search ) );
					}
				}
			}
	
			_fnCallbackFire( settings, 'aoStateLoaded', 'stateLoaded', [settings, s] );
			callback();
		};
	
		if ( ! settings.oFeatures.bStateSave ) {
			callback();
			return;
		}
	
		var state = settings.fnStateLoadCallback.call( settings.oInstance, settings, loaded );
	
		if ( state !== undefined ) {
			loaded( state );
		}
		// otherwise, wait for the loaded callback to be executed
	}
	
	
	/**
	 * Return the settings object for a particular table
	 *  @param {node} table table we are using as a dataTable
	 *  @returns {object} Settings object - or null if not found
	 *  @memberof DataTable#oApi
	 */
	function _fnSettingsFromNode ( table )
	{
		var settings = DataTable.settings;
		var idx = $.inArray( table, _pluck( settings, 'nTable' ) );
	
		return idx !== -1 ?
			settings[ idx ] :
			null;
	}
	
	
	/**
	 * Log an error message
	 *  @param {object} settings dataTables settings object
	 *  @param {int} level log error messages, or display them to the user
	 *  @param {string} msg error message
	 *  @param {int} tn Technical note id to get more information about the error.
	 *  @memberof DataTable#oApi
	 */
	function _fnLog( settings, level, msg, tn )
	{
		msg = 'DataTables warning: '+
			(settings ? 'table id='+settings.sTableId+' - ' : '')+msg;
	
		if ( tn ) {
			msg += '. For more information about this error, please see '+
			'http://datatables.net/tn/'+tn;
		}
	
		if ( ! level  ) {
			// Backwards compatibility pre 1.10
			var ext = DataTable.ext;
			var type = ext.sErrMode || ext.errMode;
	
			if ( settings ) {
				_fnCallbackFire( settings, null, 'error', [ settings, tn, msg ] );
			}
	
			if ( type == 'alert' ) {
				alert( msg );
			}
			else if ( type == 'throw' ) {
				throw new Error(msg);
			}
			else if ( typeof type == 'function' ) {
				type( settings, tn, msg );
			}
		}
		else if ( window.console && console.log ) {
			console.log( msg );
		}
	}
	
	
	/**
	 * See if a property is defined on one object, if so assign it to the other object
	 *  @param {object} ret target object
	 *  @param {object} src source object
	 *  @param {string} name property
	 *  @param {string} [mappedName] name to map too - optional, name used if not given
	 *  @memberof DataTable#oApi
	 */
	function _fnMap( ret, src, name, mappedName )
	{
		if ( $.isArray( name ) ) {
			$.each( name, function (i, val) {
				if ( $.isArray( val ) ) {
					_fnMap( ret, src, val[0], val[1] );
				}
				else {
					_fnMap( ret, src, val );
				}
			} );
	
			return;
		}
	
		if ( mappedName === undefined ) {
			mappedName = name;
		}
	
		if ( src[name] !== undefined ) {
			ret[mappedName] = src[name];
		}
	}
	
	
	/**
	 * Extend objects - very similar to jQuery.extend, but deep copy objects, and
	 * shallow copy arrays. The reason we need to do this, is that we don't want to
	 * deep copy array init values (such as aaSorting) since the dev wouldn't be
	 * able to override them, but we do want to deep copy arrays.
	 *  @param {object} out Object to extend
	 *  @param {object} extender Object from which the properties will be applied to
	 *      out
	 *  @param {boolean} breakRefs If true, then arrays will be sliced to take an
	 *      independent copy with the exception of the `data` or `aaData` parameters
	 *      if they are present. This is so you can pass in a collection to
	 *      DataTables and have that used as your data source without breaking the
	 *      references
	 *  @returns {object} out Reference, just for convenience - out === the return.
	 *  @memberof DataTable#oApi
	 *  @todo This doesn't take account of arrays inside the deep copied objects.
	 */
	function _fnExtend( out, extender, breakRefs )
	{
		var val;
	
		for ( var prop in extender ) {
			if ( extender.hasOwnProperty(prop) ) {
				val = extender[prop];
	
				if ( $.isPlainObject( val ) ) {
					if ( ! $.isPlainObject( out[prop] ) ) {
						out[prop] = {};
					}
					$.extend( true, out[prop], val );
				}
				else if ( breakRefs && prop !== 'data' && prop !== 'aaData' && $.isArray(val) ) {
					out[prop] = val.slice();
				}
				else {
					out[prop] = val;
				}
			}
		}
	
		return out;
	}
	
	
	/**
	 * Bind an event handers to allow a click or return key to activate the callback.
	 * This is good for accessibility since a return on the keyboard will have the
	 * same effect as a click, if the element has focus.
	 *  @param {element} n Element to bind the action to
	 *  @param {object} oData Data object to pass to the triggered function
	 *  @param {function} fn Callback function for when the event is triggered
	 *  @memberof DataTable#oApi
	 */
	function _fnBindAction( n, oData, fn )
	{
		$(n)
			.on( 'click.DT', oData, function (e) {
					$(n).trigger('blur'); // Remove focus outline for mouse users
					fn(e);
				} )
			.on( 'keypress.DT', oData, function (e){
					if ( e.which === 13 ) {
						e.preventDefault();
						fn(e);
					}
				} )
			.on( 'selectstart.DT', function () {
					/* Take the brutal approach to cancelling text selection */
					return false;
				} );
	}
	
	
	/**
	 * Register a callback function. Easily allows a callback function to be added to
	 * an array store of callback functions that can then all be called together.
	 *  @param {object} oSettings dataTables settings object
	 *  @param {string} sStore Name of the array storage for the callbacks in oSettings
	 *  @param {function} fn Function to be called back
	 *  @param {string} sName Identifying name for the callback (i.e. a label)
	 *  @memberof DataTable#oApi
	 */
	function _fnCallbackReg( oSettings, sStore, fn, sName )
	{
		if ( fn )
		{
			oSettings[sStore].push( {
				"fn": fn,
				"sName": sName
			} );
		}
	}
	
	
	/**
	 * Fire callback functions and trigger events. Note that the loop over the
	 * callback array store is done backwards! Further note that you do not want to
	 * fire off triggers in time sensitive applications (for example cell creation)
	 * as its slow.
	 *  @param {object} settings dataTables settings object
	 *  @param {string} callbackArr Name of the array storage for the callbacks in
	 *      oSettings
	 *  @param {string} eventName Name of the jQuery custom event to trigger. If
	 *      null no trigger is fired
	 *  @param {array} args Array of arguments to pass to the callback function /
	 *      trigger
	 *  @memberof DataTable#oApi
	 */
	function _fnCallbackFire( settings, callbackArr, eventName, args )
	{
		var ret = [];
	
		if ( callbackArr ) {
			ret = $.map( settings[callbackArr].slice().reverse(), function (val, i) {
				return val.fn.apply( settings.oInstance, args );
			} );
		}
	
		if ( eventName !== null ) {
			var e = $.Event( eventName+'.dt' );
	
			$(settings.nTable).trigger( e, args );
	
			ret.push( e.result );
		}
	
		return ret;
	}
	
	
	function _fnLengthOverflow ( settings )
	{
		var
			start = settings._iDisplayStart,
			end = settings.fnDisplayEnd(),
			len = settings._iDisplayLength;
	
		/* If we have space to show extra rows (backing up from the end point - then do so */
		if ( start >= end )
		{
			start = end - len;
		}
	
		// Keep the start record on the current page
		start -= (start % len);
	
		if ( len === -1 || start < 0 )
		{
			start = 0;
		}
	
		settings._iDisplayStart = start;
	}
	
	
	function _fnRenderer( settings, type )
	{
		var renderer = settings.renderer;
		var host = DataTable.ext.renderer[type];
	
		if ( $.isPlainObject( renderer ) && renderer[type] ) {
			// Specific renderer for this type. If available use it, otherwise use
			// the default.
			return host[renderer[type]] || host._;
		}
		else if ( typeof renderer === 'string' ) {
			// Common renderer - if there is one available for this type use it,
			// otherwise use the default
			return host[renderer] || host._;
		}
	
		// Use the default
		return host._;
	}
	
	
	/**
	 * Detect the data source being used for the table. Used to simplify the code
	 * a little (ajax) and to make it compress a little smaller.
	 *
	 *  @param {object} settings dataTables settings object
	 *  @returns {string} Data source
	 *  @memberof DataTable#oApi
	 */
	function _fnDataSource ( settings )
	{
		if ( settings.oFeatures.bServerSide ) {
			return 'ssp';
		}
		else if ( settings.ajax || settings.sAjaxSource ) {
			return 'ajax';
		}
		return 'dom';
	}
	

	
	
	/**
	 * Computed structure of the DataTables API, defined by the options passed to
	 * `DataTable.Api.register()` when building the API.
	 *
	 * The structure is built in order to speed creation and extension of the Api
	 * objects since the extensions are effectively pre-parsed.
	 *
	 * The array is an array of objects with the following structure, where this
	 * base array represents the Api prototype base:
	 *
	 *     [
	 *       {
	 *         name:      'data'                -- string   - Property name
	 *         val:       function () {},       -- function - Api method (or undefined if just an object
	 *         methodExt: [ ... ],              -- array    - Array of Api object definitions to extend the method result
	 *         propExt:   [ ... ]               -- array    - Array of Api object definitions to extend the property
	 *       },
	 *       {
	 *         name:     'row'
	 *         val:       {},
	 *         methodExt: [ ... ],
	 *         propExt:   [
	 *           {
	 *             name:      'data'
	 *             val:       function () {},
	 *             methodExt: [ ... ],
	 *             propExt:   [ ... ]
	 *           },
	 *           ...
	 *         ]
	 *       }
	 *     ]
	 *
	 * @type {Array}
	 * @ignore
	 */
	var __apiStruct = [];
	
	
	/**
	 * `Array.prototype` reference.
	 *
	 * @type object
	 * @ignore
	 */
	var __arrayProto = Array.prototype;
	
	
	/**
	 * Abstraction for `context` parameter of the `Api` constructor to allow it to
	 * take several different forms for ease of use.
	 *
	 * Each of the input parameter types will be converted to a DataTables settings
	 * object where possible.
	 *
	 * @param  {string|node|jQuery|object} mixed DataTable identifier. Can be one
	 *   of:
	 *
	 *   * `string` - jQuery selector. Any DataTables' matching the given selector
	 *     with be found and used.
	 *   * `node` - `TABLE` node which has already been formed into a DataTable.
	 *   * `jQuery` - A jQuery object of `TABLE` nodes.
	 *   * `object` - DataTables settings object
	 *   * `DataTables.Api` - API instance
	 * @return {array|null} Matching DataTables settings objects. `null` or
	 *   `undefined` is returned if no matching DataTable is found.
	 * @ignore
	 */
	var _toSettings = function ( mixed )
	{
		var idx, jq;
		var settings = DataTable.settings;
		var tables = $.map( settings, function (el, i) {
			return el.nTable;
		} );
	
		if ( ! mixed ) {
			return [];
		}
		else if ( mixed.nTable && mixed.oApi ) {
			// DataTables settings object
			return [ mixed ];
		}
		else if ( mixed.nodeName && mixed.nodeName.toLowerCase() === 'table' ) {
			// Table node
			idx = $.inArray( mixed, tables );
			return idx !== -1 ? [ settings[idx] ] : null;
		}
		else if ( mixed && typeof mixed.settings === 'function' ) {
			return mixed.settings().toArray();
		}
		else if ( typeof mixed === 'string' ) {
			// jQuery selector
			jq = $(mixed);
		}
		else if ( mixed instanceof $ ) {
			// jQuery object (also DataTables instance)
			jq = mixed;
		}
	
		if ( jq ) {
			return jq.map( function(i) {
				idx = $.inArray( this, tables );
				return idx !== -1 ? settings[idx] : null;
			} ).toArray();
		}
	};
	
	
	/**
	 * DataTables API class - used to control and interface with  one or more
	 * DataTables enhanced tables.
	 *
	 * The API class is heavily based on jQuery, presenting a chainable interface
	 * that you can use to interact with tables. Each instance of the API class has
	 * a "context" - i.e. the tables that it will operate on. This could be a single
	 * table, all tables on a page or a sub-set thereof.
	 *
	 * Additionally the API is designed to allow you to easily work with the data in
	 * the tables, retrieving and manipulating it as required. This is done by
	 * presenting the API class as an array like interface. The contents of the
	 * array depend upon the actions requested by each method (for example
	 * `rows().nodes()` will return an array of nodes, while `rows().data()` will
	 * return an array of objects or arrays depending upon your table's
	 * configuration). The API object has a number of array like methods (`push`,
	 * `pop`, `reverse` etc) as well as additional helper methods (`each`, `pluck`,
	 * `unique` etc) to assist your working with the data held in a table.
	 *
	 * Most methods (those which return an Api instance) are chainable, which means
	 * the return from a method call also has all of the methods available that the
	 * top level object had. For example, these two calls are equivalent:
	 *
	 *     // Not chained
	 *     api.row.add( {...} );
	 *     api.draw();
	 *
	 *     // Chained
	 *     api.row.add( {...} ).draw();
	 *
	 * @class DataTable.Api
	 * @param {array|object|string|jQuery} context DataTable identifier. This is
	 *   used to define which DataTables enhanced tables this API will operate on.
	 *   Can be one of:
	 *
	 *   * `string` - jQuery selector. Any DataTables' matching the given selector
	 *     with be found and used.
	 *   * `node` - `TABLE` node which has already been formed into a DataTable.
	 *   * `jQuery` - A jQuery object of `TABLE` nodes.
	 *   * `object` - DataTables settings object
	 * @param {array} [data] Data to initialise the Api instance with.
	 *
	 * @example
	 *   // Direct initialisation during DataTables construction
	 *   var api = $('#example').DataTable();
	 *
	 * @example
	 *   // Initialisation using a DataTables jQuery object
	 *   var api = $('#example').dataTable().api();
	 *
	 * @example
	 *   // Initialisation as a constructor
	 *   var api = new $.fn.DataTable.Api( 'table.dataTable' );
	 */
	_Api = function ( context, data )
	{
		if ( ! (this instanceof _Api) ) {
			return new _Api( context, data );
		}
	
		var settings = [];
		var ctxSettings = function ( o ) {
			var a = _toSettings( o );
			if ( a ) {
				settings.push.apply( settings, a );
			}
		};
	
		if ( $.isArray( context ) ) {
			for ( var i=0, ien=context.length ; i<ien ; i++ ) {
				ctxSettings( context[i] );
			}
		}
		else {
			ctxSettings( context );
		}
	
		// Remove duplicates
		this.context = _unique( settings );
	
		// Initial data
		if ( data ) {
			$.merge( this, data );
		}
	
		// selector
		this.selector = {
			rows: null,
			cols: null,
			opts: null
		};
	
		_Api.extend( this, this, __apiStruct );
	};
	
	DataTable.Api = _Api;
	
	// Don't destroy the existing prototype, just extend it. Required for jQuery 2's
	// isPlainObject.
	$.extend( _Api.prototype, {
		any: function ()
		{
			return this.count() !== 0;
		},
	
	
		concat:  __arrayProto.concat,
	
	
		context: [], // array of table settings objects
	
	
		count: function ()
		{
			return this.flatten().length;
		},
	
	
		each: function ( fn )
		{
			for ( var i=0, ien=this.length ; i<ien; i++ ) {
				fn.call( this, this[i], i, this );
			}
	
			return this;
		},
	
	
		eq: function ( idx )
		{
			var ctx = this.context;
	
			return ctx.length > idx ?
				new _Api( ctx[idx], this[idx] ) :
				null;
		},
	
	
		filter: function ( fn )
		{
			var a = [];
	
			if ( __arrayProto.filter ) {
				a = __arrayProto.filter.call( this, fn, this );
			}
			else {
				// Compatibility for browsers without EMCA-252-5 (JS 1.6)
				for ( var i=0, ien=this.length ; i<ien ; i++ ) {
					if ( fn.call( this, this[i], i, this ) ) {
						a.push( this[i] );
					}
				}
			}
	
			return new _Api( this.context, a );
		},
	
	
		flatten: function ()
		{
			var a = [];
			return new _Api( this.context, a.concat.apply( a, this.toArray() ) );
		},
	
	
		join:    __arrayProto.join,
	
	
		indexOf: __arrayProto.indexOf || function (obj, start)
		{
			for ( var i=(start || 0), ien=this.length ; i<ien ; i++ ) {
				if ( this[i] === obj ) {
					return i;
				}
			}
			return -1;
		},
	
		iterator: function ( flatten, type, fn, alwaysNew ) {
			var
				a = [], ret,
				i, ien, j, jen,
				context = this.context,
				rows, items, item,
				selector = this.selector;
	
			// Argument shifting
			if ( typeof flatten === 'string' ) {
				alwaysNew = fn;
				fn = type;
				type = flatten;
				flatten = false;
			}
	
			for ( i=0, ien=context.length ; i<ien ; i++ ) {
				var apiInst = new _Api( context[i] );
	
				if ( type === 'table' ) {
					ret = fn.call( apiInst, context[i], i );
	
					if ( ret !== undefined ) {
						a.push( ret );
					}
				}
				else if ( type === 'columns' || type === 'rows' ) {
					// this has same length as context - one entry for each table
					ret = fn.call( apiInst, context[i], this[i], i );
	
					if ( ret !== undefined ) {
						a.push( ret );
					}
				}
				else if ( type === 'column' || type === 'column-rows' || type === 'row' || type === 'cell' ) {
					// columns and rows share the same structure.
					// 'this' is an array of column indexes for each context
					items = this[i];
	
					if ( type === 'column-rows' ) {
						rows = _selector_row_indexes( context[i], selector.opts );
					}
	
					for ( j=0, jen=items.length ; j<jen ; j++ ) {
						item = items[j];
	
						if ( type === 'cell' ) {
							ret = fn.call( apiInst, context[i], item.row, item.column, i, j );
						}
						else {
							ret = fn.call( apiInst, context[i], item, i, j, rows );
						}
	
						if ( ret !== undefined ) {
							a.push( ret );
						}
					}
				}
			}
	
			if ( a.length || alwaysNew ) {
				var api = new _Api( context, flatten ? a.concat.apply( [], a ) : a );
				var apiSelector = api.selector;
				apiSelector.rows = selector.rows;
				apiSelector.cols = selector.cols;
				apiSelector.opts = selector.opts;
				return api;
			}
			return this;
		},
	
	
		lastIndexOf: __arrayProto.lastIndexOf || function (obj, start)
		{
			// Bit cheeky...
			return this.indexOf.apply( this.toArray.reverse(), arguments );
		},
	
	
		length:  0,
	
	
		map: function ( fn )
		{
			var a = [];
	
			if ( __arrayProto.map ) {
				a = __arrayProto.map.call( this, fn, this );
			}
			else {
				// Compatibility for browsers without EMCA-252-5 (JS 1.6)
				for ( var i=0, ien=this.length ; i<ien ; i++ ) {
					a.push( fn.call( this, this[i], i ) );
				}
			}
	
			return new _Api( this.context, a );
		},
	
	
		pluck: function ( prop )
		{
			return this.map( function ( el ) {
				return el[ prop ];
			} );
		},
	
		pop:     __arrayProto.pop,
	
	
		push:    __arrayProto.push,
	
	
		// Does not return an API instance
		reduce: __arrayProto.reduce || function ( fn, init )
		{
			return _fnReduce( this, fn, init, 0, this.length, 1 );
		},
	
	
		reduceRight: __arrayProto.reduceRight || function ( fn, init )
		{
			return _fnReduce( this, fn, init, this.length-1, -1, -1 );
		},
	
	
		reverse: __arrayProto.reverse,
	
	
		// Object with rows, columns and opts
		selector: null,
	
	
		shift:   __arrayProto.shift,
	
	
		slice: function () {
			return new _Api( this.context, this );
		},
	
	
		sort:    __arrayProto.sort, // ? name - order?
	
	
		splice:  __arrayProto.splice,
	
	
		toArray: function ()
		{
			return __arrayProto.slice.call( this );
		},
	
	
		to$: function ()
		{
			return $( this );
		},
	
	
		toJQuery: function ()
		{
			return $( this );
		},
	
	
		unique: function ()
		{
			return new _Api( this.context, _unique(this) );
		},
	
	
		unshift: __arrayProto.unshift
	} );
	
	
	_Api.extend = function ( scope, obj, ext )
	{
		// Only extend API instances and static properties of the API
		if ( ! ext.length || ! obj || ( ! (obj instanceof _Api) && ! obj.__dt_wrapper ) ) {
			return;
		}
	
		var
			i, ien,
			struct,
			methodScoping = function ( scope, fn, struc ) {
				return function () {
					var ret = fn.apply( scope, arguments );
	
					// Method extension
					_Api.extend( ret, ret, struc.methodExt );
					return ret;
				};
			};
	
		for ( i=0, ien=ext.length ; i<ien ; i++ ) {
			struct = ext[i];
	
			// Value
			obj[ struct.name ] = struct.type === 'function' ?
				methodScoping( scope, struct.val, struct ) :
				struct.type === 'object' ?
					{} :
					struct.val;
	
			obj[ struct.name ].__dt_wrapper = true;
	
			// Property extension
			_Api.extend( scope, obj[ struct.name ], struct.propExt );
		}
	};
	
	
	// @todo - Is there need for an augment function?
	// _Api.augment = function ( inst, name )
	// {
	// 	// Find src object in the structure from the name
	// 	var parts = name.split('.');
	
	// 	_Api.extend( inst, obj );
	// };
	
	
	//     [
	//       {
	//         name:      'data'                -- string   - Property name
	//         val:       function () {},       -- function - Api method (or undefined if just an object
	//         methodExt: [ ... ],              -- array    - Array of Api object definitions to extend the method result
	//         propExt:   [ ... ]               -- array    - Array of Api object definitions to extend the property
	//       },
	//       {
	//         name:     'row'
	//         val:       {},
	//         methodExt: [ ... ],
	//         propExt:   [
	//           {
	//             name:      'data'
	//             val:       function () {},
	//             methodExt: [ ... ],
	//             propExt:   [ ... ]
	//           },
	//           ...
	//         ]
	//       }
	//     ]
	
	_Api.register = _api_register = function ( name, val )
	{
		if ( $.isArray( name ) ) {
			for ( var j=0, jen=name.length ; j<jen ; j++ ) {
				_Api.register( name[j], val );
			}
			return;
		}
	
		var
			i, ien,
			heir = name.split('.'),
			struct = __apiStruct,
			key, method;
	
		var find = function ( src, name ) {
			for ( var i=0, ien=src.length ; i<ien ; i++ ) {
				if ( src[i].name === name ) {
					return src[i];
				}
			}
			return null;
		};
	
		for ( i=0, ien=heir.length ; i<ien ; i++ ) {
			method = heir[i].indexOf('()') !== -1;
			key = method ?
				heir[i].replace('()', '') :
				heir[i];
	
			var src = find( struct, key );
			if ( ! src ) {
				src = {
					name:      key,
					val:       {},
					methodExt: [],
					propExt:   [],
					type:      'object'
				};
				struct.push( src );
			}
	
			if ( i === ien-1 ) {
				src.val = val;
				src.type = typeof val === 'function' ?
					'function' :
					$.isPlainObject( val ) ?
						'object' :
						'other';
			}
			else {
				struct = method ?
					src.methodExt :
					src.propExt;
			}
		}
	};
	
	_Api.registerPlural = _api_registerPlural = function ( pluralName, singularName, val ) {
		_Api.register( pluralName, val );
	
		_Api.register( singularName, function () {
			var ret = val.apply( this, arguments );
	
			if ( ret === this ) {
				// Returned item is the API instance that was passed in, return it
				return this;
			}
			else if ( ret instanceof _Api ) {
				// New API instance returned, want the value from the first item
				// in the returned array for the singular result.
				return ret.length ?
					$.isArray( ret[0] ) ?
						new _Api( ret.context, ret[0] ) : // Array results are 'enhanced'
						ret[0] :
					undefined;
			}
	
			// Non-API return - just fire it back
			return ret;
		} );
	};
	
	
	/**
	 * Selector for HTML tables. Apply the given selector to the give array of
	 * DataTables settings objects.
	 *
	 * @param {string|integer} [selector] jQuery selector string or integer
	 * @param  {array} Array of DataTables settings objects to be filtered
	 * @return {array}
	 * @ignore
	 */
	var __table_selector = function ( selector, a )
	{
		if ( $.isArray(selector) ) {
			return $.map( selector, function (item) {
				return __table_selector(item, a);
			} );
		}
	
		// Integer is used to pick out a table by index
		if ( typeof selector === 'number' ) {
			return [ a[ selector ] ];
		}
	
		// Perform a jQuery selector on the table nodes
		var nodes = $.map( a, function (el, i) {
			return el.nTable;
		} );
	
		return $(nodes)
			.filter( selector )
			.map( function (i) {
				// Need to translate back from the table node to the settings
				var idx = $.inArray( this, nodes );
				return a[ idx ];
			} )
			.toArray();
	};
	
	
	
	/**
	 * Context selector for the API's context (i.e. the tables the API instance
	 * refers to.
	 *
	 * @name    DataTable.Api#tables
	 * @param {string|integer} [selector] Selector to pick which tables the iterator
	 *   should operate on. If not given, all tables in the current context are
	 *   used. This can be given as a jQuery selector (for example `':gt(0)'`) to
	 *   select multiple tables or as an integer to select a single table.
	 * @returns {DataTable.Api} Returns a new API instance if a selector is given.
	 */
	_api_register( 'tables()', function ( selector ) {
		// A new instance is created if there was a selector specified
		return selector !== undefined && selector !== null ?
			new _Api( __table_selector( selector, this.context ) ) :
			this;
	} );
	
	
	_api_register( 'table()', function ( selector ) {
		var tables = this.tables( selector );
		var ctx = tables.context;
	
		// Truncate to the first matched table
		return ctx.length ?
			new _Api( ctx[0] ) :
			tables;
	} );
	
	
	_api_registerPlural( 'tables().nodes()', 'table().node()' , function () {
		return this.iterator( 'table', function ( ctx ) {
			return ctx.nTable;
		}, 1 );
	} );
	
	
	_api_registerPlural( 'tables().body()', 'table().body()' , function () {
		return this.iterator( 'table', function ( ctx ) {
			return ctx.nTBody;
		}, 1 );
	} );
	
	
	_api_registerPlural( 'tables().header()', 'table().header()' , function () {
		return this.iterator( 'table', function ( ctx ) {
			return ctx.nTHead;
		}, 1 );
	} );
	
	
	_api_registerPlural( 'tables().footer()', 'table().footer()' , function () {
		return this.iterator( 'table', function ( ctx ) {
			return ctx.nTFoot;
		}, 1 );
	} );
	
	
	_api_registerPlural( 'tables().containers()', 'table().container()' , function () {
		return this.iterator( 'table', function ( ctx ) {
			return ctx.nTableWrapper;
		}, 1 );
	} );
	
	
	
	/**
	 * Redraw the tables in the current context.
	 */
	_api_register( 'draw()', function ( paging ) {
		return this.iterator( 'table', function ( settings ) {
			if ( paging === 'page' ) {
				_fnDraw( settings );
			}
			else {
				if ( typeof paging === 'string' ) {
					paging = paging === 'full-hold' ?
						false :
						true;
				}
	
				_fnReDraw( settings, paging===false );
			}
		} );
	} );
	
	
	
	/**
	 * Get the current page index.
	 *
	 * @return {integer} Current page index (zero based)
	 *//**
	 * Set the current page.
	 *
	 * Note that if you attempt to show a page which does not exist, DataTables will
	 * not throw an error, but rather reset the paging.
	 *
	 * @param {integer|string} action The paging action to take. This can be one of:
	 *  * `integer` - The page index to jump to
	 *  * `string` - An action to take:
	 *    * `first` - Jump to first page.
	 *    * `next` - Jump to the next page
	 *    * `previous` - Jump to previous page
	 *    * `last` - Jump to the last page.
	 * @returns {DataTables.Api} this
	 */
	_api_register( 'page()', function ( action ) {
		if ( action === undefined ) {
			return this.page.info().page; // not an expensive call
		}
	
		// else, have an action to take on all tables
		return this.iterator( 'table', function ( settings ) {
			_fnPageChange( settings, action );
		} );
	} );
	
	
	/**
	 * Paging information for the first table in the current context.
	 *
	 * If you require paging information for another table, use the `table()` method
	 * with a suitable selector.
	 *
	 * @return {object} Object with the following properties set:
	 *  * `page` - Current page index (zero based - i.e. the first page is `0`)
	 *  * `pages` - Total number of pages
	 *  * `start` - Display index for the first record shown on the current page
	 *  * `end` - Display index for the last record shown on the current page
	 *  * `length` - Display length (number of records). Note that generally `start
	 *    + length = end`, but this is not always true, for example if there are
	 *    only 2 records to show on the final page, with a length of 10.
	 *  * `recordsTotal` - Full data set length
	 *  * `recordsDisplay` - Data set length once the current filtering criterion
	 *    are applied.
	 */
	_api_register( 'page.info()', function ( action ) {
		if ( this.context.length === 0 ) {
			return undefined;
		}
	
		var
			settings   = this.context[0],
			start      = settings._iDisplayStart,
			len        = settings.oFeatures.bPaginate ? settings._iDisplayLength : -1,
			visRecords = settings.fnRecordsDisplay(),
			all        = len === -1;
	
		return {
			"page":           all ? 0 : Math.floor( start / len ),
			"pages":          all ? 1 : Math.ceil( visRecords / len ),
			"start":          start,
			"end":            settings.fnDisplayEnd(),
			"length":         len,
			"recordsTotal":   settings.fnRecordsTotal(),
			"recordsDisplay": visRecords,
			"serverSide":     _fnDataSource( settings ) === 'ssp'
		};
	} );
	
	
	/**
	 * Get the current page length.
	 *
	 * @return {integer} Current page length. Note `-1` indicates that all records
	 *   are to be shown.
	 *//**
	 * Set the current page length.
	 *
	 * @param {integer} Page length to set. Use `-1` to show all records.
	 * @returns {DataTables.Api} this
	 */
	_api_register( 'page.len()', function ( len ) {
		// Note that we can't call this function 'length()' because `length`
		// is a Javascript property of functions which defines how many arguments
		// the function expects.
		if ( len === undefined ) {
			return this.context.length !== 0 ?
				this.context[0]._iDisplayLength :
				undefined;
		}
	
		// else, set the page length
		return this.iterator( 'table', function ( settings ) {
			_fnLengthChange( settings, len );
		} );
	} );
	
	
	
	var __reload = function ( settings, holdPosition, callback ) {
		// Use the draw event to trigger a callback
		if ( callback ) {
			var api = new _Api( settings );
	
			api.one( 'draw', function () {
				callback( api.ajax.json() );
			} );
		}
	
		if ( _fnDataSource( settings ) == 'ssp' ) {
			_fnReDraw( settings, holdPosition );
		}
		else {
			_fnProcessingDisplay( settings, true );
	
			// Cancel an existing request
			var xhr = settings.jqXHR;
			if ( xhr && xhr.readyState !== 4 ) {
				xhr.abort();
			}
	
			// Trigger xhr
			_fnBuildAjax( settings, [], function( json ) {
				_fnClearTable( settings );
	
				var data = _fnAjaxDataSrc( settings, json );
				for ( var i=0, ien=data.length ; i<ien ; i++ ) {
					_fnAddData( settings, data[i] );
				}
	
				_fnReDraw( settings, holdPosition );
				_fnProcessingDisplay( settings, false );
			} );
		}
	};
	
	
	/**
	 * Get the JSON response from the last Ajax request that DataTables made to the
	 * server. Note that this returns the JSON from the first table in the current
	 * context.
	 *
	 * @return {object} JSON received from the server.
	 */
	_api_register( 'ajax.json()', function () {
		var ctx = this.context;
	
		if ( ctx.length > 0 ) {
			return ctx[0].json;
		}
	
		// else return undefined;
	} );
	
	
	/**
	 * Get the data submitted in the last Ajax request
	 */
	_api_register( 'ajax.params()', function () {
		var ctx = this.context;
	
		if ( ctx.length > 0 ) {
			return ctx[0].oAjaxData;
		}
	
		// else return undefined;
	} );
	
	
	/**
	 * Reload tables from the Ajax data source. Note that this function will
	 * automatically re-draw the table when the remote data has been loaded.
	 *
	 * @param {boolean} [reset=true] Reset (default) or hold the current paging
	 *   position. A full re-sort and re-filter is performed when this method is
	 *   called, which is why the pagination reset is the default action.
	 * @returns {DataTables.Api} this
	 */
	_api_register( 'ajax.reload()', function ( callback, resetPaging ) {
		return this.iterator( 'table', function (settings) {
			__reload( settings, resetPaging===false, callback );
		} );
	} );
	
	
	/**
	 * Get the current Ajax URL. Note that this returns the URL from the first
	 * table in the current context.
	 *
	 * @return {string} Current Ajax source URL
	 *//**
	 * Set the Ajax URL. Note that this will set the URL for all tables in the
	 * current context.
	 *
	 * @param {string} url URL to set.
	 * @returns {DataTables.Api} this
	 */
	_api_register( 'ajax.url()', function ( url ) {
		var ctx = this.context;
	
		if ( url === undefined ) {
			// get
			if ( ctx.length === 0 ) {
				return undefined;
			}
			ctx = ctx[0];
	
			return ctx.ajax ?
				$.isPlainObject( ctx.ajax ) ?
					ctx.ajax.url :
					ctx.ajax :
				ctx.sAjaxSource;
		}
	
		// set
		return this.iterator( 'table', function ( settings ) {
			if ( $.isPlainObject( settings.ajax ) ) {
				settings.ajax.url = url;
			}
			else {
				settings.ajax = url;
			}
			// No need to consider sAjaxSource here since DataTables gives priority
			// to `ajax` over `sAjaxSource`. So setting `ajax` here, renders any
			// value of `sAjaxSource` redundant.
		} );
	} );
	
	
	/**
	 * Load data from the newly set Ajax URL. Note that this method is only
	 * available when `ajax.url()` is used to set a URL. Additionally, this method
	 * has the same effect as calling `ajax.reload()` but is provided for
	 * convenience when setting a new URL. Like `ajax.reload()` it will
	 * automatically redraw the table once the remote data has been loaded.
	 *
	 * @returns {DataTables.Api} this
	 */
	_api_register( 'ajax.url().load()', function ( callback, resetPaging ) {
		// Same as a reload, but makes sense to present it for easy access after a
		// url change
		return this.iterator( 'table', function ( ctx ) {
			__reload( ctx, resetPaging===false, callback );
		} );
	} );
	
	
	
	
	var _selector_run = function ( type, selector, selectFn, settings, opts )
	{
		var
			out = [], res,
			a, i, ien, j, jen,
			selectorType = typeof selector;
	
		// Can't just check for isArray here, as an API or jQuery instance might be
		// given with their array like look
		if ( ! selector || selectorType === 'string' || selectorType === 'function' || selector.length === undefined ) {
			selector = [ selector ];
		}
	
		for ( i=0, ien=selector.length ; i<ien ; i++ ) {
			// Only split on simple strings - complex expressions will be jQuery selectors
			a = selector[i] && selector[i].split && ! selector[i].match(/[\[\(:]/) ?
				selector[i].split(',') :
				[ selector[i] ];
	
			for ( j=0, jen=a.length ; j<jen ; j++ ) {
				res = selectFn( typeof a[j] === 'string' ? $.trim(a[j]) : a[j] );
	
				if ( res && res.length ) {
					out = out.concat( res );
				}
			}
		}
	
		// selector extensions
		var ext = _ext.selector[ type ];
		if ( ext.length ) {
			for ( i=0, ien=ext.length ; i<ien ; i++ ) {
				out = ext[i]( settings, opts, out );
			}
		}
	
		return _unique( out );
	};
	
	
	var _selector_opts = function ( opts )
	{
		if ( ! opts ) {
			opts = {};
		}
	
		// Backwards compatibility for 1.9- which used the terminology filter rather
		// than search
		if ( opts.filter && opts.search === undefined ) {
			opts.search = opts.filter;
		}
	
		return $.extend( {
			search: 'none',
			order: 'current',
			page: 'all'
		}, opts );
	};
	
	
	var _selector_first = function ( inst )
	{
		// Reduce the API instance to the first item found
		for ( var i=0, ien=inst.length ; i<ien ; i++ ) {
			if ( inst[i].length > 0 ) {
				// Assign the first element to the first item in the instance
				// and truncate the instance and context
				inst[0] = inst[i];
				inst[0].length = 1;
				inst.length = 1;
				inst.context = [ inst.context[i] ];
	
				return inst;
			}
		}
	
		// Not found - return an empty instance
		inst.length = 0;
		return inst;
	};
	
	
	var _selector_row_indexes = function ( settings, opts )
	{
		var
			i, ien, tmp, a=[],
			displayFiltered = settings.aiDisplay,
			displayMaster = settings.aiDisplayMaster;
	
		var
			search = opts.search,  // none, applied, removed
			order  = opts.order,   // applied, current, index (original - compatibility with 1.9)
			page   = opts.page;    // all, current
	
		if ( _fnDataSource( settings ) == 'ssp' ) {
			// In server-side processing mode, most options are irrelevant since
			// rows not shown don't exist and the index order is the applied order
			// Removed is a special case - for consistency just return an empty
			// array
			return search === 'removed' ?
				[] :
				_range( 0, displayMaster.length );
		}
		else if ( page == 'current' ) {
			// Current page implies that order=current and fitler=applied, since it is
			// fairly senseless otherwise, regardless of what order and search actually
			// are
			for ( i=settings._iDisplayStart, ien=settings.fnDisplayEnd() ; i<ien ; i++ ) {
				a.push( displayFiltered[i] );
			}
		}
		else if ( order == 'current' || order == 'applied' ) {
			if ( search == 'none') {
				a = displayMaster.slice();
			}
			else if ( search == 'applied' ) {
				a = displayFiltered.slice();
			}
			else if ( search == 'removed' ) {
				// O(n+m) solution by creating a hash map
				var displayFilteredMap = {};
	
				for ( var i=0, ien=displayFiltered.length ; i<ien ; i++ ) {
					displayFilteredMap[displayFiltered[i]] = null;
				}
	
				a = $.map( displayMaster, function (el) {
					return ! displayFilteredMap.hasOwnProperty(el) ?
						el :
						null;
				} );
			}
		}
		else if ( order == 'index' || order == 'original' ) {
			for ( i=0, ien=settings.aoData.length ; i<ien ; i++ ) {
				if ( search == 'none' ) {
					a.push( i );
				}
				else { // applied | removed
					tmp = $.inArray( i, displayFiltered );
	
					if ((tmp === -1 && search == 'removed') ||
						(tmp >= 0   && search == 'applied') )
					{
						a.push( i );
					}
				}
			}
		}
	
		return a;
	};
	
	
	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Rows
	 *
	 * {}          - no selector - use all available rows
	 * {integer}   - row aoData index
	 * {node}      - TR node
	 * {string}    - jQuery selector to apply to the TR elements
	 * {array}     - jQuery array of nodes, or simply an array of TR nodes
	 *
	 */
	var __row_selector = function ( settings, selector, opts )
	{
		var rows;
		var run = function ( sel ) {
			var selInt = _intVal( sel );
			var i, ien;
			var aoData = settings.aoData;
	
			// Short cut - selector is a number and no options provided (default is
			// all records, so no need to check if the index is in there, since it
			// must be - dev error if the index doesn't exist).
			if ( selInt !== null && ! opts ) {
				return [ selInt ];
			}
	
			if ( ! rows ) {
				rows = _selector_row_indexes( settings, opts );
			}
	
			if ( selInt !== null && $.inArray( selInt, rows ) !== -1 ) {
				// Selector - integer
				return [ selInt ];
			}
			else if ( sel === null || sel === undefined || sel === '' ) {
				// Selector - none
				return rows;
			}
	
			// Selector - function
			if ( typeof sel === 'function' ) {
				return $.map( rows, function (idx) {
					var row = aoData[ idx ];
					return sel( idx, row._aData, row.nTr ) ? idx : null;
				} );
			}
	
			// Selector - node
			if ( sel.nodeName ) {
				var rowIdx = sel._DT_RowIndex;  // Property added by DT for fast lookup
				var cellIdx = sel._DT_CellIndex;
	
				if ( rowIdx !== undefined ) {
					// Make sure that the row is actually still present in the table
					return aoData[ rowIdx ] && aoData[ rowIdx ].nTr === sel ?
						[ rowIdx ] :
						[];
				}
				else if ( cellIdx ) {
					return aoData[ cellIdx.row ] && aoData[ cellIdx.row ].nTr === sel.parentNode ?
						[ cellIdx.row ] :
						[];
				}
				else {
					var host = $(sel).closest('*[data-dt-row]');
					return host.length ?
						[ host.data('dt-row') ] :
						[];
				}
			}
	
			// ID selector. Want to always be able to select rows by id, regardless
			// of if the tr element has been created or not, so can't rely upon
			// jQuery here - hence a custom implementation. This does not match
			// Sizzle's fast selector or HTML4 - in HTML5 the ID can be anything,
			// but to select it using a CSS selector engine (like Sizzle or
			// querySelect) it would need to need to be escaped for some characters.
			// DataTables simplifies this for row selectors since you can select
			// only a row. A # indicates an id any anything that follows is the id -
			// unescaped.
			if ( typeof sel === 'string' && sel.charAt(0) === '#' ) {
				// get row index from id
				var rowObj = settings.aIds[ sel.replace( /^#/, '' ) ];
				if ( rowObj !== undefined ) {
					return [ rowObj.idx ];
				}
	
				// need to fall through to jQuery in case there is DOM id that
				// matches
			}
			
			// Get nodes in the order from the `rows` array with null values removed
			var nodes = _removeEmpty(
				_pluck_order( settings.aoData, rows, 'nTr' )
			);
	
			// Selector - jQuery selector string, array of nodes or jQuery object/
			// As jQuery's .filter() allows jQuery objects to be passed in filter,
			// it also allows arrays, so this will cope with all three options
			return $(nodes)
				.filter( sel )
				.map( function () {
					return this._DT_RowIndex;
				} )
				.toArray();
		};
	
		return _selector_run( 'row', selector, run, settings, opts );
	};
	
	
	_api_register( 'rows()', function ( selector, opts ) {
		// argument shifting
		if ( selector === undefined ) {
			selector = '';
		}
		else if ( $.isPlainObject( selector ) ) {
			opts = selector;
			selector = '';
		}
	
		opts = _selector_opts( opts );
	
		var inst = this.iterator( 'table', function ( settings ) {
			return __row_selector( settings, selector, opts );
		}, 1 );
	
		// Want argument shifting here and in __row_selector?
		inst.selector.rows = selector;
		inst.selector.opts = opts;
	
		return inst;
	} );
	
	_api_register( 'rows().nodes()', function () {
		return this.iterator( 'row', function ( settings, row ) {
			return settings.aoData[ row ].nTr || undefined;
		}, 1 );
	} );
	
	_api_register( 'rows().data()', function () {
		return this.iterator( true, 'rows', function ( settings, rows ) {
			return _pluck_order( settings.aoData, rows, '_aData' );
		}, 1 );
	} );
	
	_api_registerPlural( 'rows().cache()', 'row().cache()', function ( type ) {
		return this.iterator( 'row', function ( settings, row ) {
			var r = settings.aoData[ row ];
			return type === 'search' ? r._aFilterData : r._aSortData;
		}, 1 );
	} );
	
	_api_registerPlural( 'rows().invalidate()', 'row().invalidate()', function ( src ) {
		return this.iterator( 'row', function ( settings, row ) {
			_fnInvalidate( settings, row, src );
		} );
	} );
	
	_api_registerPlural( 'rows().indexes()', 'row().index()', function () {
		return this.iterator( 'row', function ( settings, row ) {
			return row;
		}, 1 );
	} );
	
	_api_registerPlural( 'rows().ids()', 'row().id()', function ( hash ) {
		var a = [];
		var context = this.context;
	
		// `iterator` will drop undefined values, but in this case we want them
		for ( var i=0, ien=context.length ; i<ien ; i++ ) {
			for ( var j=0, jen=this[i].length ; j<jen ; j++ ) {
				var id = context[i].rowIdFn( context[i].aoData[ this[i][j] ]._aData );
				a.push( (hash === true ? '#' : '' )+ id );
			}
		}
	
		return new _Api( context, a );
	} );
	
	_api_registerPlural( 'rows().remove()', 'row().remove()', function () {
		var that = this;
	
		this.iterator( 'row', function ( settings, row, thatIdx ) {
			var data = settings.aoData;
			var rowData = data[ row ];
			var i, ien, j, jen;
			var loopRow, loopCells;
	
			data.splice( row, 1 );
	
			// Update the cached indexes
			for ( i=0, ien=data.length ; i<ien ; i++ ) {
				loopRow = data[i];
				loopCells = loopRow.anCells;
	
				// Rows
				if ( loopRow.nTr !== null ) {
					loopRow.nTr._DT_RowIndex = i;
				}
	
				// Cells
				if ( loopCells !== null ) {
					for ( j=0, jen=loopCells.length ; j<jen ; j++ ) {
						loopCells[j]._DT_CellIndex.row = i;
					}
				}
			}
	
			// Delete from the display arrays
			_fnDeleteIndex( settings.aiDisplayMaster, row );
			_fnDeleteIndex( settings.aiDisplay, row );
			_fnDeleteIndex( that[ thatIdx ], row, false ); // maintain local indexes
	
			// For server-side processing tables - subtract the deleted row from the count
			if ( settings._iRecordsDisplay > 0 ) {
				settings._iRecordsDisplay--;
			}
	
			// Check for an 'overflow' they case for displaying the table
			_fnLengthOverflow( settings );
	
			// Remove the row's ID reference if there is one
			var id = settings.rowIdFn( rowData._aData );
			if ( id !== undefined ) {
				delete settings.aIds[ id ];
			}
		} );
	
		this.iterator( 'table', function ( settings ) {
			for ( var i=0, ien=settings.aoData.length ; i<ien ; i++ ) {
				settings.aoData[i].idx = i;
			}
		} );
	
		return this;
	} );
	
	
	_api_register( 'rows.add()', function ( rows ) {
		var newRows = this.iterator( 'table', function ( settings ) {
				var row, i, ien;
				var out = [];
	
				for ( i=0, ien=rows.length ; i<ien ; i++ ) {
					row = rows[i];
	
					if ( row.nodeName && row.nodeName.toUpperCase() === 'TR' ) {
						out.push( _fnAddTr( settings, row )[0] );
					}
					else {
						out.push( _fnAddData( settings, row ) );
					}
				}
	
				return out;
			}, 1 );
	
		// Return an Api.rows() extended instance, so rows().nodes() etc can be used
		var modRows = this.rows( -1 );
		modRows.pop();
		$.merge( modRows, newRows );
	
		return modRows;
	} );
	
	
	
	
	
	/**
	 *
	 */
	_api_register( 'row()', function ( selector, opts ) {
		return _selector_first( this.rows( selector, opts ) );
	} );
	
	
	_api_register( 'row().data()', function ( data ) {
		var ctx = this.context;
	
		if ( data === undefined ) {
			// Get
			return ctx.length && this.length ?
				ctx[0].aoData[ this[0] ]._aData :
				undefined;
		}
	
		// Set
		var row = ctx[0].aoData[ this[0] ];
		row._aData = data;
	
		// If the DOM has an id, and the data source is an array
		if ( $.isArray( data ) && row.nTr && row.nTr.id ) {
			_fnSetObjectDataFn( ctx[0].rowId )( data, row.nTr.id );
		}
	
		// Automatically invalidate
		_fnInvalidate( ctx[0], this[0], 'data' );
	
		return this;
	} );
	
	
	_api_register( 'row().node()', function () {
		var ctx = this.context;
	
		return ctx.length && this.length ?
			ctx[0].aoData[ this[0] ].nTr || null :
			null;
	} );
	
	
	_api_register( 'row.add()', function ( row ) {
		// Allow a jQuery object to be passed in - only a single row is added from
		// it though - the first element in the set
		if ( row instanceof $ && row.length ) {
			row = row[0];
		}
	
		var rows = this.iterator( 'table', function ( settings ) {
			if ( row.nodeName && row.nodeName.toUpperCase() === 'TR' ) {
				return _fnAddTr( settings, row )[0];
			}
			return _fnAddData( settings, row );
		} );
	
		// Return an Api.rows() extended instance, with the newly added row selected
		return this.row( rows[0] );
	} );
	
	
	
	var __details_add = function ( ctx, row, data, klass )
	{
		// Convert to array of TR elements
		var rows = [];
		var addRow = function ( r, k ) {
			// Recursion to allow for arrays of jQuery objects
			if ( $.isArray( r ) || r instanceof $ ) {
				for ( var i=0, ien=r.length ; i<ien ; i++ ) {
					addRow( r[i], k );
				}
				return;
			}
	
			// If we get a TR element, then just add it directly - up to the dev
			// to add the correct number of columns etc
			if ( r.nodeName && r.nodeName.toLowerCase() === 'tr' ) {
				rows.push( r );
			}
			else {
				// Otherwise create a row with a wrapper
				var created = $('<tr><td/></tr>').addClass( k );
				$('td', created)
					.addClass( k )
					.html( r )
					[0].colSpan = _fnVisbleColumns( ctx );
	
				rows.push( created[0] );
			}
		};
	
		addRow( data, klass );
	
		if ( row._details ) {
			row._details.detach();
		}
	
		row._details = $(rows);
	
		// If the children were already shown, that state should be retained
		if ( row._detailsShow ) {
			row._details.insertAfter( row.nTr );
		}
	};
	
	
	var __details_remove = function ( api, idx )
	{
		var ctx = api.context;
	
		if ( ctx.length ) {
			var row = ctx[0].aoData[ idx !== undefined ? idx : api[0] ];
	
			if ( row && row._details ) {
				row._details.remove();
	
				row._detailsShow = undefined;
				row._details = undefined;
			}
		}
	};
	
	
	var __details_display = function ( api, show ) {
		var ctx = api.context;
	
		if ( ctx.length && api.length ) {
			var row = ctx[0].aoData[ api[0] ];
	
			if ( row._details ) {
				row._detailsShow = show;
	
				if ( show ) {
					row._details.insertAfter( row.nTr );
				}
				else {
					row._details.detach();
				}
	
				__details_events( ctx[0] );
			}
		}
	};
	
	
	var __details_events = function ( settings )
	{
		var api = new _Api( settings );
		var namespace = '.dt.DT_details';
		var drawEvent = 'draw'+namespace;
		var colvisEvent = 'column-visibility'+namespace;
		var destroyEvent = 'destroy'+namespace;
		var data = settings.aoData;
	
		api.off( drawEvent +' '+ colvisEvent +' '+ destroyEvent );
	
		if ( _pluck( data, '_details' ).length > 0 ) {
			// On each draw, insert the required elements into the document
			api.on( drawEvent, function ( e, ctx ) {
				if ( settings !== ctx ) {
					return;
				}
	
				api.rows( {page:'current'} ).eq(0).each( function (idx) {
					// Internal data grab
					var row = data[ idx ];
	
					if ( row._detailsShow ) {
						row._details.insertAfter( row.nTr );
					}
				} );
			} );
	
			// Column visibility change - update the colspan
			api.on( colvisEvent, function ( e, ctx, idx, vis ) {
				if ( settings !== ctx ) {
					return;
				}
	
				// Update the colspan for the details rows (note, only if it already has
				// a colspan)
				var row, visible = _fnVisbleColumns( ctx );
	
				for ( var i=0, ien=data.length ; i<ien ; i++ ) {
					row = data[i];
	
					if ( row._details ) {
						row._details.children('td[colspan]').attr('colspan', visible );
					}
				}
			} );
	
			// Table destroyed - nuke any child rows
			api.on( destroyEvent, function ( e, ctx ) {
				if ( settings !== ctx ) {
					return;
				}
	
				for ( var i=0, ien=data.length ; i<ien ; i++ ) {
					if ( data[i]._details ) {
						__details_remove( api, i );
					}
				}
			} );
		}
	};
	
	// Strings for the method names to help minification
	var _emp = '';
	var _child_obj = _emp+'row().child';
	var _child_mth = _child_obj+'()';
	
	// data can be:
	//  tr
	//  string
	//  jQuery or array of any of the above
	_api_register( _child_mth, function ( data, klass ) {
		var ctx = this.context;
	
		if ( data === undefined ) {
			// get
			return ctx.length && this.length ?
				ctx[0].aoData[ this[0] ]._details :
				undefined;
		}
		else if ( data === true ) {
			// show
			this.child.show();
		}
		else if ( data === false ) {
			// remove
			__details_remove( this );
		}
		else if ( ctx.length && this.length ) {
			// set
			__details_add( ctx[0], ctx[0].aoData[ this[0] ], data, klass );
		}
	
		return this;
	} );
	
	
	_api_register( [
		_child_obj+'.show()',
		_child_mth+'.show()' // only when `child()` was called with parameters (without
	], function ( show ) {   // it returns an object and this method is not executed)
		__details_display( this, true );
		return this;
	} );
	
	
	_api_register( [
		_child_obj+'.hide()',
		_child_mth+'.hide()' // only when `child()` was called with parameters (without
	], function () {         // it returns an object and this method is not executed)
		__details_display( this, false );
		return this;
	} );
	
	
	_api_register( [
		_child_obj+'.remove()',
		_child_mth+'.remove()' // only when `child()` was called with parameters (without
	], function () {           // it returns an object and this method is not executed)
		__details_remove( this );
		return this;
	} );
	
	
	_api_register( _child_obj+'.isShown()', function () {
		var ctx = this.context;
	
		if ( ctx.length && this.length ) {
			// _detailsShown as false or undefined will fall through to return false
			return ctx[0].aoData[ this[0] ]._detailsShow || false;
		}
		return false;
	} );
	
	
	
	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Columns
	 *
	 * {integer}           - column index (>=0 count from left, <0 count from right)
	 * "{integer}:visIdx"  - visible column index (i.e. translate to column index)  (>=0 count from left, <0 count from right)
	 * "{integer}:visible" - alias for {integer}:visIdx  (>=0 count from left, <0 count from right)
	 * "{string}:name"     - column name
	 * "{string}"          - jQuery selector on column header nodes
	 *
	 */
	
	// can be an array of these items, comma separated list, or an array of comma
	// separated lists
	
	var __re_column_selector = /^([^:]+):(name|visIdx|visible)$/;
	
	
	// r1 and r2 are redundant - but it means that the parameters match for the
	// iterator callback in columns().data()
	var __columnData = function ( settings, column, r1, r2, rows ) {
		var a = [];
		for ( var row=0, ien=rows.length ; row<ien ; row++ ) {
			a.push( _fnGetCellData( settings, rows[row], column ) );
		}
		return a;
	};
	
	
	var __column_selector = function ( settings, selector, opts )
	{
		var
			columns = settings.aoColumns,
			names = _pluck( columns, 'sName' ),
			nodes = _pluck( columns, 'nTh' );
	
		var run = function ( s ) {
			var selInt = _intVal( s );
	
			// Selector - all
			if ( s === '' ) {
				return _range( columns.length );
			}
	
			// Selector - index
			if ( selInt !== null ) {
				return [ selInt >= 0 ?
					selInt : // Count from left
					columns.length + selInt // Count from right (+ because its a negative value)
				];
			}
	
			// Selector = function
			if ( typeof s === 'function' ) {
				var rows = _selector_row_indexes( settings, opts );
	
				return $.map( columns, function (col, idx) {
					return s(
							idx,
							__columnData( settings, idx, 0, 0, rows ),
							nodes[ idx ]
						) ? idx : null;
				} );
			}
	
			// jQuery or string selector
			var match = typeof s === 'string' ?
				s.match( __re_column_selector ) :
				'';
	
			if ( match ) {
				switch( match[2] ) {
					case 'visIdx':
					case 'visible':
						var idx = parseInt( match[1], 10 );
						// Visible index given, convert to column index
						if ( idx < 0 ) {
							// Counting from the right
							var visColumns = $.map( columns, function (col,i) {
								return col.bVisible ? i : null;
							} );
							return [ visColumns[ visColumns.length + idx ] ];
						}
						// Counting from the left
						return [ _fnVisibleToColumnIndex( settings, idx ) ];
	
					case 'name':
						// match by name. `names` is column index complete and in order
						return $.map( names, function (name, i) {
							return name === match[1] ? i : null;
						} );
	
					default:
						return [];
				}
			}
	
			// Cell in the table body
			if ( s.nodeName && s._DT_CellIndex ) {
				return [ s._DT_CellIndex.column ];
			}
	
			// jQuery selector on the TH elements for the columns
			var jqResult = $( nodes )
				.filter( s )
				.map( function () {
					return $.inArray( this, nodes ); // `nodes` is column index complete and in order
				} )
				.toArray();
	
			if ( jqResult.length || ! s.nodeName ) {
				return jqResult;
			}
	
			// Otherwise a node which might have a `dt-column` data attribute, or be
			// a child or such an element
			var host = $(s).closest('*[data-dt-column]');
			return host.length ?
				[ host.data('dt-column') ] :
				[];
		};
	
		return _selector_run( 'column', selector, run, settings, opts );
	};
	
	
	var __setColumnVis = function ( settings, column, vis ) {
		var
			cols = settings.aoColumns,
			col  = cols[ column ],
			data = settings.aoData,
			row, cells, i, ien, tr;
	
		// Get
		if ( vis === undefined ) {
			return col.bVisible;
		}
	
		// Set
		// No change
		if ( col.bVisible === vis ) {
			return;
		}
	
		if ( vis ) {
			// Insert column
			// Need to decide if we should use appendChild or insertBefore
			var insertBefore = $.inArray( true, _pluck(cols, 'bVisible'), column+1 );
	
			for ( i=0, ien=data.length ; i<ien ; i++ ) {
				tr = data[i].nTr;
				cells = data[i].anCells;
	
				if ( tr ) {
					// insertBefore can act like appendChild if 2nd arg is null
					tr.insertBefore( cells[ column ], cells[ insertBefore ] || null );
				}
			}
		}
		else {
			// Remove column
			$( _pluck( settings.aoData, 'anCells', column ) ).detach();
		}
	
		// Common actions
		col.bVisible = vis;
	};
	
	
	_api_register( 'columns()', function ( selector, opts ) {
		// argument shifting
		if ( selector === undefined ) {
			selector = '';
		}
		else if ( $.isPlainObject( selector ) ) {
			opts = selector;
			selector = '';
		}
	
		opts = _selector_opts( opts );
	
		var inst = this.iterator( 'table', function ( settings ) {
			return __column_selector( settings, selector, opts );
		}, 1 );
	
		// Want argument shifting here and in _row_selector?
		inst.selector.cols = selector;
		inst.selector.opts = opts;
	
		return inst;
	} );
	
	_api_registerPlural( 'columns().header()', 'column().header()', function ( selector, opts ) {
		return this.iterator( 'column', function ( settings, column ) {
			return settings.aoColumns[column].nTh;
		}, 1 );
	} );
	
	_api_registerPlural( 'columns().footer()', 'column().footer()', function ( selector, opts ) {
		return this.iterator( 'column', function ( settings, column ) {
			return settings.aoColumns[column].nTf;
		}, 1 );
	} );
	
	_api_registerPlural( 'columns().data()', 'column().data()', function () {
		return this.iterator( 'column-rows', __columnData, 1 );
	} );
	
	_api_registerPlural( 'columns().dataSrc()', 'column().dataSrc()', function () {
		return this.iterator( 'column', function ( settings, column ) {
			return settings.aoColumns[column].mData;
		}, 1 );
	} );
	
	_api_registerPlural( 'columns().cache()', 'column().cache()', function ( type ) {
		return this.iterator( 'column-rows', function ( settings, column, i, j, rows ) {
			return _pluck_order( settings.aoData, rows,
				type === 'search' ? '_aFilterData' : '_aSortData', column
			);
		}, 1 );
	} );
	
	_api_registerPlural( 'columns().nodes()', 'column().nodes()', function () {
		return this.iterator( 'column-rows', function ( settings, column, i, j, rows ) {
			return _pluck_order( settings.aoData, rows, 'anCells', column ) ;
		}, 1 );
	} );
	
	_api_registerPlural( 'columns().visible()', 'column().visible()', function ( vis, calc ) {
		var that = this;
		var ret = this.iterator( 'column', function ( settings, column ) {
			if ( vis === undefined ) {
				return settings.aoColumns[ column ].bVisible;
			} // else
			__setColumnVis( settings, column, vis );
		} );
	
		// Group the column visibility changes
		if ( vis !== undefined ) {
			this.iterator( 'table', function ( settings ) {
				// Redraw the header after changes
				_fnDrawHead( settings, settings.aoHeader );
				_fnDrawHead( settings, settings.aoFooter );
		
				// Update colspan for no records display. Child rows and extensions will use their own
				// listeners to do this - only need to update the empty table item here
				if ( ! settings.aiDisplay.length ) {
					$(settings.nTBody).find('td[colspan]').attr('colspan', _fnVisbleColumns(settings));
				}
		
				_fnSaveState( settings );
	
				// Second loop once the first is done for events
				that.iterator( 'column', function ( settings, column ) {
					_fnCallbackFire( settings, null, 'column-visibility', [settings, column, vis, calc] );
				} );
	
				if ( calc === undefined || calc ) {
					that.columns.adjust();
				}
			});
		}
	
		return ret;
	} );
	
	_api_registerPlural( 'columns().indexes()', 'column().index()', function ( type ) {
		return this.iterator( 'column', function ( settings, column ) {
			return type === 'visible' ?
				_fnColumnIndexToVisible( settings, column ) :
				column;
		}, 1 );
	} );
	
	_api_register( 'columns.adjust()', function () {
		return this.iterator( 'table', function ( settings ) {
			_fnAdjustColumnSizing( settings );
		}, 1 );
	} );
	
	_api_register( 'column.index()', function ( type, idx ) {
		if ( this.context.length !== 0 ) {
			var ctx = this.context[0];
	
			if ( type === 'fromVisible' || type === 'toData' ) {
				return _fnVisibleToColumnIndex( ctx, idx );
			}
			else if ( type === 'fromData' || type === 'toVisible' ) {
				return _fnColumnIndexToVisible( ctx, idx );
			}
		}
	} );
	
	_api_register( 'column()', function ( selector, opts ) {
		return _selector_first( this.columns( selector, opts ) );
	} );
	
	
	
	var __cell_selector = function ( settings, selector, opts )
	{
		var data = settings.aoData;
		var rows = _selector_row_indexes( settings, opts );
		var cells = _removeEmpty( _pluck_order( data, rows, 'anCells' ) );
		var allCells = $( [].concat.apply([], cells) );
		var row;
		var columns = settings.aoColumns.length;
		var a, i, ien, j, o, host;
	
		var run = function ( s ) {
			var fnSelector = typeof s === 'function';
	
			if ( s === null || s === undefined || fnSelector ) {
				// All cells and function selectors
				a = [];
	
				for ( i=0, ien=rows.length ; i<ien ; i++ ) {
					row = rows[i];
	
					for ( j=0 ; j<columns ; j++ ) {
						o = {
							row: row,
							column: j
						};
	
						if ( fnSelector ) {
							// Selector - function
							host = data[ row ];
	
							if ( s( o, _fnGetCellData(settings, row, j), host.anCells ? host.anCells[j] : null ) ) {
								a.push( o );
							}
						}
						else {
							// Selector - all
							a.push( o );
						}
					}
				}
	
				return a;
			}
			
			// Selector - index
			if ( $.isPlainObject( s ) ) {
				// Valid cell index and its in the array of selectable rows
				return s.column !== undefined && s.row !== undefined && $.inArray( s.row, rows ) !== -1 ?
					[s] :
					[];
			}
	
			// Selector - jQuery filtered cells
			var jqResult = allCells
				.filter( s )
				.map( function (i, el) {
					return { // use a new object, in case someone changes the values
						row:    el._DT_CellIndex.row,
						column: el._DT_CellIndex.column
	 				};
				} )
				.toArray();
	
			if ( jqResult.length || ! s.nodeName ) {
				return jqResult;
			}
	
			// Otherwise the selector is a node, and there is one last option - the
			// element might be a child of an element which has dt-row and dt-column
			// data attributes
			host = $(s).closest('*[data-dt-row]');
			return host.length ?
				[ {
					row: host.data('dt-row'),
					column: host.data('dt-column')
				} ] :
				[];
		};
	
		return _selector_run( 'cell', selector, run, settings, opts );
	};
	
	
	
	
	_api_register( 'cells()', function ( rowSelector, columnSelector, opts ) {
		// Argument shifting
		if ( $.isPlainObject( rowSelector ) ) {
			// Indexes
			if ( rowSelector.row === undefined ) {
				// Selector options in first parameter
				opts = rowSelector;
				rowSelector = null;
			}
			else {
				// Cell index objects in first parameter
				opts = columnSelector;
				columnSelector = null;
			}
		}
		if ( $.isPlainObject( columnSelector ) ) {
			opts = columnSelector;
			columnSelector = null;
		}
	
		// Cell selector
		if ( columnSelector === null || columnSelector === undefined ) {
			return this.iterator( 'table', function ( settings ) {
				return __cell_selector( settings, rowSelector, _selector_opts( opts ) );
			} );
		}
	
		// The default built in options need to apply to row and columns
		var internalOpts = opts ? {
			page: opts.page,
			order: opts.order,
			search: opts.search
		} : {};
	
		// Row + column selector
		var columns = this.columns( columnSelector, internalOpts );
		var rows = this.rows( rowSelector, internalOpts );
		var i, ien, j, jen;
	
		var cellsNoOpts = this.iterator( 'table', function ( settings, idx ) {
			var a = [];
	
			for ( i=0, ien=rows[idx].length ; i<ien ; i++ ) {
				for ( j=0, jen=columns[idx].length ; j<jen ; j++ ) {
					a.push( {
						row:    rows[idx][i],
						column: columns[idx][j]
					} );
				}
			}
	
			return a;
		}, 1 );
	
		// There is currently only one extension which uses a cell selector extension
		// It is a _major_ performance drag to run this if it isn't needed, so this is
		// an extension specific check at the moment
		var cells = opts && opts.selected ?
			this.cells( cellsNoOpts, opts ) :
			cellsNoOpts;
	
		$.extend( cells.selector, {
			cols: columnSelector,
			rows: rowSelector,
			opts: opts
		} );
	
		return cells;
	} );
	
	
	_api_registerPlural( 'cells().nodes()', 'cell().node()', function () {
		return this.iterator( 'cell', function ( settings, row, column ) {
			var data = settings.aoData[ row ];
	
			return data && data.anCells ?
				data.anCells[ column ] :
				undefined;
		}, 1 );
	} );
	
	
	_api_register( 'cells().data()', function () {
		return this.iterator( 'cell', function ( settings, row, column ) {
			return _fnGetCellData( settings, row, column );
		}, 1 );
	} );
	
	
	_api_registerPlural( 'cells().cache()', 'cell().cache()', function ( type ) {
		type = type === 'search' ? '_aFilterData' : '_aSortData';
	
		return this.iterator( 'cell', function ( settings, row, column ) {
			return settings.aoData[ row ][ type ][ column ];
		}, 1 );
	} );
	
	
	_api_registerPlural( 'cells().render()', 'cell().render()', function ( type ) {
		return this.iterator( 'cell', function ( settings, row, column ) {
			return _fnGetCellData( settings, row, column, type );
		}, 1 );
	} );
	
	
	_api_registerPlural( 'cells().indexes()', 'cell().index()', function () {
		return this.iterator( 'cell', function ( settings, row, column ) {
			return {
				row: row,
				column: column,
				columnVisible: _fnColumnIndexToVisible( settings, column )
			};
		}, 1 );
	} );
	
	
	_api_registerPlural( 'cells().invalidate()', 'cell().invalidate()', function ( src ) {
		return this.iterator( 'cell', function ( settings, row, column ) {
			_fnInvalidate( settings, row, src, column );
		} );
	} );
	
	
	
	_api_register( 'cell()', function ( rowSelector, columnSelector, opts ) {
		return _selector_first( this.cells( rowSelector, columnSelector, opts ) );
	} );
	
	
	_api_register( 'cell().data()', function ( data ) {
		var ctx = this.context;
		var cell = this[0];
	
		if ( data === undefined ) {
			// Get
			return ctx.length && cell.length ?
				_fnGetCellData( ctx[0], cell[0].row, cell[0].column ) :
				undefined;
		}
	
		// Set
		_fnSetCellData( ctx[0], cell[0].row, cell[0].column, data );
		_fnInvalidate( ctx[0], cell[0].row, 'data', cell[0].column );
	
		return this;
	} );
	
	
	
	/**
	 * Get current ordering (sorting) that has been applied to the table.
	 *
	 * @returns {array} 2D array containing the sorting information for the first
	 *   table in the current context. Each element in the parent array represents
	 *   a column being sorted upon (i.e. multi-sorting with two columns would have
	 *   2 inner arrays). The inner arrays may have 2 or 3 elements. The first is
	 *   the column index that the sorting condition applies to, the second is the
	 *   direction of the sort (`desc` or `asc`) and, optionally, the third is the
	 *   index of the sorting order from the `column.sorting` initialisation array.
	 *//**
	 * Set the ordering for the table.
	 *
	 * @param {integer} order Column index to sort upon.
	 * @param {string} direction Direction of the sort to be applied (`asc` or `desc`)
	 * @returns {DataTables.Api} this
	 *//**
	 * Set the ordering for the table.
	 *
	 * @param {array} order 1D array of sorting information to be applied.
	 * @param {array} [...] Optional additional sorting conditions
	 * @returns {DataTables.Api} this
	 *//**
	 * Set the ordering for the table.
	 *
	 * @param {array} order 2D array of sorting information to be applied.
	 * @returns {DataTables.Api} this
	 */
	_api_register( 'order()', function ( order, dir ) {
		var ctx = this.context;
	
		if ( order === undefined ) {
			// get
			return ctx.length !== 0 ?
				ctx[0].aaSorting :
				undefined;
		}
	
		// set
		if ( typeof order === 'number' ) {
			// Simple column / direction passed in
			order = [ [ order, dir ] ];
		}
		else if ( order.length && ! $.isArray( order[0] ) ) {
			// Arguments passed in (list of 1D arrays)
			order = Array.prototype.slice.call( arguments );
		}
		// otherwise a 2D array was passed in
	
		return this.iterator( 'table', function ( settings ) {
			settings.aaSorting = order.slice();
		} );
	} );
	
	
	/**
	 * Attach a sort listener to an element for a given column
	 *
	 * @param {node|jQuery|string} node Identifier for the element(s) to attach the
	 *   listener to. This can take the form of a single DOM node, a jQuery
	 *   collection of nodes or a jQuery selector which will identify the node(s).
	 * @param {integer} column the column that a click on this node will sort on
	 * @param {function} [callback] callback function when sort is run
	 * @returns {DataTables.Api} this
	 */
	_api_register( 'order.listener()', function ( node, column, callback ) {
		return this.iterator( 'table', function ( settings ) {
			_fnSortAttachListener( settings, node, column, callback );
		} );
	} );
	
	
	_api_register( 'order.fixed()', function ( set ) {
		if ( ! set ) {
			var ctx = this.context;
			var fixed = ctx.length ?
				ctx[0].aaSortingFixed :
				undefined;
	
			return $.isArray( fixed ) ?
				{ pre: fixed } :
				fixed;
		}
	
		return this.iterator( 'table', function ( settings ) {
			settings.aaSortingFixed = $.extend( true, {}, set );
		} );
	} );
	
	
	// Order by the selected column(s)
	_api_register( [
		'columns().order()',
		'column().order()'
	], function ( dir ) {
		var that = this;
	
		return this.iterator( 'table', function ( settings, i ) {
			var sort = [];
	
			$.each( that[i], function (j, col) {
				sort.push( [ col, dir ] );
			} );
	
			settings.aaSorting = sort;
		} );
	} );
	
	
	
	_api_register( 'search()', function ( input, regex, smart, caseInsen ) {
		var ctx = this.context;
	
		if ( input === undefined ) {
			// get
			return ctx.length !== 0 ?
				ctx[0].oPreviousSearch.sSearch :
				undefined;
		}
	
		// set
		return this.iterator( 'table', function ( settings ) {
			if ( ! settings.oFeatures.bFilter ) {
				return;
			}
	
			_fnFilterComplete( settings, $.extend( {}, settings.oPreviousSearch, {
				"sSearch": input+"",
				"bRegex":  regex === null ? false : regex,
				"bSmart":  smart === null ? true  : smart,
				"bCaseInsensitive": caseInsen === null ? true : caseInsen
			} ), 1 );
		} );
	} );
	
	
	_api_registerPlural(
		'columns().search()',
		'column().search()',
		function ( input, regex, smart, caseInsen ) {
			return this.iterator( 'column', function ( settings, column ) {
				var preSearch = settings.aoPreSearchCols;
	
				if ( input === undefined ) {
					// get
					return preSearch[ column ].sSearch;
				}
	
				// set
				if ( ! settings.oFeatures.bFilter ) {
					return;
				}
	
				$.extend( preSearch[ column ], {
					"sSearch": input+"",
					"bRegex":  regex === null ? false : regex,
					"bSmart":  smart === null ? true  : smart,
					"bCaseInsensitive": caseInsen === null ? true : caseInsen
				} );
	
				_fnFilterComplete( settings, settings.oPreviousSearch, 1 );
			} );
		}
	);
	
	/*
	 * State API methods
	 */
	
	_api_register( 'state()', function () {
		return this.context.length ?
			this.context[0].oSavedState :
			null;
	} );
	
	
	_api_register( 'state.clear()', function () {
		return this.iterator( 'table', function ( settings ) {
			// Save an empty object
			settings.fnStateSaveCallback.call( settings.oInstance, settings, {} );
		} );
	} );
	
	
	_api_register( 'state.loaded()', function () {
		return this.context.length ?
			this.context[0].oLoadedState :
			null;
	} );
	
	
	_api_register( 'state.save()', function () {
		return this.iterator( 'table', function ( settings ) {
			_fnSaveState( settings );
		} );
	} );
	
	
	
	/**
	 * Provide a common method for plug-ins to check the version of DataTables being
	 * used, in order to ensure compatibility.
	 *
	 *  @param {string} version Version string to check for, in the format "X.Y.Z".
	 *    Note that the formats "X" and "X.Y" are also acceptable.
	 *  @returns {boolean} true if this version of DataTables is greater or equal to
	 *    the required version, or false if this version of DataTales is not
	 *    suitable
	 *  @static
	 *  @dtopt API-Static
	 *
	 *  @example
	 *    alert( $.fn.dataTable.versionCheck( '1.9.0' ) );
	 */
	DataTable.versionCheck = DataTable.fnVersionCheck = function( version )
	{
		var aThis = DataTable.version.split('.');
		var aThat = version.split('.');
		var iThis, iThat;
	
		for ( var i=0, iLen=aThat.length ; i<iLen ; i++ ) {
			iThis = parseInt( aThis[i], 10 ) || 0;
			iThat = parseInt( aThat[i], 10 ) || 0;
	
			// Parts are the same, keep comparing
			if (iThis === iThat) {
				continue;
			}
	
			// Parts are different, return immediately
			return iThis > iThat;
		}
	
		return true;
	};
	
	
	/**
	 * Check if a `<table>` node is a DataTable table already or not.
	 *
	 *  @param {node|jquery|string} table Table node, jQuery object or jQuery
	 *      selector for the table to test. Note that if more than more than one
	 *      table is passed on, only the first will be checked
	 *  @returns {boolean} true the table given is a DataTable, or false otherwise
	 *  @static
	 *  @dtopt API-Static
	 *
	 *  @example
	 *    if ( ! $.fn.DataTable.isDataTable( '#example' ) ) {
	 *      $('#example').dataTable();
	 *    }
	 */
	DataTable.isDataTable = DataTable.fnIsDataTable = function ( table )
	{
		var t = $(table).get(0);
		var is = false;
	
		if ( table instanceof DataTable.Api ) {
			return true;
		}
	
		$.each( DataTable.settings, function (i, o) {
			var head = o.nScrollHead ? $('table', o.nScrollHead)[0] : null;
			var foot = o.nScrollFoot ? $('table', o.nScrollFoot)[0] : null;
	
			if ( o.nTable === t || head === t || foot === t ) {
				is = true;
			}
		} );
	
		return is;
	};
	
	
	/**
	 * Get all DataTable tables that have been initialised - optionally you can
	 * select to get only currently visible tables.
	 *
	 *  @param {boolean} [visible=false] Flag to indicate if you want all (default)
	 *    or visible tables only.
	 *  @returns {array} Array of `table` nodes (not DataTable instances) which are
	 *    DataTables
	 *  @static
	 *  @dtopt API-Static
	 *
	 *  @example
	 *    $.each( $.fn.dataTable.tables(true), function () {
	 *      $(table).DataTable().columns.adjust();
	 *    } );
	 */
	DataTable.tables = DataTable.fnTables = function ( visible )
	{
		var api = false;
	
		if ( $.isPlainObject( visible ) ) {
			api = visible.api;
			visible = visible.visible;
		}
	
		var a = $.map( DataTable.settings, function (o) {
			if ( !visible || (visible && $(o.nTable).is(':visible')) ) {
				return o.nTable;
			}
		} );
	
		return api ?
			new _Api( a ) :
			a;
	};
	
	
	/**
	 * Convert from camel case parameters to Hungarian notation. This is made public
	 * for the extensions to provide the same ability as DataTables core to accept
	 * either the 1.9 style Hungarian notation, or the 1.10+ style camelCase
	 * parameters.
	 *
	 *  @param {object} src The model object which holds all parameters that can be
	 *    mapped.
	 *  @param {object} user The object to convert from camel case to Hungarian.
	 *  @param {boolean} force When set to `true`, properties which already have a
	 *    Hungarian value in the `user` object will be overwritten. Otherwise they
	 *    won't be.
	 */
	DataTable.camelToHungarian = _fnCamelToHungarian;
	
	
	
	/**
	 *
	 */
	_api_register( '$()', function ( selector, opts ) {
		var
			rows   = this.rows( opts ).nodes(), // Get all rows
			jqRows = $(rows);
	
		return $( [].concat(
			jqRows.filter( selector ).toArray(),
			jqRows.find( selector ).toArray()
		) );
	} );
	
	
	// jQuery functions to operate on the tables
	$.each( [ 'on', 'one', 'off' ], function (i, key) {
		_api_register( key+'()', function ( /* event, handler */ ) {
			var args = Array.prototype.slice.call(arguments);
	
			// Add the `dt` namespace automatically if it isn't already present
			args[0] = $.map( args[0].split( /\s/ ), function ( e ) {
				return ! e.match(/\.dt\b/) ?
					e+'.dt' :
					e;
				} ).join( ' ' );
	
			var inst = $( this.tables().nodes() );
			inst[key].apply( inst, args );
			return this;
		} );
	} );
	
	
	_api_register( 'clear()', function () {
		return this.iterator( 'table', function ( settings ) {
			_fnClearTable( settings );
		} );
	} );
	
	
	_api_register( 'settings()', function () {
		return new _Api( this.context, this.context );
	} );
	
	
	_api_register( 'init()', function () {
		var ctx = this.context;
		return ctx.length ? ctx[0].oInit : null;
	} );
	
	
	_api_register( 'data()', function () {
		return this.iterator( 'table', function ( settings ) {
			return _pluck( settings.aoData, '_aData' );
		} ).flatten();
	} );
	
	
	_api_register( 'destroy()', function ( remove ) {
		remove = remove || false;
	
		return this.iterator( 'table', function ( settings ) {
			var orig      = settings.nTableWrapper.parentNode;
			var classes   = settings.oClasses;
			var table     = settings.nTable;
			var tbody     = settings.nTBody;
			var thead     = settings.nTHead;
			var tfoot     = settings.nTFoot;
			var jqTable   = $(table);
			var jqTbody   = $(tbody);
			var jqWrapper = $(settings.nTableWrapper);
			var rows      = $.map( settings.aoData, function (r) { return r.nTr; } );
			var i, ien;
	
			// Flag to note that the table is currently being destroyed - no action
			// should be taken
			settings.bDestroying = true;
	
			// Fire off the destroy callbacks for plug-ins etc
			_fnCallbackFire( settings, "aoDestroyCallback", "destroy", [settings] );
	
			// If not being removed from the document, make all columns visible
			if ( ! remove ) {
				new _Api( settings ).columns().visible( true );
			}
	
			// Blitz all `DT` namespaced events (these are internal events, the
			// lowercase, `dt` events are user subscribed and they are responsible
			// for removing them
			jqWrapper.off('.DT').find(':not(tbody *)').off('.DT');
			$(window).off('.DT-'+settings.sInstance);
	
			// When scrolling we had to break the table up - restore it
			if ( table != thead.parentNode ) {
				jqTable.children('thead').detach();
				jqTable.append( thead );
			}
	
			if ( tfoot && table != tfoot.parentNode ) {
				jqTable.children('tfoot').detach();
				jqTable.append( tfoot );
			}
	
			settings.aaSorting = [];
			settings.aaSortingFixed = [];
			_fnSortingClasses( settings );
	
			$( rows ).removeClass( settings.asStripeClasses.join(' ') );
	
			$('th, td', thead).removeClass( classes.sSortable+' '+
				classes.sSortableAsc+' '+classes.sSortableDesc+' '+classes.sSortableNone
			);
	
			// Add the TR elements back into the table in their original order
			jqTbody.children().detach();
			jqTbody.append( rows );
	
			// Remove the DataTables generated nodes, events and classes
			var removedMethod = remove ? 'remove' : 'detach';
			jqTable[ removedMethod ]();
			jqWrapper[ removedMethod ]();
	
			// If we need to reattach the table to the document
			if ( ! remove && orig ) {
				// insertBefore acts like appendChild if !arg[1]
				orig.insertBefore( table, settings.nTableReinsertBefore );
	
				// Restore the width of the original table - was read from the style property,
				// so we can restore directly to that
				jqTable
					.css( 'width', settings.sDestroyWidth )
					.removeClass( classes.sTable );
	
				// If the were originally stripe classes - then we add them back here.
				// Note this is not fool proof (for example if not all rows had stripe
				// classes - but it's a good effort without getting carried away
				ien = settings.asDestroyStripes.length;
	
				if ( ien ) {
					jqTbody.children().each( function (i) {
						$(this).addClass( settings.asDestroyStripes[i % ien] );
					} );
				}
			}
	
			/* Remove the settings object from the settings array */
			var idx = $.inArray( settings, DataTable.settings );
			if ( idx !== -1 ) {
				DataTable.settings.splice( idx, 1 );
			}
		} );
	} );
	
	
	// Add the `every()` method for rows, columns and cells in a compact form
	$.each( [ 'column', 'row', 'cell' ], function ( i, type ) {
		_api_register( type+'s().every()', function ( fn ) {
			var opts = this.selector.opts;
			var api = this;
	
			return this.iterator( type, function ( settings, arg1, arg2, arg3, arg4 ) {
				// Rows and columns:
				//  arg1 - index
				//  arg2 - table counter
				//  arg3 - loop counter
				//  arg4 - undefined
				// Cells:
				//  arg1 - row index
				//  arg2 - column index
				//  arg3 - table counter
				//  arg4 - loop counter
				fn.call(
					api[ type ](
						arg1,
						type==='cell' ? arg2 : opts,
						type==='cell' ? opts : undefined
					),
					arg1, arg2, arg3, arg4
				);
			} );
		} );
	} );
	
	
	// i18n method for extensions to be able to use the language object from the
	// DataTable
	_api_register( 'i18n()', function ( token, def, plural ) {
		var ctx = this.context[0];
		var resolved = _fnGetObjectDataFn( token )( ctx.oLanguage );
	
		if ( resolved === undefined ) {
			resolved = def;
		}
	
		if ( plural !== undefined && $.isPlainObject( resolved ) ) {
			resolved = resolved[ plural ] !== undefined ?
				resolved[ plural ] :
				resolved._;
		}
	
		return resolved.replace( '%d', plural ); // nb: plural might be undefined,
	} );
	/**
	 * Version string for plug-ins to check compatibility. Allowed format is
	 * `a.b.c-d` where: a:int, b:int, c:int, d:string(dev|beta|alpha). `d` is used
	 * only for non-release builds. See http://semver.org/ for more information.
	 *  @member
	 *  @type string
	 *  @default Version number
	 */
	DataTable.version = "1.10.21";

	/**
	 * Private data store, containing all of the settings objects that are
	 * created for the tables on a given page.
	 *
	 * Note that the `DataTable.settings` object is aliased to
	 * `jQuery.fn.dataTableExt` through which it may be accessed and
	 * manipulated, or `jQuery.fn.dataTable.settings`.
	 *  @member
	 *  @type array
	 *  @default []
	 *  @private
	 */
	DataTable.settings = [];

	/**
	 * Object models container, for the various models that DataTables has
	 * available to it. These models define the objects that are used to hold
	 * the active state and configuration of the table.
	 *  @namespace
	 */
	DataTable.models = {};
	
	
	
	/**
	 * Template object for the way in which DataTables holds information about
	 * search information for the global filter and individual column filters.
	 *  @namespace
	 */
	DataTable.models.oSearch = {
		/**
		 * Flag to indicate if the filtering should be case insensitive or not
		 *  @type boolean
		 *  @default true
		 */
		"bCaseInsensitive": true,
	
		/**
		 * Applied search term
		 *  @type string
		 *  @default <i>Empty string</i>
		 */
		"sSearch": "",
	
		/**
		 * Flag to indicate if the search term should be interpreted as a
		 * regular expression (true) or not (false) and therefore and special
		 * regex characters escaped.
		 *  @type boolean
		 *  @default false
		 */
		"bRegex": false,
	
		/**
		 * Flag to indicate if DataTables is to use its smart filtering or not.
		 *  @type boolean
		 *  @default true
		 */
		"bSmart": true
	};
	
	
	
	
	/**
	 * Template object for the way in which DataTables holds information about
	 * each individual row. This is the object format used for the settings
	 * aoData array.
	 *  @namespace
	 */
	DataTable.models.oRow = {
		/**
		 * TR element for the row
		 *  @type node
		 *  @default null
		 */
		"nTr": null,
	
		/**
		 * Array of TD elements for each row. This is null until the row has been
		 * created.
		 *  @type array nodes
		 *  @default []
		 */
		"anCells": null,
	
		/**
		 * Data object from the original data source for the row. This is either
		 * an array if using the traditional form of DataTables, or an object if
		 * using mData options. The exact type will depend on the passed in
		 * data from the data source, or will be an array if using DOM a data
		 * source.
		 *  @type array|object
		 *  @default []
		 */
		"_aData": [],
	
		/**
		 * Sorting data cache - this array is ostensibly the same length as the
		 * number of columns (although each index is generated only as it is
		 * needed), and holds the data that is used for sorting each column in the
		 * row. We do this cache generation at the start of the sort in order that
		 * the formatting of the sort data need be done only once for each cell
		 * per sort. This array should not be read from or written to by anything
		 * other than the master sorting methods.
		 *  @type array
		 *  @default null
		 *  @private
		 */
		"_aSortData": null,
	
		/**
		 * Per cell filtering data cache. As per the sort data cache, used to
		 * increase the performance of the filtering in DataTables
		 *  @type array
		 *  @default null
		 *  @private
		 */
		"_aFilterData": null,
	
		/**
		 * Filtering data cache. This is the same as the cell filtering cache, but
		 * in this case a string rather than an array. This is easily computed with
		 * a join on `_aFilterData`, but is provided as a cache so the join isn't
		 * needed on every search (memory traded for performance)
		 *  @type array
		 *  @default null
		 *  @private
		 */
		"_sFilterRow": null,
	
		/**
		 * Cache of the class name that DataTables has applied to the row, so we
		 * can quickly look at this variable rather than needing to do a DOM check
		 * on className for the nTr property.
		 *  @type string
		 *  @default <i>Empty string</i>
		 *  @private
		 */
		"_sRowStripe": "",
	
		/**
		 * Denote if the original data source was from the DOM, or the data source
		 * object. This is used for invalidating data, so DataTables can
		 * automatically read data from the original source, unless uninstructed
		 * otherwise.
		 *  @type string
		 *  @default null
		 *  @private
		 */
		"src": null,
	
		/**
		 * Index in the aoData array. This saves an indexOf lookup when we have the
		 * object, but want to know the index
		 *  @type integer
		 *  @default -1
		 *  @private
		 */
		"idx": -1
	};
	
	
	/**
	 * Template object for the column information object in DataTables. This object
	 * is held in the settings aoColumns array and contains all the information that
	 * DataTables needs about each individual column.
	 *
	 * Note that this object is related to {@link DataTable.defaults.column}
	 * but this one is the internal data store for DataTables's cache of columns.
	 * It should NOT be manipulated outside of DataTables. Any configuration should
	 * be done through the initialisation options.
	 *  @namespace
	 */
	DataTable.models.oColumn = {
		/**
		 * Column index. This could be worked out on-the-fly with $.inArray, but it
		 * is faster to just hold it as a variable
		 *  @type integer
		 *  @default null
		 */
		"idx": null,
	
		/**
		 * A list of the columns that sorting should occur on when this column
		 * is sorted. That this property is an array allows multi-column sorting
		 * to be defined for a column (for example first name / last name columns
		 * would benefit from this). The values are integers pointing to the
		 * columns to be sorted on (typically it will be a single integer pointing
		 * at itself, but that doesn't need to be the case).
		 *  @type array
		 */
		"aDataSort": null,
	
		/**
		 * Define the sorting directions that are applied to the column, in sequence
		 * as the column is repeatedly sorted upon - i.e. the first value is used
		 * as the sorting direction when the column if first sorted (clicked on).
		 * Sort it again (click again) and it will move on to the next index.
		 * Repeat until loop.
		 *  @type array
		 */
		"asSorting": null,
	
		/**
		 * Flag to indicate if the column is searchable, and thus should be included
		 * in the filtering or not.
		 *  @type boolean
		 */
		"bSearchable": null,
	
		/**
		 * Flag to indicate if the column is sortable or not.
		 *  @type boolean
		 */
		"bSortable": null,
	
		/**
		 * Flag to indicate if the column is currently visible in the table or not
		 *  @type boolean
		 */
		"bVisible": null,
	
		/**
		 * Store for manual type assignment using the `column.type` option. This
		 * is held in store so we can manipulate the column's `sType` property.
		 *  @type string
		 *  @default null
		 *  @private
		 */
		"_sManualType": null,
	
		/**
		 * Flag to indicate if HTML5 data attributes should be used as the data
		 * source for filtering or sorting. True is either are.
		 *  @type boolean
		 *  @default false
		 *  @private
		 */
		"_bAttrSrc": false,
	
		/**
		 * Developer definable function that is called whenever a cell is created (Ajax source,
		 * etc) or processed for input (DOM source). This can be used as a compliment to mRender
		 * allowing you to modify the DOM element (add background colour for example) when the
		 * element is available.
		 *  @type function
		 *  @param {element} nTd The TD node that has been created
		 *  @param {*} sData The Data for the cell
		 *  @param {array|object} oData The data for the whole row
		 *  @param {int} iRow The row index for the aoData data store
		 *  @default null
		 */
		"fnCreatedCell": null,
	
		/**
		 * Function to get data from a cell in a column. You should <b>never</b>
		 * access data directly through _aData internally in DataTables - always use
		 * the method attached to this property. It allows mData to function as
		 * required. This function is automatically assigned by the column
		 * initialisation method
		 *  @type function
		 *  @param {array|object} oData The data array/object for the array
		 *    (i.e. aoData[]._aData)
		 *  @param {string} sSpecific The specific data type you want to get -
		 *    'display', 'type' 'filter' 'sort'
		 *  @returns {*} The data for the cell from the given row's data
		 *  @default null
		 */
		"fnGetData": null,
	
		/**
		 * Function to set data for a cell in the column. You should <b>never</b>
		 * set the data directly to _aData internally in DataTables - always use
		 * this method. It allows mData to function as required. This function
		 * is automatically assigned by the column initialisation method
		 *  @type function
		 *  @param {array|object} oData The data array/object for the array
		 *    (i.e. aoData[]._aData)
		 *  @param {*} sValue Value to set
		 *  @default null
		 */
		"fnSetData": null,
	
		/**
		 * Property to read the value for the cells in the column from the data
		 * source array / object. If null, then the default content is used, if a
		 * function is given then the return from the function is used.
		 *  @type function|int|string|null
		 *  @default null
		 */
		"mData": null,
	
		/**
		 * Partner property to mData which is used (only when defined) to get
		 * the data - i.e. it is basically the same as mData, but without the
		 * 'set' option, and also the data fed to it is the result from mData.
		 * This is the rendering method to match the data method of mData.
		 *  @type function|int|string|null
		 *  @default null
		 */
		"mRender": null,
	
		/**
		 * Unique header TH/TD element for this column - this is what the sorting
		 * listener is attached to (if sorting is enabled.)
		 *  @type node
		 *  @default null
		 */
		"nTh": null,
	
		/**
		 * Unique footer TH/TD element for this column (if there is one). Not used
		 * in DataTables as such, but can be used for plug-ins to reference the
		 * footer for each column.
		 *  @type node
		 *  @default null
		 */
		"nTf": null,
	
		/**
		 * The class to apply to all TD elements in the table's TBODY for the column
		 *  @type string
		 *  @default null
		 */
		"sClass": null,
	
		/**
		 * When DataTables calculates the column widths to assign to each column,
		 * it finds the longest string in each column and then constructs a
		 * temporary table and reads the widths from that. The problem with this
		 * is that "mmm" is much wider then "iiii", but the latter is a longer
		 * string - thus the calculation can go wrong (doing it properly and putting
		 * it into an DOM object and measuring that is horribly(!) slow). Thus as
		 * a "work around" we provide this option. It will append its value to the
		 * text that is found to be the longest string for the column - i.e. padding.
		 *  @type string
		 */
		"sContentPadding": null,
	
		/**
		 * Allows a default value to be given for a column's data, and will be used
		 * whenever a null data source is encountered (this can be because mData
		 * is set to null, or because the data source itself is null).
		 *  @type string
		 *  @default null
		 */
		"sDefaultContent": null,
	
		/**
		 * Name for the column, allowing reference to the column by name as well as
		 * by index (needs a lookup to work by name).
		 *  @type string
		 */
		"sName": null,
	
		/**
		 * Custom sorting data type - defines which of the available plug-ins in
		 * afnSortData the custom sorting will use - if any is defined.
		 *  @type string
		 *  @default std
		 */
		"sSortDataType": 'std',
	
		/**
		 * Class to be applied to the header element when sorting on this column
		 *  @type string
		 *  @default null
		 */
		"sSortingClass": null,
	
		/**
		 * Class to be applied to the header element when sorting on this column -
		 * when jQuery UI theming is used.
		 *  @type string
		 *  @default null
		 */
		"sSortingClassJUI": null,
	
		/**
		 * Title of the column - what is seen in the TH element (nTh).
		 *  @type string
		 */
		"sTitle": null,
	
		/**
		 * Column sorting and filtering type
		 *  @type string
		 *  @default null
		 */
		"sType": null,
	
		/**
		 * Width of the column
		 *  @type string
		 *  @default null
		 */
		"sWidth": null,
	
		/**
		 * Width of the column when it was first "encountered"
		 *  @type string
		 *  @default null
		 */
		"sWidthOrig": null
	};
	
	
	/*
	 * Developer note: The properties of the object below are given in Hungarian
	 * notation, that was used as the interface for DataTables prior to v1.10, however
	 * from v1.10 onwards the primary interface is camel case. In order to avoid
	 * breaking backwards compatibility utterly with this change, the Hungarian
	 * version is still, internally the primary interface, but is is not documented
	 * - hence the @name tags in each doc comment. This allows a Javascript function
	 * to create a map from Hungarian notation to camel case (going the other direction
	 * would require each property to be listed, which would at around 3K to the size
	 * of DataTables, while this method is about a 0.5K hit.
	 *
	 * Ultimately this does pave the way for Hungarian notation to be dropped
	 * completely, but that is a massive amount of work and will break current
	 * installs (therefore is on-hold until v2).
	 */
	
	/**
	 * Initialisation options that can be given to DataTables at initialisation
	 * time.
	 *  @namespace
	 */
	DataTable.defaults = {
		/**
		 * An array of data to use for the table, passed in at initialisation which
		 * will be used in preference to any data which is already in the DOM. This is
		 * particularly useful for constructing tables purely in Javascript, for
		 * example with a custom Ajax call.
		 *  @type array
		 *  @default null
		 *
		 *  @dtopt Option
		 *  @name DataTable.defaults.data
		 *
		 *  @example
		 *    // Using a 2D array data source
		 *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "data": [
		 *          ['Trident', 'Internet Explorer 4.0', 'Win 95+', 4, 'X'],
		 *          ['Trident', 'Internet Explorer 5.0', 'Win 95+', 5, 'C'],
		 *        ],
		 *        "columns": [
		 *          { "title": "Engine" },
		 *          { "title": "Browser" },
		 *          { "title": "Platform" },
		 *          { "title": "Version" },
		 *          { "title": "Grade" }
		 *        ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Using an array of objects as a data source (`data`)
		 *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "data": [
		 *          {
		 *            "engine":   "Trident",
		 *            "browser":  "Internet Explorer 4.0",
		 *            "platform": "Win 95+",
		 *            "version":  4,
		 *            "grade":    "X"
		 *          },
		 *          {
		 *            "engine":   "Trident",
		 *            "browser":  "Internet Explorer 5.0",
		 *            "platform": "Win 95+",
		 *            "version":  5,
		 *            "grade":    "C"
		 *          }
		 *        ],
		 *        "columns": [
		 *          { "title": "Engine",   "data": "engine" },
		 *          { "title": "Browser",  "data": "browser" },
		 *          { "title": "Platform", "data": "platform" },
		 *          { "title": "Version",  "data": "version" },
		 *          { "title": "Grade",    "data": "grade" }
		 *        ]
		 *      } );
		 *    } );
		 */
		"aaData": null,
	
	
		/**
		 * If ordering is enabled, then DataTables will perform a first pass sort on
		 * initialisation. You can define which column(s) the sort is performed
		 * upon, and the sorting direction, with this variable. The `sorting` array
		 * should contain an array for each column to be sorted initially containing
		 * the column's index and a direction string ('asc' or 'desc').
		 *  @type array
		 *  @default [[0,'asc']]
		 *
		 *  @dtopt Option
		 *  @name DataTable.defaults.order
		 *
		 *  @example
		 *    // Sort by 3rd column first, and then 4th column
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "order": [[2,'asc'], [3,'desc']]
		 *      } );
		 *    } );
		 *
		 *    // No initial sorting
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "order": []
		 *      } );
		 *    } );
		 */
		"aaSorting": [[0,'asc']],
	
	
		/**
		 * This parameter is basically identical to the `sorting` parameter, but
		 * cannot be overridden by user interaction with the table. What this means
		 * is that you could have a column (visible or hidden) which the sorting
		 * will always be forced on first - any sorting after that (from the user)
		 * will then be performed as required. This can be useful for grouping rows
		 * together.
		 *  @type array
		 *  @default null
		 *
		 *  @dtopt Option
		 *  @name DataTable.defaults.orderFixed
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "orderFixed": [[0,'asc']]
		 *      } );
		 *    } )
		 */
		"aaSortingFixed": [],
	
	
		/**
		 * DataTables can be instructed to load data to display in the table from a
		 * Ajax source. This option defines how that Ajax call is made and where to.
		 *
		 * The `ajax` property has three different modes of operation, depending on
		 * how it is defined. These are:
		 *
		 * * `string` - Set the URL from where the data should be loaded from.
		 * * `object` - Define properties for `jQuery.ajax`.
		 * * `function` - Custom data get function
		 *
		 * `string`
		 * --------
		 *
		 * As a string, the `ajax` property simply defines the URL from which
		 * DataTables will load data.
		 *
		 * `object`
		 * --------
		 *
		 * As an object, the parameters in the object are passed to
		 * [jQuery.ajax](http://api.jquery.com/jQuery.ajax/) allowing fine control
		 * of the Ajax request. DataTables has a number of default parameters which
		 * you can override using this option. Please refer to the jQuery
		 * documentation for a full description of the options available, although
		 * the following parameters provide additional options in DataTables or
		 * require special consideration:
		 *
		 * * `data` - As with jQuery, `data` can be provided as an object, but it
		 *   can also be used as a function to manipulate the data DataTables sends
		 *   to the server. The function takes a single parameter, an object of
		 *   parameters with the values that DataTables has readied for sending. An
		 *   object may be returned which will be merged into the DataTables
		 *   defaults, or you can add the items to the object that was passed in and
		 *   not return anything from the function. This supersedes `fnServerParams`
		 *   from DataTables 1.9-.
		 *
		 * * `dataSrc` - By default DataTables will look for the property `data` (or
		 *   `aaData` for compatibility with DataTables 1.9-) when obtaining data
		 *   from an Ajax source or for server-side processing - this parameter
		 *   allows that property to be changed. You can use Javascript dotted
		 *   object notation to get a data source for multiple levels of nesting, or
		 *   it my be used as a function. As a function it takes a single parameter,
		 *   the JSON returned from the server, which can be manipulated as
		 *   required, with the returned value being that used by DataTables as the
		 *   data source for the table. This supersedes `sAjaxDataProp` from
		 *   DataTables 1.9-.
		 *
		 * * `success` - Should not be overridden it is used internally in
		 *   DataTables. To manipulate / transform the data returned by the server
		 *   use `ajax.dataSrc`, or use `ajax` as a function (see below).
		 *
		 * `function`
		 * ----------
		 *
		 * As a function, making the Ajax call is left up to yourself allowing
		 * complete control of the Ajax request. Indeed, if desired, a method other
		 * than Ajax could be used to obtain the required data, such as Web storage
		 * or an AIR database.
		 *
		 * The function is given four parameters and no return is required. The
		 * parameters are:
		 *
		 * 1. _object_ - Data to send to the server
		 * 2. _function_ - Callback function that must be executed when the required
		 *    data has been obtained. That data should be passed into the callback
		 *    as the only parameter
		 * 3. _object_ - DataTables settings object for the table
		 *
		 * Note that this supersedes `fnServerData` from DataTables 1.9-.
		 *
		 *  @type string|object|function
		 *  @default null
		 *
		 *  @dtopt Option
		 *  @name DataTable.defaults.ajax
		 *  @since 1.10.0
		 *
		 * @example
		 *   // Get JSON data from a file via Ajax.
		 *   // Note DataTables expects data in the form `{ data: [ ...data... ] }` by default).
		 *   $('#example').dataTable( {
		 *     "ajax": "data.json"
		 *   } );
		 *
		 * @example
		 *   // Get JSON data from a file via Ajax, using `dataSrc` to change
		 *   // `data` to `tableData` (i.e. `{ tableData: [ ...data... ] }`)
		 *   $('#example').dataTable( {
		 *     "ajax": {
		 *       "url": "data.json",
		 *       "dataSrc": "tableData"
		 *     }
		 *   } );
		 *
		 * @example
		 *   // Get JSON data from a file via Ajax, using `dataSrc` to read data
		 *   // from a plain array rather than an array in an object
		 *   $('#example').dataTable( {
		 *     "ajax": {
		 *       "url": "data.json",
		 *       "dataSrc": ""
		 *     }
		 *   } );
		 *
		 * @example
		 *   // Manipulate the data returned from the server - add a link to data
		 *   // (note this can, should, be done using `render` for the column - this
		 *   // is just a simple example of how the data can be manipulated).
		 *   $('#example').dataTable( {
		 *     "ajax": {
		 *       "url": "data.json",
		 *       "dataSrc": function ( json ) {
		 *         for ( var i=0, ien=json.length ; i<ien ; i++ ) {
		 *           json[i][0] = '<a href="/message/'+json[i][0]+'>View message</a>';
		 *         }
		 *         return json;
		 *       }
		 *     }
		 *   } );
		 *
		 * @example
		 *   // Add data to the request
		 *   $('#example').dataTable( {
		 *     "ajax": {
		 *       "url": "data.json",
		 *       "data": function ( d ) {
		 *         return {
		 *           "extra_search": $('#extra').val()
		 *         };
		 *       }
		 *     }
		 *   } );
		 *
		 * @example
		 *   // Send request as POST
		 *   $('#example').dataTable( {
		 *     "ajax": {
		 *       "url": "data.json",
		 *       "type": "POST"
		 *     }
		 *   } );
		 *
		 * @example
		 *   // Get the data from localStorage (could interface with a form for
		 *   // adding, editing and removing rows).
		 *   $('#example').dataTable( {
		 *     "ajax": function (data, callback, settings) {
		 *       callback(
		 *         JSON.parse( localStorage.getItem('dataTablesData') )
		 *       );
		 *     }
		 *   } );
		 */
		"ajax": null,
	
	
		/**
		 * This parameter allows you to readily specify the entries in the length drop
		 * down menu that DataTables shows when pagination is enabled. It can be
		 * either a 1D array of options which will be used for both the displayed
		 * option and the value, or a 2D array which will use the array in the first
		 * position as the value, and the array in the second position as the
		 * displayed options (useful for language strings such as 'All').
		 *
		 * Note that the `pageLength` property will be automatically set to the
		 * first value given in this array, unless `pageLength` is also provided.
		 *  @type array
		 *  @default [ 10, 25, 50, 100 ]
		 *
		 *  @dtopt Option
		 *  @name DataTable.defaults.lengthMenu
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "lengthMenu": [[10, 25, 50, -1], [10, 25, 50, "All"]]
		 *      } );
		 *    } );
		 */
		"aLengthMenu": [ 10, 25, 50, 100 ],
	
	
		/**
		 * The `columns` option in the initialisation parameter allows you to define
		 * details about the way individual columns behave. For a full list of
		 * column options that can be set, please see
		 * {@link DataTable.defaults.column}. Note that if you use `columns` to
		 * define your columns, you must have an entry in the array for every single
		 * column that you have in your table (these can be null if you don't which
		 * to specify any options).
		 *  @member
		 *
		 *  @name DataTable.defaults.column
		 */
		"aoColumns": null,
	
		/**
		 * Very similar to `columns`, `columnDefs` allows you to target a specific
		 * column, multiple columns, or all columns, using the `targets` property of
		 * each object in the array. This allows great flexibility when creating
		 * tables, as the `columnDefs` arrays can be of any length, targeting the
		 * columns you specifically want. `columnDefs` may use any of the column
		 * options available: {@link DataTable.defaults.column}, but it _must_
		 * have `targets` defined in each object in the array. Values in the `targets`
		 * array may be:
		 *   <ul>
		 *     <li>a string - class name will be matched on the TH for the column</li>
		 *     <li>0 or a positive integer - column index counting from the left</li>
		 *     <li>a negative integer - column index counting from the right</li>
		 *     <li>the string "_all" - all columns (i.e. assign a default)</li>
		 *   </ul>
		 *  @member
		 *
		 *  @name DataTable.defaults.columnDefs
		 */
		"aoColumnDefs": null,
	
	
		/**
		 * Basically the same as `search`, this parameter defines the individual column
		 * filtering state at initialisation time. The array must be of the same size
		 * as the number of columns, and each element be an object with the parameters
		 * `search` and `escapeRegex` (the latter is optional). 'null' is also
		 * accepted and the default will be used.
		 *  @type array
		 *  @default []
		 *
		 *  @dtopt Option
		 *  @name DataTable.defaults.searchCols
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "searchCols": [
		 *          null,
		 *          { "search": "My filter" },
		 *          null,
		 *          { "search": "^[0-9]", "escapeRegex": false }
		 *        ]
		 *      } );
		 *    } )
		 */
		"aoSearchCols": [],
	
	
		/**
		 * An array of CSS classes that should be applied to displayed rows. This
		 * array may be of any length, and DataTables will apply each class
		 * sequentially, looping when required.
		 *  @type array
		 *  @default null <i>Will take the values determined by the `oClasses.stripe*`
		 *    options</i>
		 *
		 *  @dtopt Option
		 *  @name DataTable.defaults.stripeClasses
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "stripeClasses": [ 'strip1', 'strip2', 'strip3' ]
		 *      } );
		 *    } )
		 */
		"asStripeClasses": null,
	
	
		/**
		 * Enable or disable automatic column width calculation. This can be disabled
		 * as an optimisation (it takes some time to calculate the widths) if the
		 * tables widths are passed in using `columns`.
		 *  @type boolean
		 *  @default true
		 *
		 *  @dtopt Features
		 *  @name DataTable.defaults.autoWidth
		 *
		 *  @example
		 *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "autoWidth": false
		 *      } );
		 *    } );
		 */
		"bAutoWidth": true,
	
	
		/**
		 * Deferred rendering can provide DataTables with a huge speed boost when you
		 * are using an Ajax or JS data source for the table. This option, when set to
		 * true, will cause DataTables to defer the creation of the table elements for
		 * each row until they are needed for a draw - saving a significant amount of
		 * time.
		 *  @type boolean
		 *  @default false
		 *
		 *  @dtopt Features
		 *  @name DataTable.defaults.deferRender
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "ajax": "sources/arrays.txt",
		 *        "deferRender": true
		 *      } );
		 *    } );
		 */
		"bDeferRender": false,
	
	
		/**
		 * Replace a DataTable which matches the given selector and replace it with
		 * one which has the properties of the new initialisation object passed. If no
		 * table matches the selector, then the new DataTable will be constructed as
		 * per normal.
		 *  @type boolean
		 *  @default false
		 *
		 *  @dtopt Options
		 *  @name DataTable.defaults.destroy
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "srollY": "200px",
		 *        "paginate": false
		 *      } );
		 *
		 *      // Some time later....
		 *      $('#example').dataTable( {
		 *        "filter": false,
		 *        "destroy": true
		 *      } );
		 *    } );
		 */
		"bDestroy": false,
	
	
		/**
		 * Enable or disable filtering of data. Filtering in DataTables is "smart" in
		 * that it allows the end user to input multiple words (space separated) and
		 * will match a row containing those words, even if not in the order that was
		 * specified (this allow matching across multiple columns). Note that if you
		 * wish to use filtering in DataTables this must remain 'true' - to remove the
		 * default filtering input box and retain filtering abilities, please use
		 * {@link DataTable.defaults.dom}.
		 *  @type boolean
		 *  @default true
		 *
		 *  @dtopt Features
		 *  @name DataTable.defaults.searching
		 *
		 *  @example
		 *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "searching": false
		 *      } );
		 *    } );
		 */
		"bFilter": true,
	
	
		/**
		 * Enable or disable the table information display. This shows information
		 * about the data that is currently visible on the page, including information
		 * about filtered data if that action is being performed.
		 *  @type boolean
		 *  @default true
		 *
		 *  @dtopt Features
		 *  @name DataTable.defaults.info
		 *
		 *  @example
		 *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "info": false
		 *      } );
		 *    } );
		 */
		"bInfo": true,
	
	
		/**
		 * Allows the end user to select the size of a formatted page from a select
		 * menu (sizes are 10, 25, 50 and 100). Requires pagination (`paginate`).
		 *  @type boolean
		 *  @default true
		 *
		 *  @dtopt Features
		 *  @name DataTable.defaults.lengthChange
		 *
		 *  @example
		 *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "lengthChange": false
		 *      } );
		 *    } );
		 */
		"bLengthChange": true,
	
	
		/**
		 * Enable or disable pagination.
		 *  @type boolean
		 *  @default true
		 *
		 *  @dtopt Features
		 *  @name DataTable.defaults.paging
		 *
		 *  @example
		 *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "paging": false
		 *      } );
		 *    } );
		 */
		"bPaginate": true,
	
	
		/**
		 * Enable or disable the display of a 'processing' indicator when the table is
		 * being processed (e.g. a sort). This is particularly useful for tables with
		 * large amounts of data where it can take a noticeable amount of time to sort
		 * the entries.
		 *  @type boolean
		 *  @default false
		 *
		 *  @dtopt Features
		 *  @name DataTable.defaults.processing
		 *
		 *  @example
		 *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "processing": true
		 *      } );
		 *    } );
		 */
		"bProcessing": false,
	
	
		/**
		 * Retrieve the DataTables object for the given selector. Note that if the
		 * table has already been initialised, this parameter will cause DataTables
		 * to simply return the object that has already been set up - it will not take
		 * account of any changes you might have made to the initialisation object
		 * passed to DataTables (setting this parameter to true is an acknowledgement
		 * that you understand this). `destroy` can be used to reinitialise a table if
		 * you need.
		 *  @type boolean
		 *  @default false
		 *
		 *  @dtopt Options
		 *  @name DataTable.defaults.retrieve
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      initTable();
		 *      tableActions();
		 *    } );
		 *
		 *    function initTable ()
		 *    {
		 *      return $('#example').dataTable( {
		 *        "scrollY": "200px",
		 *        "paginate": false,
		 *        "retrieve": true
		 *      } );
		 *    }
		 *
		 *    function tableActions ()
		 *    {
		 *      var table = initTable();
		 *      // perform API operations with oTable
		 *    }
		 */
		"bRetrieve": false,
	
	
		/**
		 * When vertical (y) scrolling is enabled, DataTables will force the height of
		 * the table's viewport to the given height at all times (useful for layout).
		 * However, this can look odd when filtering data down to a small data set,
		 * and the footer is left "floating" further down. This parameter (when
		 * enabled) will cause DataTables to collapse the table's viewport down when
		 * the result set will fit within the given Y height.
		 *  @type boolean
		 *  @default false
		 *
		 *  @dtopt Options
		 *  @name DataTable.defaults.scrollCollapse
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "scrollY": "200",
		 *        "scrollCollapse": true
		 *      } );
		 *    } );
		 */
		"bScrollCollapse": false,
	
	
		/**
		 * Configure DataTables to use server-side processing. Note that the
		 * `ajax` parameter must also be given in order to give DataTables a
		 * source to obtain the required data for each draw.
		 *  @type boolean
		 *  @default false
		 *
		 *  @dtopt Features
		 *  @dtopt Server-side
		 *  @name DataTable.defaults.serverSide
		 *
		 *  @example
		 *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "serverSide": true,
		 *        "ajax": "xhr.php"
		 *      } );
		 *    } );
		 */
		"bServerSide": false,
	
	
		/**
		 * Enable or disable sorting of columns. Sorting of individual columns can be
		 * disabled by the `sortable` option for each column.
		 *  @type boolean
		 *  @default true
		 *
		 *  @dtopt Features
		 *  @name DataTable.defaults.ordering
		 *
		 *  @example
		 *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "ordering": false
		 *      } );
		 *    } );
		 */
		"bSort": true,
	
	
		/**
		 * Enable or display DataTables' ability to sort multiple columns at the
		 * same time (activated by shift-click by the user).
		 *  @type boolean
		 *  @default true
		 *
		 *  @dtopt Options
		 *  @name DataTable.defaults.orderMulti
		 *
		 *  @example
		 *    // Disable multiple column sorting ability
		 *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "orderMulti": false
		 *      } );
		 *    } );
		 */
		"bSortMulti": true,
	
	
		/**
		 * Allows control over whether DataTables should use the top (true) unique
		 * cell that is found for a single column, or the bottom (false - default).
		 * This is useful when using complex headers.
		 *  @type boolean
		 *  @default false
		 *
		 *  @dtopt Options
		 *  @name DataTable.defaults.orderCellsTop
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "orderCellsTop": true
		 *      } );
		 *    } );
		 */
		"bSortCellsTop": false,
	
	
		/**
		 * Enable or disable the addition of the classes `sorting\_1`, `sorting\_2` and
		 * `sorting\_3` to the columns which are currently being sorted on. This is
		 * presented as a feature switch as it can increase processing time (while
		 * classes are removed and added) so for large data sets you might want to
		 * turn this off.
		 *  @type boolean
		 *  @default true
		 *
		 *  @dtopt Features
		 *  @name DataTable.defaults.orderClasses
		 *
		 *  @example
		 *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "orderClasses": false
		 *      } );
		 *    } );
		 */
		"bSortClasses": true,
	
	
		/**
		 * Enable or disable state saving. When enabled HTML5 `localStorage` will be
		 * used to save table display information such as pagination information,
		 * display length, filtering and sorting. As such when the end user reloads
		 * the page the display display will match what thy had previously set up.
		 *
		 * Due to the use of `localStorage` the default state saving is not supported
		 * in IE6 or 7. If state saving is required in those browsers, use
		 * `stateSaveCallback` to provide a storage solution such as cookies.
		 *  @type boolean
		 *  @default false
		 *
		 *  @dtopt Features
		 *  @name DataTable.defaults.stateSave
		 *
		 *  @example
		 *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "stateSave": true
		 *      } );
		 *    } );
		 */
		"bStateSave": false,
	
	
		/**
		 * This function is called when a TR element is created (and all TD child
		 * elements have been inserted), or registered if using a DOM source, allowing
		 * manipulation of the TR element (adding classes etc).
		 *  @type function
		 *  @param {node} row "TR" element for the current row
		 *  @param {array} data Raw data array for this row
		 *  @param {int} dataIndex The index of this row in the internal aoData array
		 *
		 *  @dtopt Callbacks
		 *  @name DataTable.defaults.createdRow
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "createdRow": function( row, data, dataIndex ) {
		 *          // Bold the grade for all 'A' grade browsers
		 *          if ( data[4] == "A" )
		 *          {
		 *            $('td:eq(4)', row).html( '<b>A</b>' );
		 *          }
		 *        }
		 *      } );
		 *    } );
		 */
		"fnCreatedRow": null,
	
	
		/**
		 * This function is called on every 'draw' event, and allows you to
		 * dynamically modify any aspect you want about the created DOM.
		 *  @type function
		 *  @param {object} settings DataTables settings object
		 *
		 *  @dtopt Callbacks
		 *  @name DataTable.defaults.drawCallback
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "drawCallback": function( settings ) {
		 *          alert( 'DataTables has redrawn the table' );
		 *        }
		 *      } );
		 *    } );
		 */
		"fnDrawCallback": null,
	
	
		/**
		 * Identical to fnHeaderCallback() but for the table footer this function
		 * allows you to modify the table footer on every 'draw' event.
		 *  @type function
		 *  @param {node} foot "TR" element for the footer
		 *  @param {array} data Full table data (as derived from the original HTML)
		 *  @param {int} start Index for the current display starting point in the
		 *    display array
		 *  @param {int} end Index for the current display ending point in the
		 *    display array
		 *  @param {array int} display Index array to translate the visual position
		 *    to the full data array
		 *
		 *  @dtopt Callbacks
		 *  @name DataTable.defaults.footerCallback
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "footerCallback": function( tfoot, data, start, end, display ) {
		 *          tfoot.getElementsByTagName('th')[0].innerHTML = "Starting index is "+start;
		 *        }
		 *      } );
		 *    } )
		 */
		"fnFooterCallback": null,
	
	
		/**
		 * When rendering large numbers in the information element for the table
		 * (i.e. "Showing 1 to 10 of 57 entries") DataTables will render large numbers
		 * to have a comma separator for the 'thousands' units (e.g. 1 million is
		 * rendered as "1,000,000") to help readability for the end user. This
		 * function will override the default method DataTables uses.
		 *  @type function
		 *  @member
		 *  @param {int} toFormat number to be formatted
		 *  @returns {string} formatted string for DataTables to show the number
		 *
		 *  @dtopt Callbacks
		 *  @name DataTable.defaults.formatNumber
		 *
		 *  @example
		 *    // Format a number using a single quote for the separator (note that
		 *    // this can also be done with the language.thousands option)
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "formatNumber": function ( toFormat ) {
		 *          return toFormat.toString().replace(
		 *            /\B(?=(\d{3})+(?!\d))/g, "'"
		 *          );
		 *        };
		 *      } );
		 *    } );
		 */
		"fnFormatNumber": function ( toFormat ) {
			return toFormat.toString().replace(
				/\B(?=(\d{3})+(?!\d))/g,
				this.oLanguage.sThousands
			);
		},
	
	
		/**
		 * This function is called on every 'draw' event, and allows you to
		 * dynamically modify the header row. This can be used to calculate and
		 * display useful information about the table.
		 *  @type function
		 *  @param {node} head "TR" element for the header
		 *  @param {array} data Full table data (as derived from the original HTML)
		 *  @param {int} start Index for the current display starting point in the
		 *    display array
		 *  @param {int} end Index for the current display ending point in the
		 *    display array
		 *  @param {array int} display Index array to translate the visual position
		 *    to the full data array
		 *
		 *  @dtopt Callbacks
		 *  @name DataTable.defaults.headerCallback
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "fheaderCallback": function( head, data, start, end, display ) {
		 *          head.getElementsByTagName('th')[0].innerHTML = "Displaying "+(end-start)+" records";
		 *        }
		 *      } );
		 *    } )
		 */
		"fnHeaderCallback": null,
	
	
		/**
		 * The information element can be used to convey information about the current
		 * state of the table. Although the internationalisation options presented by
		 * DataTables are quite capable of dealing with most customisations, there may
		 * be times where you wish to customise the string further. This callback
		 * allows you to do exactly that.
		 *  @type function
		 *  @param {object} oSettings DataTables settings object
		 *  @param {int} start Starting position in data for the draw
		 *  @param {int} end End position in data for the draw
		 *  @param {int} max Total number of rows in the table (regardless of
		 *    filtering)
		 *  @param {int} total Total number of rows in the data set, after filtering
		 *  @param {string} pre The string that DataTables has formatted using it's
		 *    own rules
		 *  @returns {string} The string to be displayed in the information element.
		 *
		 *  @dtopt Callbacks
		 *  @name DataTable.defaults.infoCallback
		 *
		 *  @example
		 *    $('#example').dataTable( {
		 *      "infoCallback": function( settings, start, end, max, total, pre ) {
		 *        return start +" to "+ end;
		 *      }
		 *    } );
		 */
		"fnInfoCallback": null,
	
	
		/**
		 * Called when the table has been initialised. Normally DataTables will
		 * initialise sequentially and there will be no need for this function,
		 * however, this does not hold true when using external language information
		 * since that is obtained using an async XHR call.
		 *  @type function
		 *  @param {object} settings DataTables settings object
		 *  @param {object} json The JSON object request from the server - only
		 *    present if client-side Ajax sourced data is used
		 *
		 *  @dtopt Callbacks
		 *  @name DataTable.defaults.initComplete
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "initComplete": function(settings, json) {
		 *          alert( 'DataTables has finished its initialisation.' );
		 *        }
		 *      } );
		 *    } )
		 */
		"fnInitComplete": null,
	
	
		/**
		 * Called at the very start of each table draw and can be used to cancel the
		 * draw by returning false, any other return (including undefined) results in
		 * the full draw occurring).
		 *  @type function
		 *  @param {object} settings DataTables settings object
		 *  @returns {boolean} False will cancel the draw, anything else (including no
		 *    return) will allow it to complete.
		 *
		 *  @dtopt Callbacks
		 *  @name DataTable.defaults.preDrawCallback
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "preDrawCallback": function( settings ) {
		 *          if ( $('#test').val() == 1 ) {
		 *            return false;
		 *          }
		 *        }
		 *      } );
		 *    } );
		 */
		"fnPreDrawCallback": null,
	
	
		/**
		 * This function allows you to 'post process' each row after it have been
		 * generated for each table draw, but before it is rendered on screen. This
		 * function might be used for setting the row class name etc.
		 *  @type function
		 *  @param {node} row "TR" element for the current row
		 *  @param {array} data Raw data array for this row
		 *  @param {int} displayIndex The display index for the current table draw
		 *  @param {int} displayIndexFull The index of the data in the full list of
		 *    rows (after filtering)
		 *
		 *  @dtopt Callbacks
		 *  @name DataTable.defaults.rowCallback
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "rowCallback": function( row, data, displayIndex, displayIndexFull ) {
		 *          // Bold the grade for all 'A' grade browsers
		 *          if ( data[4] == "A" ) {
		 *            $('td:eq(4)', row).html( '<b>A</b>' );
		 *          }
		 *        }
		 *      } );
		 *    } );
		 */
		"fnRowCallback": null,
	
	
		/**
		 * __Deprecated__ The functionality provided by this parameter has now been
		 * superseded by that provided through `ajax`, which should be used instead.
		 *
		 * This parameter allows you to override the default function which obtains
		 * the data from the server so something more suitable for your application.
		 * For example you could use POST data, or pull information from a Gears or
		 * AIR database.
		 *  @type function
		 *  @member
		 *  @param {string} source HTTP source to obtain the data from (`ajax`)
		 *  @param {array} data A key/value pair object containing the data to send
		 *    to the server
		 *  @param {function} callback to be called on completion of the data get
		 *    process that will draw the data on the page.
		 *  @param {object} settings DataTables settings object
		 *
		 *  @dtopt Callbacks
		 *  @dtopt Server-side
		 *  @name DataTable.defaults.serverData
		 *
		 *  @deprecated 1.10. Please use `ajax` for this functionality now.
		 */
		"fnServerData": null,
	
	
		/**
		 * __Deprecated__ The functionality provided by this parameter has now been
		 * superseded by that provided through `ajax`, which should be used instead.
		 *
		 *  It is often useful to send extra data to the server when making an Ajax
		 * request - for example custom filtering information, and this callback
		 * function makes it trivial to send extra information to the server. The
		 * passed in parameter is the data set that has been constructed by
		 * DataTables, and you can add to this or modify it as you require.
		 *  @type function
		 *  @param {array} data Data array (array of objects which are name/value
		 *    pairs) that has been constructed by DataTables and will be sent to the
		 *    server. In the case of Ajax sourced data with server-side processing
		 *    this will be an empty array, for server-side processing there will be a
		 *    significant number of parameters!
		 *  @returns {undefined} Ensure that you modify the data array passed in,
		 *    as this is passed by reference.
		 *
		 *  @dtopt Callbacks
		 *  @dtopt Server-side
		 *  @name DataTable.defaults.serverParams
		 *
		 *  @deprecated 1.10. Please use `ajax` for this functionality now.
		 */
		"fnServerParams": null,
	
	
		/**
		 * Load the table state. With this function you can define from where, and how, the
		 * state of a table is loaded. By default DataTables will load from `localStorage`
		 * but you might wish to use a server-side database or cookies.
		 *  @type function
		 *  @member
		 *  @param {object} settings DataTables settings object
		 *  @param {object} callback Callback that can be executed when done. It
		 *    should be passed the loaded state object.
		 *  @return {object} The DataTables state object to be loaded
		 *
		 *  @dtopt Callbacks
		 *  @name DataTable.defaults.stateLoadCallback
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "stateSave": true,
		 *        "stateLoadCallback": function (settings, callback) {
		 *          $.ajax( {
		 *            "url": "/state_load",
		 *            "dataType": "json",
		 *            "success": function (json) {
		 *              callback( json );
		 *            }
		 *          } );
		 *        }
		 *      } );
		 *    } );
		 */
		"fnStateLoadCallback": function ( settings ) {
			try {
				return JSON.parse(
					(settings.iStateDuration === -1 ? sessionStorage : localStorage).getItem(
						'DataTables_'+settings.sInstance+'_'+location.pathname
					)
				);
			} catch (e) {
				return {};
			}
		},
	
	
		/**
		 * Callback which allows modification of the saved state prior to loading that state.
		 * This callback is called when the table is loading state from the stored data, but
		 * prior to the settings object being modified by the saved state. Note that for
		 * plug-in authors, you should use the `stateLoadParams` event to load parameters for
		 * a plug-in.
		 *  @type function
		 *  @param {object} settings DataTables settings object
		 *  @param {object} data The state object that is to be loaded
		 *
		 *  @dtopt Callbacks
		 *  @name DataTable.defaults.stateLoadParams
		 *
		 *  @example
		 *    // Remove a saved filter, so filtering is never loaded
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "stateSave": true,
		 *        "stateLoadParams": function (settings, data) {
		 *          data.oSearch.sSearch = "";
		 *        }
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Disallow state loading by returning false
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "stateSave": true,
		 *        "stateLoadParams": function (settings, data) {
		 *          return false;
		 *        }
		 *      } );
		 *    } );
		 */
		"fnStateLoadParams": null,
	
	
		/**
		 * Callback that is called when the state has been loaded from the state saving method
		 * and the DataTables settings object has been modified as a result of the loaded state.
		 *  @type function
		 *  @param {object} settings DataTables settings object
		 *  @param {object} data The state object that was loaded
		 *
		 *  @dtopt Callbacks
		 *  @name DataTable.defaults.stateLoaded
		 *
		 *  @example
		 *    // Show an alert with the filtering value that was saved
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "stateSave": true,
		 *        "stateLoaded": function (settings, data) {
		 *          alert( 'Saved filter was: '+data.oSearch.sSearch );
		 *        }
		 *      } );
		 *    } );
		 */
		"fnStateLoaded": null,
	
	
		/**
		 * Save the table state. This function allows you to define where and how the state
		 * information for the table is stored By default DataTables will use `localStorage`
		 * but you might wish to use a server-side database or cookies.
		 *  @type function
		 *  @member
		 *  @param {object} settings DataTables settings object
		 *  @param {object} data The state object to be saved
		 *
		 *  @dtopt Callbacks
		 *  @name DataTable.defaults.stateSaveCallback
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "stateSave": true,
		 *        "stateSaveCallback": function (settings, data) {
		 *          // Send an Ajax request to the server with the state object
		 *          $.ajax( {
		 *            "url": "/state_save",
		 *            "data": data,
		 *            "dataType": "json",
		 *            "method": "POST"
		 *            "success": function () {}
		 *          } );
		 *        }
		 *      } );
		 *    } );
		 */
		"fnStateSaveCallback": function ( settings, data ) {
			try {
				(settings.iStateDuration === -1 ? sessionStorage : localStorage).setItem(
					'DataTables_'+settings.sInstance+'_'+location.pathname,
					JSON.stringify( data )
				);
			} catch (e) {}
		},
	
	
		/**
		 * Callback which allows modification of the state to be saved. Called when the table
		 * has changed state a new state save is required. This method allows modification of
		 * the state saving object prior to actually doing the save, including addition or
		 * other state properties or modification. Note that for plug-in authors, you should
		 * use the `stateSaveParams` event to save parameters for a plug-in.
		 *  @type function
		 *  @param {object} settings DataTables settings object
		 *  @param {object} data The state object to be saved
		 *
		 *  @dtopt Callbacks
		 *  @name DataTable.defaults.stateSaveParams
		 *
		 *  @example
		 *    // Remove a saved filter, so filtering is never saved
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "stateSave": true,
		 *        "stateSaveParams": function (settings, data) {
		 *          data.oSearch.sSearch = "";
		 *        }
		 *      } );
		 *    } );
		 */
		"fnStateSaveParams": null,
	
	
		/**
		 * Duration for which the saved state information is considered valid. After this period
		 * has elapsed the state will be returned to the default.
		 * Value is given in seconds.
		 *  @type int
		 *  @default 7200 <i>(2 hours)</i>
		 *
		 *  @dtopt Options
		 *  @name DataTable.defaults.stateDuration
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "stateDuration": 60*60*24; // 1 day
		 *      } );
		 *    } )
		 */
		"iStateDuration": 7200,
	
	
		/**
		 * When enabled DataTables will not make a request to the server for the first
		 * page draw - rather it will use the data already on the page (no sorting etc
		 * will be applied to it), thus saving on an XHR at load time. `deferLoading`
		 * is used to indicate that deferred loading is required, but it is also used
		 * to tell DataTables how many records there are in the full table (allowing
		 * the information element and pagination to be displayed correctly). In the case
		 * where a filtering is applied to the table on initial load, this can be
		 * indicated by giving the parameter as an array, where the first element is
		 * the number of records available after filtering and the second element is the
		 * number of records without filtering (allowing the table information element
		 * to be shown correctly).
		 *  @type int | array
		 *  @default null
		 *
		 *  @dtopt Options
		 *  @name DataTable.defaults.deferLoading
		 *
		 *  @example
		 *    // 57 records available in the table, no filtering applied
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "serverSide": true,
		 *        "ajax": "scripts/server_processing.php",
		 *        "deferLoading": 57
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // 57 records after filtering, 100 without filtering (an initial filter applied)
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "serverSide": true,
		 *        "ajax": "scripts/server_processing.php",
		 *        "deferLoading": [ 57, 100 ],
		 *        "search": {
		 *          "search": "my_filter"
		 *        }
		 *      } );
		 *    } );
		 */
		"iDeferLoading": null,
	
	
		/**
		 * Number of rows to display on a single page when using pagination. If
		 * feature enabled (`lengthChange`) then the end user will be able to override
		 * this to a custom setting using a pop-up menu.
		 *  @type int
		 *  @default 10
		 *
		 *  @dtopt Options
		 *  @name DataTable.defaults.pageLength
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "pageLength": 50
		 *      } );
		 *    } )
		 */
		"iDisplayLength": 10,
	
	
		/**
		 * Define the starting point for data display when using DataTables with
		 * pagination. Note that this parameter is the number of records, rather than
		 * the page number, so if you have 10 records per page and want to start on
		 * the third page, it should be "20".
		 *  @type int
		 *  @default 0
		 *
		 *  @dtopt Options
		 *  @name DataTable.defaults.displayStart
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "displayStart": 20
		 *      } );
		 *    } )
		 */
		"iDisplayStart": 0,
	
	
		/**
		 * By default DataTables allows keyboard navigation of the table (sorting, paging,
		 * and filtering) by adding a `tabindex` attribute to the required elements. This
		 * allows you to tab through the controls and press the enter key to activate them.
		 * The tabindex is default 0, meaning that the tab follows the flow of the document.
		 * You can overrule this using this parameter if you wish. Use a value of -1 to
		 * disable built-in keyboard navigation.
		 *  @type int
		 *  @default 0
		 *
		 *  @dtopt Options
		 *  @name DataTable.defaults.tabIndex
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "tabIndex": 1
		 *      } );
		 *    } );
		 */
		"iTabIndex": 0,
	
	
		/**
		 * Classes that DataTables assigns to the various components and features
		 * that it adds to the HTML table. This allows classes to be configured
		 * during initialisation in addition to through the static
		 * {@link DataTable.ext.oStdClasses} object).
		 *  @namespace
		 *  @name DataTable.defaults.classes
		 */
		"oClasses": {},
	
	
		/**
		 * All strings that DataTables uses in the user interface that it creates
		 * are defined in this object, allowing you to modified them individually or
		 * completely replace them all as required.
		 *  @namespace
		 *  @name DataTable.defaults.language
		 */
		"oLanguage": {
			/**
			 * Strings that are used for WAI-ARIA labels and controls only (these are not
			 * actually visible on the page, but will be read by screenreaders, and thus
			 * must be internationalised as well).
			 *  @namespace
			 *  @name DataTable.defaults.language.aria
			 */
			"oAria": {
				/**
				 * ARIA label that is added to the table headers when the column may be
				 * sorted ascending by activing the column (click or return when focused).
				 * Note that the column header is prefixed to this string.
				 *  @type string
				 *  @default : activate to sort column ascending
				 *
				 *  @dtopt Language
				 *  @name DataTable.defaults.language.aria.sortAscending
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "language": {
				 *          "aria": {
				 *            "sortAscending": " - click/return to sort ascending"
				 *          }
				 *        }
				 *      } );
				 *    } );
				 */
				"sSortAscending": ": activate to sort column ascending",
	
				/**
				 * ARIA label that is added to the table headers when the column may be
				 * sorted descending by activing the column (click or return when focused).
				 * Note that the column header is prefixed to this string.
				 *  @type string
				 *  @default : activate to sort column ascending
				 *
				 *  @dtopt Language
				 *  @name DataTable.defaults.language.aria.sortDescending
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "language": {
				 *          "aria": {
				 *            "sortDescending": " - click/return to sort descending"
				 *          }
				 *        }
				 *      } );
				 *    } );
				 */
				"sSortDescending": ": activate to sort column descending"
			},
	
			/**
			 * Pagination string used by DataTables for the built-in pagination
			 * control types.
			 *  @namespace
			 *  @name DataTable.defaults.language.paginate
			 */
			"oPaginate": {
				/**
				 * Text to use when using the 'full_numbers' type of pagination for the
				 * button to take the user to the first page.
				 *  @type string
				 *  @default First
				 *
				 *  @dtopt Language
				 *  @name DataTable.defaults.language.paginate.first
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "language": {
				 *          "paginate": {
				 *            "first": "First page"
				 *          }
				 *        }
				 *      } );
				 *    } );
				 */
				"sFirst": "First",
	
	
				/**
				 * Text to use when using the 'full_numbers' type of pagination for the
				 * button to take the user to the last page.
				 *  @type string
				 *  @default Last
				 *
				 *  @dtopt Language
				 *  @name DataTable.defaults.language.paginate.last
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "language": {
				 *          "paginate": {
				 *            "last": "Last page"
				 *          }
				 *        }
				 *      } );
				 *    } );
				 */
				"sLast": "Last",
	
	
				/**
				 * Text to use for the 'next' pagination button (to take the user to the
				 * next page).
				 *  @type string
				 *  @default Next
				 *
				 *  @dtopt Language
				 *  @name DataTable.defaults.language.paginate.next
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "language": {
				 *          "paginate": {
				 *            "next": "Next page"
				 *          }
				 *        }
				 *      } );
				 *    } );
				 */
				"sNext": "Next",
	
	
				/**
				 * Text to use for the 'previous' pagination button (to take the user to
				 * the previous page).
				 *  @type string
				 *  @default Previous
				 *
				 *  @dtopt Language
				 *  @name DataTable.defaults.language.paginate.previous
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "language": {
				 *          "paginate": {
				 *            "previous": "Previous page"
				 *          }
				 *        }
				 *      } );
				 *    } );
				 */
				"sPrevious": "Previous"
			},
	
			/**
			 * This string is shown in preference to `zeroRecords` when the table is
			 * empty of data (regardless of filtering). Note that this is an optional
			 * parameter - if it is not given, the value of `zeroRecords` will be used
			 * instead (either the default or given value).
			 *  @type string
			 *  @default No data available in table
			 *
			 *  @dtopt Language
			 *  @name DataTable.defaults.language.emptyTable
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "language": {
			 *          "emptyTable": "No data available in table"
			 *        }
			 *      } );
			 *    } );
			 */
			"sEmptyTable": "No data available in table",
	
	
			/**
			 * This string gives information to the end user about the information
			 * that is current on display on the page. The following tokens can be
			 * used in the string and will be dynamically replaced as the table
			 * display updates. This tokens can be placed anywhere in the string, or
			 * removed as needed by the language requires:
			 *
			 * * `\_START\_` - Display index of the first record on the current page
			 * * `\_END\_` - Display index of the last record on the current page
			 * * `\_TOTAL\_` - Number of records in the table after filtering
			 * * `\_MAX\_` - Number of records in the table without filtering
			 * * `\_PAGE\_` - Current page number
			 * * `\_PAGES\_` - Total number of pages of data in the table
			 *
			 *  @type string
			 *  @default Showing _START_ to _END_ of _TOTAL_ entries
			 *
			 *  @dtopt Language
			 *  @name DataTable.defaults.language.info
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "language": {
			 *          "info": "Showing page _PAGE_ of _PAGES_"
			 *        }
			 *      } );
			 *    } );
			 */
			"sInfo": "Showing _START_ to _END_ of _TOTAL_ entries",
	
	
			/**
			 * Display information string for when the table is empty. Typically the
			 * format of this string should match `info`.
			 *  @type string
			 *  @default Showing 0 to 0 of 0 entries
			 *
			 *  @dtopt Language
			 *  @name DataTable.defaults.language.infoEmpty
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "language": {
			 *          "infoEmpty": "No entries to show"
			 *        }
			 *      } );
			 *    } );
			 */
			"sInfoEmpty": "Showing 0 to 0 of 0 entries",
	
	
			/**
			 * When a user filters the information in a table, this string is appended
			 * to the information (`info`) to give an idea of how strong the filtering
			 * is. The variable _MAX_ is dynamically updated.
			 *  @type string
			 *  @default (filtered from _MAX_ total entries)
			 *
			 *  @dtopt Language
			 *  @name DataTable.defaults.language.infoFiltered
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "language": {
			 *          "infoFiltered": " - filtering from _MAX_ records"
			 *        }
			 *      } );
			 *    } );
			 */
			"sInfoFiltered": "(filtered from _MAX_ total entries)",
	
	
			/**
			 * If can be useful to append extra information to the info string at times,
			 * and this variable does exactly that. This information will be appended to
			 * the `info` (`infoEmpty` and `infoFiltered` in whatever combination they are
			 * being used) at all times.
			 *  @type string
			 *  @default <i>Empty string</i>
			 *
			 *  @dtopt Language
			 *  @name DataTable.defaults.language.infoPostFix
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "language": {
			 *          "infoPostFix": "All records shown are derived from real information."
			 *        }
			 *      } );
			 *    } );
			 */
			"sInfoPostFix": "",
	
	
			/**
			 * This decimal place operator is a little different from the other
			 * language options since DataTables doesn't output floating point
			 * numbers, so it won't ever use this for display of a number. Rather,
			 * what this parameter does is modify the sort methods of the table so
			 * that numbers which are in a format which has a character other than
			 * a period (`.`) as a decimal place will be sorted numerically.
			 *
			 * Note that numbers with different decimal places cannot be shown in
			 * the same table and still be sortable, the table must be consistent.
			 * However, multiple different tables on the page can use different
			 * decimal place characters.
			 *  @type string
			 *  @default 
			 *
			 *  @dtopt Language
			 *  @name DataTable.defaults.language.decimal
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "language": {
			 *          "decimal": ","
			 *          "thousands": "."
			 *        }
			 *      } );
			 *    } );
			 */
			"sDecimal": "",
	
	
			/**
			 * DataTables has a build in number formatter (`formatNumber`) which is
			 * used to format large numbers that are used in the table information.
			 * By default a comma is used, but this can be trivially changed to any
			 * character you wish with this parameter.
			 *  @type string
			 *  @default ,
			 *
			 *  @dtopt Language
			 *  @name DataTable.defaults.language.thousands
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "language": {
			 *          "thousands": "'"
			 *        }
			 *      } );
			 *    } );
			 */
			"sThousands": ",",
	
	
			/**
			 * Detail the action that will be taken when the drop down menu for the
			 * pagination length option is changed. The '_MENU_' variable is replaced
			 * with a default select list of 10, 25, 50 and 100, and can be replaced
			 * with a custom select box if required.
			 *  @type string
			 *  @default Show _MENU_ entries
			 *
			 *  @dtopt Language
			 *  @name DataTable.defaults.language.lengthMenu
			 *
			 *  @example
			 *    // Language change only
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "language": {
			 *          "lengthMenu": "Display _MENU_ records"
			 *        }
			 *      } );
			 *    } );
			 *
			 *  @example
			 *    // Language and options change
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "language": {
			 *          "lengthMenu": 'Display <select>'+
			 *            '<option value="10">10</option>'+
			 *            '<option value="20">20</option>'+
			 *            '<option value="30">30</option>'+
			 *            '<option value="40">40</option>'+
			 *            '<option value="50">50</option>'+
			 *            '<option value="-1">All</option>'+
			 *            '</select> records'
			 *        }
			 *      } );
			 *    } );
			 */
			"sLengthMenu": "Show _MENU_ entries",
	
	
			/**
			 * When using Ajax sourced data and during the first draw when DataTables is
			 * gathering the data, this message is shown in an empty row in the table to
			 * indicate to the end user the the data is being loaded. Note that this
			 * parameter is not used when loading data by server-side processing, just
			 * Ajax sourced data with client-side processing.
			 *  @type string
			 *  @default Loading...
			 *
			 *  @dtopt Language
			 *  @name DataTable.defaults.language.loadingRecords
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "language": {
			 *          "loadingRecords": "Please wait - loading..."
			 *        }
			 *      } );
			 *    } );
			 */
			"sLoadingRecords": "Loading...",
	
	
			/**
			 * Text which is displayed when the table is processing a user action
			 * (usually a sort command or similar).
			 *  @type string
			 *  @default Processing...
			 *
			 *  @dtopt Language
			 *  @name DataTable.defaults.language.processing
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "language": {
			 *          "processing": "DataTables is currently busy"
			 *        }
			 *      } );
			 *    } );
			 */
			"sProcessing": "Processing...",
	
	
			/**
			 * Details the actions that will be taken when the user types into the
			 * filtering input text box. The variable "_INPUT_", if used in the string,
			 * is replaced with the HTML text box for the filtering input allowing
			 * control over where it appears in the string. If "_INPUT_" is not given
			 * then the input box is appended to the string automatically.
			 *  @type string
			 *  @default Search:
			 *
			 *  @dtopt Language
			 *  @name DataTable.defaults.language.search
			 *
			 *  @example
			 *    // Input text box will be appended at the end automatically
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "language": {
			 *          "search": "Filter records:"
			 *        }
			 *      } );
			 *    } );
			 *
			 *  @example
			 *    // Specify where the filter should appear
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "language": {
			 *          "search": "Apply filter _INPUT_ to table"
			 *        }
			 *      } );
			 *    } );
			 */
			"sSearch": "Search:",
	
	
			/**
			 * Assign a `placeholder` attribute to the search `input` element
			 *  @type string
			 *  @default 
			 *
			 *  @dtopt Language
			 *  @name DataTable.defaults.language.searchPlaceholder
			 */
			"sSearchPlaceholder": "",
	
	
			/**
			 * All of the language information can be stored in a file on the
			 * server-side, which DataTables will look up if this parameter is passed.
			 * It must store the URL of the language file, which is in a JSON format,
			 * and the object has the same properties as the oLanguage object in the
			 * initialiser object (i.e. the above parameters). Please refer to one of
			 * the example language files to see how this works in action.
			 *  @type string
			 *  @default <i>Empty string - i.e. disabled</i>
			 *
			 *  @dtopt Language
			 *  @name DataTable.defaults.language.url
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "language": {
			 *          "url": "http://www.sprymedia.co.uk/dataTables/lang.txt"
			 *        }
			 *      } );
			 *    } );
			 */
			"sUrl": "",
	
	
			/**
			 * Text shown inside the table records when the is no information to be
			 * displayed after filtering. `emptyTable` is shown when there is simply no
			 * information in the table at all (regardless of filtering).
			 *  @type string
			 *  @default No matching records found
			 *
			 *  @dtopt Language
			 *  @name DataTable.defaults.language.zeroRecords
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "language": {
			 *          "zeroRecords": "No records to display"
			 *        }
			 *      } );
			 *    } );
			 */
			"sZeroRecords": "No matching records found"
		},
	
	
		/**
		 * This parameter allows you to have define the global filtering state at
		 * initialisation time. As an object the `search` parameter must be
		 * defined, but all other parameters are optional. When `regex` is true,
		 * the search string will be treated as a regular expression, when false
		 * (default) it will be treated as a straight string. When `smart`
		 * DataTables will use it's smart filtering methods (to word match at
		 * any point in the data), when false this will not be done.
		 *  @namespace
		 *  @extends DataTable.models.oSearch
		 *
		 *  @dtopt Options
		 *  @name DataTable.defaults.search
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "search": {"search": "Initial search"}
		 *      } );
		 *    } )
		 */
		"oSearch": $.extend( {}, DataTable.models.oSearch ),
	
	
		/**
		 * __Deprecated__ The functionality provided by this parameter has now been
		 * superseded by that provided through `ajax`, which should be used instead.
		 *
		 * By default DataTables will look for the property `data` (or `aaData` for
		 * compatibility with DataTables 1.9-) when obtaining data from an Ajax
		 * source or for server-side processing - this parameter allows that
		 * property to be changed. You can use Javascript dotted object notation to
		 * get a data source for multiple levels of nesting.
		 *  @type string
		 *  @default data
		 *
		 *  @dtopt Options
		 *  @dtopt Server-side
		 *  @name DataTable.defaults.ajaxDataProp
		 *
		 *  @deprecated 1.10. Please use `ajax` for this functionality now.
		 */
		"sAjaxDataProp": "data",
	
	
		/**
		 * __Deprecated__ The functionality provided by this parameter has now been
		 * superseded by that provided through `ajax`, which should be used instead.
		 *
		 * You can instruct DataTables to load data from an external
		 * source using this parameter (use aData if you want to pass data in you
		 * already have). Simply provide a url a JSON object can be obtained from.
		 *  @type string
		 *  @default null
		 *
		 *  @dtopt Options
		 *  @dtopt Server-side
		 *  @name DataTable.defaults.ajaxSource
		 *
		 *  @deprecated 1.10. Please use `ajax` for this functionality now.
		 */
		"sAjaxSource": null,
	
	
		/**
		 * This initialisation variable allows you to specify exactly where in the
		 * DOM you want DataTables to inject the various controls it adds to the page
		 * (for example you might want the pagination controls at the top of the
		 * table). DIV elements (with or without a custom class) can also be added to
		 * aid styling. The follow syntax is used:
		 *   <ul>
		 *     <li>The following options are allowed:
		 *       <ul>
		 *         <li>'l' - Length changing</li>
		 *         <li>'f' - Filtering input</li>
		 *         <li>'t' - The table!</li>
		 *         <li>'i' - Information</li>
		 *         <li>'p' - Pagination</li>
		 *         <li>'r' - pRocessing</li>
		 *       </ul>
		 *     </li>
		 *     <li>The following constants are allowed:
		 *       <ul>
		 *         <li>'H' - jQueryUI theme "header" classes ('fg-toolbar ui-widget-header ui-corner-tl ui-corner-tr ui-helper-clearfix')</li>
		 *         <li>'F' - jQueryUI theme "footer" classes ('fg-toolbar ui-widget-header ui-corner-bl ui-corner-br ui-helper-clearfix')</li>
		 *       </ul>
		 *     </li>
		 *     <li>The following syntax is expected:
		 *       <ul>
		 *         <li>'&lt;' and '&gt;' - div elements</li>
		 *         <li>'&lt;"class" and '&gt;' - div with a class</li>
		 *         <li>'&lt;"#id" and '&gt;' - div with an ID</li>
		 *       </ul>
		 *     </li>
		 *     <li>Examples:
		 *       <ul>
		 *         <li>'&lt;"wrapper"flipt&gt;'</li>
		 *         <li>'&lt;lf&lt;t&gt;ip&gt;'</li>
		 *       </ul>
		 *     </li>
		 *   </ul>
		 *  @type string
		 *  @default lfrtip <i>(when `jQueryUI` is false)</i> <b>or</b>
		 *    <"H"lfr>t<"F"ip> <i>(when `jQueryUI` is true)</i>
		 *
		 *  @dtopt Options
		 *  @name DataTable.defaults.dom
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "dom": '&lt;"top"i&gt;rt&lt;"bottom"flp&gt;&lt;"clear"&gt;'
		 *      } );
		 *    } );
		 */
		"sDom": "lfrtip",
	
	
		/**
		 * Search delay option. This will throttle full table searches that use the
		 * DataTables provided search input element (it does not effect calls to
		 * `dt-api search()`, providing a delay before the search is made.
		 *  @type integer
		 *  @default 0
		 *
		 *  @dtopt Options
		 *  @name DataTable.defaults.searchDelay
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "searchDelay": 200
		 *      } );
		 *    } )
		 */
		"searchDelay": null,
	
	
		/**
		 * DataTables features six different built-in options for the buttons to
		 * display for pagination control:
		 *
		 * * `numbers` - Page number buttons only
		 * * `simple` - 'Previous' and 'Next' buttons only
		 * * 'simple_numbers` - 'Previous' and 'Next' buttons, plus page numbers
		 * * `full` - 'First', 'Previous', 'Next' and 'Last' buttons
		 * * `full_numbers` - 'First', 'Previous', 'Next' and 'Last' buttons, plus page numbers
		 * * `first_last_numbers` - 'First' and 'Last' buttons, plus page numbers
		 *  
		 * Further methods can be added using {@link DataTable.ext.oPagination}.
		 *  @type string
		 *  @default simple_numbers
		 *
		 *  @dtopt Options
		 *  @name DataTable.defaults.pagingType
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "pagingType": "full_numbers"
		 *      } );
		 *    } )
		 */
		"sPaginationType": "simple_numbers",
	
	
		/**
		 * Enable horizontal scrolling. When a table is too wide to fit into a
		 * certain layout, or you have a large number of columns in the table, you
		 * can enable x-scrolling to show the table in a viewport, which can be
		 * scrolled. This property can be `true` which will allow the table to
		 * scroll horizontally when needed, or any CSS unit, or a number (in which
		 * case it will be treated as a pixel measurement). Setting as simply `true`
		 * is recommended.
		 *  @type boolean|string
		 *  @default <i>blank string - i.e. disabled</i>
		 *
		 *  @dtopt Features
		 *  @name DataTable.defaults.scrollX
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "scrollX": true,
		 *        "scrollCollapse": true
		 *      } );
		 *    } );
		 */
		"sScrollX": "",
	
	
		/**
		 * This property can be used to force a DataTable to use more width than it
		 * might otherwise do when x-scrolling is enabled. For example if you have a
		 * table which requires to be well spaced, this parameter is useful for
		 * "over-sizing" the table, and thus forcing scrolling. This property can by
		 * any CSS unit, or a number (in which case it will be treated as a pixel
		 * measurement).
		 *  @type string
		 *  @default <i>blank string - i.e. disabled</i>
		 *
		 *  @dtopt Options
		 *  @name DataTable.defaults.scrollXInner
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "scrollX": "100%",
		 *        "scrollXInner": "110%"
		 *      } );
		 *    } );
		 */
		"sScrollXInner": "",
	
	
		/**
		 * Enable vertical scrolling. Vertical scrolling will constrain the DataTable
		 * to the given height, and enable scrolling for any data which overflows the
		 * current viewport. This can be used as an alternative to paging to display
		 * a lot of data in a small area (although paging and scrolling can both be
		 * enabled at the same time). This property can be any CSS unit, or a number
		 * (in which case it will be treated as a pixel measurement).
		 *  @type string
		 *  @default <i>blank string - i.e. disabled</i>
		 *
		 *  @dtopt Features
		 *  @name DataTable.defaults.scrollY
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "scrollY": "200px",
		 *        "paginate": false
		 *      } );
		 *    } );
		 */
		"sScrollY": "",
	
	
		/**
		 * __Deprecated__ The functionality provided by this parameter has now been
		 * superseded by that provided through `ajax`, which should be used instead.
		 *
		 * Set the HTTP method that is used to make the Ajax call for server-side
		 * processing or Ajax sourced data.
		 *  @type string
		 *  @default GET
		 *
		 *  @dtopt Options
		 *  @dtopt Server-side
		 *  @name DataTable.defaults.serverMethod
		 *
		 *  @deprecated 1.10. Please use `ajax` for this functionality now.
		 */
		"sServerMethod": "GET",
	
	
		/**
		 * DataTables makes use of renderers when displaying HTML elements for
		 * a table. These renderers can be added or modified by plug-ins to
		 * generate suitable mark-up for a site. For example the Bootstrap
		 * integration plug-in for DataTables uses a paging button renderer to
		 * display pagination buttons in the mark-up required by Bootstrap.
		 *
		 * For further information about the renderers available see
		 * DataTable.ext.renderer
		 *  @type string|object
		 *  @default null
		 *
		 *  @name DataTable.defaults.renderer
		 *
		 */
		"renderer": null,
	
	
		/**
		 * Set the data property name that DataTables should use to get a row's id
		 * to set as the `id` property in the node.
		 *  @type string
		 *  @default DT_RowId
		 *
		 *  @name DataTable.defaults.rowId
		 */
		"rowId": "DT_RowId"
	};
	
	_fnHungarianMap( DataTable.defaults );
	
	
	
	/*
	 * Developer note - See note in model.defaults.js about the use of Hungarian
	 * notation and camel case.
	 */
	
	/**
	 * Column options that can be given to DataTables at initialisation time.
	 *  @namespace
	 */
	DataTable.defaults.column = {
		/**
		 * Define which column(s) an order will occur on for this column. This
		 * allows a column's ordering to take multiple columns into account when
		 * doing a sort or use the data from a different column. For example first
		 * name / last name columns make sense to do a multi-column sort over the
		 * two columns.
		 *  @type array|int
		 *  @default null <i>Takes the value of the column index automatically</i>
		 *
		 *  @name DataTable.defaults.column.orderData
		 *  @dtopt Columns
		 *
		 *  @example
		 *    // Using `columnDefs`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columnDefs": [
		 *          { "orderData": [ 0, 1 ], "targets": [ 0 ] },
		 *          { "orderData": [ 1, 0 ], "targets": [ 1 ] },
		 *          { "orderData": 2, "targets": [ 2 ] }
		 *        ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Using `columns`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columns": [
		 *          { "orderData": [ 0, 1 ] },
		 *          { "orderData": [ 1, 0 ] },
		 *          { "orderData": 2 },
		 *          null,
		 *          null
		 *        ]
		 *      } );
		 *    } );
		 */
		"aDataSort": null,
		"iDataSort": -1,
	
	
		/**
		 * You can control the default ordering direction, and even alter the
		 * behaviour of the sort handler (i.e. only allow ascending ordering etc)
		 * using this parameter.
		 *  @type array
		 *  @default [ 'asc', 'desc' ]
		 *
		 *  @name DataTable.defaults.column.orderSequence
		 *  @dtopt Columns
		 *
		 *  @example
		 *    // Using `columnDefs`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columnDefs": [
		 *          { "orderSequence": [ "asc" ], "targets": [ 1 ] },
		 *          { "orderSequence": [ "desc", "asc", "asc" ], "targets": [ 2 ] },
		 *          { "orderSequence": [ "desc" ], "targets": [ 3 ] }
		 *        ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Using `columns`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columns": [
		 *          null,
		 *          { "orderSequence": [ "asc" ] },
		 *          { "orderSequence": [ "desc", "asc", "asc" ] },
		 *          { "orderSequence": [ "desc" ] },
		 *          null
		 *        ]
		 *      } );
		 *    } );
		 */
		"asSorting": [ 'asc', 'desc' ],
	
	
		/**
		 * Enable or disable filtering on the data in this column.
		 *  @type boolean
		 *  @default true
		 *
		 *  @name DataTable.defaults.column.searchable
		 *  @dtopt Columns
		 *
		 *  @example
		 *    // Using `columnDefs`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columnDefs": [
		 *          { "searchable": false, "targets": [ 0 ] }
		 *        ] } );
		 *    } );
		 *
		 *  @example
		 *    // Using `columns`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columns": [
		 *          { "searchable": false },
		 *          null,
		 *          null,
		 *          null,
		 *          null
		 *        ] } );
		 *    } );
		 */
		"bSearchable": true,
	
	
		/**
		 * Enable or disable ordering on this column.
		 *  @type boolean
		 *  @default true
		 *
		 *  @name DataTable.defaults.column.orderable
		 *  @dtopt Columns
		 *
		 *  @example
		 *    // Using `columnDefs`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columnDefs": [
		 *          { "orderable": false, "targets": [ 0 ] }
		 *        ] } );
		 *    } );
		 *
		 *  @example
		 *    // Using `columns`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columns": [
		 *          { "orderable": false },
		 *          null,
		 *          null,
		 *          null,
		 *          null
		 *        ] } );
		 *    } );
		 */
		"bSortable": true,
	
	
		/**
		 * Enable or disable the display of this column.
		 *  @type boolean
		 *  @default true
		 *
		 *  @name DataTable.defaults.column.visible
		 *  @dtopt Columns
		 *
		 *  @example
		 *    // Using `columnDefs`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columnDefs": [
		 *          { "visible": false, "targets": [ 0 ] }
		 *        ] } );
		 *    } );
		 *
		 *  @example
		 *    // Using `columns`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columns": [
		 *          { "visible": false },
		 *          null,
		 *          null,
		 *          null,
		 *          null
		 *        ] } );
		 *    } );
		 */
		"bVisible": true,
	
	
		/**
		 * Developer definable function that is called whenever a cell is created (Ajax source,
		 * etc) or processed for input (DOM source). This can be used as a compliment to mRender
		 * allowing you to modify the DOM element (add background colour for example) when the
		 * element is available.
		 *  @type function
		 *  @param {element} td The TD node that has been created
		 *  @param {*} cellData The Data for the cell
		 *  @param {array|object} rowData The data for the whole row
		 *  @param {int} row The row index for the aoData data store
		 *  @param {int} col The column index for aoColumns
		 *
		 *  @name DataTable.defaults.column.createdCell
		 *  @dtopt Columns
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columnDefs": [ {
		 *          "targets": [3],
		 *          "createdCell": function (td, cellData, rowData, row, col) {
		 *            if ( cellData == "1.7" ) {
		 *              $(td).css('color', 'blue')
		 *            }
		 *          }
		 *        } ]
		 *      });
		 *    } );
		 */
		"fnCreatedCell": null,
	
	
		/**
		 * This parameter has been replaced by `data` in DataTables to ensure naming
		 * consistency. `dataProp` can still be used, as there is backwards
		 * compatibility in DataTables for this option, but it is strongly
		 * recommended that you use `data` in preference to `dataProp`.
		 *  @name DataTable.defaults.column.dataProp
		 */
	
	
		/**
		 * This property can be used to read data from any data source property,
		 * including deeply nested objects / properties. `data` can be given in a
		 * number of different ways which effect its behaviour:
		 *
		 * * `integer` - treated as an array index for the data source. This is the
		 *   default that DataTables uses (incrementally increased for each column).
		 * * `string` - read an object property from the data source. There are
		 *   three 'special' options that can be used in the string to alter how
		 *   DataTables reads the data from the source object:
		 *    * `.` - Dotted Javascript notation. Just as you use a `.` in
		 *      Javascript to read from nested objects, so to can the options
		 *      specified in `data`. For example: `browser.version` or
		 *      `browser.name`. If your object parameter name contains a period, use
		 *      `\\` to escape it - i.e. `first\\.name`.
		 *    * `[]` - Array notation. DataTables can automatically combine data
		 *      from and array source, joining the data with the characters provided
		 *      between the two brackets. For example: `name[, ]` would provide a
		 *      comma-space separated list from the source array. If no characters
		 *      are provided between the brackets, the original array source is
		 *      returned.
		 *    * `()` - Function notation. Adding `()` to the end of a parameter will
		 *      execute a function of the name given. For example: `browser()` for a
		 *      simple function on the data source, `browser.version()` for a
		 *      function in a nested property or even `browser().version` to get an
		 *      object property if the function called returns an object. Note that
		 *      function notation is recommended for use in `render` rather than
		 *      `data` as it is much simpler to use as a renderer.
		 * * `null` - use the original data source for the row rather than plucking
		 *   data directly from it. This action has effects on two other
		 *   initialisation options:
		 *    * `defaultContent` - When null is given as the `data` option and
		 *      `defaultContent` is specified for the column, the value defined by
		 *      `defaultContent` will be used for the cell.
		 *    * `render` - When null is used for the `data` option and the `render`
		 *      option is specified for the column, the whole data source for the
		 *      row is used for the renderer.
		 * * `function` - the function given will be executed whenever DataTables
		 *   needs to set or get the data for a cell in the column. The function
		 *   takes three parameters:
		 *    * Parameters:
		 *      * `{array|object}` The data source for the row
		 *      * `{string}` The type call data requested - this will be 'set' when
		 *        setting data or 'filter', 'display', 'type', 'sort' or undefined
		 *        when gathering data. Note that when `undefined` is given for the
		 *        type DataTables expects to get the raw data for the object back<
		 *      * `{*}` Data to set when the second parameter is 'set'.
		 *    * Return:
		 *      * The return value from the function is not required when 'set' is
		 *        the type of call, but otherwise the return is what will be used
		 *        for the data requested.
		 *
		 * Note that `data` is a getter and setter option. If you just require
		 * formatting of data for output, you will likely want to use `render` which
		 * is simply a getter and thus simpler to use.
		 *
		 * Note that prior to DataTables 1.9.2 `data` was called `mDataProp`. The
		 * name change reflects the flexibility of this property and is consistent
		 * with the naming of mRender. If 'mDataProp' is given, then it will still
		 * be used by DataTables, as it automatically maps the old name to the new
		 * if required.
		 *
		 *  @type string|int|function|null
		 *  @default null <i>Use automatically calculated column index</i>
		 *
		 *  @name DataTable.defaults.column.data
		 *  @dtopt Columns
		 *
		 *  @example
		 *    // Read table data from objects
		 *    // JSON structure for each row:
		 *    //   {
		 *    //      "engine": {value},
		 *    //      "browser": {value},
		 *    //      "platform": {value},
		 *    //      "version": {value},
		 *    //      "grade": {value}
		 *    //   }
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "ajaxSource": "sources/objects.txt",
		 *        "columns": [
		 *          { "data": "engine" },
		 *          { "data": "browser" },
		 *          { "data": "platform" },
		 *          { "data": "version" },
		 *          { "data": "grade" }
		 *        ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Read information from deeply nested objects
		 *    // JSON structure for each row:
		 *    //   {
		 *    //      "engine": {value},
		 *    //      "browser": {value},
		 *    //      "platform": {
		 *    //         "inner": {value}
		 *    //      },
		 *    //      "details": [
		 *    //         {value}, {value}
		 *    //      ]
		 *    //   }
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "ajaxSource": "sources/deep.txt",
		 *        "columns": [
		 *          { "data": "engine" },
		 *          { "data": "browser" },
		 *          { "data": "platform.inner" },
		 *          { "data": "details.0" },
		 *          { "data": "details.1" }
		 *        ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Using `data` as a function to provide different information for
		 *    // sorting, filtering and display. In this case, currency (price)
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columnDefs": [ {
		 *          "targets": [ 0 ],
		 *          "data": function ( source, type, val ) {
		 *            if (type === 'set') {
		 *              source.price = val;
		 *              // Store the computed dislay and filter values for efficiency
		 *              source.price_display = val=="" ? "" : "$"+numberFormat(val);
		 *              source.price_filter  = val=="" ? "" : "$"+numberFormat(val)+" "+val;
		 *              return;
		 *            }
		 *            else if (type === 'display') {
		 *              return source.price_display;
		 *            }
		 *            else if (type === 'filter') {
		 *              return source.price_filter;
		 *            }
		 *            // 'sort', 'type' and undefined all just use the integer
		 *            return source.price;
		 *          }
		 *        } ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Using default content
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columnDefs": [ {
		 *          "targets": [ 0 ],
		 *          "data": null,
		 *          "defaultContent": "Click to edit"
		 *        } ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Using array notation - outputting a list from an array
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columnDefs": [ {
		 *          "targets": [ 0 ],
		 *          "data": "name[, ]"
		 *        } ]
		 *      } );
		 *    } );
		 *
		 */
		"mData": null,
	
	
		/**
		 * This property is the rendering partner to `data` and it is suggested that
		 * when you want to manipulate data for display (including filtering,
		 * sorting etc) without altering the underlying data for the table, use this
		 * property. `render` can be considered to be the the read only companion to
		 * `data` which is read / write (then as such more complex). Like `data`
		 * this option can be given in a number of different ways to effect its
		 * behaviour:
		 *
		 * * `integer` - treated as an array index for the data source. This is the
		 *   default that DataTables uses (incrementally increased for each column).
		 * * `string` - read an object property from the data source. There are
		 *   three 'special' options that can be used in the string to alter how
		 *   DataTables reads the data from the source object:
		 *    * `.` - Dotted Javascript notation. Just as you use a `.` in
		 *      Javascript to read from nested objects, so to can the options
		 *      specified in `data`. For example: `browser.version` or
		 *      `browser.name`. If your object parameter name contains a period, use
		 *      `\\` to escape it - i.e. `first\\.name`.
		 *    * `[]` - Array notation. DataTables can automatically combine data
		 *      from and array source, joining the data with the characters provided
		 *      between the two brackets. For example: `name[, ]` would provide a
		 *      comma-space separated list from the source array. If no characters
		 *      are provided between the brackets, the original array source is
		 *      returned.
		 *    * `()` - Function notation. Adding `()` to the end of a parameter will
		 *      execute a function of the name given. For example: `browser()` for a
		 *      simple function on the data source, `browser.version()` for a
		 *      function in a nested property or even `browser().version` to get an
		 *      object property if the function called returns an object.
		 * * `object` - use different data for the different data types requested by
		 *   DataTables ('filter', 'display', 'type' or 'sort'). The property names
		 *   of the object is the data type the property refers to and the value can
		 *   defined using an integer, string or function using the same rules as
		 *   `render` normally does. Note that an `_` option _must_ be specified.
		 *   This is the default value to use if you haven't specified a value for
		 *   the data type requested by DataTables.
		 * * `function` - the function given will be executed whenever DataTables
		 *   needs to set or get the data for a cell in the column. The function
		 *   takes three parameters:
		 *    * Parameters:
		 *      * {array|object} The data source for the row (based on `data`)
		 *      * {string} The type call data requested - this will be 'filter',
		 *        'display', 'type' or 'sort'.
		 *      * {array|object} The full data source for the row (not based on
		 *        `data`)
		 *    * Return:
		 *      * The return value from the function is what will be used for the
		 *        data requested.
		 *
		 *  @type string|int|function|object|null
		 *  @default null Use the data source value.
		 *
		 *  @name DataTable.defaults.column.render
		 *  @dtopt Columns
		 *
		 *  @example
		 *    // Create a comma separated list from an array of objects
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "ajaxSource": "sources/deep.txt",
		 *        "columns": [
		 *          { "data": "engine" },
		 *          { "data": "browser" },
		 *          {
		 *            "data": "platform",
		 *            "render": "[, ].name"
		 *          }
		 *        ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Execute a function to obtain data
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columnDefs": [ {
		 *          "targets": [ 0 ],
		 *          "data": null, // Use the full data source object for the renderer's source
		 *          "render": "browserName()"
		 *        } ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // As an object, extracting different data for the different types
		 *    // This would be used with a data source such as:
		 *    //   { "phone": 5552368, "phone_filter": "5552368 555-2368", "phone_display": "555-2368" }
		 *    // Here the `phone` integer is used for sorting and type detection, while `phone_filter`
		 *    // (which has both forms) is used for filtering for if a user inputs either format, while
		 *    // the formatted phone number is the one that is shown in the table.
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columnDefs": [ {
		 *          "targets": [ 0 ],
		 *          "data": null, // Use the full data source object for the renderer's source
		 *          "render": {
		 *            "_": "phone",
		 *            "filter": "phone_filter",
		 *            "display": "phone_display"
		 *          }
		 *        } ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Use as a function to create a link from the data source
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columnDefs": [ {
		 *          "targets": [ 0 ],
		 *          "data": "download_link",
		 *          "render": function ( data, type, full ) {
		 *            return '<a href="'+data+'">Download</a>';
		 *          }
		 *        } ]
		 *      } );
		 *    } );
		 */
		"mRender": null,
	
	
		/**
		 * Change the cell type created for the column - either TD cells or TH cells. This
		 * can be useful as TH cells have semantic meaning in the table body, allowing them
		 * to act as a header for a row (you may wish to add scope='row' to the TH elements).
		 *  @type string
		 *  @default td
		 *
		 *  @name DataTable.defaults.column.cellType
		 *  @dtopt Columns
		 *
		 *  @example
		 *    // Make the first column use TH cells
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columnDefs": [ {
		 *          "targets": [ 0 ],
		 *          "cellType": "th"
		 *        } ]
		 *      } );
		 *    } );
		 */
		"sCellType": "td",
	
	
		/**
		 * Class to give to each cell in this column.
		 *  @type string
		 *  @default <i>Empty string</i>
		 *
		 *  @name DataTable.defaults.column.class
		 *  @dtopt Columns
		 *
		 *  @example
		 *    // Using `columnDefs`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columnDefs": [
		 *          { "class": "my_class", "targets": [ 0 ] }
		 *        ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Using `columns`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columns": [
		 *          { "class": "my_class" },
		 *          null,
		 *          null,
		 *          null,
		 *          null
		 *        ]
		 *      } );
		 *    } );
		 */
		"sClass": "",
	
		/**
		 * When DataTables calculates the column widths to assign to each column,
		 * it finds the longest string in each column and then constructs a
		 * temporary table and reads the widths from that. The problem with this
		 * is that "mmm" is much wider then "iiii", but the latter is a longer
		 * string - thus the calculation can go wrong (doing it properly and putting
		 * it into an DOM object and measuring that is horribly(!) slow). Thus as
		 * a "work around" we provide this option. It will append its value to the
		 * text that is found to be the longest string for the column - i.e. padding.
		 * Generally you shouldn't need this!
		 *  @type string
		 *  @default <i>Empty string<i>
		 *
		 *  @name DataTable.defaults.column.contentPadding
		 *  @dtopt Columns
		 *
		 *  @example
		 *    // Using `columns`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columns": [
		 *          null,
		 *          null,
		 *          null,
		 *          {
		 *            "contentPadding": "mmm"
		 *          }
		 *        ]
		 *      } );
		 *    } );
		 */
		"sContentPadding": "",
	
	
		/**
		 * Allows a default value to be given for a column's data, and will be used
		 * whenever a null data source is encountered (this can be because `data`
		 * is set to null, or because the data source itself is null).
		 *  @type string
		 *  @default null
		 *
		 *  @name DataTable.defaults.column.defaultContent
		 *  @dtopt Columns
		 *
		 *  @example
		 *    // Using `columnDefs`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columnDefs": [
		 *          {
		 *            "data": null,
		 *            "defaultContent": "Edit",
		 *            "targets": [ -1 ]
		 *          }
		 *        ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Using `columns`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columns": [
		 *          null,
		 *          null,
		 *          null,
		 *          {
		 *            "data": null,
		 *            "defaultContent": "Edit"
		 *          }
		 *        ]
		 *      } );
		 *    } );
		 */
		"sDefaultContent": null,
	
	
		/**
		 * This parameter is only used in DataTables' server-side processing. It can
		 * be exceptionally useful to know what columns are being displayed on the
		 * client side, and to map these to database fields. When defined, the names
		 * also allow DataTables to reorder information from the server if it comes
		 * back in an unexpected order (i.e. if you switch your columns around on the
		 * client-side, your server-side code does not also need updating).
		 *  @type string
		 *  @default <i>Empty string</i>
		 *
		 *  @name DataTable.defaults.column.name
		 *  @dtopt Columns
		 *
		 *  @example
		 *    // Using `columnDefs`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columnDefs": [
		 *          { "name": "engine", "targets": [ 0 ] },
		 *          { "name": "browser", "targets": [ 1 ] },
		 *          { "name": "platform", "targets": [ 2 ] },
		 *          { "name": "version", "targets": [ 3 ] },
		 *          { "name": "grade", "targets": [ 4 ] }
		 *        ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Using `columns`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columns": [
		 *          { "name": "engine" },
		 *          { "name": "browser" },
		 *          { "name": "platform" },
		 *          { "name": "version" },
		 *          { "name": "grade" }
		 *        ]
		 *      } );
		 *    } );
		 */
		"sName": "",
	
	
		/**
		 * Defines a data source type for the ordering which can be used to read
		 * real-time information from the table (updating the internally cached
		 * version) prior to ordering. This allows ordering to occur on user
		 * editable elements such as form inputs.
		 *  @type string
		 *  @default std
		 *
		 *  @name DataTable.defaults.column.orderDataType
		 *  @dtopt Columns
		 *
		 *  @example
		 *    // Using `columnDefs`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columnDefs": [
		 *          { "orderDataType": "dom-text", "targets": [ 2, 3 ] },
		 *          { "type": "numeric", "targets": [ 3 ] },
		 *          { "orderDataType": "dom-select", "targets": [ 4 ] },
		 *          { "orderDataType": "dom-checkbox", "targets": [ 5 ] }
		 *        ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Using `columns`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columns": [
		 *          null,
		 *          null,
		 *          { "orderDataType": "dom-text" },
		 *          { "orderDataType": "dom-text", "type": "numeric" },
		 *          { "orderDataType": "dom-select" },
		 *          { "orderDataType": "dom-checkbox" }
		 *        ]
		 *      } );
		 *    } );
		 */
		"sSortDataType": "std",
	
	
		/**
		 * The title of this column.
		 *  @type string
		 *  @default null <i>Derived from the 'TH' value for this column in the
		 *    original HTML table.</i>
		 *
		 *  @name DataTable.defaults.column.title
		 *  @dtopt Columns
		 *
		 *  @example
		 *    // Using `columnDefs`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columnDefs": [
		 *          { "title": "My column title", "targets": [ 0 ] }
		 *        ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Using `columns`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columns": [
		 *          { "title": "My column title" },
		 *          null,
		 *          null,
		 *          null,
		 *          null
		 *        ]
		 *      } );
		 *    } );
		 */
		"sTitle": null,
	
	
		/**
		 * The type allows you to specify how the data for this column will be
		 * ordered. Four types (string, numeric, date and html (which will strip
		 * HTML tags before ordering)) are currently available. Note that only date
		 * formats understood by Javascript's Date() object will be accepted as type
		 * date. For example: "Mar 26, 2008 5:03 PM". May take the values: 'string',
		 * 'numeric', 'date' or 'html' (by default). Further types can be adding
		 * through plug-ins.
		 *  @type string
		 *  @default null <i>Auto-detected from raw data</i>
		 *
		 *  @name DataTable.defaults.column.type
		 *  @dtopt Columns
		 *
		 *  @example
		 *    // Using `columnDefs`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columnDefs": [
		 *          { "type": "html", "targets": [ 0 ] }
		 *        ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Using `columns`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columns": [
		 *          { "type": "html" },
		 *          null,
		 *          null,
		 *          null,
		 *          null
		 *        ]
		 *      } );
		 *    } );
		 */
		"sType": null,
	
	
		/**
		 * Defining the width of the column, this parameter may take any CSS value
		 * (3em, 20px etc). DataTables applies 'smart' widths to columns which have not
		 * been given a specific width through this interface ensuring that the table
		 * remains readable.
		 *  @type string
		 *  @default null <i>Automatic</i>
		 *
		 *  @name DataTable.defaults.column.width
		 *  @dtopt Columns
		 *
		 *  @example
		 *    // Using `columnDefs`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columnDefs": [
		 *          { "width": "20%", "targets": [ 0 ] }
		 *        ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Using `columns`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columns": [
		 *          { "width": "20%" },
		 *          null,
		 *          null,
		 *          null,
		 *          null
		 *        ]
		 *      } );
		 *    } );
		 */
		"sWidth": null
	};
	
	_fnHungarianMap( DataTable.defaults.column );
	
	
	
	/**
	 * DataTables settings object - this holds all the information needed for a
	 * given table, including configuration, data and current application of the
	 * table options. DataTables does not have a single instance for each DataTable
	 * with the settings attached to that instance, but rather instances of the
	 * DataTable "class" are created on-the-fly as needed (typically by a
	 * $().dataTable() call) and the settings object is then applied to that
	 * instance.
	 *
	 * Note that this object is related to {@link DataTable.defaults} but this
	 * one is the internal data store for DataTables's cache of columns. It should
	 * NOT be manipulated outside of DataTables. Any configuration should be done
	 * through the initialisation options.
	 *  @namespace
	 *  @todo Really should attach the settings object to individual instances so we
	 *    don't need to create new instances on each $().dataTable() call (if the
	 *    table already exists). It would also save passing oSettings around and
	 *    into every single function. However, this is a very significant
	 *    architecture change for DataTables and will almost certainly break
	 *    backwards compatibility with older installations. This is something that
	 *    will be done in 2.0.
	 */
	DataTable.models.oSettings = {
		/**
		 * Primary features of DataTables and their enablement state.
		 *  @namespace
		 */
		"oFeatures": {
	
			/**
			 * Flag to say if DataTables should automatically try to calculate the
			 * optimum table and columns widths (true) or not (false).
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bAutoWidth": null,
	
			/**
			 * Delay the creation of TR and TD elements until they are actually
			 * needed by a driven page draw. This can give a significant speed
			 * increase for Ajax source and Javascript source data, but makes no
			 * difference at all fro DOM and server-side processing tables.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bDeferRender": null,
	
			/**
			 * Enable filtering on the table or not. Note that if this is disabled
			 * then there is no filtering at all on the table, including fnFilter.
			 * To just remove the filtering input use sDom and remove the 'f' option.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bFilter": null,
	
			/**
			 * Table information element (the 'Showing x of y records' div) enable
			 * flag.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bInfo": null,
	
			/**
			 * Present a user control allowing the end user to change the page size
			 * when pagination is enabled.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bLengthChange": null,
	
			/**
			 * Pagination enabled or not. Note that if this is disabled then length
			 * changing must also be disabled.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bPaginate": null,
	
			/**
			 * Processing indicator enable flag whenever DataTables is enacting a
			 * user request - typically an Ajax request for server-side processing.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bProcessing": null,
	
			/**
			 * Server-side processing enabled flag - when enabled DataTables will
			 * get all data from the server for every draw - there is no filtering,
			 * sorting or paging done on the client-side.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bServerSide": null,
	
			/**
			 * Sorting enablement flag.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bSort": null,
	
			/**
			 * Multi-column sorting
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bSortMulti": null,
	
			/**
			 * Apply a class to the columns which are being sorted to provide a
			 * visual highlight or not. This can slow things down when enabled since
			 * there is a lot of DOM interaction.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bSortClasses": null,
	
			/**
			 * State saving enablement flag.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bStateSave": null
		},
	
	
		/**
		 * Scrolling settings for a table.
		 *  @namespace
		 */
		"oScroll": {
			/**
			 * When the table is shorter in height than sScrollY, collapse the
			 * table container down to the height of the table (when true).
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bCollapse": null,
	
			/**
			 * Width of the scrollbar for the web-browser's platform. Calculated
			 * during table initialisation.
			 *  @type int
			 *  @default 0
			 */
			"iBarWidth": 0,
	
			/**
			 * Viewport width for horizontal scrolling. Horizontal scrolling is
			 * disabled if an empty string.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type string
			 */
			"sX": null,
	
			/**
			 * Width to expand the table to when using x-scrolling. Typically you
			 * should not need to use this.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type string
			 *  @deprecated
			 */
			"sXInner": null,
	
			/**
			 * Viewport height for vertical scrolling. Vertical scrolling is disabled
			 * if an empty string.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type string
			 */
			"sY": null
		},
	
		/**
		 * Language information for the table.
		 *  @namespace
		 *  @extends DataTable.defaults.oLanguage
		 */
		"oLanguage": {
			/**
			 * Information callback function. See
			 * {@link DataTable.defaults.fnInfoCallback}
			 *  @type function
			 *  @default null
			 */
			"fnInfoCallback": null
		},
	
		/**
		 * Browser support parameters
		 *  @namespace
		 */
		"oBrowser": {
			/**
			 * Indicate if the browser incorrectly calculates width:100% inside a
			 * scrolling element (IE6/7)
			 *  @type boolean
			 *  @default false
			 */
			"bScrollOversize": false,
	
			/**
			 * Determine if the vertical scrollbar is on the right or left of the
			 * scrolling container - needed for rtl language layout, although not
			 * all browsers move the scrollbar (Safari).
			 *  @type boolean
			 *  @default false
			 */
			"bScrollbarLeft": false,
	
			/**
			 * Flag for if `getBoundingClientRect` is fully supported or not
			 *  @type boolean
			 *  @default false
			 */
			"bBounding": false,
	
			/**
			 * Browser scrollbar width
			 *  @type integer
			 *  @default 0
			 */
			"barWidth": 0
		},
	
	
		"ajax": null,
	
	
		/**
		 * Array referencing the nodes which are used for the features. The
		 * parameters of this object match what is allowed by sDom - i.e.
		 *   <ul>
		 *     <li>'l' - Length changing</li>
		 *     <li>'f' - Filtering input</li>
		 *     <li>'t' - The table!</li>
		 *     <li>'i' - Information</li>
		 *     <li>'p' - Pagination</li>
		 *     <li>'r' - pRocessing</li>
		 *   </ul>
		 *  @type array
		 *  @default []
		 */
		"aanFeatures": [],
	
		/**
		 * Store data information - see {@link DataTable.models.oRow} for detailed
		 * information.
		 *  @type array
		 *  @default []
		 */
		"aoData": [],
	
		/**
		 * Array of indexes which are in the current display (after filtering etc)
		 *  @type array
		 *  @default []
		 */
		"aiDisplay": [],
	
		/**
		 * Array of indexes for display - no filtering
		 *  @type array
		 *  @default []
		 */
		"aiDisplayMaster": [],
	
		/**
		 * Map of row ids to data indexes
		 *  @type object
		 *  @default {}
		 */
		"aIds": {},
	
		/**
		 * Store information about each column that is in use
		 *  @type array
		 *  @default []
		 */
		"aoColumns": [],
	
		/**
		 * Store information about the table's header
		 *  @type array
		 *  @default []
		 */
		"aoHeader": [],
	
		/**
		 * Store information about the table's footer
		 *  @type array
		 *  @default []
		 */
		"aoFooter": [],
	
		/**
		 * Store the applied global search information in case we want to force a
		 * research or compare the old search to a new one.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @namespace
		 *  @extends DataTable.models.oSearch
		 */
		"oPreviousSearch": {},
	
		/**
		 * Store the applied search for each column - see
		 * {@link DataTable.models.oSearch} for the format that is used for the
		 * filtering information for each column.
		 *  @type array
		 *  @default []
		 */
		"aoPreSearchCols": [],
	
		/**
		 * Sorting that is applied to the table. Note that the inner arrays are
		 * used in the following manner:
		 * <ul>
		 *   <li>Index 0 - column number</li>
		 *   <li>Index 1 - current sorting direction</li>
		 * </ul>
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type array
		 *  @todo These inner arrays should really be objects
		 */
		"aaSorting": null,
	
		/**
		 * Sorting that is always applied to the table (i.e. prefixed in front of
		 * aaSorting).
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type array
		 *  @default []
		 */
		"aaSortingFixed": [],
	
		/**
		 * Classes to use for the striping of a table.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type array
		 *  @default []
		 */
		"asStripeClasses": null,
	
		/**
		 * If restoring a table - we should restore its striping classes as well
		 *  @type array
		 *  @default []
		 */
		"asDestroyStripes": [],
	
		/**
		 * If restoring a table - we should restore its width
		 *  @type int
		 *  @default 0
		 */
		"sDestroyWidth": 0,
	
		/**
		 * Callback functions array for every time a row is inserted (i.e. on a draw).
		 *  @type array
		 *  @default []
		 */
		"aoRowCallback": [],
	
		/**
		 * Callback functions for the header on each draw.
		 *  @type array
		 *  @default []
		 */
		"aoHeaderCallback": [],
	
		/**
		 * Callback function for the footer on each draw.
		 *  @type array
		 *  @default []
		 */
		"aoFooterCallback": [],
	
		/**
		 * Array of callback functions for draw callback functions
		 *  @type array
		 *  @default []
		 */
		"aoDrawCallback": [],
	
		/**
		 * Array of callback functions for row created function
		 *  @type array
		 *  @default []
		 */
		"aoRowCreatedCallback": [],
	
		/**
		 * Callback functions for just before the table is redrawn. A return of
		 * false will be used to cancel the draw.
		 *  @type array
		 *  @default []
		 */
		"aoPreDrawCallback": [],
	
		/**
		 * Callback functions for when the table has been initialised.
		 *  @type array
		 *  @default []
		 */
		"aoInitComplete": [],
	
	
		/**
		 * Callbacks for modifying the settings to be stored for state saving, prior to
		 * saving state.
		 *  @type array
		 *  @default []
		 */
		"aoStateSaveParams": [],
	
		/**
		 * Callbacks for modifying the settings that have been stored for state saving
		 * prior to using the stored values to restore the state.
		 *  @type array
		 *  @default []
		 */
		"aoStateLoadParams": [],
	
		/**
		 * Callbacks for operating on the settings object once the saved state has been
		 * loaded
		 *  @type array
		 *  @default []
		 */
		"aoStateLoaded": [],
	
		/**
		 * Cache the table ID for quick access
		 *  @type string
		 *  @default <i>Empty string</i>
		 */
		"sTableId": "",
	
		/**
		 * The TABLE node for the main table
		 *  @type node
		 *  @default null
		 */
		"nTable": null,
	
		/**
		 * Permanent ref to the thead element
		 *  @type node
		 *  @default null
		 */
		"nTHead": null,
	
		/**
		 * Permanent ref to the tfoot element - if it exists
		 *  @type node
		 *  @default null
		 */
		"nTFoot": null,
	
		/**
		 * Permanent ref to the tbody element
		 *  @type node
		 *  @default null
		 */
		"nTBody": null,
	
		/**
		 * Cache the wrapper node (contains all DataTables controlled elements)
		 *  @type node
		 *  @default null
		 */
		"nTableWrapper": null,
	
		/**
		 * Indicate if when using server-side processing the loading of data
		 * should be deferred until the second draw.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type boolean
		 *  @default false
		 */
		"bDeferLoading": false,
	
		/**
		 * Indicate if all required information has been read in
		 *  @type boolean
		 *  @default false
		 */
		"bInitialised": false,
	
		/**
		 * Information about open rows. Each object in the array has the parameters
		 * 'nTr' and 'nParent'
		 *  @type array
		 *  @default []
		 */
		"aoOpenRows": [],
	
		/**
		 * Dictate the positioning of DataTables' control elements - see
		 * {@link DataTable.model.oInit.sDom}.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type string
		 *  @default null
		 */
		"sDom": null,
	
		/**
		 * Search delay (in mS)
		 *  @type integer
		 *  @default null
		 */
		"searchDelay": null,
	
		/**
		 * Which type of pagination should be used.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type string
		 *  @default two_button
		 */
		"sPaginationType": "two_button",
	
		/**
		 * The state duration (for `stateSave`) in seconds.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type int
		 *  @default 0
		 */
		"iStateDuration": 0,
	
		/**
		 * Array of callback functions for state saving. Each array element is an
		 * object with the following parameters:
		 *   <ul>
		 *     <li>function:fn - function to call. Takes two parameters, oSettings
		 *       and the JSON string to save that has been thus far created. Returns
		 *       a JSON string to be inserted into a json object
		 *       (i.e. '"param": [ 0, 1, 2]')</li>
		 *     <li>string:sName - name of callback</li>
		 *   </ul>
		 *  @type array
		 *  @default []
		 */
		"aoStateSave": [],
	
		/**
		 * Array of callback functions for state loading. Each array element is an
		 * object with the following parameters:
		 *   <ul>
		 *     <li>function:fn - function to call. Takes two parameters, oSettings
		 *       and the object stored. May return false to cancel state loading</li>
		 *     <li>string:sName - name of callback</li>
		 *   </ul>
		 *  @type array
		 *  @default []
		 */
		"aoStateLoad": [],
	
		/**
		 * State that was saved. Useful for back reference
		 *  @type object
		 *  @default null
		 */
		"oSavedState": null,
	
		/**
		 * State that was loaded. Useful for back reference
		 *  @type object
		 *  @default null
		 */
		"oLoadedState": null,
	
		/**
		 * Source url for AJAX data for the table.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type string
		 *  @default null
		 */
		"sAjaxSource": null,
	
		/**
		 * Property from a given object from which to read the table data from. This
		 * can be an empty string (when not server-side processing), in which case
		 * it is  assumed an an array is given directly.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type string
		 */
		"sAjaxDataProp": null,
	
		/**
		 * Note if draw should be blocked while getting data
		 *  @type boolean
		 *  @default true
		 */
		"bAjaxDataGet": true,
	
		/**
		 * The last jQuery XHR object that was used for server-side data gathering.
		 * This can be used for working with the XHR information in one of the
		 * callbacks
		 *  @type object
		 *  @default null
		 */
		"jqXHR": null,
	
		/**
		 * JSON returned from the server in the last Ajax request
		 *  @type object
		 *  @default undefined
		 */
		"json": undefined,
	
		/**
		 * Data submitted as part of the last Ajax request
		 *  @type object
		 *  @default undefined
		 */
		"oAjaxData": undefined,
	
		/**
		 * Function to get the server-side data.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type function
		 */
		"fnServerData": null,
	
		/**
		 * Functions which are called prior to sending an Ajax request so extra
		 * parameters can easily be sent to the server
		 *  @type array
		 *  @default []
		 */
		"aoServerParams": [],
	
		/**
		 * Send the XHR HTTP method - GET or POST (could be PUT or DELETE if
		 * required).
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type string
		 */
		"sServerMethod": null,
	
		/**
		 * Format numbers for display.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type function
		 */
		"fnFormatNumber": null,
	
		/**
		 * List of options that can be used for the user selectable length menu.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type array
		 *  @default []
		 */
		"aLengthMenu": null,
	
		/**
		 * Counter for the draws that the table does. Also used as a tracker for
		 * server-side processing
		 *  @type int
		 *  @default 0
		 */
		"iDraw": 0,
	
		/**
		 * Indicate if a redraw is being done - useful for Ajax
		 *  @type boolean
		 *  @default false
		 */
		"bDrawing": false,
	
		/**
		 * Draw index (iDraw) of the last error when parsing the returned data
		 *  @type int
		 *  @default -1
		 */
		"iDrawError": -1,
	
		/**
		 * Paging display length
		 *  @type int
		 *  @default 10
		 */
		"_iDisplayLength": 10,
	
		/**
		 * Paging start point - aiDisplay index
		 *  @type int
		 *  @default 0
		 */
		"_iDisplayStart": 0,
	
		/**
		 * Server-side processing - number of records in the result set
		 * (i.e. before filtering), Use fnRecordsTotal rather than
		 * this property to get the value of the number of records, regardless of
		 * the server-side processing setting.
		 *  @type int
		 *  @default 0
		 *  @private
		 */
		"_iRecordsTotal": 0,
	
		/**
		 * Server-side processing - number of records in the current display set
		 * (i.e. after filtering). Use fnRecordsDisplay rather than
		 * this property to get the value of the number of records, regardless of
		 * the server-side processing setting.
		 *  @type boolean
		 *  @default 0
		 *  @private
		 */
		"_iRecordsDisplay": 0,
	
		/**
		 * The classes to use for the table
		 *  @type object
		 *  @default {}
		 */
		"oClasses": {},
	
		/**
		 * Flag attached to the settings object so you can check in the draw
		 * callback if filtering has been done in the draw. Deprecated in favour of
		 * events.
		 *  @type boolean
		 *  @default false
		 *  @deprecated
		 */
		"bFiltered": false,
	
		/**
		 * Flag attached to the settings object so you can check in the draw
		 * callback if sorting has been done in the draw. Deprecated in favour of
		 * events.
		 *  @type boolean
		 *  @default false
		 *  @deprecated
		 */
		"bSorted": false,
	
		/**
		 * Indicate that if multiple rows are in the header and there is more than
		 * one unique cell per column, if the top one (true) or bottom one (false)
		 * should be used for sorting / title by DataTables.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type boolean
		 */
		"bSortCellsTop": null,
	
		/**
		 * Initialisation object that is used for the table
		 *  @type object
		 *  @default null
		 */
		"oInit": null,
	
		/**
		 * Destroy callback functions - for plug-ins to attach themselves to the
		 * destroy so they can clean up markup and events.
		 *  @type array
		 *  @default []
		 */
		"aoDestroyCallback": [],
	
	
		/**
		 * Get the number of records in the current record set, before filtering
		 *  @type function
		 */
		"fnRecordsTotal": function ()
		{
			return _fnDataSource( this ) == 'ssp' ?
				this._iRecordsTotal * 1 :
				this.aiDisplayMaster.length;
		},
	
		/**
		 * Get the number of records in the current record set, after filtering
		 *  @type function
		 */
		"fnRecordsDisplay": function ()
		{
			return _fnDataSource( this ) == 'ssp' ?
				this._iRecordsDisplay * 1 :
				this.aiDisplay.length;
		},
	
		/**
		 * Get the display end point - aiDisplay index
		 *  @type function
		 */
		"fnDisplayEnd": function ()
		{
			var
				len      = this._iDisplayLength,
				start    = this._iDisplayStart,
				calc     = start + len,
				records  = this.aiDisplay.length,
				features = this.oFeatures,
				paginate = features.bPaginate;
	
			if ( features.bServerSide ) {
				return paginate === false || len === -1 ?
					start + records :
					Math.min( start+len, this._iRecordsDisplay );
			}
			else {
				return ! paginate || calc>records || len===-1 ?
					records :
					calc;
			}
		},
	
		/**
		 * The DataTables object for this table
		 *  @type object
		 *  @default null
		 */
		"oInstance": null,
	
		/**
		 * Unique identifier for each instance of the DataTables object. If there
		 * is an ID on the table node, then it takes that value, otherwise an
		 * incrementing internal counter is used.
		 *  @type string
		 *  @default null
		 */
		"sInstance": null,
	
		/**
		 * tabindex attribute value that is added to DataTables control elements, allowing
		 * keyboard navigation of the table and its controls.
		 */
		"iTabIndex": 0,
	
		/**
		 * DIV container for the footer scrolling table if scrolling
		 */
		"nScrollHead": null,
	
		/**
		 * DIV container for the footer scrolling table if scrolling
		 */
		"nScrollFoot": null,
	
		/**
		 * Last applied sort
		 *  @type array
		 *  @default []
		 */
		"aLastSort": [],
	
		/**
		 * Stored plug-in instances
		 *  @type object
		 *  @default {}
		 */
		"oPlugins": {},
	
		/**
		 * Function used to get a row's id from the row's data
		 *  @type function
		 *  @default null
		 */
		"rowIdFn": null,
	
		/**
		 * Data location where to store a row's id
		 *  @type string
		 *  @default null
		 */
		"rowId": null
	};

	/**
	 * Extension object for DataTables that is used to provide all extension
	 * options.
	 *
	 * Note that the `DataTable.ext` object is available through
	 * `jQuery.fn.dataTable.ext` where it may be accessed and manipulated. It is
	 * also aliased to `jQuery.fn.dataTableExt` for historic reasons.
	 *  @namespace
	 *  @extends DataTable.models.ext
	 */
	
	
	/**
	 * DataTables extensions
	 * 
	 * This namespace acts as a collection area for plug-ins that can be used to
	 * extend DataTables capabilities. Indeed many of the build in methods
	 * use this method to provide their own capabilities (sorting methods for
	 * example).
	 *
	 * Note that this namespace is aliased to `jQuery.fn.dataTableExt` for legacy
	 * reasons
	 *
	 *  @namespace
	 */
	DataTable.ext = _ext = {
		/**
		 * Buttons. For use with the Buttons extension for DataTables. This is
		 * defined here so other extensions can define buttons regardless of load
		 * order. It is _not_ used by DataTables core.
		 *
		 *  @type object
		 *  @default {}
		 */
		buttons: {},
	
	
		/**
		 * Element class names
		 *
		 *  @type object
		 *  @default {}
		 */
		classes: {},
	
	
		/**
		 * DataTables build type (expanded by the download builder)
		 *
		 *  @type string
		 */
		builder: "-source-",
	
	
		/**
		 * Error reporting.
		 * 
		 * How should DataTables report an error. Can take the value 'alert',
		 * 'throw', 'none' or a function.
		 *
		 *  @type string|function
		 *  @default alert
		 */
		errMode: "alert",
	
	
		/**
		 * Feature plug-ins.
		 * 
		 * This is an array of objects which describe the feature plug-ins that are
		 * available to DataTables. These feature plug-ins are then available for
		 * use through the `dom` initialisation option.
		 * 
		 * Each feature plug-in is described by an object which must have the
		 * following properties:
		 * 
		 * * `fnInit` - function that is used to initialise the plug-in,
		 * * `cFeature` - a character so the feature can be enabled by the `dom`
		 *   instillation option. This is case sensitive.
		 *
		 * The `fnInit` function has the following input parameters:
		 *
		 * 1. `{object}` DataTables settings object: see
		 *    {@link DataTable.models.oSettings}
		 *
		 * And the following return is expected:
		 * 
		 * * {node|null} The element which contains your feature. Note that the
		 *   return may also be void if your plug-in does not require to inject any
		 *   DOM elements into DataTables control (`dom`) - for example this might
		 *   be useful when developing a plug-in which allows table control via
		 *   keyboard entry
		 *
		 *  @type array
		 *
		 *  @example
		 *    $.fn.dataTable.ext.features.push( {
		 *      "fnInit": function( oSettings ) {
		 *        return new TableTools( { "oDTSettings": oSettings } );
		 *      },
		 *      "cFeature": "T"
		 *    } );
		 */
		feature: [],
	
	
		/**
		 * Row searching.
		 * 
		 * This method of searching is complimentary to the default type based
		 * searching, and a lot more comprehensive as it allows you complete control
		 * over the searching logic. Each element in this array is a function
		 * (parameters described below) that is called for every row in the table,
		 * and your logic decides if it should be included in the searching data set
		 * or not.
		 *
		 * Searching functions have the following input parameters:
		 *
		 * 1. `{object}` DataTables settings object: see
		 *    {@link DataTable.models.oSettings}
		 * 2. `{array|object}` Data for the row to be processed (same as the
		 *    original format that was passed in as the data source, or an array
		 *    from a DOM data source
		 * 3. `{int}` Row index ({@link DataTable.models.oSettings.aoData}), which
		 *    can be useful to retrieve the `TR` element if you need DOM interaction.
		 *
		 * And the following return is expected:
		 *
		 * * {boolean} Include the row in the searched result set (true) or not
		 *   (false)
		 *
		 * Note that as with the main search ability in DataTables, technically this
		 * is "filtering", since it is subtractive. However, for consistency in
		 * naming we call it searching here.
		 *
		 *  @type array
		 *  @default []
		 *
		 *  @example
		 *    // The following example shows custom search being applied to the
		 *    // fourth column (i.e. the data[3] index) based on two input values
		 *    // from the end-user, matching the data in a certain range.
		 *    $.fn.dataTable.ext.search.push(
		 *      function( settings, data, dataIndex ) {
		 *        var min = document.getElementById('min').value * 1;
		 *        var max = document.getElementById('max').value * 1;
		 *        var version = data[3] == "-" ? 0 : data[3]*1;
		 *
		 *        if ( min == "" && max == "" ) {
		 *          return true;
		 *        }
		 *        else if ( min == "" && version < max ) {
		 *          return true;
		 *        }
		 *        else if ( min < version && "" == max ) {
		 *          return true;
		 *        }
		 *        else if ( min < version && version < max ) {
		 *          return true;
		 *        }
		 *        return false;
		 *      }
		 *    );
		 */
		search: [],
	
	
		/**
		 * Selector extensions
		 *
		 * The `selector` option can be used to extend the options available for the
		 * selector modifier options (`selector-modifier` object data type) that
		 * each of the three built in selector types offer (row, column and cell +
		 * their plural counterparts). For example the Select extension uses this
		 * mechanism to provide an option to select only rows, columns and cells
		 * that have been marked as selected by the end user (`{selected: true}`),
		 * which can be used in conjunction with the existing built in selector
		 * options.
		 *
		 * Each property is an array to which functions can be pushed. The functions
		 * take three attributes:
		 *
		 * * Settings object for the host table
		 * * Options object (`selector-modifier` object type)
		 * * Array of selected item indexes
		 *
		 * The return is an array of the resulting item indexes after the custom
		 * selector has been applied.
		 *
		 *  @type object
		 */
		selector: {
			cell: [],
			column: [],
			row: []
		},
	
	
		/**
		 * Internal functions, exposed for used in plug-ins.
		 * 
		 * Please note that you should not need to use the internal methods for
		 * anything other than a plug-in (and even then, try to avoid if possible).
		 * The internal function may change between releases.
		 *
		 *  @type object
		 *  @default {}
		 */
		internal: {},
	
	
		/**
		 * Legacy configuration options. Enable and disable legacy options that
		 * are available in DataTables.
		 *
		 *  @type object
		 */
		legacy: {
			/**
			 * Enable / disable DataTables 1.9 compatible server-side processing
			 * requests
			 *
			 *  @type boolean
			 *  @default null
			 */
			ajax: null
		},
	
	
		/**
		 * Pagination plug-in methods.
		 * 
		 * Each entry in this object is a function and defines which buttons should
		 * be shown by the pagination rendering method that is used for the table:
		 * {@link DataTable.ext.renderer.pageButton}. The renderer addresses how the
		 * buttons are displayed in the document, while the functions here tell it
		 * what buttons to display. This is done by returning an array of button
		 * descriptions (what each button will do).
		 *
		 * Pagination types (the four built in options and any additional plug-in
		 * options defined here) can be used through the `paginationType`
		 * initialisation parameter.
		 *
		 * The functions defined take two parameters:
		 *
		 * 1. `{int} page` The current page index
		 * 2. `{int} pages` The number of pages in the table
		 *
		 * Each function is expected to return an array where each element of the
		 * array can be one of:
		 *
		 * * `first` - Jump to first page when activated
		 * * `last` - Jump to last page when activated
		 * * `previous` - Show previous page when activated
		 * * `next` - Show next page when activated
		 * * `{int}` - Show page of the index given
		 * * `{array}` - A nested array containing the above elements to add a
		 *   containing 'DIV' element (might be useful for styling).
		 *
		 * Note that DataTables v1.9- used this object slightly differently whereby
		 * an object with two functions would be defined for each plug-in. That
		 * ability is still supported by DataTables 1.10+ to provide backwards
		 * compatibility, but this option of use is now decremented and no longer
		 * documented in DataTables 1.10+.
		 *
		 *  @type object
		 *  @default {}
		 *
		 *  @example
		 *    // Show previous, next and current page buttons only
		 *    $.fn.dataTableExt.oPagination.current = function ( page, pages ) {
		 *      return [ 'previous', page, 'next' ];
		 *    };
		 */
		pager: {},
	
	
		renderer: {
			pageButton: {},
			header: {}
		},
	
	
		/**
		 * Ordering plug-ins - custom data source
		 * 
		 * The extension options for ordering of data available here is complimentary
		 * to the default type based ordering that DataTables typically uses. It
		 * allows much greater control over the the data that is being used to
		 * order a column, but is necessarily therefore more complex.
		 * 
		 * This type of ordering is useful if you want to do ordering based on data
		 * live from the DOM (for example the contents of an 'input' element) rather
		 * than just the static string that DataTables knows of.
		 * 
		 * The way these plug-ins work is that you create an array of the values you
		 * wish to be ordering for the column in question and then return that
		 * array. The data in the array much be in the index order of the rows in
		 * the table (not the currently ordering order!). Which order data gathering
		 * function is run here depends on the `dt-init columns.orderDataType`
		 * parameter that is used for the column (if any).
		 *
		 * The functions defined take two parameters:
		 *
		 * 1. `{object}` DataTables settings object: see
		 *    {@link DataTable.models.oSettings}
		 * 2. `{int}` Target column index
		 *
		 * Each function is expected to return an array:
		 *
		 * * `{array}` Data for the column to be ordering upon
		 *
		 *  @type array
		 *
		 *  @example
		 *    // Ordering using `input` node values
		 *    $.fn.dataTable.ext.order['dom-text'] = function  ( settings, col )
		 *    {
		 *      return this.api().column( col, {order:'index'} ).nodes().map( function ( td, i ) {
		 *        return $('input', td).val();
		 *      } );
		 *    }
		 */
		order: {},
	
	
		/**
		 * Type based plug-ins.
		 *
		 * Each column in DataTables has a type assigned to it, either by automatic
		 * detection or by direct assignment using the `type` option for the column.
		 * The type of a column will effect how it is ordering and search (plug-ins
		 * can also make use of the column type if required).
		 *
		 * @namespace
		 */
		type: {
			/**
			 * Type detection functions.
			 *
			 * The functions defined in this object are used to automatically detect
			 * a column's type, making initialisation of DataTables super easy, even
			 * when complex data is in the table.
			 *
			 * The functions defined take two parameters:
			 *
		     *  1. `{*}` Data from the column cell to be analysed
		     *  2. `{settings}` DataTables settings object. This can be used to
		     *     perform context specific type detection - for example detection
		     *     based on language settings such as using a comma for a decimal
		     *     place. Generally speaking the options from the settings will not
		     *     be required
			 *
			 * Each function is expected to return:
			 *
			 * * `{string|null}` Data type detected, or null if unknown (and thus
			 *   pass it on to the other type detection functions.
			 *
			 *  @type array
			 *
			 *  @example
			 *    // Currency type detection plug-in:
			 *    $.fn.dataTable.ext.type.detect.push(
			 *      function ( data, settings ) {
			 *        // Check the numeric part
			 *        if ( ! data.substring(1).match(/[0-9]/) ) {
			 *          return null;
			 *        }
			 *
			 *        // Check prefixed by currency
			 *        if ( data.charAt(0) == '$' || data.charAt(0) == '&pound;' ) {
			 *          return 'currency';
			 *        }
			 *        return null;
			 *      }
			 *    );
			 */
			detect: [],
	
	
			/**
			 * Type based search formatting.
			 *
			 * The type based searching functions can be used to pre-format the
			 * data to be search on. For example, it can be used to strip HTML
			 * tags or to de-format telephone numbers for numeric only searching.
			 *
			 * Note that is a search is not defined for a column of a given type,
			 * no search formatting will be performed.
			 * 
			 * Pre-processing of searching data plug-ins - When you assign the sType
			 * for a column (or have it automatically detected for you by DataTables
			 * or a type detection plug-in), you will typically be using this for
			 * custom sorting, but it can also be used to provide custom searching
			 * by allowing you to pre-processing the data and returning the data in
			 * the format that should be searched upon. This is done by adding
			 * functions this object with a parameter name which matches the sType
			 * for that target column. This is the corollary of <i>afnSortData</i>
			 * for searching data.
			 *
			 * The functions defined take a single parameter:
			 *
		     *  1. `{*}` Data from the column cell to be prepared for searching
			 *
			 * Each function is expected to return:
			 *
			 * * `{string|null}` Formatted string that will be used for the searching.
			 *
			 *  @type object
			 *  @default {}
			 *
			 *  @example
			 *    $.fn.dataTable.ext.type.search['title-numeric'] = function ( d ) {
			 *      return d.replace(/\n/g," ").replace( /<.*?>/g, "" );
			 *    }
			 */
			search: {},
	
	
			/**
			 * Type based ordering.
			 *
			 * The column type tells DataTables what ordering to apply to the table
			 * when a column is sorted upon. The order for each type that is defined,
			 * is defined by the functions available in this object.
			 *
			 * Each ordering option can be described by three properties added to
			 * this object:
			 *
			 * * `{type}-pre` - Pre-formatting function
			 * * `{type}-asc` - Ascending order function
			 * * `{type}-desc` - Descending order function
			 *
			 * All three can be used together, only `{type}-pre` or only
			 * `{type}-asc` and `{type}-desc` together. It is generally recommended
			 * that only `{type}-pre` is used, as this provides the optimal
			 * implementation in terms of speed, although the others are provided
			 * for compatibility with existing Javascript sort functions.
			 *
			 * `{type}-pre`: Functions defined take a single parameter:
			 *
		     *  1. `{*}` Data from the column cell to be prepared for ordering
			 *
			 * And return:
			 *
			 * * `{*}` Data to be sorted upon
			 *
			 * `{type}-asc` and `{type}-desc`: Functions are typical Javascript sort
			 * functions, taking two parameters:
			 *
		     *  1. `{*}` Data to compare to the second parameter
		     *  2. `{*}` Data to compare to the first parameter
			 *
			 * And returning:
			 *
			 * * `{*}` Ordering match: <0 if first parameter should be sorted lower
			 *   than the second parameter, ===0 if the two parameters are equal and
			 *   >0 if the first parameter should be sorted height than the second
			 *   parameter.
			 * 
			 *  @type object
			 *  @default {}
			 *
			 *  @example
			 *    // Numeric ordering of formatted numbers with a pre-formatter
			 *    $.extend( $.fn.dataTable.ext.type.order, {
			 *      "string-pre": function(x) {
			 *        a = (a === "-" || a === "") ? 0 : a.replace( /[^\d\-\.]/g, "" );
			 *        return parseFloat( a );
			 *      }
			 *    } );
			 *
			 *  @example
			 *    // Case-sensitive string ordering, with no pre-formatting method
			 *    $.extend( $.fn.dataTable.ext.order, {
			 *      "string-case-asc": function(x,y) {
			 *        return ((x < y) ? -1 : ((x > y) ? 1 : 0));
			 *      },
			 *      "string-case-desc": function(x,y) {
			 *        return ((x < y) ? 1 : ((x > y) ? -1 : 0));
			 *      }
			 *    } );
			 */
			order: {}
		},
	
		/**
		 * Unique DataTables instance counter
		 *
		 * @type int
		 * @private
		 */
		_unique: 0,
	
	
		//
		// Depreciated
		// The following properties are retained for backwards compatiblity only.
		// The should not be used in new projects and will be removed in a future
		// version
		//
	
		/**
		 * Version check function.
		 *  @type function
		 *  @depreciated Since 1.10
		 */
		fnVersionCheck: DataTable.fnVersionCheck,
	
	
		/**
		 * Index for what 'this' index API functions should use
		 *  @type int
		 *  @deprecated Since v1.10
		 */
		iApiIndex: 0,
	
	
		/**
		 * jQuery UI class container
		 *  @type object
		 *  @deprecated Since v1.10
		 */
		oJUIClasses: {},
	
	
		/**
		 * Software version
		 *  @type string
		 *  @deprecated Since v1.10
		 */
		sVersion: DataTable.version
	};
	
	
	//
	// Backwards compatibility. Alias to pre 1.10 Hungarian notation counter parts
	//
	$.extend( _ext, {
		afnFiltering: _ext.search,
		aTypes:       _ext.type.detect,
		ofnSearch:    _ext.type.search,
		oSort:        _ext.type.order,
		afnSortData:  _ext.order,
		aoFeatures:   _ext.feature,
		oApi:         _ext.internal,
		oStdClasses:  _ext.classes,
		oPagination:  _ext.pager
	} );
	
	
	$.extend( DataTable.ext.classes, {
		"sTable": "dataTable",
		"sNoFooter": "no-footer",
	
		/* Paging buttons */
		"sPageButton": "paginate_button",
		"sPageButtonActive": "current",
		"sPageButtonDisabled": "disabled",
	
		/* Striping classes */
		"sStripeOdd": "odd",
		"sStripeEven": "even",
	
		/* Empty row */
		"sRowEmpty": "dataTables_empty",
	
		/* Features */
		"sWrapper": "dataTables_wrapper",
		"sFilter": "dataTables_filter",
		"sInfo": "dataTables_info",
		"sPaging": "dataTables_paginate paging_", /* Note that the type is postfixed */
		"sLength": "dataTables_length",
		"sProcessing": "dataTables_processing",
	
		/* Sorting */
		"sSortAsc": "sorting_asc",
		"sSortDesc": "sorting_desc",
		"sSortable": "sorting", /* Sortable in both directions */
		"sSortableAsc": "sorting_asc_disabled",
		"sSortableDesc": "sorting_desc_disabled",
		"sSortableNone": "sorting_disabled",
		"sSortColumn": "sorting_", /* Note that an int is postfixed for the sorting order */
	
		/* Filtering */
		"sFilterInput": "",
	
		/* Page length */
		"sLengthSelect": "",
	
		/* Scrolling */
		"sScrollWrapper": "dataTables_scroll",
		"sScrollHead": "dataTables_scrollHead",
		"sScrollHeadInner": "dataTables_scrollHeadInner",
		"sScrollBody": "dataTables_scrollBody",
		"sScrollFoot": "dataTables_scrollFoot",
		"sScrollFootInner": "dataTables_scrollFootInner",
	
		/* Misc */
		"sHeaderTH": "",
		"sFooterTH": "",
	
		// Deprecated
		"sSortJUIAsc": "",
		"sSortJUIDesc": "",
		"sSortJUI": "",
		"sSortJUIAscAllowed": "",
		"sSortJUIDescAllowed": "",
		"sSortJUIWrapper": "",
		"sSortIcon": "",
		"sJUIHeader": "",
		"sJUIFooter": ""
	} );
	
	
	var extPagination = DataTable.ext.pager;
	
	function _numbers ( page, pages ) {
		var
			numbers = [],
			buttons = extPagination.numbers_length,
			half = Math.floor( buttons / 2 ),
			i = 1;
	
		if ( pages <= buttons ) {
			numbers = _range( 0, pages );
		}
		else if ( page <= half ) {
			numbers = _range( 0, buttons-2 );
			numbers.push( 'ellipsis' );
			numbers.push( pages-1 );
		}
		else if ( page >= pages - 1 - half ) {
			numbers = _range( pages-(buttons-2), pages );
			numbers.splice( 0, 0, 'ellipsis' ); // no unshift in ie6
			numbers.splice( 0, 0, 0 );
		}
		else {
			numbers = _range( page-half+2, page+half-1 );
			numbers.push( 'ellipsis' );
			numbers.push( pages-1 );
			numbers.splice( 0, 0, 'ellipsis' );
			numbers.splice( 0, 0, 0 );
		}
	
		numbers.DT_el = 'span';
		return numbers;
	}
	
	
	$.extend( extPagination, {
		simple: function ( page, pages ) {
			return [ 'previous', 'next' ];
		},
	
		full: function ( page, pages ) {
			return [  'first', 'previous', 'next', 'last' ];
		},
	
		numbers: function ( page, pages ) {
			return [ _numbers(page, pages) ];
		},
	
		simple_numbers: function ( page, pages ) {
			return [ 'previous', _numbers(page, pages), 'next' ];
		},
	
		full_numbers: function ( page, pages ) {
			return [ 'first', 'previous', _numbers(page, pages), 'next', 'last' ];
		},
		
		first_last_numbers: function (page, pages) {
	 		return ['first', _numbers(page, pages), 'last'];
	 	},
	
		// For testing and plug-ins to use
		_numbers: _numbers,
	
		// Number of number buttons (including ellipsis) to show. _Must be odd!_
		numbers_length: 7
	} );
	
	
	$.extend( true, DataTable.ext.renderer, {
		pageButton: {
			_: function ( settings, host, idx, buttons, page, pages ) {
				var classes = settings.oClasses;
				var lang = settings.oLanguage.oPaginate;
				var aria = settings.oLanguage.oAria.paginate || {};
				var btnDisplay, btnClass, counter=0;
	
				var attach = function( container, buttons ) {
					var i, ien, node, button, tabIndex;
					var disabledClass = classes.sPageButtonDisabled;
					var clickHandler = function ( e ) {
						_fnPageChange( settings, e.data.action, true );
					};
	
					for ( i=0, ien=buttons.length ; i<ien ; i++ ) {
						button = buttons[i];
	
						if ( $.isArray( button ) ) {
							var inner = $( '<'+(button.DT_el || 'div')+'/>' )
								.appendTo( container );
							attach( inner, button );
						}
						else {
							btnDisplay = null;
							btnClass = button;
							tabIndex = settings.iTabIndex;
	
							switch ( button ) {
								case 'ellipsis':
									container.append('<span class="ellipsis">&#x2026;</span>');
									break;
	
								case 'first':
									btnDisplay = lang.sFirst;
	
									if ( page === 0 ) {
										tabIndex = -1;
										btnClass += ' ' + disabledClass;
									}
									break;
	
								case 'previous':
									btnDisplay = lang.sPrevious;
	
									if ( page === 0 ) {
										tabIndex = -1;
										btnClass += ' ' + disabledClass;
									}
									break;
	
								case 'next':
									btnDisplay = lang.sNext;
	
									if ( pages === 0 || page === pages-1 ) {
										tabIndex = -1;
										btnClass += ' ' + disabledClass;
									}
									break;
	
								case 'last':
									btnDisplay = lang.sLast;
	
									if ( page === pages-1 ) {
										tabIndex = -1;
										btnClass += ' ' + disabledClass;
									}
									break;
	
								default:
									btnDisplay = button + 1;
									btnClass = page === button ?
										classes.sPageButtonActive : '';
									break;
							}
	
							if ( btnDisplay !== null ) {
								node = $('<a>', {
										'class': classes.sPageButton+' '+btnClass,
										'aria-controls': settings.sTableId,
										'aria-label': aria[ button ],
										'data-dt-idx': counter,
										'tabindex': tabIndex,
										'id': idx === 0 && typeof button === 'string' ?
											settings.sTableId +'_'+ button :
											null
									} )
									.html( btnDisplay )
									.appendTo( container );
	
								_fnBindAction(
									node, {action: button}, clickHandler
								);
	
								counter++;
							}
						}
					}
				};
	
				// IE9 throws an 'unknown error' if document.activeElement is used
				// inside an iframe or frame. Try / catch the error. Not good for
				// accessibility, but neither are frames.
				var activeEl;
	
				try {
					// Because this approach is destroying and recreating the paging
					// elements, focus is lost on the select button which is bad for
					// accessibility. So we want to restore focus once the draw has
					// completed
					activeEl = $(host).find(document.activeElement).data('dt-idx');
				}
				catch (e) {}
	
				attach( $(host).empty(), buttons );
	
				if ( activeEl !== undefined ) {
					$(host).find( '[data-dt-idx='+activeEl+']' ).trigger('focus');
				}
			}
		}
	} );
	
	
	
	// Built in type detection. See model.ext.aTypes for information about
	// what is required from this methods.
	$.extend( DataTable.ext.type.detect, [
		// Plain numbers - first since V8 detects some plain numbers as dates
		// e.g. Date.parse('55') (but not all, e.g. Date.parse('22')...).
		function ( d, settings )
		{
			var decimal = settings.oLanguage.sDecimal;
			return _isNumber( d, decimal ) ? 'num'+decimal : null;
		},
	
		// Dates (only those recognised by the browser's Date.parse)
		function ( d, settings )
		{
			// V8 tries _very_ hard to make a string passed into `Date.parse()`
			// valid, so we need to use a regex to restrict date formats. Use a
			// plug-in for anything other than ISO8601 style strings
			if ( d && !(d instanceof Date) && ! _re_date.test(d) ) {
				return null;
			}
			var parsed = Date.parse(d);
			return (parsed !== null && !isNaN(parsed)) || _empty(d) ? 'date' : null;
		},
	
		// Formatted numbers
		function ( d, settings )
		{
			var decimal = settings.oLanguage.sDecimal;
			return _isNumber( d, decimal, true ) ? 'num-fmt'+decimal : null;
		},
	
		// HTML numeric
		function ( d, settings )
		{
			var decimal = settings.oLanguage.sDecimal;
			return _htmlNumeric( d, decimal ) ? 'html-num'+decimal : null;
		},
	
		// HTML numeric, formatted
		function ( d, settings )
		{
			var decimal = settings.oLanguage.sDecimal;
			return _htmlNumeric( d, decimal, true ) ? 'html-num-fmt'+decimal : null;
		},
	
		// HTML (this is strict checking - there must be html)
		function ( d, settings )
		{
			return _empty( d ) || (typeof d === 'string' && d.indexOf('<') !== -1) ?
				'html' : null;
		}
	] );
	
	
	
	// Filter formatting functions. See model.ext.ofnSearch for information about
	// what is required from these methods.
	// 
	// Note that additional search methods are added for the html numbers and
	// html formatted numbers by `_addNumericSort()` when we know what the decimal
	// place is
	
	
	$.extend( DataTable.ext.type.search, {
		html: function ( data ) {
			return _empty(data) ?
				data :
				typeof data === 'string' ?
					data
						.replace( _re_new_lines, " " )
						.replace( _re_html, "" ) :
					'';
		},
	
		string: function ( data ) {
			return _empty(data) ?
				data :
				typeof data === 'string' ?
					data.replace( _re_new_lines, " " ) :
					data;
		}
	} );
	
	
	
	var __numericReplace = function ( d, decimalPlace, re1, re2 ) {
		if ( d !== 0 && (!d || d === '-') ) {
			return -Infinity;
		}
	
		// If a decimal place other than `.` is used, it needs to be given to the
		// function so we can detect it and replace with a `.` which is the only
		// decimal place Javascript recognises - it is not locale aware.
		if ( decimalPlace ) {
			d = _numToDecimal( d, decimalPlace );
		}
	
		if ( d.replace ) {
			if ( re1 ) {
				d = d.replace( re1, '' );
			}
	
			if ( re2 ) {
				d = d.replace( re2, '' );
			}
		}
	
		return d * 1;
	};
	
	
	// Add the numeric 'deformatting' functions for sorting and search. This is done
	// in a function to provide an easy ability for the language options to add
	// additional methods if a non-period decimal place is used.
	function _addNumericSort ( decimalPlace ) {
		$.each(
			{
				// Plain numbers
				"num": function ( d ) {
					return __numericReplace( d, decimalPlace );
				},
	
				// Formatted numbers
				"num-fmt": function ( d ) {
					return __numericReplace( d, decimalPlace, _re_formatted_numeric );
				},
	
				// HTML numeric
				"html-num": function ( d ) {
					return __numericReplace( d, decimalPlace, _re_html );
				},
	
				// HTML numeric, formatted
				"html-num-fmt": function ( d ) {
					return __numericReplace( d, decimalPlace, _re_html, _re_formatted_numeric );
				}
			},
			function ( key, fn ) {
				// Add the ordering method
				_ext.type.order[ key+decimalPlace+'-pre' ] = fn;
	
				// For HTML types add a search formatter that will strip the HTML
				if ( key.match(/^html\-/) ) {
					_ext.type.search[ key+decimalPlace ] = _ext.type.search.html;
				}
			}
		);
	}
	
	
	// Default sort methods
	$.extend( _ext.type.order, {
		// Dates
		"date-pre": function ( d ) {
			var ts = Date.parse( d );
			return isNaN(ts) ? -Infinity : ts;
		},
	
		// html
		"html-pre": function ( a ) {
			return _empty(a) ?
				'' :
				a.replace ?
					a.replace( /<.*?>/g, "" ).toLowerCase() :
					a+'';
		},
	
		// string
		"string-pre": function ( a ) {
			// This is a little complex, but faster than always calling toString,
			// http://jsperf.com/tostring-v-check
			return _empty(a) ?
				'' :
				typeof a === 'string' ?
					a.toLowerCase() :
					! a.toString ?
						'' :
						a.toString();
		},
	
		// string-asc and -desc are retained only for compatibility with the old
		// sort methods
		"string-asc": function ( x, y ) {
			return ((x < y) ? -1 : ((x > y) ? 1 : 0));
		},
	
		"string-desc": function ( x, y ) {
			return ((x < y) ? 1 : ((x > y) ? -1 : 0));
		}
	} );
	
	
	// Numeric sorting types - order doesn't matter here
	_addNumericSort( '' );
	
	
	$.extend( true, DataTable.ext.renderer, {
		header: {
			_: function ( settings, cell, column, classes ) {
				// No additional mark-up required
				// Attach a sort listener to update on sort - note that using the
				// `DT` namespace will allow the event to be removed automatically
				// on destroy, while the `dt` namespaced event is the one we are
				// listening for
				$(settings.nTable).on( 'order.dt.DT', function ( e, ctx, sorting, columns ) {
					if ( settings !== ctx ) { // need to check this this is the host
						return;               // table, not a nested one
					}
	
					var colIdx = column.idx;
	
					cell
						.removeClass(
							column.sSortingClass +' '+
							classes.sSortAsc +' '+
							classes.sSortDesc
						)
						.addClass( columns[ colIdx ] == 'asc' ?
							classes.sSortAsc : columns[ colIdx ] == 'desc' ?
								classes.sSortDesc :
								column.sSortingClass
						);
				} );
			},
	
			jqueryui: function ( settings, cell, column, classes ) {
				$('<div/>')
					.addClass( classes.sSortJUIWrapper )
					.append( cell.contents() )
					.append( $('<span/>')
						.addClass( classes.sSortIcon+' '+column.sSortingClassJUI )
					)
					.appendTo( cell );
	
				// Attach a sort listener to update on sort
				$(settings.nTable).on( 'order.dt.DT', function ( e, ctx, sorting, columns ) {
					if ( settings !== ctx ) {
						return;
					}
	
					var colIdx = column.idx;
	
					cell
						.removeClass( classes.sSortAsc +" "+classes.sSortDesc )
						.addClass( columns[ colIdx ] == 'asc' ?
							classes.sSortAsc : columns[ colIdx ] == 'desc' ?
								classes.sSortDesc :
								column.sSortingClass
						);
	
					cell
						.find( 'span.'+classes.sSortIcon )
						.removeClass(
							classes.sSortJUIAsc +" "+
							classes.sSortJUIDesc +" "+
							classes.sSortJUI +" "+
							classes.sSortJUIAscAllowed +" "+
							classes.sSortJUIDescAllowed
						)
						.addClass( columns[ colIdx ] == 'asc' ?
							classes.sSortJUIAsc : columns[ colIdx ] == 'desc' ?
								classes.sSortJUIDesc :
								column.sSortingClassJUI
						);
				} );
			}
		}
	} );
	
	/*
	 * Public helper functions. These aren't used internally by DataTables, or
	 * called by any of the options passed into DataTables, but they can be used
	 * externally by developers working with DataTables. They are helper functions
	 * to make working with DataTables a little bit easier.
	 */
	
	var __htmlEscapeEntities = function ( d ) {
		return typeof d === 'string' ?
			d
				.replace(/&/g, '&amp;')
				.replace(/</g, '&lt;')
				.replace(/>/g, '&gt;')
				.replace(/"/g, '&quot;') :
			d;
	};
	
	/**
	 * Helpers for `columns.render`.
	 *
	 * The options defined here can be used with the `columns.render` initialisation
	 * option to provide a display renderer. The following functions are defined:
	 *
	 * * `number` - Will format numeric data (defined by `columns.data`) for
	 *   display, retaining the original unformatted data for sorting and filtering.
	 *   It takes 5 parameters:
	 *   * `string` - Thousands grouping separator
	 *   * `string` - Decimal point indicator
	 *   * `integer` - Number of decimal points to show
	 *   * `string` (optional) - Prefix.
	 *   * `string` (optional) - Postfix (/suffix).
	 * * `text` - Escape HTML to help prevent XSS attacks. It has no optional
	 *   parameters.
	 *
	 * @example
	 *   // Column definition using the number renderer
	 *   {
	 *     data: "salary",
	 *     render: $.fn.dataTable.render.number( '\'', '.', 0, '$' )
	 *   }
	 *
	 * @namespace
	 */
	DataTable.render = {
		number: function ( thousands, decimal, precision, prefix, postfix ) {
			return {
				display: function ( d ) {
					if ( typeof d !== 'number' && typeof d !== 'string' ) {
						return d;
					}
	
					var negative = d < 0 ? '-' : '';
					var flo = parseFloat( d );
	
					// If NaN then there isn't much formatting that we can do - just
					// return immediately, escaping any HTML (this was supposed to
					// be a number after all)
					if ( isNaN( flo ) ) {
						return __htmlEscapeEntities( d );
					}
	
					flo = flo.toFixed( precision );
					d = Math.abs( flo );
	
					var intPart = parseInt( d, 10 );
					var floatPart = precision ?
						decimal+(d - intPart).toFixed( precision ).substring( 2 ):
						'';
	
					return negative + (prefix||'') +
						intPart.toString().replace(
							/\B(?=(\d{3})+(?!\d))/g, thousands
						) +
						floatPart +
						(postfix||'');
				}
			};
		},
	
		text: function () {
			return {
				display: __htmlEscapeEntities,
				filter: __htmlEscapeEntities
			};
		}
	};
	
	
	/*
	 * This is really a good bit rubbish this method of exposing the internal methods
	 * publicly... - To be fixed in 2.0 using methods on the prototype
	 */
	
	
	/**
	 * Create a wrapper function for exporting an internal functions to an external API.
	 *  @param {string} fn API function name
	 *  @returns {function} wrapped function
	 *  @memberof DataTable#internal
	 */
	function _fnExternApiFunc (fn)
	{
		return function() {
			var args = [_fnSettingsFromNode( this[DataTable.ext.iApiIndex] )].concat(
				Array.prototype.slice.call(arguments)
			);
			return DataTable.ext.internal[fn].apply( this, args );
		};
	}
	
	
	/**
	 * Reference to internal functions for use by plug-in developers. Note that
	 * these methods are references to internal functions and are considered to be
	 * private. If you use these methods, be aware that they are liable to change
	 * between versions.
	 *  @namespace
	 */
	$.extend( DataTable.ext.internal, {
		_fnExternApiFunc: _fnExternApiFunc,
		_fnBuildAjax: _fnBuildAjax,
		_fnAjaxUpdate: _fnAjaxUpdate,
		_fnAjaxParameters: _fnAjaxParameters,
		_fnAjaxUpdateDraw: _fnAjaxUpdateDraw,
		_fnAjaxDataSrc: _fnAjaxDataSrc,
		_fnAddColumn: _fnAddColumn,
		_fnColumnOptions: _fnColumnOptions,
		_fnAdjustColumnSizing: _fnAdjustColumnSizing,
		_fnVisibleToColumnIndex: _fnVisibleToColumnIndex,
		_fnColumnIndexToVisible: _fnColumnIndexToVisible,
		_fnVisbleColumns: _fnVisbleColumns,
		_fnGetColumns: _fnGetColumns,
		_fnColumnTypes: _fnColumnTypes,
		_fnApplyColumnDefs: _fnApplyColumnDefs,
		_fnHungarianMap: _fnHungarianMap,
		_fnCamelToHungarian: _fnCamelToHungarian,
		_fnLanguageCompat: _fnLanguageCompat,
		_fnBrowserDetect: _fnBrowserDetect,
		_fnAddData: _fnAddData,
		_fnAddTr: _fnAddTr,
		_fnNodeToDataIndex: _fnNodeToDataIndex,
		_fnNodeToColumnIndex: _fnNodeToColumnIndex,
		_fnGetCellData: _fnGetCellData,
		_fnSetCellData: _fnSetCellData,
		_fnSplitObjNotation: _fnSplitObjNotation,
		_fnGetObjectDataFn: _fnGetObjectDataFn,
		_fnSetObjectDataFn: _fnSetObjectDataFn,
		_fnGetDataMaster: _fnGetDataMaster,
		_fnClearTable: _fnClearTable,
		_fnDeleteIndex: _fnDeleteIndex,
		_fnInvalidate: _fnInvalidate,
		_fnGetRowElements: _fnGetRowElements,
		_fnCreateTr: _fnCreateTr,
		_fnBuildHead: _fnBuildHead,
		_fnDrawHead: _fnDrawHead,
		_fnDraw: _fnDraw,
		_fnReDraw: _fnReDraw,
		_fnAddOptionsHtml: _fnAddOptionsHtml,
		_fnDetectHeader: _fnDetectHeader,
		_fnGetUniqueThs: _fnGetUniqueThs,
		_fnFeatureHtmlFilter: _fnFeatureHtmlFilter,
		_fnFilterComplete: _fnFilterComplete,
		_fnFilterCustom: _fnFilterCustom,
		_fnFilterColumn: _fnFilterColumn,
		_fnFilter: _fnFilter,
		_fnFilterCreateSearch: _fnFilterCreateSearch,
		_fnEscapeRegex: _fnEscapeRegex,
		_fnFilterData: _fnFilterData,
		_fnFeatureHtmlInfo: _fnFeatureHtmlInfo,
		_fnUpdateInfo: _fnUpdateInfo,
		_fnInfoMacros: _fnInfoMacros,
		_fnInitialise: _fnInitialise,
		_fnInitComplete: _fnInitComplete,
		_fnLengthChange: _fnLengthChange,
		_fnFeatureHtmlLength: _fnFeatureHtmlLength,
		_fnFeatureHtmlPaginate: _fnFeatureHtmlPaginate,
		_fnPageChange: _fnPageChange,
		_fnFeatureHtmlProcessing: _fnFeatureHtmlProcessing,
		_fnProcessingDisplay: _fnProcessingDisplay,
		_fnFeatureHtmlTable: _fnFeatureHtmlTable,
		_fnScrollDraw: _fnScrollDraw,
		_fnApplyToChildren: _fnApplyToChildren,
		_fnCalculateColumnWidths: _fnCalculateColumnWidths,
		_fnThrottle: _fnThrottle,
		_fnConvertToWidth: _fnConvertToWidth,
		_fnGetWidestNode: _fnGetWidestNode,
		_fnGetMaxLenString: _fnGetMaxLenString,
		_fnStringToCss: _fnStringToCss,
		_fnSortFlatten: _fnSortFlatten,
		_fnSort: _fnSort,
		_fnSortAria: _fnSortAria,
		_fnSortListener: _fnSortListener,
		_fnSortAttachListener: _fnSortAttachListener,
		_fnSortingClasses: _fnSortingClasses,
		_fnSortData: _fnSortData,
		_fnSaveState: _fnSaveState,
		_fnLoadState: _fnLoadState,
		_fnSettingsFromNode: _fnSettingsFromNode,
		_fnLog: _fnLog,
		_fnMap: _fnMap,
		_fnBindAction: _fnBindAction,
		_fnCallbackReg: _fnCallbackReg,
		_fnCallbackFire: _fnCallbackFire,
		_fnLengthOverflow: _fnLengthOverflow,
		_fnRenderer: _fnRenderer,
		_fnDataSource: _fnDataSource,
		_fnRowAttributes: _fnRowAttributes,
		_fnExtend: _fnExtend,
		_fnCalculateEnd: function () {} // Used by a lot of plug-ins, but redundant
		                                // in 1.10, so this dead-end function is
		                                // added to prevent errors
	} );
	

	// jQuery access
	$.fn.dataTable = DataTable;

	// Provide access to the host jQuery object (circular reference)
	DataTable.$ = $;

	// Legacy aliases
	$.fn.dataTableSettings = DataTable.settings;
	$.fn.dataTableExt = DataTable.ext;

	// With a capital `D` we return a DataTables API instance rather than a
	// jQuery object
	$.fn.DataTable = function ( opts ) {
		return $(this).dataTable( opts ).api();
	};

	// All properties that are available to $.fn.dataTable should also be
	// available on $.fn.DataTable
	$.each( DataTable, function ( prop, val ) {
		$.fn.DataTable[ prop ] = val;
	} );


	// Information about events fired by DataTables - for documentation.
	/**
	 * Draw event, fired whenever the table is redrawn on the page, at the same
	 * point as fnDrawCallback. This may be useful for binding events or
	 * performing calculations when the table is altered at all.
	 *  @name DataTable#draw.dt
	 *  @event
	 *  @param {event} e jQuery event object
	 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
	 */

	/**
	 * Search event, fired when the searching applied to the table (using the
	 * built-in global search, or column filters) is altered.
	 *  @name DataTable#search.dt
	 *  @event
	 *  @param {event} e jQuery event object
	 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
	 */

	/**
	 * Page change event, fired when the paging of the table is altered.
	 *  @name DataTable#page.dt
	 *  @event
	 *  @param {event} e jQuery event object
	 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
	 */

	/**
	 * Order event, fired when the ordering applied to the table is altered.
	 *  @name DataTable#order.dt
	 *  @event
	 *  @param {event} e jQuery event object
	 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
	 */

	/**
	 * DataTables initialisation complete event, fired when the table is fully
	 * drawn, including Ajax data loaded, if Ajax data is required.
	 *  @name DataTable#init.dt
	 *  @event
	 *  @param {event} e jQuery event object
	 *  @param {object} oSettings DataTables settings object
	 *  @param {object} json The JSON object request from the server - only
	 *    present if client-side Ajax sourced data is used</li></ol>
	 */

	/**
	 * State save event, fired when the table has changed state a new state save
	 * is required. This event allows modification of the state saving object
	 * prior to actually doing the save, including addition or other state
	 * properties (for plug-ins) or modification of a DataTables core property.
	 *  @name DataTable#stateSaveParams.dt
	 *  @event
	 *  @param {event} e jQuery event object
	 *  @param {object} oSettings DataTables settings object
	 *  @param {object} json The state information to be saved
	 */

	/**
	 * State load event, fired when the table is loading state from the stored
	 * data, but prior to the settings object being modified by the saved state
	 * - allowing modification of the saved state is required or loading of
	 * state for a plug-in.
	 *  @name DataTable#stateLoadParams.dt
	 *  @event
	 *  @param {event} e jQuery event object
	 *  @param {object} oSettings DataTables settings object
	 *  @param {object} json The saved state information
	 */

	/**
	 * State loaded event, fired when state has been loaded from stored data and
	 * the settings object has been modified by the loaded data.
	 *  @name DataTable#stateLoaded.dt
	 *  @event
	 *  @param {event} e jQuery event object
	 *  @param {object} oSettings DataTables settings object
	 *  @param {object} json The saved state information
	 */

	/**
	 * Processing event, fired when DataTables is doing some kind of processing
	 * (be it, order, search or anything else). It can be used to indicate to
	 * the end user that there is something happening, or that something has
	 * finished.
	 *  @name DataTable#processing.dt
	 *  @event
	 *  @param {event} e jQuery event object
	 *  @param {object} oSettings DataTables settings object
	 *  @param {boolean} bShow Flag for if DataTables is doing processing or not
	 */

	/**
	 * Ajax (XHR) event, fired whenever an Ajax request is completed from a
	 * request to made to the server for new data. This event is called before
	 * DataTables processed the returned data, so it can also be used to pre-
	 * process the data returned from the server, if needed.
	 *
	 * Note that this trigger is called in `fnServerData`, if you override
	 * `fnServerData` and which to use this event, you need to trigger it in you
	 * success function.
	 *  @name DataTable#xhr.dt
	 *  @event
	 *  @param {event} e jQuery event object
	 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
	 *  @param {object} json JSON returned from the server
	 *
	 *  @example
	 *     // Use a custom property returned from the server in another DOM element
	 *     $('#table').dataTable().on('xhr.dt', function (e, settings, json) {
	 *       $('#status').html( json.status );
	 *     } );
	 *
	 *  @example
	 *     // Pre-process the data returned from the server
	 *     $('#table').dataTable().on('xhr.dt', function (e, settings, json) {
	 *       for ( var i=0, ien=json.aaData.length ; i<ien ; i++ ) {
	 *         json.aaData[i].sum = json.aaData[i].one + json.aaData[i].two;
	 *       }
	 *       // Note no return - manipulate the data directly in the JSON object.
	 *     } );
	 */

	/**
	 * Destroy event, fired when the DataTable is destroyed by calling fnDestroy
	 * or passing the bDestroy:true parameter in the initialisation object. This
	 * can be used to remove bound events, added DOM nodes, etc.
	 *  @name DataTable#destroy.dt
	 *  @event
	 *  @param {event} e jQuery event object
	 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
	 */

	/**
	 * Page length change event, fired when number of records to show on each
	 * page (the length) is changed.
	 *  @name DataTable#length.dt
	 *  @event
	 *  @param {event} e jQuery event object
	 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
	 *  @param {integer} len New length
	 */

	/**
	 * Column sizing has changed.
	 *  @name DataTable#column-sizing.dt
	 *  @event
	 *  @param {event} e jQuery event object
	 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
	 */

	/**
	 * Column visibility has changed.
	 *  @name DataTable#column-visibility.dt
	 *  @event
	 *  @param {event} e jQuery event object
	 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
	 *  @param {int} column Column index
	 *  @param {bool} vis `false` if column now hidden, or `true` if visible
	 */

	return $.fn.dataTable;
}));


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktbGFzdC1pbmRleC1vZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktcmVkdWNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9udW1iZXItcGFyc2UtZmxvYXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NhbWUtdmFsdWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3N0cmluZy1yZXBlYXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RoaXMtbnVtYmVyLXZhbHVlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkubGFzdC1pbmRleC1vZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnJlZHVjZS1yaWdodC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnJlZHVjZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnJldmVyc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5zb3J0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMubnVtYmVyLnRvLWZpeGVkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMucGFyc2UtZmxvYXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuc2VhcmNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kYXRhdGFibGVzLm5ldC9qcy9qcXVlcnkuZGF0YVRhYmxlcy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQWE7QUFDYixzQkFBc0IsbUJBQU8sQ0FBQyw2RkFBZ0M7QUFDOUQsZ0JBQWdCLG1CQUFPLENBQUMsK0VBQXlCO0FBQ2pELGVBQWUsbUJBQU8sQ0FBQyw2RUFBd0I7QUFDL0MsMEJBQTBCLG1CQUFPLENBQUMsdUdBQXFDO0FBQ3ZFLDhCQUE4QixtQkFBTyxDQUFDLGlIQUEwQzs7QUFFaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCx3QkFBd0I7QUFDakY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLFdBQVc7QUFDbkI7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7QUMzQkQsZ0JBQWdCLG1CQUFPLENBQUMsK0VBQXlCO0FBQ2pELGVBQWUsbUJBQU8sQ0FBQyw2RUFBd0I7QUFDL0Msb0JBQW9CLG1CQUFPLENBQUMsdUZBQTZCO0FBQ3pELGVBQWUsbUJBQU8sQ0FBQyw2RUFBd0I7O0FBRS9DLHFCQUFxQixzQkFBc0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHVDQUF1QztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3ZDQSxhQUFhLG1CQUFPLENBQUMsdUVBQXFCO0FBQzFDLFdBQVcsbUJBQU8sQ0FBQyxpRkFBMEI7QUFDN0Msa0JBQWtCLG1CQUFPLENBQUMsaUZBQTBCOztBQUVwRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtB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QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxTQUFTO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsK0JBQStCLFNBQVM7QUFDeEM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0JBQStCLFNBQVM7QUFDeEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0EsaUJBQWlCLGFBQWE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxLQUFLO0FBQ2xCLGFBQWEsTUFBTTtBQUNuQixxQkFBcUIsS0FBSztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNDQUFzQyxTQUFTO0FBQy9DO0FBQ0EsMENBQTBDLFNBQVM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksTUFBTTtBQUNsQjtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMsYUFBYTtBQUNiLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlLEtBQUs7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLCtCQUErQjtBQUM5Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixnQ0FBZ0M7O0FBRW5EO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxJQUFJO0FBQ2pCLGFBQWEsSUFBSTtBQUNqQixhQUFhLE1BQU07QUFDbkIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLEtBQUs7QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxJQUFJO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQix3QkFBd0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDLFFBQVE7QUFDN0M7O0FBRUE7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxJQUFJO0FBQ2pCLGFBQWEsS0FBSztBQUNsQixhQUFhLEtBQUs7QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixtQkFBbUI7QUFDcEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxJQUFJO0FBQ2pCLGFBQWEsS0FBSztBQUNsQixhQUFhLEtBQUs7QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsY0FBYyxtQkFBbUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsS0FBSztBQUNsQixhQUFhLEtBQUs7QUFDbEIsYUFBYSxLQUFLO0FBQ2xCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlDQUF5QyxRQUFRO0FBQ2pEOztBQUVBO0FBQ0E7O0FBRUEsbUNBQW1DLFFBQVE7QUFDM0M7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGVBQWUsS0FBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qzs7QUFFNUM7QUFDQTtBQUNBLDBCQUEwQiwyQkFBMkIsRUFBRTtBQUN2RDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0MsU0FBUztBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGVBQWUsS0FBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxxQ0FBcUMsUUFBUTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGVBQWUsS0FBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDLFFBQVE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsV0FBVztBQUN4QjtBQUNBO0FBQ0EsZUFBZSxLQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlLEtBQUs7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsZUFBZSxLQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGtDQUFrQztBQUM3RDtBQUNBLGFBQWEsK0JBQStCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSwrQkFBK0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSwrQkFBK0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QixtQkFBbUIsTUFBTTtBQUN6QixtQkFBbUIsTUFBTTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7O0FBSUE7OztBQUdBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsMEJBQTBCO0FBQ3ZDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZ0JBQWdCO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxjQUFjLDBCQUEwQjtBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSwwQkFBMEI7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDBCQUEwQjtBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QixhQUFhLElBQUk7QUFDakIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLEtBQUs7QUFDbEIsZUFBZSxJQUFJO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxJQUFJO0FBQ2pCLGVBQWUsS0FBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxJQUFJO0FBQ2pCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLHNCQUFzQjtBQUNuQztBQUNBO0FBQ0E7O0FBRUEscUNBQXFDLFNBQVM7QUFDOUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLCtCQUErQixRQUFRO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixRQUFRO0FBQ3hCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsUUFBUTtBQUN4Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0MsU0FBUztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxLQUFLO0FBQ2xCLGFBQWEsSUFBSTtBQUNqQixhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLEtBQUs7QUFDbEIsYUFBYSxJQUFJO0FBQ2pCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQyxRQUFRO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0JBQStCLFFBQVE7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw2Q0FBNkMsUUFBUTtBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkNBQTZDOztBQUU3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsUUFBUTtBQUM3Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxhQUFhLEtBQUs7QUFDbEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLElBQUk7QUFDakIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsSUFBSTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsT0FBTztBQUNwQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsU0FBUztBQUN0QixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0EsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDBCQUEwQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsSUFBSTtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsSUFBSTtBQUMxQjtBQUNBO0FBQ0EsWUFBWSwyQkFBMkI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0MsUUFBUTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDs7O0FBR0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQSxtQ0FBbUMsT0FBTztBQUMxQztBQUNBOztBQUVBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFFBQVE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7OztBQUdBO0FBQ0E7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0MsUUFBUTtBQUMxQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtDQUFrQyxRQUFRO0FBQzFDOztBQUVBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0MsUUFBUTtBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOzs7Ozs7QUFNRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOzs7QUFHRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsRUFBRTs7OztBQUlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFFBQVE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsZUFBZTtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9DQUFvQyxRQUFRO0FBQzVDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DQUFvQyxRQUFRO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7Ozs7QUFJRjtBQUNBO0FBQ0E7QUFDQSxLQUFLLFFBQVE7QUFDYixNQUFNLFFBQVE7QUFDZCxNQUFNLFFBQVEsdUJBQXVCLFFBQVE7QUFDN0MsTUFBTSxPQUFPO0FBQ2IsTUFBTSxPQUFPO0FBQ2I7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxVQUFVO0FBQzlDO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQyxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCQUErQixRQUFRO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOzs7O0FBSUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGdDQUFnQyxRQUFRO0FBQ3hDOztBQUVBLGdCQUFnQixZQUFZO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQ0FBb0MsUUFBUTtBQUM1Qyx3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBO0FBQ0E7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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSCxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBDQUEwQztBQUMxQyxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsRUFBRTtBQUNoQixjQUFjLGFBQWE7QUFDM0IsY0FBYyxJQUFJO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsYUFBYTtBQUMzQjtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBLGdCQUFnQixFQUFFO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGFBQWE7QUFDM0I7QUFDQSxjQUFjLEVBQUU7QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DLGVBQWUscUJBQXFCO0FBQ3BDLGVBQWUsc0JBQXNCO0FBQ3JDLGVBQWUscUJBQXFCO0FBQ3BDLGVBQWU7QUFDZjtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsd0NBQXdDO0FBQ3ZELGVBQWUseUNBQXlDO0FBQ3hELGVBQWUsMENBQTBDO0FBQ3pELGVBQWUseUNBQXlDO0FBQ3hELGVBQWU7QUFDZjtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCx1QkFBdUI7QUFDNUU7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsNEJBQTRCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLGdDQUFnQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnQ0FBZ0M7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHdCQUF3QjtBQUN2QztBQUNBLGVBQWU7QUFDZjtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sNkJBQTZCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLEtBQUs7QUFDbkIsY0FBYyxNQUFNO0FBQ3BCLGNBQWMsSUFBSTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLEtBQUs7QUFDbkIsY0FBYyxNQUFNO0FBQ3BCLGNBQWMsSUFBSTtBQUNsQjtBQUNBLGNBQWMsSUFBSTtBQUNsQjtBQUNBLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxJQUFJO0FBQ2xCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsRUFBRTtBQUM1QjtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxjQUFjLEVBQUU7QUFDaEI7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLEtBQUs7QUFDbkIsY0FBYyxNQUFNO0FBQ3BCLGNBQWMsSUFBSTtBQUNsQjtBQUNBLGNBQWMsSUFBSTtBQUNsQjtBQUNBLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLElBQUk7QUFDbEIsY0FBYyxJQUFJO0FBQ2xCLGNBQWMsSUFBSTtBQUNsQjtBQUNBLGNBQWMsSUFBSTtBQUNsQixjQUFjLE9BQU87QUFDckI7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxLQUFLO0FBQ25CLGNBQWMsTUFBTTtBQUNwQixjQUFjLElBQUk7QUFDbEIsY0FBYyxJQUFJO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsTUFBTTtBQUNwQjtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQjtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sZ0NBQWdDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjs7O0FBR2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLFVBQVU7QUFDVjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLFVBQVU7QUFDVjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osVUFBVTtBQUNWO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLFVBQVU7QUFDVjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLFVBQVU7QUFDVjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixVQUFVO0FBQ1Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixVQUFVO0FBQ1Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osVUFBVTtBQUNWO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixVQUFVO0FBQ1Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLFVBQVU7QUFDVjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixVQUFVO0FBQ1Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixVQUFVO0FBQ1Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osVUFBVTtBQUNWO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQSx5QkFBeUI7OztBQUd6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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LFNBQVM7QUFDVDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsc0JBQXNCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxQ0FBcUM7QUFDcEQsZUFBZSxzQ0FBc0M7QUFDckQsZUFBZSx1Q0FBdUM7QUFDdEQsZUFB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QUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBLE1BQU0sK0JBQStCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5QkFBeUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5QkFBeUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTSxpQ0FBaUM7QUFDdkM7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5QkFBeUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5QkFBeUI7QUFDakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjs7QUFFaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOzs7QUFHYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOzs7QUFHYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQixTQUFTO0FBQ1Q7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QUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DLFFBQVE7QUFDNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7O0FBSUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7Ozs7QUFJRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLGFBQWE7QUFDYjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6Qix3QkFBd0I7QUFDeEIsd0JBQXdCO0FBQ3hCLDBCQUEwQjtBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsRUFBRTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQixhQUFhLE9BQU8sK0JBQStCO0FBQ25EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkIsYUFBYSxPQUFPLCtCQUErQjtBQUNuRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQixhQUFhLE9BQU8sK0JBQStCO0FBQ25EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CLGFBQWEsT0FBTywrQkFBK0I7QUFDbkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQixhQUFhLE9BQU87QUFDcEIsYUFBYSxRQUFRO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkIsYUFBYSxPQUFPLCtCQUErQjtBQUNuRCxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxRQUFRO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkIsYUFBYSxPQUFPLCtCQUErQjtBQUNuRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CLGFBQWEsT0FBTywrQkFBK0I7QUFDbkQsYUFBYSxRQUFRO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CLGFBQWEsT0FBTywrQkFBK0I7QUFDbkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkIsYUFBYSxPQUFPLCtCQUErQjtBQUNuRCxhQUFhLElBQUk7QUFDakIsYUFBYSxLQUFLO0FBQ2xCOztBQUVBO0FBQ0EsQ0FBQyIsImZpbGUiOiJ2ZW5kb3JzfmFic2VuY2VzfmFkbS5hYnNlbmNlc35hZG0uZXR1ZGlhbnRzfmFkbS5wZXJzb25uZWxzfmRhdGF0YWJsZX5zYWRtLnBlcnNvbm5lbHMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG52YXIgdG9JbmRleGVkT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0Jyk7XG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWludGVnZXInKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1sZW5ndGgnKTtcbnZhciBhcnJheU1ldGhvZElzU3RyaWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LW1ldGhvZC1pcy1zdHJpY3QnKTtcbnZhciBhcnJheU1ldGhvZFVzZXNUb0xlbmd0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1tZXRob2QtdXNlcy10by1sZW5ndGgnKTtcblxudmFyIG1pbiA9IE1hdGgubWluO1xudmFyIG5hdGl2ZUxhc3RJbmRleE9mID0gW10ubGFzdEluZGV4T2Y7XG52YXIgTkVHQVRJVkVfWkVSTyA9ICEhbmF0aXZlTGFzdEluZGV4T2YgJiYgMSAvIFsxXS5sYXN0SW5kZXhPZigxLCAtMCkgPCAwO1xudmFyIFNUUklDVF9NRVRIT0QgPSBhcnJheU1ldGhvZElzU3RyaWN0KCdsYXN0SW5kZXhPZicpO1xuLy8gRm9yIHByZXZlbnRpbmcgcG9zc2libGUgYWxtb3N0IGluZmluaXRlIGxvb3AgaW4gbm9uLXN0YW5kYXJkIGltcGxlbWVudGF0aW9ucywgdGVzdCB0aGUgZm9yd2FyZCB2ZXJzaW9uIG9mIHRoZSBtZXRob2RcbnZhciBVU0VTX1RPX0xFTkdUSCA9IGFycmF5TWV0aG9kVXNlc1RvTGVuZ3RoKCdpbmRleE9mJywgeyBBQ0NFU1NPUlM6IHRydWUsIDE6IDAgfSk7XG52YXIgRk9SQ0VEID0gTkVHQVRJVkVfWkVSTyB8fCAhU1RSSUNUX01FVEhPRCB8fCAhVVNFU19UT19MRU5HVEg7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2ZgIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmxhc3RpbmRleG9mXG5tb2R1bGUuZXhwb3J0cyA9IEZPUkNFRCA/IGZ1bmN0aW9uIGxhc3RJbmRleE9mKHNlYXJjaEVsZW1lbnQgLyogLCBmcm9tSW5kZXggPSBAWyotMV0gKi8pIHtcbiAgLy8gY29udmVydCAtMCB0byArMFxuICBpZiAoTkVHQVRJVkVfWkVSTykgcmV0dXJuIG5hdGl2ZUxhc3RJbmRleE9mLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgMDtcbiAgdmFyIE8gPSB0b0luZGV4ZWRPYmplY3QodGhpcyk7XG4gIHZhciBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gIHZhciBpbmRleCA9IGxlbmd0aCAtIDE7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkgaW5kZXggPSBtaW4oaW5kZXgsIHRvSW50ZWdlcihhcmd1bWVudHNbMV0pKTtcbiAgaWYgKGluZGV4IDwgMCkgaW5kZXggPSBsZW5ndGggKyBpbmRleDtcbiAgZm9yICg7aW5kZXggPj0gMDsgaW5kZXgtLSkgaWYgKGluZGV4IGluIE8gJiYgT1tpbmRleF0gPT09IHNlYXJjaEVsZW1lbnQpIHJldHVybiBpbmRleCB8fCAwO1xuICByZXR1cm4gLTE7XG59IDogbmF0aXZlTGFzdEluZGV4T2Y7XG4iLCJ2YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2EtZnVuY3Rpb24nKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1vYmplY3QnKTtcbnZhciBJbmRleGVkT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2luZGV4ZWQtb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tbGVuZ3RoJyk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUueyByZWR1Y2UsIHJlZHVjZVJpZ2h0IH1gIG1ldGhvZHMgaW1wbGVtZW50YXRpb25cbnZhciBjcmVhdGVNZXRob2QgPSBmdW5jdGlvbiAoSVNfUklHSFQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh0aGF0LCBjYWxsYmFja2ZuLCBhcmd1bWVudHNMZW5ndGgsIG1lbW8pIHtcbiAgICBhRnVuY3Rpb24oY2FsbGJhY2tmbik7XG4gICAgdmFyIE8gPSB0b09iamVjdCh0aGF0KTtcbiAgICB2YXIgc2VsZiA9IEluZGV4ZWRPYmplY3QoTyk7XG4gICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSBJU19SSUdIVCA/IGxlbmd0aCAtIDEgOiAwO1xuICAgIHZhciBpID0gSVNfUklHSFQgPyAtMSA6IDE7XG4gICAgaWYgKGFyZ3VtZW50c0xlbmd0aCA8IDIpIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAoaW5kZXggaW4gc2VsZikge1xuICAgICAgICBtZW1vID0gc2VsZltpbmRleF07XG4gICAgICAgIGluZGV4ICs9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaW5kZXggKz0gaTtcbiAgICAgIGlmIChJU19SSUdIVCA/IGluZGV4IDwgMCA6IGxlbmd0aCA8PSBpbmRleCkge1xuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ1JlZHVjZSBvZiBlbXB0eSBhcnJheSB3aXRoIG5vIGluaXRpYWwgdmFsdWUnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yICg7SVNfUklHSFQgPyBpbmRleCA+PSAwIDogbGVuZ3RoID4gaW5kZXg7IGluZGV4ICs9IGkpIGlmIChpbmRleCBpbiBzZWxmKSB7XG4gICAgICBtZW1vID0gY2FsbGJhY2tmbihtZW1vLCBzZWxmW2luZGV4XSwgaW5kZXgsIE8pO1xuICAgIH1cbiAgICByZXR1cm4gbWVtbztcbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvLyBgQXJyYXkucHJvdG90eXBlLnJlZHVjZWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5yZWR1Y2VcbiAgbGVmdDogY3JlYXRlTWV0aG9kKGZhbHNlKSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5yZWR1Y2VSaWdodGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5yZWR1Y2VyaWdodFxuICByaWdodDogY3JlYXRlTWV0aG9kKHRydWUpXG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciB0cmltID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3N0cmluZy10cmltJykudHJpbTtcbnZhciB3aGl0ZXNwYWNlcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93aGl0ZXNwYWNlcycpO1xuXG52YXIgJHBhcnNlRmxvYXQgPSBnbG9iYWwucGFyc2VGbG9hdDtcbnZhciBGT1JDRUQgPSAxIC8gJHBhcnNlRmxvYXQod2hpdGVzcGFjZXMgKyAnLTAnKSAhPT0gLUluZmluaXR5O1xuXG4vLyBgcGFyc2VGbG9hdGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1wYXJzZWZsb2F0LXN0cmluZ1xubW9kdWxlLmV4cG9ydHMgPSBGT1JDRUQgPyBmdW5jdGlvbiBwYXJzZUZsb2F0KHN0cmluZykge1xuICB2YXIgdHJpbW1lZFN0cmluZyA9IHRyaW0oU3RyaW5nKHN0cmluZykpO1xuICB2YXIgcmVzdWx0ID0gJHBhcnNlRmxvYXQodHJpbW1lZFN0cmluZyk7XG4gIHJldHVybiByZXN1bHQgPT09IDAgJiYgdHJpbW1lZFN0cmluZy5jaGFyQXQoMCkgPT0gJy0nID8gLTAgOiByZXN1bHQ7XG59IDogJHBhcnNlRmxvYXQ7XG4iLCIvLyBgU2FtZVZhbHVlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXNhbWV2YWx1ZVxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuaXMgfHwgZnVuY3Rpb24gaXMoeCwgeSkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gIHJldHVybiB4ID09PSB5ID8geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHkgOiB4ICE9IHggJiYgeSAhPSB5O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW50ZWdlcicpO1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlJyk7XG5cbi8vIGBTdHJpbmcucHJvdG90eXBlLnJlcGVhdGAgbWV0aG9kIGltcGxlbWVudGF0aW9uXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnJlcGVhdFxubW9kdWxlLmV4cG9ydHMgPSAnJy5yZXBlYXQgfHwgZnVuY3Rpb24gcmVwZWF0KGNvdW50KSB7XG4gIHZhciBzdHIgPSBTdHJpbmcocmVxdWlyZU9iamVjdENvZXJjaWJsZSh0aGlzKSk7XG4gIHZhciByZXN1bHQgPSAnJztcbiAgdmFyIG4gPSB0b0ludGVnZXIoY291bnQpO1xuICBpZiAobiA8IDAgfHwgbiA9PSBJbmZpbml0eSkgdGhyb3cgUmFuZ2VFcnJvcignV3JvbmcgbnVtYmVyIG9mIHJlcGV0aXRpb25zJyk7XG4gIGZvciAoO24gPiAwOyAobiA+Pj49IDEpICYmIChzdHIgKz0gc3RyKSkgaWYgKG4gJiAxKSByZXN1bHQgKz0gc3RyO1xuICByZXR1cm4gcmVzdWx0O1xufTtcbiIsInZhciBjbGFzc29mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NsYXNzb2YtcmF3Jyk7XG5cbi8vIGB0aGlzTnVtYmVyVmFsdWVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdGhpc251bWJlcnZhbHVlXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9ICdudW1iZXInICYmIGNsYXNzb2YodmFsdWUpICE9ICdOdW1iZXInKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKCdJbmNvcnJlY3QgaW52b2NhdGlvbicpO1xuICB9XG4gIHJldHVybiArdmFsdWU7XG59O1xuIiwidmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgbGFzdEluZGV4T2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktbGFzdC1pbmRleC1vZicpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5sYXN0aW5kZXhvZlxuJCh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUsIGZvcmNlZDogbGFzdEluZGV4T2YgIT09IFtdLmxhc3RJbmRleE9mIH0sIHtcbiAgbGFzdEluZGV4T2Y6IGxhc3RJbmRleE9mXG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyICRyZWR1Y2VSaWdodCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1yZWR1Y2UnKS5yaWdodDtcbnZhciBhcnJheU1ldGhvZElzU3RyaWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LW1ldGhvZC1pcy1zdHJpY3QnKTtcbnZhciBhcnJheU1ldGhvZFVzZXNUb0xlbmd0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1tZXRob2QtdXNlcy10by1sZW5ndGgnKTtcblxudmFyIFNUUklDVF9NRVRIT0QgPSBhcnJheU1ldGhvZElzU3RyaWN0KCdyZWR1Y2VSaWdodCcpO1xuLy8gRm9yIHByZXZlbnRpbmcgcG9zc2libGUgYWxtb3N0IGluZmluaXRlIGxvb3AgaW4gbm9uLXN0YW5kYXJkIGltcGxlbWVudGF0aW9ucywgdGVzdCB0aGUgZm9yd2FyZCB2ZXJzaW9uIG9mIHRoZSBtZXRob2RcbnZhciBVU0VTX1RPX0xFTkdUSCA9IGFycmF5TWV0aG9kVXNlc1RvTGVuZ3RoKCdyZWR1Y2UnLCB7IDE6IDAgfSk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUucmVkdWNlUmlnaHRgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnJlZHVjZXJpZ2h0XG4kKHsgdGFyZ2V0OiAnQXJyYXknLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiAhU1RSSUNUX01FVEhPRCB8fCAhVVNFU19UT19MRU5HVEggfSwge1xuICByZWR1Y2VSaWdodDogZnVuY3Rpb24gcmVkdWNlUmlnaHQoY2FsbGJhY2tmbiAvKiAsIGluaXRpYWxWYWx1ZSAqLykge1xuICAgIHJldHVybiAkcmVkdWNlUmlnaHQodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyICRyZWR1Y2UgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktcmVkdWNlJykubGVmdDtcbnZhciBhcnJheU1ldGhvZElzU3RyaWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LW1ldGhvZC1pcy1zdHJpY3QnKTtcbnZhciBhcnJheU1ldGhvZFVzZXNUb0xlbmd0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1tZXRob2QtdXNlcy10by1sZW5ndGgnKTtcblxudmFyIFNUUklDVF9NRVRIT0QgPSBhcnJheU1ldGhvZElzU3RyaWN0KCdyZWR1Y2UnKTtcbnZhciBVU0VTX1RPX0xFTkdUSCA9IGFycmF5TWV0aG9kVXNlc1RvTGVuZ3RoKCdyZWR1Y2UnLCB7IDE6IDAgfSk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUucmVkdWNlYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5yZWR1Y2VcbiQoeyB0YXJnZXQ6ICdBcnJheScsIHByb3RvOiB0cnVlLCBmb3JjZWQ6ICFTVFJJQ1RfTUVUSE9EIHx8ICFVU0VTX1RPX0xFTkdUSCB9LCB7XG4gIHJlZHVjZTogZnVuY3Rpb24gcmVkdWNlKGNhbGxiYWNrZm4gLyogLCBpbml0aWFsVmFsdWUgKi8pIHtcbiAgICByZXR1cm4gJHJlZHVjZSh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1hcnJheScpO1xuXG52YXIgbmF0aXZlUmV2ZXJzZSA9IFtdLnJldmVyc2U7XG52YXIgdGVzdCA9IFsxLCAyXTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5yZXZlcnNlYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5yZXZlcnNlXG4vLyBmaXggZm9yIFNhZmFyaSAxMi4wIGJ1Z1xuLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE4ODc5NFxuJCh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUsIGZvcmNlZDogU3RyaW5nKHRlc3QpID09PSBTdHJpbmcodGVzdC5yZXZlcnNlKCkpIH0sIHtcbiAgcmV2ZXJzZTogZnVuY3Rpb24gcmV2ZXJzZSgpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1hc3NpZ25cbiAgICBpZiAoaXNBcnJheSh0aGlzKSkgdGhpcy5sZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgICByZXR1cm4gbmF0aXZlUmV2ZXJzZS5jYWxsKHRoaXMpO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hLWZ1bmN0aW9uJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tb2JqZWN0Jyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciBhcnJheU1ldGhvZElzU3RyaWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LW1ldGhvZC1pcy1zdHJpY3QnKTtcblxudmFyIHRlc3QgPSBbXTtcbnZhciBuYXRpdmVTb3J0ID0gdGVzdC5zb3J0O1xuXG4vLyBJRTgtXG52YXIgRkFJTFNfT05fVU5ERUZJTkVEID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuICB0ZXN0LnNvcnQodW5kZWZpbmVkKTtcbn0pO1xuLy8gVjggYnVnXG52YXIgRkFJTFNfT05fTlVMTCA9IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgdGVzdC5zb3J0KG51bGwpO1xufSk7XG4vLyBPbGQgV2ViS2l0XG52YXIgU1RSSUNUX01FVEhPRCA9IGFycmF5TWV0aG9kSXNTdHJpY3QoJ3NvcnQnKTtcblxudmFyIEZPUkNFRCA9IEZBSUxTX09OX1VOREVGSU5FRCB8fCAhRkFJTFNfT05fTlVMTCB8fCAhU1RSSUNUX01FVEhPRDtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5zb3J0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5zb3J0XG4kKHsgdGFyZ2V0OiAnQXJyYXknLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBGT1JDRUQgfSwge1xuICBzb3J0OiBmdW5jdGlvbiBzb3J0KGNvbXBhcmVmbikge1xuICAgIHJldHVybiBjb21wYXJlZm4gPT09IHVuZGVmaW5lZFxuICAgICAgPyBuYXRpdmVTb3J0LmNhbGwodG9PYmplY3QodGhpcykpXG4gICAgICA6IG5hdGl2ZVNvcnQuY2FsbCh0b09iamVjdCh0aGlzKSwgYUZ1bmN0aW9uKGNvbXBhcmVmbikpO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbnRlZ2VyJyk7XG52YXIgdGhpc051bWJlclZhbHVlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RoaXMtbnVtYmVyLXZhbHVlJyk7XG52YXIgcmVwZWF0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3N0cmluZy1yZXBlYXQnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xuXG52YXIgbmF0aXZlVG9GaXhlZCA9IDEuMC50b0ZpeGVkO1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcblxudmFyIHBvdyA9IGZ1bmN0aW9uICh4LCBuLCBhY2MpIHtcbiAgcmV0dXJuIG4gPT09IDAgPyBhY2MgOiBuICUgMiA9PT0gMSA/IHBvdyh4LCBuIC0gMSwgYWNjICogeCkgOiBwb3coeCAqIHgsIG4gLyAyLCBhY2MpO1xufTtcblxudmFyIGxvZyA9IGZ1bmN0aW9uICh4KSB7XG4gIHZhciBuID0gMDtcbiAgdmFyIHgyID0geDtcbiAgd2hpbGUgKHgyID49IDQwOTYpIHtcbiAgICBuICs9IDEyO1xuICAgIHgyIC89IDQwOTY7XG4gIH1cbiAgd2hpbGUgKHgyID49IDIpIHtcbiAgICBuICs9IDE7XG4gICAgeDIgLz0gMjtcbiAgfSByZXR1cm4gbjtcbn07XG5cbnZhciBGT1JDRUQgPSBuYXRpdmVUb0ZpeGVkICYmIChcbiAgMC4wMDAwOC50b0ZpeGVkKDMpICE9PSAnMC4wMDAnIHx8XG4gIDAuOS50b0ZpeGVkKDApICE9PSAnMScgfHxcbiAgMS4yNTUudG9GaXhlZCgyKSAhPT0gJzEuMjUnIHx8XG4gIDEwMDAwMDAwMDAwMDAwMDAxMjguMC50b0ZpeGVkKDApICE9PSAnMTAwMDAwMDAwMDAwMDAwMDEyOCdcbikgfHwgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gVjggfiBBbmRyb2lkIDQuMy1cbiAgbmF0aXZlVG9GaXhlZC5jYWxsKHt9KTtcbn0pO1xuXG4vLyBgTnVtYmVyLnByb3RvdHlwZS50b0ZpeGVkYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW51bWJlci5wcm90b3R5cGUudG9maXhlZFxuJCh7IHRhcmdldDogJ051bWJlcicsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IEZPUkNFRCB9LCB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtc3RhdGVtZW50c1xuICB0b0ZpeGVkOiBmdW5jdGlvbiB0b0ZpeGVkKGZyYWN0aW9uRGlnaXRzKSB7XG4gICAgdmFyIG51bWJlciA9IHRoaXNOdW1iZXJWYWx1ZSh0aGlzKTtcbiAgICB2YXIgZnJhY3REaWdpdHMgPSB0b0ludGVnZXIoZnJhY3Rpb25EaWdpdHMpO1xuICAgIHZhciBkYXRhID0gWzAsIDAsIDAsIDAsIDAsIDBdO1xuICAgIHZhciBzaWduID0gJyc7XG4gICAgdmFyIHJlc3VsdCA9ICcwJztcbiAgICB2YXIgZSwgeiwgaiwgaztcblxuICAgIHZhciBtdWx0aXBseSA9IGZ1bmN0aW9uIChuLCBjKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMTtcbiAgICAgIHZhciBjMiA9IGM7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IDYpIHtcbiAgICAgICAgYzIgKz0gbiAqIGRhdGFbaW5kZXhdO1xuICAgICAgICBkYXRhW2luZGV4XSA9IGMyICUgMWU3O1xuICAgICAgICBjMiA9IGZsb29yKGMyIC8gMWU3KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGRpdmlkZSA9IGZ1bmN0aW9uIChuKSB7XG4gICAgICB2YXIgaW5kZXggPSA2O1xuICAgICAgdmFyIGMgPSAwO1xuICAgICAgd2hpbGUgKC0taW5kZXggPj0gMCkge1xuICAgICAgICBjICs9IGRhdGFbaW5kZXhdO1xuICAgICAgICBkYXRhW2luZGV4XSA9IGZsb29yKGMgLyBuKTtcbiAgICAgICAgYyA9IChjICUgbikgKiAxZTc7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBkYXRhVG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaW5kZXggPSA2O1xuICAgICAgdmFyIHMgPSAnJztcbiAgICAgIHdoaWxlICgtLWluZGV4ID49IDApIHtcbiAgICAgICAgaWYgKHMgIT09ICcnIHx8IGluZGV4ID09PSAwIHx8IGRhdGFbaW5kZXhdICE9PSAwKSB7XG4gICAgICAgICAgdmFyIHQgPSBTdHJpbmcoZGF0YVtpbmRleF0pO1xuICAgICAgICAgIHMgPSBzID09PSAnJyA/IHQgOiBzICsgcmVwZWF0LmNhbGwoJzAnLCA3IC0gdC5sZW5ndGgpICsgdDtcbiAgICAgICAgfVxuICAgICAgfSByZXR1cm4gcztcbiAgICB9O1xuXG4gICAgaWYgKGZyYWN0RGlnaXRzIDwgMCB8fCBmcmFjdERpZ2l0cyA+IDIwKSB0aHJvdyBSYW5nZUVycm9yKCdJbmNvcnJlY3QgZnJhY3Rpb24gZGlnaXRzJyk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgIGlmIChudW1iZXIgIT0gbnVtYmVyKSByZXR1cm4gJ05hTic7XG4gICAgaWYgKG51bWJlciA8PSAtMWUyMSB8fCBudW1iZXIgPj0gMWUyMSkgcmV0dXJuIFN0cmluZyhudW1iZXIpO1xuICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICBzaWduID0gJy0nO1xuICAgICAgbnVtYmVyID0gLW51bWJlcjtcbiAgICB9XG4gICAgaWYgKG51bWJlciA+IDFlLTIxKSB7XG4gICAgICBlID0gbG9nKG51bWJlciAqIHBvdygyLCA2OSwgMSkpIC0gNjk7XG4gICAgICB6ID0gZSA8IDAgPyBudW1iZXIgKiBwb3coMiwgLWUsIDEpIDogbnVtYmVyIC8gcG93KDIsIGUsIDEpO1xuICAgICAgeiAqPSAweDEwMDAwMDAwMDAwMDAwO1xuICAgICAgZSA9IDUyIC0gZTtcbiAgICAgIGlmIChlID4gMCkge1xuICAgICAgICBtdWx0aXBseSgwLCB6KTtcbiAgICAgICAgaiA9IGZyYWN0RGlnaXRzO1xuICAgICAgICB3aGlsZSAoaiA+PSA3KSB7XG4gICAgICAgICAgbXVsdGlwbHkoMWU3LCAwKTtcbiAgICAgICAgICBqIC09IDc7XG4gICAgICAgIH1cbiAgICAgICAgbXVsdGlwbHkocG93KDEwLCBqLCAxKSwgMCk7XG4gICAgICAgIGogPSBlIC0gMTtcbiAgICAgICAgd2hpbGUgKGogPj0gMjMpIHtcbiAgICAgICAgICBkaXZpZGUoMSA8PCAyMyk7XG4gICAgICAgICAgaiAtPSAyMztcbiAgICAgICAgfVxuICAgICAgICBkaXZpZGUoMSA8PCBqKTtcbiAgICAgICAgbXVsdGlwbHkoMSwgMSk7XG4gICAgICAgIGRpdmlkZSgyKTtcbiAgICAgICAgcmVzdWx0ID0gZGF0YVRvU3RyaW5nKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtdWx0aXBseSgwLCB6KTtcbiAgICAgICAgbXVsdGlwbHkoMSA8PCAtZSwgMCk7XG4gICAgICAgIHJlc3VsdCA9IGRhdGFUb1N0cmluZygpICsgcmVwZWF0LmNhbGwoJzAnLCBmcmFjdERpZ2l0cyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChmcmFjdERpZ2l0cyA+IDApIHtcbiAgICAgIGsgPSByZXN1bHQubGVuZ3RoO1xuICAgICAgcmVzdWx0ID0gc2lnbiArIChrIDw9IGZyYWN0RGlnaXRzXG4gICAgICAgID8gJzAuJyArIHJlcGVhdC5jYWxsKCcwJywgZnJhY3REaWdpdHMgLSBrKSArIHJlc3VsdFxuICAgICAgICA6IHJlc3VsdC5zbGljZSgwLCBrIC0gZnJhY3REaWdpdHMpICsgJy4nICsgcmVzdWx0LnNsaWNlKGsgLSBmcmFjdERpZ2l0cykpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBzaWduICsgcmVzdWx0O1xuICAgIH0gcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7XG4iLCJ2YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBwYXJzZUZsb2F0SW1wbGVtZW50YXRpb24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvbnVtYmVyLXBhcnNlLWZsb2F0Jyk7XG5cbi8vIGBwYXJzZUZsb2F0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXBhcnNlZmxvYXQtc3RyaW5nXG4kKHsgZ2xvYmFsOiB0cnVlLCBmb3JjZWQ6IHBhcnNlRmxvYXQgIT0gcGFyc2VGbG9hdEltcGxlbWVudGF0aW9uIH0sIHtcbiAgcGFyc2VGbG9hdDogcGFyc2VGbG9hdEltcGxlbWVudGF0aW9uXG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBmaXhSZWdFeHBXZWxsS25vd25TeW1ib2xMb2dpYyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9maXgtcmVnZXhwLXdlbGwta25vd24tc3ltYm9sLWxvZ2ljJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUnKTtcbnZhciBzYW1lVmFsdWUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2FtZS12YWx1ZScpO1xudmFyIHJlZ0V4cEV4ZWMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVnZXhwLWV4ZWMtYWJzdHJhY3QnKTtcblxuLy8gQEBzZWFyY2ggbG9naWNcbmZpeFJlZ0V4cFdlbGxLbm93blN5bWJvbExvZ2ljKCdzZWFyY2gnLCAxLCBmdW5jdGlvbiAoU0VBUkNILCBuYXRpdmVTZWFyY2gsIG1heWJlQ2FsbE5hdGl2ZSkge1xuICByZXR1cm4gW1xuICAgIC8vIGBTdHJpbmcucHJvdG90eXBlLnNlYXJjaGAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5zZWFyY2hcbiAgICBmdW5jdGlvbiBzZWFyY2gocmVnZXhwKSB7XG4gICAgICB2YXIgTyA9IHJlcXVpcmVPYmplY3RDb2VyY2libGUodGhpcyk7XG4gICAgICB2YXIgc2VhcmNoZXIgPSByZWdleHAgPT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogcmVnZXhwW1NFQVJDSF07XG4gICAgICByZXR1cm4gc2VhcmNoZXIgIT09IHVuZGVmaW5lZCA/IHNlYXJjaGVyLmNhbGwocmVnZXhwLCBPKSA6IG5ldyBSZWdFeHAocmVnZXhwKVtTRUFSQ0hdKFN0cmluZyhPKSk7XG4gICAgfSxcbiAgICAvLyBgUmVnRXhwLnByb3RvdHlwZVtAQHNlYXJjaF1gIG1ldGhvZFxuICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXJlZ2V4cC5wcm90b3R5cGUtQEBzZWFyY2hcbiAgICBmdW5jdGlvbiAocmVnZXhwKSB7XG4gICAgICB2YXIgcmVzID0gbWF5YmVDYWxsTmF0aXZlKG5hdGl2ZVNlYXJjaCwgcmVnZXhwLCB0aGlzKTtcbiAgICAgIGlmIChyZXMuZG9uZSkgcmV0dXJuIHJlcy52YWx1ZTtcblxuICAgICAgdmFyIHJ4ID0gYW5PYmplY3QocmVnZXhwKTtcbiAgICAgIHZhciBTID0gU3RyaW5nKHRoaXMpO1xuXG4gICAgICB2YXIgcHJldmlvdXNMYXN0SW5kZXggPSByeC5sYXN0SW5kZXg7XG4gICAgICBpZiAoIXNhbWVWYWx1ZShwcmV2aW91c0xhc3RJbmRleCwgMCkpIHJ4Lmxhc3RJbmRleCA9IDA7XG4gICAgICB2YXIgcmVzdWx0ID0gcmVnRXhwRXhlYyhyeCwgUyk7XG4gICAgICBpZiAoIXNhbWVWYWx1ZShyeC5sYXN0SW5kZXgsIHByZXZpb3VzTGFzdEluZGV4KSkgcngubGFzdEluZGV4ID0gcHJldmlvdXNMYXN0SW5kZXg7XG4gICAgICByZXR1cm4gcmVzdWx0ID09PSBudWxsID8gLTEgOiByZXN1bHQuaW5kZXg7XG4gICAgfVxuICBdO1xufSk7XG4iLCIvKiEgRGF0YVRhYmxlcyAxLjEwLjIxXG4gKiDCqTIwMDgtMjAyMCBTcHJ5TWVkaWEgTHRkIC0gZGF0YXRhYmxlcy5uZXQvbGljZW5zZVxuICovXG5cbi8qKlxuICogQHN1bW1hcnkgICAgIERhdGFUYWJsZXNcbiAqIEBkZXNjcmlwdGlvbiBQYWdpbmF0ZSwgc2VhcmNoIGFuZCBvcmRlciBIVE1MIHRhYmxlc1xuICogQHZlcnNpb24gICAgIDEuMTAuMjFcbiAqIEBmaWxlICAgICAgICBqcXVlcnkuZGF0YVRhYmxlcy5qc1xuICogQGF1dGhvciAgICAgIFNwcnlNZWRpYSBMdGRcbiAqIEBjb250YWN0ICAgICB3d3cuZGF0YXRhYmxlcy5uZXRcbiAqIEBjb3B5cmlnaHQgICBDb3B5cmlnaHQgMjAwOC0yMDIwIFNwcnlNZWRpYSBMdGQuXG4gKlxuICogVGhpcyBzb3VyY2UgZmlsZSBpcyBmcmVlIHNvZnR3YXJlLCBhdmFpbGFibGUgdW5kZXIgdGhlIGZvbGxvd2luZyBsaWNlbnNlOlxuICogICBNSVQgbGljZW5zZSAtIGh0dHA6Ly9kYXRhdGFibGVzLm5ldC9saWNlbnNlXG4gKlxuICogVGhpcyBzb3VyY2UgZmlsZSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXRcbiAqIFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gKiBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBsaWNlbnNlIGZpbGVzIGZvciBkZXRhaWxzLlxuICpcbiAqIEZvciBkZXRhaWxzIHBsZWFzZSByZWZlciB0bzogaHR0cDovL3d3dy5kYXRhdGFibGVzLm5ldFxuICovXG5cbi8qanNsaW50IGV2aWw6IHRydWUsIHVuZGVmOiB0cnVlLCBicm93c2VyOiB0cnVlICovXG4vKmdsb2JhbHMgJCxyZXF1aXJlLGpRdWVyeSxkZWZpbmUsX3NlbGVjdG9yX3J1bixfc2VsZWN0b3Jfb3B0cyxfc2VsZWN0b3JfZmlyc3QsX3NlbGVjdG9yX3Jvd19pbmRleGVzLF9leHQsX0FwaSxfYXBpX3JlZ2lzdGVyLF9hcGlfcmVnaXN0ZXJQbHVyYWwsX3JlX25ld19saW5lcyxfcmVfaHRtbCxfcmVfZm9ybWF0dGVkX251bWVyaWMsX3JlX2VzY2FwZV9yZWdleCxfZW1wdHksX2ludFZhbCxfbnVtVG9EZWNpbWFsLF9pc051bWJlcixfaXNIdG1sLF9odG1sTnVtZXJpYyxfcGx1Y2ssX3BsdWNrX29yZGVyLF9yYW5nZSxfc3RyaXBIdG1sLF91bmlxdWUsX2ZuQnVpbGRBamF4LF9mbkFqYXhVcGRhdGUsX2ZuQWpheFBhcmFtZXRlcnMsX2ZuQWpheFVwZGF0ZURyYXcsX2ZuQWpheERhdGFTcmMsX2ZuQWRkQ29sdW1uLF9mbkNvbHVtbk9wdGlvbnMsX2ZuQWRqdXN0Q29sdW1uU2l6aW5nLF9mblZpc2libGVUb0NvbHVtbkluZGV4LF9mbkNvbHVtbkluZGV4VG9WaXNpYmxlLF9mblZpc2JsZUNvbHVtbnMsX2ZuR2V0Q29sdW1ucyxfZm5Db2x1bW5UeXBlcyxfZm5BcHBseUNvbHVtbkRlZnMsX2ZuSHVuZ2FyaWFuTWFwLF9mbkNhbWVsVG9IdW5nYXJpYW4sX2ZuTGFuZ3VhZ2VDb21wYXQsX2ZuQnJvd3NlckRldGVjdCxfZm5BZGREYXRhLF9mbkFkZFRyLF9mbk5vZGVUb0RhdGFJbmRleCxfZm5Ob2RlVG9Db2x1bW5JbmRleCxfZm5HZXRDZWxsRGF0YSxfZm5TZXRDZWxsRGF0YSxfZm5TcGxpdE9iak5vdGF0aW9uLF9mbkdldE9iamVjdERhdGFGbixfZm5TZXRPYmplY3REYXRhRm4sX2ZuR2V0RGF0YU1hc3RlcixfZm5DbGVhclRhYmxlLF9mbkRlbGV0ZUluZGV4LF9mbkludmFsaWRhdGUsX2ZuR2V0Um93RWxlbWVudHMsX2ZuQ3JlYXRlVHIsX2ZuQnVpbGRIZWFkLF9mbkRyYXdIZWFkLF9mbkRyYXcsX2ZuUmVEcmF3LF9mbkFkZE9wdGlvbnNIdG1sLF9mbkRldGVjdEhlYWRlcixfZm5HZXRVbmlxdWVUaHMsX2ZuRmVhdHVyZUh0bWxGaWx0ZXIsX2ZuRmlsdGVyQ29tcGxldGUsX2ZuRmlsdGVyQ3VzdG9tLF9mbkZpbHRlckNvbHVtbixfZm5GaWx0ZXIsX2ZuRmlsdGVyQ3JlYXRlU2VhcmNoLF9mbkVzY2FwZVJlZ2V4LF9mbkZpbHRlckRhdGEsX2ZuRmVhdHVyZUh0bWxJbmZvLF9mblVwZGF0ZUluZm8sX2ZuSW5mb01hY3JvcyxfZm5Jbml0aWFsaXNlLF9mbkluaXRDb21wbGV0ZSxfZm5MZW5ndGhDaGFuZ2UsX2ZuRmVhdHVyZUh0bWxMZW5ndGgsX2ZuRmVhdHVyZUh0bWxQYWdpbmF0ZSxfZm5QYWdlQ2hhbmdlLF9mbkZlYXR1cmVIdG1sUHJvY2Vzc2luZyxfZm5Qcm9jZXNzaW5nRGlzcGxheSxfZm5GZWF0dXJlSHRtbFRhYmxlLF9mblNjcm9sbERyYXcsX2ZuQXBwbHlUb0NoaWxkcmVuLF9mbkNhbGN1bGF0ZUNvbHVtbldpZHRocyxfZm5UaHJvdHRsZSxfZm5Db252ZXJ0VG9XaWR0aCxfZm5HZXRXaWRlc3ROb2RlLF9mbkdldE1heExlblN0cmluZyxfZm5TdHJpbmdUb0NzcyxfZm5Tb3J0RmxhdHRlbixfZm5Tb3J0LF9mblNvcnRBcmlhLF9mblNvcnRMaXN0ZW5lcixfZm5Tb3J0QXR0YWNoTGlzdGVuZXIsX2ZuU29ydGluZ0NsYXNzZXMsX2ZuU29ydERhdGEsX2ZuU2F2ZVN0YXRlLF9mbkxvYWRTdGF0ZSxfZm5TZXR0aW5nc0Zyb21Ob2RlLF9mbkxvZyxfZm5NYXAsX2ZuQmluZEFjdGlvbixfZm5DYWxsYmFja1JlZyxfZm5DYWxsYmFja0ZpcmUsX2ZuTGVuZ3RoT3ZlcmZsb3csX2ZuUmVuZGVyZXIsX2ZuRGF0YVNvdXJjZSxfZm5Sb3dBdHRyaWJ1dGVzKi9cblxuKGZ1bmN0aW9uKCBmYWN0b3J5ICkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHRpZiAoIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCApIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoIFsnanF1ZXJ5J10sIGZ1bmN0aW9uICggJCApIHtcblx0XHRcdHJldHVybiBmYWN0b3J5KCAkLCB3aW5kb3csIGRvY3VtZW50ICk7XG5cdFx0fSApO1xuXHR9XG5cdGVsc2UgaWYgKCB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChyb290LCAkKSB7XG5cdFx0XHRpZiAoICEgcm9vdCApIHtcblx0XHRcdFx0Ly8gQ29tbW9uSlMgZW52aXJvbm1lbnRzIHdpdGhvdXQgYSB3aW5kb3cgZ2xvYmFsIG11c3QgcGFzcyBhXG5cdFx0XHRcdC8vIHJvb3QuIFRoaXMgd2lsbCBnaXZlIGFuIGVycm9yIG90aGVyd2lzZVxuXHRcdFx0XHRyb290ID0gd2luZG93O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoICEgJCApIHtcblx0XHRcdFx0JCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gLy8galF1ZXJ5J3MgZmFjdG9yeSBjaGVja3MgZm9yIGEgZ2xvYmFsIHdpbmRvd1xuXHRcdFx0XHRcdHJlcXVpcmUoJ2pxdWVyeScpIDpcblx0XHRcdFx0XHRyZXF1aXJlKCdqcXVlcnknKSggcm9vdCApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZmFjdG9yeSggJCwgcm9vdCwgcm9vdC5kb2N1bWVudCApO1xuXHRcdH07XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gQnJvd3NlclxuXHRcdGZhY3RvcnkoIGpRdWVyeSwgd2luZG93LCBkb2N1bWVudCApO1xuXHR9XG59XG4oZnVuY3Rpb24oICQsIHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCApIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0LyoqXG5cdCAqIERhdGFUYWJsZXMgaXMgYSBwbHVnLWluIGZvciB0aGUgalF1ZXJ5IEphdmFzY3JpcHQgbGlicmFyeS4gSXQgaXMgYSBoaWdobHlcblx0ICogZmxleGlibGUgdG9vbCwgYmFzZWQgdXBvbiB0aGUgZm91bmRhdGlvbnMgb2YgcHJvZ3Jlc3NpdmUgZW5oYW5jZW1lbnQsXG5cdCAqIHdoaWNoIHdpbGwgYWRkIGFkdmFuY2VkIGludGVyYWN0aW9uIGNvbnRyb2xzIHRvIGFueSBIVE1MIHRhYmxlLiBGb3IgYVxuXHQgKiBmdWxsIGxpc3Qgb2YgZmVhdHVyZXMgcGxlYXNlIHJlZmVyIHRvXG5cdCAqIFtEYXRhVGFibGVzLm5ldF0oaHJlZj1cImh0dHA6Ly9kYXRhdGFibGVzLm5ldCkuXG5cdCAqXG5cdCAqIE5vdGUgdGhhdCB0aGUgYERhdGFUYWJsZWAgb2JqZWN0IGlzIG5vdCBhIGdsb2JhbCB2YXJpYWJsZSBidXQgaXMgYWxpYXNlZFxuXHQgKiB0byBgalF1ZXJ5LmZuLkRhdGFUYWJsZWAgYW5kIGBqUXVlcnkuZm4uZGF0YVRhYmxlYCB0aHJvdWdoIHdoaWNoIGl0IG1heVxuXHQgKiBiZSAgYWNjZXNzZWQuXG5cdCAqXG5cdCAqICBAY2xhc3Ncblx0ICogIEBwYXJhbSB7b2JqZWN0fSBbaW5pdD17fV0gQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIERhdGFUYWJsZXMuIE9wdGlvbnNcblx0ICogICAgYXJlIGRlZmluZWQgYnkge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c31cblx0ICogIEByZXF1aXJlcyBqUXVlcnkgMS43K1xuXHQgKlxuXHQgKiAgQGV4YW1wbGVcblx0ICogICAgLy8gQmFzaWMgaW5pdGlhbGlzYXRpb25cblx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uIHtcblx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xuXHQgKiAgICB9ICk7XG5cdCAqXG5cdCAqICBAZXhhbXBsZVxuXHQgKiAgICAvLyBJbml0aWFsaXNhdGlvbiB3aXRoIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyAtIGluIHRoaXMgY2FzZSwgZGlzYWJsZVxuXHQgKiAgICAvLyBwYWdpbmF0aW9uIGFuZCBzb3J0aW5nLlxuXHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24ge1xuXHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdCAqICAgICAgICBcInBhZ2luYXRlXCI6IGZhbHNlLFxuXHQgKiAgICAgICAgXCJzb3J0XCI6IGZhbHNlXG5cdCAqICAgICAgfSApO1xuXHQgKiAgICB9ICk7XG5cdCAqL1xuXHR2YXIgRGF0YVRhYmxlID0gZnVuY3Rpb24gKCBvcHRpb25zIClcblx0e1xuXHRcdC8qKlxuXHRcdCAqIFBlcmZvcm0gYSBqUXVlcnkgc2VsZWN0b3IgYWN0aW9uIG9uIHRoZSB0YWJsZSdzIFRSIGVsZW1lbnRzIChmcm9tIHRoZSB0Ym9keSkgYW5kXG5cdFx0ICogcmV0dXJuIHRoZSByZXN1bHRpbmcgalF1ZXJ5IG9iamVjdC5cblx0XHQgKiAgQHBhcmFtIHtzdHJpbmd8bm9kZXxqUXVlcnl9IHNTZWxlY3RvciBqUXVlcnkgc2VsZWN0b3Igb3Igbm9kZSBjb2xsZWN0aW9uIHRvIGFjdCBvblxuXHRcdCAqICBAcGFyYW0ge29iamVjdH0gW29PcHRzXSBPcHRpb25hbCBwYXJhbWV0ZXJzIGZvciBtb2RpZnlpbmcgdGhlIHJvd3MgdG8gYmUgaW5jbHVkZWRcblx0XHQgKiAgQHBhcmFtIHtzdHJpbmd9IFtvT3B0cy5maWx0ZXI9bm9uZV0gU2VsZWN0IFRSIGVsZW1lbnRzIHRoYXQgbWVldCB0aGUgY3VycmVudCBmaWx0ZXJcblx0XHQgKiAgICBjcml0ZXJpb24gKFwiYXBwbGllZFwiKSBvciBhbGwgVFIgZWxlbWVudHMgKGkuZS4gbm8gZmlsdGVyKS5cblx0XHQgKiAgQHBhcmFtIHtzdHJpbmd9IFtvT3B0cy5vcmRlcj1jdXJyZW50XSBPcmRlciBvZiB0aGUgVFIgZWxlbWVudHMgaW4gdGhlIHByb2Nlc3NlZCBhcnJheS5cblx0XHQgKiAgICBDYW4gYmUgZWl0aGVyICdjdXJyZW50Jywgd2hlcmVieSB0aGUgY3VycmVudCBzb3J0aW5nIG9mIHRoZSB0YWJsZSBpcyB1c2VkLCBvclxuXHRcdCAqICAgICdvcmlnaW5hbCcgd2hlcmVieSB0aGUgb3JpZ2luYWwgb3JkZXIgdGhlIGRhdGEgd2FzIHJlYWQgaW50byB0aGUgdGFibGUgaXMgdXNlZC5cblx0XHQgKiAgQHBhcmFtIHtzdHJpbmd9IFtvT3B0cy5wYWdlPWFsbF0gTGltaXQgdGhlIHNlbGVjdGlvbiB0byB0aGUgY3VycmVudGx5IGRpc3BsYXllZCBwYWdlXG5cdFx0ICogICAgKFwiY3VycmVudFwiKSBvciBub3QgKFwiYWxsXCIpLiBJZiAnY3VycmVudCcgaXMgZ2l2ZW4sIHRoZW4gb3JkZXIgaXMgYXNzdW1lZCB0byBiZVxuXHRcdCAqICAgICdjdXJyZW50JyBhbmQgZmlsdGVyIGlzICdhcHBsaWVkJywgcmVnYXJkbGVzcyBvZiB3aGF0IHRoZXkgbWlnaHQgYmUgZ2l2ZW4gYXMuXG5cdFx0ICogIEByZXR1cm5zIHtvYmplY3R9IGpRdWVyeSBvYmplY3QsIGZpbHRlcmVkIGJ5IHRoZSBnaXZlbiBzZWxlY3Rvci5cblx0XHQgKiAgQGR0b3B0IEFQSVxuXHRcdCAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICB2YXIgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcblx0XHQgKlxuXHRcdCAqICAgICAgLy8gSGlnaGxpZ2h0IGV2ZXJ5IHNlY29uZCByb3dcblx0XHQgKiAgICAgIG9UYWJsZS4kKCd0cjpvZGQnKS5jc3MoJ2JhY2tncm91bmRDb2xvcicsICdibHVlJyk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICB2YXIgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcblx0XHQgKlxuXHRcdCAqICAgICAgLy8gRmlsdGVyIHRvIHJvd3Mgd2l0aCAnV2Via2l0JyBpbiB0aGVtLCBhZGQgYSBiYWNrZ3JvdW5kIGNvbG91ciBhbmQgdGhlblxuXHRcdCAqICAgICAgLy8gcmVtb3ZlIHRoZSBmaWx0ZXIsIHRodXMgaGlnaGxpZ2h0aW5nIHRoZSAnV2Via2l0JyByb3dzIG9ubHkuXG5cdFx0ICogICAgICBvVGFibGUuZm5GaWx0ZXIoJ1dlYmtpdCcpO1xuXHRcdCAqICAgICAgb1RhYmxlLiQoJ3RyJywge1wic2VhcmNoXCI6IFwiYXBwbGllZFwifSkuY3NzKCdiYWNrZ3JvdW5kQ29sb3InLCAnYmx1ZScpO1xuXHRcdCAqICAgICAgb1RhYmxlLmZuRmlsdGVyKCcnKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0dGhpcy4kID0gZnVuY3Rpb24gKCBzU2VsZWN0b3IsIG9PcHRzIClcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5hcGkodHJ1ZSkuJCggc1NlbGVjdG9yLCBvT3B0cyApO1xuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQWxtb3N0IGlkZW50aWNhbCB0byAkIGluIG9wZXJhdGlvbiwgYnV0IGluIHRoaXMgY2FzZSByZXR1cm5zIHRoZSBkYXRhIGZvciB0aGUgbWF0Y2hlZFxuXHRcdCAqIHJvd3MgLSBhcyBzdWNoLCB0aGUgalF1ZXJ5IHNlbGVjdG9yIHVzZWQgc2hvdWxkIG1hdGNoIFRSIHJvdyBub2RlcyBvciBURC9USCBjZWxsIG5vZGVzXG5cdFx0ICogcmF0aGVyIHRoYW4gYW55IGRlc2NlbmRhbnRzLCBzbyB0aGUgZGF0YSBjYW4gYmUgb2J0YWluZWQgZm9yIHRoZSByb3cvY2VsbC4gSWYgbWF0Y2hpbmdcblx0XHQgKiByb3dzIGFyZSBmb3VuZCwgdGhlIGRhdGEgcmV0dXJuZWQgaXMgdGhlIG9yaWdpbmFsIGRhdGEgYXJyYXkvb2JqZWN0IHRoYXQgd2FzIHVzZWQgdG9cblx0XHQgKiBjcmVhdGUgdGhlIHJvdyAob3IgYSBnZW5lcmF0ZWQgYXJyYXkgaWYgZnJvbSBhIERPTSBzb3VyY2UpLlxuXHRcdCAqXG5cdFx0ICogVGhpcyBtZXRob2QgaXMgb2Z0ZW4gdXNlZnVsIGluLWNvbWJpbmF0aW9uIHdpdGggJCB3aGVyZSBib3RoIGZ1bmN0aW9ucyBhcmUgZ2l2ZW4gdGhlXG5cdFx0ICogc2FtZSBwYXJhbWV0ZXJzIGFuZCB0aGUgYXJyYXkgaW5kZXhlcyB3aWxsIG1hdGNoIGlkZW50aWNhbGx5LlxuXHRcdCAqICBAcGFyYW0ge3N0cmluZ3xub2RlfGpRdWVyeX0gc1NlbGVjdG9yIGpRdWVyeSBzZWxlY3RvciBvciBub2RlIGNvbGxlY3Rpb24gdG8gYWN0IG9uXG5cdFx0ICogIEBwYXJhbSB7b2JqZWN0fSBbb09wdHNdIE9wdGlvbmFsIHBhcmFtZXRlcnMgZm9yIG1vZGlmeWluZyB0aGUgcm93cyB0byBiZSBpbmNsdWRlZFxuXHRcdCAqICBAcGFyYW0ge3N0cmluZ30gW29PcHRzLmZpbHRlcj1ub25lXSBTZWxlY3QgZWxlbWVudHMgdGhhdCBtZWV0IHRoZSBjdXJyZW50IGZpbHRlclxuXHRcdCAqICAgIGNyaXRlcmlvbiAoXCJhcHBsaWVkXCIpIG9yIGFsbCBlbGVtZW50cyAoaS5lLiBubyBmaWx0ZXIpLlxuXHRcdCAqICBAcGFyYW0ge3N0cmluZ30gW29PcHRzLm9yZGVyPWN1cnJlbnRdIE9yZGVyIG9mIHRoZSBkYXRhIGluIHRoZSBwcm9jZXNzZWQgYXJyYXkuXG5cdFx0ICogICAgQ2FuIGJlIGVpdGhlciAnY3VycmVudCcsIHdoZXJlYnkgdGhlIGN1cnJlbnQgc29ydGluZyBvZiB0aGUgdGFibGUgaXMgdXNlZCwgb3Jcblx0XHQgKiAgICAnb3JpZ2luYWwnIHdoZXJlYnkgdGhlIG9yaWdpbmFsIG9yZGVyIHRoZSBkYXRhIHdhcyByZWFkIGludG8gdGhlIHRhYmxlIGlzIHVzZWQuXG5cdFx0ICogIEBwYXJhbSB7c3RyaW5nfSBbb09wdHMucGFnZT1hbGxdIExpbWl0IHRoZSBzZWxlY3Rpb24gdG8gdGhlIGN1cnJlbnRseSBkaXNwbGF5ZWQgcGFnZVxuXHRcdCAqICAgIChcImN1cnJlbnRcIikgb3Igbm90IChcImFsbFwiKS4gSWYgJ2N1cnJlbnQnIGlzIGdpdmVuLCB0aGVuIG9yZGVyIGlzIGFzc3VtZWQgdG8gYmVcblx0XHQgKiAgICAnY3VycmVudCcgYW5kIGZpbHRlciBpcyAnYXBwbGllZCcsIHJlZ2FyZGxlc3Mgb2Ygd2hhdCB0aGV5IG1pZ2h0IGJlIGdpdmVuIGFzLlxuXHRcdCAqICBAcmV0dXJucyB7YXJyYXl9IERhdGEgZm9yIHRoZSBtYXRjaGVkIGVsZW1lbnRzLiBJZiBhbnkgZWxlbWVudHMsIGFzIGEgcmVzdWx0IG9mIHRoZVxuXHRcdCAqICAgIHNlbGVjdG9yLCB3ZXJlIG5vdCBUUiwgVEQgb3IgVEggZWxlbWVudHMgaW4gdGhlIERhdGFUYWJsZSwgdGhleSB3aWxsIGhhdmUgYSBudWxsXG5cdFx0ICogICAgZW50cnkgaW4gdGhlIGFycmF5LlxuXHRcdCAqICBAZHRvcHQgQVBJXG5cdFx0ICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgIHZhciBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xuXHRcdCAqXG5cdFx0ICogICAgICAvLyBHZXQgdGhlIGRhdGEgZnJvbSB0aGUgZmlyc3Qgcm93IGluIHRoZSB0YWJsZVxuXHRcdCAqICAgICAgdmFyIGRhdGEgPSBvVGFibGUuXygndHI6Zmlyc3QnKTtcblx0XHQgKlxuXHRcdCAqICAgICAgLy8gRG8gc29tZXRoaW5nIHVzZWZ1bCB3aXRoIHRoZSBkYXRhXG5cdFx0ICogICAgICBhbGVydCggXCJGaXJzdCBjZWxsIGlzOiBcIitkYXRhWzBdICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICB2YXIgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcblx0XHQgKlxuXHRcdCAqICAgICAgLy8gRmlsdGVyIHRvICdXZWJraXQnIGFuZCBnZXQgYWxsIGRhdGEgZm9yXG5cdFx0ICogICAgICBvVGFibGUuZm5GaWx0ZXIoJ1dlYmtpdCcpO1xuXHRcdCAqICAgICAgdmFyIGRhdGEgPSBvVGFibGUuXygndHInLCB7XCJzZWFyY2hcIjogXCJhcHBsaWVkXCJ9KTtcblx0XHQgKlxuXHRcdCAqICAgICAgLy8gRG8gc29tZXRoaW5nIHdpdGggdGhlIGRhdGFcblx0XHQgKiAgICAgIGFsZXJ0KCBkYXRhLmxlbmd0aCtcIiByb3dzIG1hdGNoZWQgdGhlIHNlYXJjaFwiICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdHRoaXMuXyA9IGZ1bmN0aW9uICggc1NlbGVjdG9yLCBvT3B0cyApXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMuYXBpKHRydWUpLnJvd3MoIHNTZWxlY3Rvciwgb09wdHMgKS5kYXRhKCk7XG5cdFx0fTtcblx0XHRcblx0XHRcblx0XHQvKipcblx0XHQgKiBDcmVhdGUgYSBEYXRhVGFibGVzIEFwaSBpbnN0YW5jZSwgd2l0aCB0aGUgY3VycmVudGx5IHNlbGVjdGVkIHRhYmxlcyBmb3Jcblx0XHQgKiB0aGUgQXBpJ3MgY29udGV4dC5cblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IFt0cmFkaXRpb25hbD1mYWxzZV0gU2V0IHRoZSBBUEkgaW5zdGFuY2UncyBjb250ZXh0IHRvIGJlXG5cdFx0ICogICBvbmx5IHRoZSB0YWJsZSByZWZlcnJlZCB0byBieSB0aGUgYERhdGFUYWJsZS5leHQuaUFwaUluZGV4YCBvcHRpb24sIGFzIHdhc1xuXHRcdCAqICAgdXNlZCBpbiB0aGUgQVBJIHByZXNlbnRlZCBieSBEYXRhVGFibGVzIDEuOS0gKGkuZS4gdGhlIHRyYWRpdGlvbmFsIG1vZGUpLFxuXHRcdCAqICAgb3IgaWYgYWxsIHRhYmxlcyBjYXB0dXJlZCBpbiB0aGUgalF1ZXJ5IG9iamVjdCBzaG91bGQgYmUgdXNlZC5cblx0XHQgKiBAcmV0dXJuIHtEYXRhVGFibGVzLkFwaX1cblx0XHQgKi9cblx0XHR0aGlzLmFwaSA9IGZ1bmN0aW9uICggdHJhZGl0aW9uYWwgKVxuXHRcdHtcblx0XHRcdHJldHVybiB0cmFkaXRpb25hbCA/XG5cdFx0XHRcdG5ldyBfQXBpKFxuXHRcdFx0XHRcdF9mblNldHRpbmdzRnJvbU5vZGUoIHRoaXNbIF9leHQuaUFwaUluZGV4IF0gKVxuXHRcdFx0XHQpIDpcblx0XHRcdFx0bmV3IF9BcGkoIHRoaXMgKTtcblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEFkZCBhIHNpbmdsZSBuZXcgcm93IG9yIG11bHRpcGxlIHJvd3Mgb2YgZGF0YSB0byB0aGUgdGFibGUuIFBsZWFzZSBub3RlXG5cdFx0ICogdGhhdCB0aGlzIGlzIHN1aXRhYmxlIGZvciBjbGllbnQtc2lkZSBwcm9jZXNzaW5nIG9ubHkgLSBpZiB5b3UgYXJlIHVzaW5nXG5cdFx0ICogc2VydmVyLXNpZGUgcHJvY2Vzc2luZyAoaS5lLiBcImJTZXJ2ZXJTaWRlXCI6IHRydWUpLCB0aGVuIHRvIGFkZCBkYXRhLCB5b3Vcblx0XHQgKiBtdXN0IGFkZCBpdCB0byB0aGUgZGF0YSBzb3VyY2UsIGkuZS4gdGhlIHNlcnZlci1zaWRlLCB0aHJvdWdoIGFuIEFqYXggY2FsbC5cblx0XHQgKiAgQHBhcmFtIHthcnJheXxvYmplY3R9IGRhdGEgVGhlIGRhdGEgdG8gYmUgYWRkZWQgdG8gdGhlIHRhYmxlLiBUaGlzIGNhbiBiZTpcblx0XHQgKiAgICA8dWw+XG5cdFx0ICogICAgICA8bGk+MUQgYXJyYXkgb2YgZGF0YSAtIGFkZCBhIHNpbmdsZSByb3cgd2l0aCB0aGUgZGF0YSBwcm92aWRlZDwvbGk+XG5cdFx0ICogICAgICA8bGk+MkQgYXJyYXkgb2YgYXJyYXlzIC0gYWRkIG11bHRpcGxlIHJvd3MgaW4gYSBzaW5nbGUgY2FsbDwvbGk+XG5cdFx0ICogICAgICA8bGk+b2JqZWN0IC0gZGF0YSBvYmplY3Qgd2hlbiB1c2luZyA8aT5tRGF0YTwvaT48L2xpPlxuXHRcdCAqICAgICAgPGxpPmFycmF5IG9mIG9iamVjdHMgLSBtdWx0aXBsZSBkYXRhIG9iamVjdHMgd2hlbiB1c2luZyA8aT5tRGF0YTwvaT48L2xpPlxuXHRcdCAqICAgIDwvdWw+XG5cdFx0ICogIEBwYXJhbSB7Ym9vbH0gW3JlZHJhdz10cnVlXSByZWRyYXcgdGhlIHRhYmxlIG9yIG5vdFxuXHRcdCAqICBAcmV0dXJucyB7YXJyYXl9IEFuIGFycmF5IG9mIGludGVnZXJzLCByZXByZXNlbnRpbmcgdGhlIGxpc3Qgb2YgaW5kZXhlcyBpblxuXHRcdCAqICAgIDxpPmFvRGF0YTwvaT4gKHtAbGluayBEYXRhVGFibGUubW9kZWxzLm9TZXR0aW5nc30pIHRoYXQgaGF2ZSBiZWVuIGFkZGVkIHRvXG5cdFx0ICogICAgdGhlIHRhYmxlLlxuXHRcdCAqICBAZHRvcHQgQVBJXG5cdFx0ICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBHbG9iYWwgdmFyIGZvciBjb3VudGVyXG5cdFx0ICogICAgdmFyIGdpQ291bnQgPSAyO1xuXHRcdCAqXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKlxuXHRcdCAqICAgIGZ1bmN0aW9uIGZuQ2xpY2tBZGRSb3coKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpLmZuQWRkRGF0YSggW1xuXHRcdCAqICAgICAgICBnaUNvdW50K1wiLjFcIixcblx0XHQgKiAgICAgICAgZ2lDb3VudCtcIi4yXCIsXG5cdFx0ICogICAgICAgIGdpQ291bnQrXCIuM1wiLFxuXHRcdCAqICAgICAgICBnaUNvdW50K1wiLjRcIiBdXG5cdFx0ICogICAgICApO1xuXHRcdCAqXG5cdFx0ICogICAgICBnaUNvdW50Kys7XG5cdFx0ICogICAgfVxuXHRcdCAqL1xuXHRcdHRoaXMuZm5BZGREYXRhID0gZnVuY3Rpb24oIGRhdGEsIHJlZHJhdyApXG5cdFx0e1xuXHRcdFx0dmFyIGFwaSA9IHRoaXMuYXBpKCB0cnVlICk7XG5cdFx0XG5cdFx0XHQvKiBDaGVjayBpZiB3ZSB3YW50IHRvIGFkZCBtdWx0aXBsZSByb3dzIG9yIG5vdCAqL1xuXHRcdFx0dmFyIHJvd3MgPSAkLmlzQXJyYXkoZGF0YSkgJiYgKCAkLmlzQXJyYXkoZGF0YVswXSkgfHwgJC5pc1BsYWluT2JqZWN0KGRhdGFbMF0pICkgP1xuXHRcdFx0XHRhcGkucm93cy5hZGQoIGRhdGEgKSA6XG5cdFx0XHRcdGFwaS5yb3cuYWRkKCBkYXRhICk7XG5cdFx0XG5cdFx0XHRpZiAoIHJlZHJhdyA9PT0gdW5kZWZpbmVkIHx8IHJlZHJhdyApIHtcblx0XHRcdFx0YXBpLmRyYXcoKTtcblx0XHRcdH1cblx0XHRcblx0XHRcdHJldHVybiByb3dzLmZsYXR0ZW4oKS50b0FycmF5KCk7XG5cdFx0fTtcblx0XHRcblx0XHRcblx0XHQvKipcblx0XHQgKiBUaGlzIGZ1bmN0aW9uIHdpbGwgbWFrZSBEYXRhVGFibGVzIHJlY2FsY3VsYXRlIHRoZSBjb2x1bW4gc2l6ZXMsIGJhc2VkIG9uIHRoZSBkYXRhXG5cdFx0ICogY29udGFpbmVkIGluIHRoZSB0YWJsZSBhbmQgdGhlIHNpemVzIGFwcGxpZWQgdG8gdGhlIGNvbHVtbnMgKGluIHRoZSBET00sIENTUyBvclxuXHRcdCAqIHRocm91Z2ggdGhlIHNXaWR0aCBwYXJhbWV0ZXIpLiBUaGlzIGNhbiBiZSB1c2VmdWwgd2hlbiB0aGUgd2lkdGggb2YgdGhlIHRhYmxlJ3Ncblx0XHQgKiBwYXJlbnQgZWxlbWVudCBjaGFuZ2VzIChmb3IgZXhhbXBsZSBhIHdpbmRvdyByZXNpemUpLlxuXHRcdCAqICBAcGFyYW0ge2Jvb2xlYW59IFtiUmVkcmF3PXRydWVdIFJlZHJhdyB0aGUgdGFibGUgb3Igbm90LCB5b3Ugd2lsbCB0eXBpY2FsbHkgd2FudCB0b1xuXHRcdCAqICBAZHRvcHQgQVBJXG5cdFx0ICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgIHZhciBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcInNTY3JvbGxZXCI6IFwiMjAwcHhcIixcblx0XHQgKiAgICAgICAgXCJiUGFnaW5hdGVcIjogZmFsc2Vcblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKlxuXHRcdCAqICAgICAgJCh3aW5kb3cpLm9uKCdyZXNpemUnLCBmdW5jdGlvbiAoKSB7XG5cdFx0ICogICAgICAgIG9UYWJsZS5mbkFkanVzdENvbHVtblNpemluZygpO1xuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHR0aGlzLmZuQWRqdXN0Q29sdW1uU2l6aW5nID0gZnVuY3Rpb24gKCBiUmVkcmF3IClcblx0XHR7XG5cdFx0XHR2YXIgYXBpID0gdGhpcy5hcGkoIHRydWUgKS5jb2x1bW5zLmFkanVzdCgpO1xuXHRcdFx0dmFyIHNldHRpbmdzID0gYXBpLnNldHRpbmdzKClbMF07XG5cdFx0XHR2YXIgc2Nyb2xsID0gc2V0dGluZ3Mub1Njcm9sbDtcblx0XHRcblx0XHRcdGlmICggYlJlZHJhdyA9PT0gdW5kZWZpbmVkIHx8IGJSZWRyYXcgKSB7XG5cdFx0XHRcdGFwaS5kcmF3KCBmYWxzZSApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIHNjcm9sbC5zWCAhPT0gXCJcIiB8fCBzY3JvbGwuc1kgIT09IFwiXCIgKSB7XG5cdFx0XHRcdC8qIElmIG5vdCByZWRyYXdpbmcsIGJ1dCBzY3JvbGxpbmcsIHdlIHdhbnQgdG8gYXBwbHkgdGhlIG5ldyBjb2x1bW4gc2l6ZXMgYW55d2F5ICovXG5cdFx0XHRcdF9mblNjcm9sbERyYXcoIHNldHRpbmdzICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRcblx0XHRcblx0XHQvKipcblx0XHQgKiBRdWlja2x5IGFuZCBzaW1wbHkgY2xlYXIgYSB0YWJsZVxuXHRcdCAqICBAcGFyYW0ge2Jvb2x9IFtiUmVkcmF3PXRydWVdIHJlZHJhdyB0aGUgdGFibGUgb3Igbm90XG5cdFx0ICogIEBkdG9wdCBBUElcblx0XHQgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgdmFyIG9UYWJsZSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XG5cdFx0ICpcblx0XHQgKiAgICAgIC8vIEltbWVkaWF0ZWx5ICdudWtlJyB0aGUgY3VycmVudCByb3dzIChwZXJoYXBzIHdhaXRpbmcgZm9yIGFuIEFqYXggY2FsbGJhY2suLi4pXG5cdFx0ICogICAgICBvVGFibGUuZm5DbGVhclRhYmxlKCk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdHRoaXMuZm5DbGVhclRhYmxlID0gZnVuY3Rpb24oIGJSZWRyYXcgKVxuXHRcdHtcblx0XHRcdHZhciBhcGkgPSB0aGlzLmFwaSggdHJ1ZSApLmNsZWFyKCk7XG5cdFx0XG5cdFx0XHRpZiAoIGJSZWRyYXcgPT09IHVuZGVmaW5lZCB8fCBiUmVkcmF3ICkge1xuXHRcdFx0XHRhcGkuZHJhdygpO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIGV4YWN0IG9wcG9zaXRlIG9mICdvcGVuaW5nJyBhIHJvdywgdGhpcyBmdW5jdGlvbiB3aWxsIGNsb3NlIGFueSByb3dzIHdoaWNoXG5cdFx0ICogYXJlIGN1cnJlbnRseSAnb3BlbicuXG5cdFx0ICogIEBwYXJhbSB7bm9kZX0gblRyIHRoZSB0YWJsZSByb3cgdG8gJ2Nsb3NlJ1xuXHRcdCAqICBAcmV0dXJucyB7aW50fSAwIG9uIHN1Y2Nlc3MsIG9yIDEgaWYgZmFpbGVkIChjYW4ndCBmaW5kIHRoZSByb3cpXG5cdFx0ICogIEBkdG9wdCBBUElcblx0XHQgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgdmFyIG9UYWJsZTtcblx0XHQgKlxuXHRcdCAqICAgICAgLy8gJ29wZW4nIGFuIGluZm9ybWF0aW9uIHJvdyB3aGVuIGEgcm93IGlzIGNsaWNrZWQgb25cblx0XHQgKiAgICAgICQoJyNleGFtcGxlIHRib2R5IHRyJykuY2xpY2soIGZ1bmN0aW9uICgpIHtcblx0XHQgKiAgICAgICAgaWYgKCBvVGFibGUuZm5Jc09wZW4odGhpcykgKSB7XG5cdFx0ICogICAgICAgICAgb1RhYmxlLmZuQ2xvc2UoIHRoaXMgKTtcblx0XHQgKiAgICAgICAgfSBlbHNlIHtcblx0XHQgKiAgICAgICAgICBvVGFibGUuZm5PcGVuKCB0aGlzLCBcIlRlbXBvcmFyeSByb3cgb3BlbmVkXCIsIFwiaW5mb19yb3dcIiApO1xuXHRcdCAqICAgICAgICB9XG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICpcblx0XHQgKiAgICAgIG9UYWJsZSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdHRoaXMuZm5DbG9zZSA9IGZ1bmN0aW9uKCBuVHIgKVxuXHRcdHtcblx0XHRcdHRoaXMuYXBpKCB0cnVlICkucm93KCBuVHIgKS5jaGlsZC5oaWRlKCk7XG5cdFx0fTtcblx0XHRcblx0XHRcblx0XHQvKipcblx0XHQgKiBSZW1vdmUgYSByb3cgZm9yIHRoZSB0YWJsZVxuXHRcdCAqICBAcGFyYW0ge21peGVkfSB0YXJnZXQgVGhlIGluZGV4IG9mIHRoZSByb3cgZnJvbSBhb0RhdGEgdG8gYmUgZGVsZXRlZCwgb3Jcblx0XHQgKiAgICB0aGUgVFIgZWxlbWVudCB5b3Ugd2FudCB0byBkZWxldGVcblx0XHQgKiAgQHBhcmFtIHtmdW5jdGlvbnxudWxsfSBbY2FsbEJhY2tdIENhbGxiYWNrIGZ1bmN0aW9uXG5cdFx0ICogIEBwYXJhbSB7Ym9vbH0gW3JlZHJhdz10cnVlXSBSZWRyYXcgdGhlIHRhYmxlIG9yIG5vdFxuXHRcdCAqICBAcmV0dXJucyB7YXJyYXl9IFRoZSByb3cgdGhhdCB3YXMgZGVsZXRlZFxuXHRcdCAqICBAZHRvcHQgQVBJXG5cdFx0ICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgIHZhciBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xuXHRcdCAqXG5cdFx0ICogICAgICAvLyBJbW1lZGlhdGVseSByZW1vdmUgdGhlIGZpcnN0IHJvd1xuXHRcdCAqICAgICAgb1RhYmxlLmZuRGVsZXRlUm93KCAwICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdHRoaXMuZm5EZWxldGVSb3cgPSBmdW5jdGlvbiggdGFyZ2V0LCBjYWxsYmFjaywgcmVkcmF3IClcblx0XHR7XG5cdFx0XHR2YXIgYXBpID0gdGhpcy5hcGkoIHRydWUgKTtcblx0XHRcdHZhciByb3dzID0gYXBpLnJvd3MoIHRhcmdldCApO1xuXHRcdFx0dmFyIHNldHRpbmdzID0gcm93cy5zZXR0aW5ncygpWzBdO1xuXHRcdFx0dmFyIGRhdGEgPSBzZXR0aW5ncy5hb0RhdGFbIHJvd3NbMF1bMF0gXTtcblx0XHRcblx0XHRcdHJvd3MucmVtb3ZlKCk7XG5cdFx0XG5cdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRjYWxsYmFjay5jYWxsKCB0aGlzLCBzZXR0aW5ncywgZGF0YSApO1xuXHRcdFx0fVxuXHRcdFxuXHRcdFx0aWYgKCByZWRyYXcgPT09IHVuZGVmaW5lZCB8fCByZWRyYXcgKSB7XG5cdFx0XHRcdGFwaS5kcmF3KCk7XG5cdFx0XHR9XG5cdFx0XG5cdFx0XHRyZXR1cm4gZGF0YTtcblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJlc3RvcmUgdGhlIHRhYmxlIHRvIGl0J3Mgb3JpZ2luYWwgc3RhdGUgaW4gdGhlIERPTSBieSByZW1vdmluZyBhbGwgb2YgRGF0YVRhYmxlc1xuXHRcdCAqIGVuaGFuY2VtZW50cywgYWx0ZXJhdGlvbnMgdG8gdGhlIERPTSBzdHJ1Y3R1cmUgb2YgdGhlIHRhYmxlIGFuZCBldmVudCBsaXN0ZW5lcnMuXG5cdFx0ICogIEBwYXJhbSB7Ym9vbGVhbn0gW3JlbW92ZT1mYWxzZV0gQ29tcGxldGVseSByZW1vdmUgdGhlIHRhYmxlIGZyb20gdGhlIERPTVxuXHRcdCAqICBAZHRvcHQgQVBJXG5cdFx0ICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgIC8vIFRoaXMgZXhhbXBsZSBpcyBmYWlybHkgcG9pbnRsZXNzIGluIHJlYWxpdHksIGJ1dCBzaG93cyBob3cgZm5EZXN0cm95IGNhbiBiZSB1c2VkXG5cdFx0ICogICAgICB2YXIgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcblx0XHQgKiAgICAgIG9UYWJsZS5mbkRlc3Ryb3koKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0dGhpcy5mbkRlc3Ryb3kgPSBmdW5jdGlvbiAoIHJlbW92ZSApXG5cdFx0e1xuXHRcdFx0dGhpcy5hcGkoIHRydWUgKS5kZXN0cm95KCByZW1vdmUgKTtcblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJlZHJhdyB0aGUgdGFibGVcblx0XHQgKiAgQHBhcmFtIHtib29sfSBbY29tcGxldGU9dHJ1ZV0gUmUtZmlsdGVyIGFuZCByZXNvcnQgKGlmIGVuYWJsZWQpIHRoZSB0YWJsZSBiZWZvcmUgdGhlIGRyYXcuXG5cdFx0ICogIEBkdG9wdCBBUElcblx0XHQgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgdmFyIG9UYWJsZSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XG5cdFx0ICpcblx0XHQgKiAgICAgIC8vIFJlLWRyYXcgdGhlIHRhYmxlIC0geW91IHdvdWxkbid0IHdhbnQgdG8gZG8gaXQgaGVyZSwgYnV0IGl0J3MgYW4gZXhhbXBsZSA6LSlcblx0XHQgKiAgICAgIG9UYWJsZS5mbkRyYXcoKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0dGhpcy5mbkRyYXcgPSBmdW5jdGlvbiggY29tcGxldGUgKVxuXHRcdHtcblx0XHRcdC8vIE5vdGUgdGhhdCB0aGlzIGlzbid0IGFuIGV4YWN0IG1hdGNoIHRvIHRoZSBvbGQgY2FsbCB0byBfZm5EcmF3IC0gaXQgdGFrZXNcblx0XHRcdC8vIGludG8gYWNjb3VudCB0aGUgbmV3IGRhdGEsIGJ1dCBjYW4gaG9sZCBwb3NpdGlvbi5cblx0XHRcdHRoaXMuYXBpKCB0cnVlICkuZHJhdyggY29tcGxldGUgKTtcblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEZpbHRlciB0aGUgaW5wdXQgYmFzZWQgb24gZGF0YVxuXHRcdCAqICBAcGFyYW0ge3N0cmluZ30gc0lucHV0IFN0cmluZyB0byBmaWx0ZXIgdGhlIHRhYmxlIG9uXG5cdFx0ICogIEBwYXJhbSB7aW50fG51bGx9IFtpQ29sdW1uXSBDb2x1bW4gdG8gbGltaXQgZmlsdGVyaW5nIHRvXG5cdFx0ICogIEBwYXJhbSB7Ym9vbH0gW2JSZWdleD1mYWxzZV0gVHJlYXQgYXMgcmVndWxhciBleHByZXNzaW9uIG9yIG5vdFxuXHRcdCAqICBAcGFyYW0ge2Jvb2x9IFtiU21hcnQ9dHJ1ZV0gUGVyZm9ybSBzbWFydCBmaWx0ZXJpbmcgb3Igbm90XG5cdFx0ICogIEBwYXJhbSB7Ym9vbH0gW2JTaG93R2xvYmFsPXRydWVdIFNob3cgdGhlIGlucHV0IGdsb2JhbCBmaWx0ZXIgaW4gaXQncyBpbnB1dCBib3goZXMpXG5cdFx0ICogIEBwYXJhbSB7Ym9vbH0gW2JDYXNlSW5zZW5zaXRpdmU9dHJ1ZV0gRG8gY2FzZS1pbnNlbnNpdGl2ZSBtYXRjaGluZyAodHJ1ZSkgb3Igbm90IChmYWxzZSlcblx0XHQgKiAgQGR0b3B0IEFQSVxuXHRcdCAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICB2YXIgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcblx0XHQgKlxuXHRcdCAqICAgICAgLy8gU29tZXRpbWUgbGF0ZXIgLSBmaWx0ZXIuLi5cblx0XHQgKiAgICAgIG9UYWJsZS5mbkZpbHRlciggJ3Rlc3Qgc3RyaW5nJyApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHR0aGlzLmZuRmlsdGVyID0gZnVuY3Rpb24oIHNJbnB1dCwgaUNvbHVtbiwgYlJlZ2V4LCBiU21hcnQsIGJTaG93R2xvYmFsLCBiQ2FzZUluc2Vuc2l0aXZlIClcblx0XHR7XG5cdFx0XHR2YXIgYXBpID0gdGhpcy5hcGkoIHRydWUgKTtcblx0XHRcblx0XHRcdGlmICggaUNvbHVtbiA9PT0gbnVsbCB8fCBpQ29sdW1uID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdGFwaS5zZWFyY2goIHNJbnB1dCwgYlJlZ2V4LCBiU21hcnQsIGJDYXNlSW5zZW5zaXRpdmUgKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRhcGkuY29sdW1uKCBpQ29sdW1uICkuc2VhcmNoKCBzSW5wdXQsIGJSZWdleCwgYlNtYXJ0LCBiQ2FzZUluc2Vuc2l0aXZlICk7XG5cdFx0XHR9XG5cdFx0XG5cdFx0XHRhcGkuZHJhdygpO1xuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogR2V0IHRoZSBkYXRhIGZvciB0aGUgd2hvbGUgdGFibGUsIGFuIGluZGl2aWR1YWwgcm93IG9yIGFuIGluZGl2aWR1YWwgY2VsbCBiYXNlZCBvbiB0aGVcblx0XHQgKiBwcm92aWRlZCBwYXJhbWV0ZXJzLlxuXHRcdCAqICBAcGFyYW0ge2ludHxub2RlfSBbc3JjXSBBIFRSIHJvdyBub2RlLCBURC9USCBjZWxsIG5vZGUgb3IgYW4gaW50ZWdlci4gSWYgZ2l2ZW4gYXNcblx0XHQgKiAgICBhIFRSIG5vZGUgdGhlbiB0aGUgZGF0YSBzb3VyY2UgZm9yIHRoZSB3aG9sZSByb3cgd2lsbCBiZSByZXR1cm5lZC4gSWYgZ2l2ZW4gYXMgYVxuXHRcdCAqICAgIFREL1RIIGNlbGwgbm9kZSB0aGVuIGlDb2wgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGNhbGN1bGF0ZWQgYW5kIHRoZSBkYXRhIGZvciB0aGVcblx0XHQgKiAgICBjZWxsIHJldHVybmVkLiBJZiBnaXZlbiBhcyBhbiBpbnRlZ2VyLCB0aGVuIHRoaXMgaXMgdHJlYXRlZCBhcyB0aGUgYW9EYXRhIGludGVybmFsXG5cdFx0ICogICAgZGF0YSBpbmRleCBmb3IgdGhlIHJvdyAoc2VlIGZuR2V0UG9zaXRpb24pIGFuZCB0aGUgZGF0YSBmb3IgdGhhdCByb3cgdXNlZC5cblx0XHQgKiAgQHBhcmFtIHtpbnR9IFtjb2xdIE9wdGlvbmFsIGNvbHVtbiBpbmRleCB0aGF0IHlvdSB3YW50IHRoZSBkYXRhIG9mLlxuXHRcdCAqICBAcmV0dXJucyB7YXJyYXl8b2JqZWN0fHN0cmluZ30gSWYgbVJvdyBpcyB1bmRlZmluZWQsIHRoZW4gdGhlIGRhdGEgZm9yIGFsbCByb3dzIGlzXG5cdFx0ICogICAgcmV0dXJuZWQuIElmIG1Sb3cgaXMgZGVmaW5lZCwganVzdCBkYXRhIGZvciB0aGF0IHJvdywgYW5kIGlzIGlDb2wgaXNcblx0XHQgKiAgICBkZWZpbmVkLCBvbmx5IGRhdGEgZm9yIHRoZSBkZXNpZ25hdGVkIGNlbGwgaXMgcmV0dXJuZWQuXG5cdFx0ICogIEBkdG9wdCBBUElcblx0XHQgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIFJvdyBkYXRhXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xuXHRcdCAqXG5cdFx0ICogICAgICBvVGFibGUuJCgndHInKS5jbGljayggZnVuY3Rpb24gKCkge1xuXHRcdCAqICAgICAgICB2YXIgZGF0YSA9IG9UYWJsZS5mbkdldERhdGEoIHRoaXMgKTtcblx0XHQgKiAgICAgICAgLy8gLi4uIGRvIHNvbWV0aGluZyB3aXRoIHRoZSBhcnJheSAvIG9iamVjdCBvZiBkYXRhIGZvciB0aGUgcm93XG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gSW5kaXZpZHVhbCBjZWxsIGRhdGFcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgIG9UYWJsZSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XG5cdFx0ICpcblx0XHQgKiAgICAgIG9UYWJsZS4kKCd0ZCcpLmNsaWNrKCBmdW5jdGlvbiAoKSB7XG5cdFx0ICogICAgICAgIHZhciBzRGF0YSA9IG9UYWJsZS5mbkdldERhdGEoIHRoaXMgKTtcblx0XHQgKiAgICAgICAgYWxlcnQoICdUaGUgY2VsbCBjbGlja2VkIG9uIGhhZCB0aGUgdmFsdWUgb2YgJytzRGF0YSApO1xuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHR0aGlzLmZuR2V0RGF0YSA9IGZ1bmN0aW9uKCBzcmMsIGNvbCApXG5cdFx0e1xuXHRcdFx0dmFyIGFwaSA9IHRoaXMuYXBpKCB0cnVlICk7XG5cdFx0XG5cdFx0XHRpZiAoIHNyYyAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHR2YXIgdHlwZSA9IHNyYy5ub2RlTmFtZSA/IHNyYy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIDogJyc7XG5cdFx0XG5cdFx0XHRcdHJldHVybiBjb2wgIT09IHVuZGVmaW5lZCB8fCB0eXBlID09ICd0ZCcgfHwgdHlwZSA9PSAndGgnID9cblx0XHRcdFx0XHRhcGkuY2VsbCggc3JjLCBjb2wgKS5kYXRhKCkgOlxuXHRcdFx0XHRcdGFwaS5yb3coIHNyYyApLmRhdGEoKSB8fCBudWxsO1xuXHRcdFx0fVxuXHRcdFxuXHRcdFx0cmV0dXJuIGFwaS5kYXRhKCkudG9BcnJheSgpO1xuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogR2V0IGFuIGFycmF5IG9mIHRoZSBUUiBub2RlcyB0aGF0IGFyZSB1c2VkIGluIHRoZSB0YWJsZSdzIGJvZHkuIE5vdGUgdGhhdCB5b3Ugd2lsbFxuXHRcdCAqIHR5cGljYWxseSB3YW50IHRvIHVzZSB0aGUgJyQnIEFQSSBtZXRob2QgaW4gcHJlZmVyZW5jZSB0byB0aGlzIGFzIGl0IGlzIG1vcmVcblx0XHQgKiBmbGV4aWJsZS5cblx0XHQgKiAgQHBhcmFtIHtpbnR9IFtpUm93XSBPcHRpb25hbCByb3cgaW5kZXggZm9yIHRoZSBUUiBlbGVtZW50IHlvdSB3YW50XG5cdFx0ICogIEByZXR1cm5zIHthcnJheXxub2RlfSBJZiBpUm93IGlzIHVuZGVmaW5lZCwgcmV0dXJucyBhbiBhcnJheSBvZiBhbGwgVFIgZWxlbWVudHNcblx0XHQgKiAgICBpbiB0aGUgdGFibGUncyBib2R5LCBvciBpUm93IGlzIGRlZmluZWQsIGp1c3QgdGhlIFRSIGVsZW1lbnQgcmVxdWVzdGVkLlxuXHRcdCAqICBAZHRvcHQgQVBJXG5cdFx0ICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgIHZhciBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xuXHRcdCAqXG5cdFx0ICogICAgICAvLyBHZXQgdGhlIG5vZGVzIGZyb20gdGhlIHRhYmxlXG5cdFx0ICogICAgICB2YXIgbk5vZGVzID0gb1RhYmxlLmZuR2V0Tm9kZXMoICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdHRoaXMuZm5HZXROb2RlcyA9IGZ1bmN0aW9uKCBpUm93IClcblx0XHR7XG5cdFx0XHR2YXIgYXBpID0gdGhpcy5hcGkoIHRydWUgKTtcblx0XHRcblx0XHRcdHJldHVybiBpUm93ICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRhcGkucm93KCBpUm93ICkubm9kZSgpIDpcblx0XHRcdFx0YXBpLnJvd3MoKS5ub2RlcygpLmZsYXR0ZW4oKS50b0FycmF5KCk7XG5cdFx0fTtcblx0XHRcblx0XHRcblx0XHQvKipcblx0XHQgKiBHZXQgdGhlIGFycmF5IGluZGV4ZXMgb2YgYSBwYXJ0aWN1bGFyIGNlbGwgZnJvbSBpdCdzIERPTSBlbGVtZW50XG5cdFx0ICogYW5kIGNvbHVtbiBpbmRleCBpbmNsdWRpbmcgaGlkZGVuIGNvbHVtbnNcblx0XHQgKiAgQHBhcmFtIHtub2RlfSBub2RlIHRoaXMgY2FuIGVpdGhlciBiZSBhIFRSLCBURCBvciBUSCBpbiB0aGUgdGFibGUncyBib2R5XG5cdFx0ICogIEByZXR1cm5zIHtpbnR9IElmIG5Ob2RlIGlzIGdpdmVuIGFzIGEgVFIsIHRoZW4gYSBzaW5nbGUgaW5kZXggaXMgcmV0dXJuZWQsIG9yXG5cdFx0ICogICAgaWYgZ2l2ZW4gYXMgYSBjZWxsLCBhbiBhcnJheSBvZiBbcm93IGluZGV4LCBjb2x1bW4gaW5kZXggKHZpc2libGUpLFxuXHRcdCAqICAgIGNvbHVtbiBpbmRleCAoYWxsKV0gaXMgZ2l2ZW4uXG5cdFx0ICogIEBkdG9wdCBBUElcblx0XHQgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUgdGJvZHkgdGQnKS5jbGljayggZnVuY3Rpb24gKCkge1xuXHRcdCAqICAgICAgICAvLyBHZXQgdGhlIHBvc2l0aW9uIG9mIHRoZSBjdXJyZW50IGRhdGEgZnJvbSB0aGUgbm9kZVxuXHRcdCAqICAgICAgICB2YXIgYVBvcyA9IG9UYWJsZS5mbkdldFBvc2l0aW9uKCB0aGlzICk7XG5cdFx0ICpcblx0XHQgKiAgICAgICAgLy8gR2V0IHRoZSBkYXRhIGFycmF5IGZvciB0aGlzIHJvd1xuXHRcdCAqICAgICAgICB2YXIgYURhdGEgPSBvVGFibGUuZm5HZXREYXRhKCBhUG9zWzBdICk7XG5cdFx0ICpcblx0XHQgKiAgICAgICAgLy8gVXBkYXRlIHRoZSBkYXRhIGFycmF5IGFuZCByZXR1cm4gdGhlIHZhbHVlXG5cdFx0ICogICAgICAgIGFEYXRhWyBhUG9zWzFdIF0gPSAnY2xpY2tlZCc7XG5cdFx0ICogICAgICAgIHRoaXMuaW5uZXJIVE1MID0gJ2NsaWNrZWQnO1xuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqXG5cdFx0ICogICAgICAvLyBJbml0IERhdGFUYWJsZXNcblx0XHQgKiAgICAgIG9UYWJsZSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdHRoaXMuZm5HZXRQb3NpdGlvbiA9IGZ1bmN0aW9uKCBub2RlIClcblx0XHR7XG5cdFx0XHR2YXIgYXBpID0gdGhpcy5hcGkoIHRydWUgKTtcblx0XHRcdHZhciBub2RlTmFtZSA9IG5vZGUubm9kZU5hbWUudG9VcHBlckNhc2UoKTtcblx0XHRcblx0XHRcdGlmICggbm9kZU5hbWUgPT0gJ1RSJyApIHtcblx0XHRcdFx0cmV0dXJuIGFwaS5yb3coIG5vZGUgKS5pbmRleCgpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIG5vZGVOYW1lID09ICdURCcgfHwgbm9kZU5hbWUgPT0gJ1RIJyApIHtcblx0XHRcdFx0dmFyIGNlbGwgPSBhcGkuY2VsbCggbm9kZSApLmluZGV4KCk7XG5cdFx0XG5cdFx0XHRcdHJldHVybiBbXG5cdFx0XHRcdFx0Y2VsbC5yb3csXG5cdFx0XHRcdFx0Y2VsbC5jb2x1bW5WaXNpYmxlLFxuXHRcdFx0XHRcdGNlbGwuY29sdW1uXG5cdFx0XHRcdF07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIENoZWNrIHRvIHNlZSBpZiBhIHJvdyBpcyAnb3Blbicgb3Igbm90LlxuXHRcdCAqICBAcGFyYW0ge25vZGV9IG5UciB0aGUgdGFibGUgcm93IHRvIGNoZWNrXG5cdFx0ICogIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSByb3cgaXMgY3VycmVudGx5IG9wZW4sIGZhbHNlIG90aGVyd2lzZVxuXHRcdCAqICBAZHRvcHQgQVBJXG5cdFx0ICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgIHZhciBvVGFibGU7XG5cdFx0ICpcblx0XHQgKiAgICAgIC8vICdvcGVuJyBhbiBpbmZvcm1hdGlvbiByb3cgd2hlbiBhIHJvdyBpcyBjbGlja2VkIG9uXG5cdFx0ICogICAgICAkKCcjZXhhbXBsZSB0Ym9keSB0cicpLmNsaWNrKCBmdW5jdGlvbiAoKSB7XG5cdFx0ICogICAgICAgIGlmICggb1RhYmxlLmZuSXNPcGVuKHRoaXMpICkge1xuXHRcdCAqICAgICAgICAgIG9UYWJsZS5mbkNsb3NlKCB0aGlzICk7XG5cdFx0ICogICAgICAgIH0gZWxzZSB7XG5cdFx0ICogICAgICAgICAgb1RhYmxlLmZuT3BlbiggdGhpcywgXCJUZW1wb3Jhcnkgcm93IG9wZW5lZFwiLCBcImluZm9fcm93XCIgKTtcblx0XHQgKiAgICAgICAgfVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqXG5cdFx0ICogICAgICBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHR0aGlzLmZuSXNPcGVuID0gZnVuY3Rpb24oIG5UciApXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMuYXBpKCB0cnVlICkucm93KCBuVHIgKS5jaGlsZC5pc1Nob3duKCk7XG5cdFx0fTtcblx0XHRcblx0XHRcblx0XHQvKipcblx0XHQgKiBUaGlzIGZ1bmN0aW9uIHdpbGwgcGxhY2UgYSBuZXcgcm93IGRpcmVjdGx5IGFmdGVyIGEgcm93IHdoaWNoIGlzIGN1cnJlbnRseVxuXHRcdCAqIG9uIGRpc3BsYXkgb24gdGhlIHBhZ2UsIHdpdGggdGhlIEhUTUwgY29udGVudHMgdGhhdCBpcyBwYXNzZWQgaW50byB0aGVcblx0XHQgKiBmdW5jdGlvbi4gVGhpcyBjYW4gYmUgdXNlZCwgZm9yIGV4YW1wbGUsIHRvIGFzayBmb3IgY29uZmlybWF0aW9uIHRoYXQgYVxuXHRcdCAqIHBhcnRpY3VsYXIgcmVjb3JkIHNob3VsZCBiZSBkZWxldGVkLlxuXHRcdCAqICBAcGFyYW0ge25vZGV9IG5UciBUaGUgdGFibGUgcm93IHRvICdvcGVuJ1xuXHRcdCAqICBAcGFyYW0ge3N0cmluZ3xub2RlfGpRdWVyeX0gbUh0bWwgVGhlIEhUTUwgdG8gcHV0IGludG8gdGhlIHJvd1xuXHRcdCAqICBAcGFyYW0ge3N0cmluZ30gc0NsYXNzIENsYXNzIHRvIGdpdmUgdGhlIG5ldyBURCBjZWxsXG5cdFx0ICogIEByZXR1cm5zIHtub2RlfSBUaGUgcm93IG9wZW5lZC4gTm90ZSB0aGF0IGlmIHRoZSB0YWJsZSByb3cgcGFzc2VkIGluIGFzIHRoZVxuXHRcdCAqICAgIGZpcnN0IHBhcmFtZXRlciwgaXMgbm90IGZvdW5kIGluIHRoZSB0YWJsZSwgdGhpcyBtZXRob2Qgd2lsbCBzaWxlbnRseVxuXHRcdCAqICAgIHJldHVybi5cblx0XHQgKiAgQGR0b3B0IEFQSVxuXHRcdCAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICB2YXIgb1RhYmxlO1xuXHRcdCAqXG5cdFx0ICogICAgICAvLyAnb3BlbicgYW4gaW5mb3JtYXRpb24gcm93IHdoZW4gYSByb3cgaXMgY2xpY2tlZCBvblxuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUgdGJvZHkgdHInKS5jbGljayggZnVuY3Rpb24gKCkge1xuXHRcdCAqICAgICAgICBpZiAoIG9UYWJsZS5mbklzT3Blbih0aGlzKSApIHtcblx0XHQgKiAgICAgICAgICBvVGFibGUuZm5DbG9zZSggdGhpcyApO1xuXHRcdCAqICAgICAgICB9IGVsc2Uge1xuXHRcdCAqICAgICAgICAgIG9UYWJsZS5mbk9wZW4oIHRoaXMsIFwiVGVtcG9yYXJ5IHJvdyBvcGVuZWRcIiwgXCJpbmZvX3Jvd1wiICk7XG5cdFx0ICogICAgICAgIH1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKlxuXHRcdCAqICAgICAgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0dGhpcy5mbk9wZW4gPSBmdW5jdGlvbiggblRyLCBtSHRtbCwgc0NsYXNzIClcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5hcGkoIHRydWUgKVxuXHRcdFx0XHQucm93KCBuVHIgKVxuXHRcdFx0XHQuY2hpbGQoIG1IdG1sLCBzQ2xhc3MgKVxuXHRcdFx0XHQuc2hvdygpXG5cdFx0XHRcdC5jaGlsZCgpWzBdO1xuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQ2hhbmdlIHRoZSBwYWdpbmF0aW9uIC0gcHJvdmlkZXMgdGhlIGludGVybmFsIGxvZ2ljIGZvciBwYWdpbmF0aW9uIGluIGEgc2ltcGxlIEFQSVxuXHRcdCAqIGZ1bmN0aW9uLiBXaXRoIHRoaXMgZnVuY3Rpb24geW91IGNhbiBoYXZlIGEgRGF0YVRhYmxlcyB0YWJsZSBnbyB0byB0aGUgbmV4dCxcblx0XHQgKiBwcmV2aW91cywgZmlyc3Qgb3IgbGFzdCBwYWdlcy5cblx0XHQgKiAgQHBhcmFtIHtzdHJpbmd8aW50fSBtQWN0aW9uIFBhZ2luZyBhY3Rpb24gdG8gdGFrZTogXCJmaXJzdFwiLCBcInByZXZpb3VzXCIsIFwibmV4dFwiIG9yIFwibGFzdFwiXG5cdFx0ICogICAgb3IgcGFnZSBudW1iZXIgdG8ganVtcCB0byAoaW50ZWdlciksIG5vdGUgdGhhdCBwYWdlIDAgaXMgdGhlIGZpcnN0IHBhZ2UuXG5cdFx0ICogIEBwYXJhbSB7Ym9vbH0gW2JSZWRyYXc9dHJ1ZV0gUmVkcmF3IHRoZSB0YWJsZSBvciBub3Rcblx0XHQgKiAgQGR0b3B0IEFQSVxuXHRcdCAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICB2YXIgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcblx0XHQgKiAgICAgIG9UYWJsZS5mblBhZ2VDaGFuZ2UoICduZXh0JyApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHR0aGlzLmZuUGFnZUNoYW5nZSA9IGZ1bmN0aW9uICggbUFjdGlvbiwgYlJlZHJhdyApXG5cdFx0e1xuXHRcdFx0dmFyIGFwaSA9IHRoaXMuYXBpKCB0cnVlICkucGFnZSggbUFjdGlvbiApO1xuXHRcdFxuXHRcdFx0aWYgKCBiUmVkcmF3ID09PSB1bmRlZmluZWQgfHwgYlJlZHJhdyApIHtcblx0XHRcdFx0YXBpLmRyYXcoZmFsc2UpO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU2hvdyBhIHBhcnRpY3VsYXIgY29sdW1uXG5cdFx0ICogIEBwYXJhbSB7aW50fSBpQ29sIFRoZSBjb2x1bW4gd2hvc2UgZGlzcGxheSBzaG91bGQgYmUgY2hhbmdlZFxuXHRcdCAqICBAcGFyYW0ge2Jvb2x9IGJTaG93IFNob3cgKHRydWUpIG9yIGhpZGUgKGZhbHNlKSB0aGUgY29sdW1uXG5cdFx0ICogIEBwYXJhbSB7Ym9vbH0gW2JSZWRyYXc9dHJ1ZV0gUmVkcmF3IHRoZSB0YWJsZSBvciBub3Rcblx0XHQgKiAgQGR0b3B0IEFQSVxuXHRcdCAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICB2YXIgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcblx0XHQgKlxuXHRcdCAqICAgICAgLy8gSGlkZSB0aGUgc2Vjb25kIGNvbHVtbiBhZnRlciBpbml0aWFsaXNhdGlvblxuXHRcdCAqICAgICAgb1RhYmxlLmZuU2V0Q29sdW1uVmlzKCAxLCBmYWxzZSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHR0aGlzLmZuU2V0Q29sdW1uVmlzID0gZnVuY3Rpb24gKCBpQ29sLCBiU2hvdywgYlJlZHJhdyApXG5cdFx0e1xuXHRcdFx0dmFyIGFwaSA9IHRoaXMuYXBpKCB0cnVlICkuY29sdW1uKCBpQ29sICkudmlzaWJsZSggYlNob3cgKTtcblx0XHRcblx0XHRcdGlmICggYlJlZHJhdyA9PT0gdW5kZWZpbmVkIHx8IGJSZWRyYXcgKSB7XG5cdFx0XHRcdGFwaS5jb2x1bW5zLmFkanVzdCgpLmRyYXcoKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEdldCB0aGUgc2V0dGluZ3MgZm9yIGEgcGFydGljdWxhciB0YWJsZSBmb3IgZXh0ZXJuYWwgbWFuaXB1bGF0aW9uXG5cdFx0ICogIEByZXR1cm5zIHtvYmplY3R9IERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0LiBTZWVcblx0XHQgKiAgICB7QGxpbmsgRGF0YVRhYmxlLm1vZGVscy5vU2V0dGluZ3N9XG5cdFx0ICogIEBkdG9wdCBBUElcblx0XHQgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgdmFyIG9UYWJsZSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XG5cdFx0ICogICAgICB2YXIgb1NldHRpbmdzID0gb1RhYmxlLmZuU2V0dGluZ3MoKTtcblx0XHQgKlxuXHRcdCAqICAgICAgLy8gU2hvdyBhbiBleGFtcGxlIHBhcmFtZXRlciBmcm9tIHRoZSBzZXR0aW5nc1xuXHRcdCAqICAgICAgYWxlcnQoIG9TZXR0aW5ncy5faURpc3BsYXlTdGFydCApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHR0aGlzLmZuU2V0dGluZ3MgPSBmdW5jdGlvbigpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIF9mblNldHRpbmdzRnJvbU5vZGUoIHRoaXNbX2V4dC5pQXBpSW5kZXhdICk7XG5cdFx0fTtcblx0XHRcblx0XHRcblx0XHQvKipcblx0XHQgKiBTb3J0IHRoZSB0YWJsZSBieSBhIHBhcnRpY3VsYXIgY29sdW1uXG5cdFx0ICogIEBwYXJhbSB7aW50fSBpQ29sIHRoZSBkYXRhIGluZGV4IHRvIHNvcnQgb24uIE5vdGUgdGhhdCB0aGlzIHdpbGwgbm90IG1hdGNoIHRoZVxuXHRcdCAqICAgICdkaXNwbGF5IGluZGV4JyBpZiB5b3UgaGF2ZSBoaWRkZW4gZGF0YSBlbnRyaWVzXG5cdFx0ICogIEBkdG9wdCBBUElcblx0XHQgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgdmFyIG9UYWJsZSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XG5cdFx0ICpcblx0XHQgKiAgICAgIC8vIFNvcnQgaW1tZWRpYXRlbHkgd2l0aCBjb2x1bW5zIDAgYW5kIDFcblx0XHQgKiAgICAgIG9UYWJsZS5mblNvcnQoIFsgWzAsJ2FzYyddLCBbMSwnYXNjJ10gXSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHR0aGlzLmZuU29ydCA9IGZ1bmN0aW9uKCBhYVNvcnQgKVxuXHRcdHtcblx0XHRcdHRoaXMuYXBpKCB0cnVlICkub3JkZXIoIGFhU29ydCApLmRyYXcoKTtcblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEF0dGFjaCBhIHNvcnQgbGlzdGVuZXIgdG8gYW4gZWxlbWVudCBmb3IgYSBnaXZlbiBjb2x1bW5cblx0XHQgKiAgQHBhcmFtIHtub2RlfSBuTm9kZSB0aGUgZWxlbWVudCB0byBhdHRhY2ggdGhlIHNvcnQgbGlzdGVuZXIgdG9cblx0XHQgKiAgQHBhcmFtIHtpbnR9IGlDb2x1bW4gdGhlIGNvbHVtbiB0aGF0IGEgY2xpY2sgb24gdGhpcyBub2RlIHdpbGwgc29ydCBvblxuXHRcdCAqICBAcGFyYW0ge2Z1bmN0aW9ufSBbZm5DYWxsYmFja10gY2FsbGJhY2sgZnVuY3Rpb24gd2hlbiBzb3J0IGlzIHJ1blxuXHRcdCAqICBAZHRvcHQgQVBJXG5cdFx0ICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgIHZhciBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xuXHRcdCAqXG5cdFx0ICogICAgICAvLyBTb3J0IG9uIGNvbHVtbiAxLCB3aGVuICdzb3J0ZXInIGlzIGNsaWNrZWQgb25cblx0XHQgKiAgICAgIG9UYWJsZS5mblNvcnRMaXN0ZW5lciggZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NvcnRlcicpLCAxICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdHRoaXMuZm5Tb3J0TGlzdGVuZXIgPSBmdW5jdGlvbiggbk5vZGUsIGlDb2x1bW4sIGZuQ2FsbGJhY2sgKVxuXHRcdHtcblx0XHRcdHRoaXMuYXBpKCB0cnVlICkub3JkZXIubGlzdGVuZXIoIG5Ob2RlLCBpQ29sdW1uLCBmbkNhbGxiYWNrICk7XG5cdFx0fTtcblx0XHRcblx0XHRcblx0XHQvKipcblx0XHQgKiBVcGRhdGUgYSB0YWJsZSBjZWxsIG9yIHJvdyAtIHRoaXMgbWV0aG9kIHdpbGwgYWNjZXB0IGVpdGhlciBhIHNpbmdsZSB2YWx1ZSB0b1xuXHRcdCAqIHVwZGF0ZSB0aGUgY2VsbCB3aXRoLCBhbiBhcnJheSBvZiB2YWx1ZXMgd2l0aCBvbmUgZWxlbWVudCBmb3IgZWFjaCBjb2x1bW4gb3Jcblx0XHQgKiBhbiBvYmplY3QgaW4gdGhlIHNhbWUgZm9ybWF0IGFzIHRoZSBvcmlnaW5hbCBkYXRhIHNvdXJjZS4gVGhlIGZ1bmN0aW9uIGlzXG5cdFx0ICogc2VsZi1yZWZlcmVuY2luZyBpbiBvcmRlciB0byBtYWtlIHRoZSBtdWx0aSBjb2x1bW4gdXBkYXRlcyBlYXNpZXIuXG5cdFx0ICogIEBwYXJhbSB7b2JqZWN0fGFycmF5fHN0cmluZ30gbURhdGEgRGF0YSB0byB1cGRhdGUgdGhlIGNlbGwvcm93IHdpdGhcblx0XHQgKiAgQHBhcmFtIHtub2RlfGludH0gbVJvdyBUUiBlbGVtZW50IHlvdSB3YW50IHRvIHVwZGF0ZSBvciB0aGUgYW9EYXRhIGluZGV4XG5cdFx0ICogIEBwYXJhbSB7aW50fSBbaUNvbHVtbl0gVGhlIGNvbHVtbiB0byB1cGRhdGUsIGdpdmUgYXMgbnVsbCBvciB1bmRlZmluZWQgdG9cblx0XHQgKiAgICB1cGRhdGUgYSB3aG9sZSByb3cuXG5cdFx0ICogIEBwYXJhbSB7Ym9vbH0gW2JSZWRyYXc9dHJ1ZV0gUmVkcmF3IHRoZSB0YWJsZSBvciBub3Rcblx0XHQgKiAgQHBhcmFtIHtib29sfSBbYkFjdGlvbj10cnVlXSBQZXJmb3JtIHByZS1kcmF3IGFjdGlvbnMgb3Igbm90XG5cdFx0ICogIEByZXR1cm5zIHtpbnR9IDAgb24gc3VjY2VzcywgMSBvbiBlcnJvclxuXHRcdCAqICBAZHRvcHQgQVBJXG5cdFx0ICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgIHZhciBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xuXHRcdCAqICAgICAgb1RhYmxlLmZuVXBkYXRlKCAnRXhhbXBsZSB1cGRhdGUnLCAwLCAwICk7IC8vIFNpbmdsZSBjZWxsXG5cdFx0ICogICAgICBvVGFibGUuZm5VcGRhdGUoIFsnYScsICdiJywgJ2MnLCAnZCcsICdlJ10sICQoJ3Rib2R5IHRyJylbMF0gKTsgLy8gUm93XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdHRoaXMuZm5VcGRhdGUgPSBmdW5jdGlvbiggbURhdGEsIG1Sb3csIGlDb2x1bW4sIGJSZWRyYXcsIGJBY3Rpb24gKVxuXHRcdHtcblx0XHRcdHZhciBhcGkgPSB0aGlzLmFwaSggdHJ1ZSApO1xuXHRcdFxuXHRcdFx0aWYgKCBpQ29sdW1uID09PSB1bmRlZmluZWQgfHwgaUNvbHVtbiA9PT0gbnVsbCApIHtcblx0XHRcdFx0YXBpLnJvdyggbVJvdyApLmRhdGEoIG1EYXRhICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0YXBpLmNlbGwoIG1Sb3csIGlDb2x1bW4gKS5kYXRhKCBtRGF0YSApO1xuXHRcdFx0fVxuXHRcdFxuXHRcdFx0aWYgKCBiQWN0aW9uID09PSB1bmRlZmluZWQgfHwgYkFjdGlvbiApIHtcblx0XHRcdFx0YXBpLmNvbHVtbnMuYWRqdXN0KCk7XG5cdFx0XHR9XG5cdFx0XG5cdFx0XHRpZiAoIGJSZWRyYXcgPT09IHVuZGVmaW5lZCB8fCBiUmVkcmF3ICkge1xuXHRcdFx0XHRhcGkuZHJhdygpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fTtcblx0XHRcblx0XHRcblx0XHQvKipcblx0XHQgKiBQcm92aWRlIGEgY29tbW9uIG1ldGhvZCBmb3IgcGx1Zy1pbnMgdG8gY2hlY2sgdGhlIHZlcnNpb24gb2YgRGF0YVRhYmxlcyBiZWluZyB1c2VkLCBpbiBvcmRlclxuXHRcdCAqIHRvIGVuc3VyZSBjb21wYXRpYmlsaXR5LlxuXHRcdCAqICBAcGFyYW0ge3N0cmluZ30gc1ZlcnNpb24gVmVyc2lvbiBzdHJpbmcgdG8gY2hlY2sgZm9yLCBpbiB0aGUgZm9ybWF0IFwiWC5ZLlpcIi4gTm90ZSB0aGF0IHRoZVxuXHRcdCAqICAgIGZvcm1hdHMgXCJYXCIgYW5kIFwiWC5ZXCIgYXJlIGFsc28gYWNjZXB0YWJsZS5cblx0XHQgKiAgQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhpcyB2ZXJzaW9uIG9mIERhdGFUYWJsZXMgaXMgZ3JlYXRlciBvciBlcXVhbCB0byB0aGUgcmVxdWlyZWRcblx0XHQgKiAgICB2ZXJzaW9uLCBvciBmYWxzZSBpZiB0aGlzIHZlcnNpb24gb2YgRGF0YVRhbGVzIGlzIG5vdCBzdWl0YWJsZVxuXHRcdCAqICBAbWV0aG9kXG5cdFx0ICogIEBkdG9wdCBBUElcblx0XHQgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgdmFyIG9UYWJsZSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XG5cdFx0ICogICAgICBhbGVydCggb1RhYmxlLmZuVmVyc2lvbkNoZWNrKCAnMS45LjAnICkgKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0dGhpcy5mblZlcnNpb25DaGVjayA9IF9leHQuZm5WZXJzaW9uQ2hlY2s7XG5cdFx0XG5cblx0XHR2YXIgX3RoYXQgPSB0aGlzO1xuXHRcdHZhciBlbXB0eUluaXQgPSBvcHRpb25zID09PSB1bmRlZmluZWQ7XG5cdFx0dmFyIGxlbiA9IHRoaXMubGVuZ3RoO1xuXG5cdFx0aWYgKCBlbXB0eUluaXQgKSB7XG5cdFx0XHRvcHRpb25zID0ge307XG5cdFx0fVxuXG5cdFx0dGhpcy5vQXBpID0gdGhpcy5pbnRlcm5hbCA9IF9leHQuaW50ZXJuYWw7XG5cblx0XHQvLyBFeHRlbmQgd2l0aCBvbGQgc3R5bGUgcGx1Zy1pbiBBUEkgbWV0aG9kc1xuXHRcdGZvciAoIHZhciBmbiBpbiBEYXRhVGFibGUuZXh0LmludGVybmFsICkge1xuXHRcdFx0aWYgKCBmbiApIHtcblx0XHRcdFx0dGhpc1tmbl0gPSBfZm5FeHRlcm5BcGlGdW5jKGZuKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyBGb3IgZWFjaCBpbml0aWFsaXNhdGlvbiB3ZSB3YW50IHRvIGdpdmUgaXQgYSBjbGVhbiBpbml0aWFsaXNhdGlvblxuXHRcdFx0Ly8gb2JqZWN0IHRoYXQgY2FuIGJlIGJhc2hlZCBhcm91bmRcblx0XHRcdHZhciBvID0ge307XG5cdFx0XHR2YXIgb0luaXQgPSBsZW4gPiAxID8gLy8gb3B0aW1pc2F0aW9uIGZvciBzaW5nbGUgdGFibGUgY2FzZVxuXHRcdFx0XHRfZm5FeHRlbmQoIG8sIG9wdGlvbnMsIHRydWUgKSA6XG5cdFx0XHRcdG9wdGlvbnM7XG5cblx0XHRcdC8qZ2xvYmFsIG9Jbml0LF90aGF0LGVtcHR5SW5pdCovXG5cdFx0XHR2YXIgaT0wLCBpTGVuLCBqLCBqTGVuLCBrLCBrTGVuO1xuXHRcdFx0dmFyIHNJZCA9IHRoaXMuZ2V0QXR0cmlidXRlKCAnaWQnICk7XG5cdFx0XHR2YXIgYkluaXRIYW5kZWRPZmYgPSBmYWxzZTtcblx0XHRcdHZhciBkZWZhdWx0cyA9IERhdGFUYWJsZS5kZWZhdWx0cztcblx0XHRcdHZhciAkdGhpcyA9ICQodGhpcyk7XG5cdFx0XHRcblx0XHRcdFxuXHRcdFx0LyogU2FuaXR5IGNoZWNrICovXG5cdFx0XHRpZiAoIHRoaXMubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPSAndGFibGUnIClcblx0XHRcdHtcblx0XHRcdFx0X2ZuTG9nKCBudWxsLCAwLCAnTm9uLXRhYmxlIG5vZGUgaW5pdGlhbGlzYXRpb24gKCcrdGhpcy5ub2RlTmFtZSsnKScsIDIgKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvKiBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBmb3IgdGhlIGRlZmF1bHRzICovXG5cdFx0XHRfZm5Db21wYXRPcHRzKCBkZWZhdWx0cyApO1xuXHRcdFx0X2ZuQ29tcGF0Q29scyggZGVmYXVsdHMuY29sdW1uICk7XG5cdFx0XHRcblx0XHRcdC8qIENvbnZlcnQgdGhlIGNhbWVsLWNhc2UgZGVmYXVsdHMgdG8gSHVuZ2FyaWFuICovXG5cdFx0XHRfZm5DYW1lbFRvSHVuZ2FyaWFuKCBkZWZhdWx0cywgZGVmYXVsdHMsIHRydWUgKTtcblx0XHRcdF9mbkNhbWVsVG9IdW5nYXJpYW4oIGRlZmF1bHRzLmNvbHVtbiwgZGVmYXVsdHMuY29sdW1uLCB0cnVlICk7XG5cdFx0XHRcblx0XHRcdC8qIFNldHRpbmcgdXAgdGhlIGluaXRpYWxpc2F0aW9uIG9iamVjdCAqL1xuXHRcdFx0X2ZuQ2FtZWxUb0h1bmdhcmlhbiggZGVmYXVsdHMsICQuZXh0ZW5kKCBvSW5pdCwgJHRoaXMuZGF0YSgpICksIHRydWUgKTtcblx0XHRcdFxuXHRcdFx0XG5cdFx0XHRcblx0XHRcdC8qIENoZWNrIHRvIHNlZSBpZiB3ZSBhcmUgcmUtaW5pdGlhbGlzaW5nIGEgdGFibGUgKi9cblx0XHRcdHZhciBhbGxTZXR0aW5ncyA9IERhdGFUYWJsZS5zZXR0aW5ncztcblx0XHRcdGZvciAoIGk9MCwgaUxlbj1hbGxTZXR0aW5ncy5sZW5ndGggOyBpPGlMZW4gOyBpKysgKVxuXHRcdFx0e1xuXHRcdFx0XHR2YXIgcyA9IGFsbFNldHRpbmdzW2ldO1xuXHRcdFx0XG5cdFx0XHRcdC8qIEJhc2UgY2hlY2sgb24gdGFibGUgbm9kZSAqL1xuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0cy5uVGFibGUgPT0gdGhpcyB8fFxuXHRcdFx0XHRcdChzLm5USGVhZCAmJiBzLm5USGVhZC5wYXJlbnROb2RlID09IHRoaXMpIHx8XG5cdFx0XHRcdFx0KHMublRGb290ICYmIHMublRGb290LnBhcmVudE5vZGUgPT0gdGhpcylcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0dmFyIGJSZXRyaWV2ZSA9IG9Jbml0LmJSZXRyaWV2ZSAhPT0gdW5kZWZpbmVkID8gb0luaXQuYlJldHJpZXZlIDogZGVmYXVsdHMuYlJldHJpZXZlO1xuXHRcdFx0XHRcdHZhciBiRGVzdHJveSA9IG9Jbml0LmJEZXN0cm95ICE9PSB1bmRlZmluZWQgPyBvSW5pdC5iRGVzdHJveSA6IGRlZmF1bHRzLmJEZXN0cm95O1xuXHRcdFx0XG5cdFx0XHRcdFx0aWYgKCBlbXB0eUluaXQgfHwgYlJldHJpZXZlIClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcy5vSW5zdGFuY2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2UgaWYgKCBiRGVzdHJveSApXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0cy5vSW5zdGFuY2UuZm5EZXN0cm95KCk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdF9mbkxvZyggcywgMCwgJ0Nhbm5vdCByZWluaXRpYWxpc2UgRGF0YVRhYmxlJywgMyApO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRcdC8qIElmIHRoZSBlbGVtZW50IHdlIGFyZSBpbml0aWFsaXNpbmcgaGFzIHRoZSBzYW1lIElEIGFzIGEgdGFibGUgd2hpY2ggd2FzIHByZXZpb3VzbHlcblx0XHRcdFx0ICogaW5pdGlhbGlzZWQsIGJ1dCB0aGUgdGFibGUgbm9kZXMgZG9uJ3QgbWF0Y2ggKGZyb20gYmVmb3JlKSB0aGVuIHdlIGRlc3Ryb3kgdGhlIG9sZFxuXHRcdFx0XHQgKiBpbnN0YW5jZSBieSBzaW1wbHkgZGVsZXRpbmcgaXQuIFRoaXMgaXMgdW5kZXIgdGhlIGFzc3VtcHRpb24gdGhhdCB0aGUgdGFibGUgaGFzIGJlZW5cblx0XHRcdFx0ICogZGVzdHJveWVkIGJ5IG90aGVyIG1ldGhvZHMuIEFueW9uZSB1c2luZyBub24taWQgc2VsZWN0b3JzIHdpbGwgbmVlZCB0byBkbyB0aGlzIG1hbnVhbGx5XG5cdFx0XHRcdCAqL1xuXHRcdFx0XHRpZiAoIHMuc1RhYmxlSWQgPT0gdGhpcy5pZCApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRhbGxTZXR0aW5ncy5zcGxpY2UoIGksIDEgKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvKiBFbnN1cmUgdGhlIHRhYmxlIGhhcyBhbiBJRCAtIHJlcXVpcmVkIGZvciBhY2Nlc3NpYmlsaXR5ICovXG5cdFx0XHRpZiAoIHNJZCA9PT0gbnVsbCB8fCBzSWQgPT09IFwiXCIgKVxuXHRcdFx0e1xuXHRcdFx0XHRzSWQgPSBcIkRhdGFUYWJsZXNfVGFibGVfXCIrKERhdGFUYWJsZS5leHQuX3VuaXF1ZSsrKTtcblx0XHRcdFx0dGhpcy5pZCA9IHNJZDtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0LyogQ3JlYXRlIHRoZSBzZXR0aW5ncyBvYmplY3QgZm9yIHRoaXMgdGFibGUgYW5kIHNldCBzb21lIG9mIHRoZSBkZWZhdWx0IHBhcmFtZXRlcnMgKi9cblx0XHRcdHZhciBvU2V0dGluZ3MgPSAkLmV4dGVuZCggdHJ1ZSwge30sIERhdGFUYWJsZS5tb2RlbHMub1NldHRpbmdzLCB7XG5cdFx0XHRcdFwic0Rlc3Ryb3lXaWR0aFwiOiAkdGhpc1swXS5zdHlsZS53aWR0aCxcblx0XHRcdFx0XCJzSW5zdGFuY2VcIjogICAgIHNJZCxcblx0XHRcdFx0XCJzVGFibGVJZFwiOiAgICAgIHNJZFxuXHRcdFx0fSApO1xuXHRcdFx0b1NldHRpbmdzLm5UYWJsZSA9IHRoaXM7XG5cdFx0XHRvU2V0dGluZ3Mub0FwaSAgID0gX3RoYXQuaW50ZXJuYWw7XG5cdFx0XHRvU2V0dGluZ3Mub0luaXQgID0gb0luaXQ7XG5cdFx0XHRcblx0XHRcdGFsbFNldHRpbmdzLnB1c2goIG9TZXR0aW5ncyApO1xuXHRcdFx0XG5cdFx0XHQvLyBOZWVkIHRvIGFkZCB0aGUgaW5zdGFuY2UgYWZ0ZXIgdGhlIGluc3RhbmNlIGFmdGVyIHRoZSBzZXR0aW5ncyBvYmplY3QgaGFzIGJlZW4gYWRkZWRcblx0XHRcdC8vIHRvIHRoZSBzZXR0aW5ncyBhcnJheSwgc28gd2UgY2FuIHNlbGYgcmVmZXJlbmNlIHRoZSB0YWJsZSBpbnN0YW5jZSBpZiBtb3JlIHRoYW4gb25lXG5cdFx0XHRvU2V0dGluZ3Mub0luc3RhbmNlID0gKF90aGF0Lmxlbmd0aD09PTEpID8gX3RoYXQgOiAkdGhpcy5kYXRhVGFibGUoKTtcblx0XHRcdFxuXHRcdFx0Ly8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHksIGJlZm9yZSB3ZSBhcHBseSBhbGwgdGhlIGRlZmF1bHRzXG5cdFx0XHRfZm5Db21wYXRPcHRzKCBvSW5pdCApO1xuXHRcdFx0X2ZuTGFuZ3VhZ2VDb21wYXQoIG9Jbml0Lm9MYW5ndWFnZSApO1xuXHRcdFx0XG5cdFx0XHQvLyBJZiB0aGUgbGVuZ3RoIG1lbnUgaXMgZ2l2ZW4sIGJ1dCB0aGUgaW5pdCBkaXNwbGF5IGxlbmd0aCBpcyBub3QsIHVzZSB0aGUgbGVuZ3RoIG1lbnVcblx0XHRcdGlmICggb0luaXQuYUxlbmd0aE1lbnUgJiYgISBvSW5pdC5pRGlzcGxheUxlbmd0aCApXG5cdFx0XHR7XG5cdFx0XHRcdG9Jbml0LmlEaXNwbGF5TGVuZ3RoID0gJC5pc0FycmF5KCBvSW5pdC5hTGVuZ3RoTWVudVswXSApID9cblx0XHRcdFx0XHRvSW5pdC5hTGVuZ3RoTWVudVswXVswXSA6IG9Jbml0LmFMZW5ndGhNZW51WzBdO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvLyBBcHBseSB0aGUgZGVmYXVsdHMgYW5kIGluaXQgb3B0aW9ucyB0byBtYWtlIGEgc2luZ2xlIGluaXQgb2JqZWN0IHdpbGwgYWxsXG5cdFx0XHQvLyBvcHRpb25zIGRlZmluZWQgZnJvbSBkZWZhdWx0cyBhbmQgaW5zdGFuY2Ugb3B0aW9ucy5cblx0XHRcdG9Jbml0ID0gX2ZuRXh0ZW5kKCAkLmV4dGVuZCggdHJ1ZSwge30sIGRlZmF1bHRzICksIG9Jbml0ICk7XG5cdFx0XHRcblx0XHRcdFxuXHRcdFx0Ly8gTWFwIHRoZSBpbml0aWFsaXNhdGlvbiBvcHRpb25zIG9udG8gdGhlIHNldHRpbmdzIG9iamVjdFxuXHRcdFx0X2ZuTWFwKCBvU2V0dGluZ3Mub0ZlYXR1cmVzLCBvSW5pdCwgW1xuXHRcdFx0XHRcImJQYWdpbmF0ZVwiLFxuXHRcdFx0XHRcImJMZW5ndGhDaGFuZ2VcIixcblx0XHRcdFx0XCJiRmlsdGVyXCIsXG5cdFx0XHRcdFwiYlNvcnRcIixcblx0XHRcdFx0XCJiU29ydE11bHRpXCIsXG5cdFx0XHRcdFwiYkluZm9cIixcblx0XHRcdFx0XCJiUHJvY2Vzc2luZ1wiLFxuXHRcdFx0XHRcImJBdXRvV2lkdGhcIixcblx0XHRcdFx0XCJiU29ydENsYXNzZXNcIixcblx0XHRcdFx0XCJiU2VydmVyU2lkZVwiLFxuXHRcdFx0XHRcImJEZWZlclJlbmRlclwiXG5cdFx0XHRdICk7XG5cdFx0XHRfZm5NYXAoIG9TZXR0aW5ncywgb0luaXQsIFtcblx0XHRcdFx0XCJhc1N0cmlwZUNsYXNzZXNcIixcblx0XHRcdFx0XCJhamF4XCIsXG5cdFx0XHRcdFwiZm5TZXJ2ZXJEYXRhXCIsXG5cdFx0XHRcdFwiZm5Gb3JtYXROdW1iZXJcIixcblx0XHRcdFx0XCJzU2VydmVyTWV0aG9kXCIsXG5cdFx0XHRcdFwiYWFTb3J0aW5nXCIsXG5cdFx0XHRcdFwiYWFTb3J0aW5nRml4ZWRcIixcblx0XHRcdFx0XCJhTGVuZ3RoTWVudVwiLFxuXHRcdFx0XHRcInNQYWdpbmF0aW9uVHlwZVwiLFxuXHRcdFx0XHRcInNBamF4U291cmNlXCIsXG5cdFx0XHRcdFwic0FqYXhEYXRhUHJvcFwiLFxuXHRcdFx0XHRcImlTdGF0ZUR1cmF0aW9uXCIsXG5cdFx0XHRcdFwic0RvbVwiLFxuXHRcdFx0XHRcImJTb3J0Q2VsbHNUb3BcIixcblx0XHRcdFx0XCJpVGFiSW5kZXhcIixcblx0XHRcdFx0XCJmblN0YXRlTG9hZENhbGxiYWNrXCIsXG5cdFx0XHRcdFwiZm5TdGF0ZVNhdmVDYWxsYmFja1wiLFxuXHRcdFx0XHRcInJlbmRlcmVyXCIsXG5cdFx0XHRcdFwic2VhcmNoRGVsYXlcIixcblx0XHRcdFx0XCJyb3dJZFwiLFxuXHRcdFx0XHRbIFwiaUNvb2tpZUR1cmF0aW9uXCIsIFwiaVN0YXRlRHVyYXRpb25cIiBdLCAvLyBiYWNrd2FyZHMgY29tcGF0XG5cdFx0XHRcdFsgXCJvU2VhcmNoXCIsIFwib1ByZXZpb3VzU2VhcmNoXCIgXSxcblx0XHRcdFx0WyBcImFvU2VhcmNoQ29sc1wiLCBcImFvUHJlU2VhcmNoQ29sc1wiIF0sXG5cdFx0XHRcdFsgXCJpRGlzcGxheUxlbmd0aFwiLCBcIl9pRGlzcGxheUxlbmd0aFwiIF1cblx0XHRcdF0gKTtcblx0XHRcdF9mbk1hcCggb1NldHRpbmdzLm9TY3JvbGwsIG9Jbml0LCBbXG5cdFx0XHRcdFsgXCJzU2Nyb2xsWFwiLCBcInNYXCIgXSxcblx0XHRcdFx0WyBcInNTY3JvbGxYSW5uZXJcIiwgXCJzWElubmVyXCIgXSxcblx0XHRcdFx0WyBcInNTY3JvbGxZXCIsIFwic1lcIiBdLFxuXHRcdFx0XHRbIFwiYlNjcm9sbENvbGxhcHNlXCIsIFwiYkNvbGxhcHNlXCIgXVxuXHRcdFx0XSApO1xuXHRcdFx0X2ZuTWFwKCBvU2V0dGluZ3Mub0xhbmd1YWdlLCBvSW5pdCwgXCJmbkluZm9DYWxsYmFja1wiICk7XG5cdFx0XHRcblx0XHRcdC8qIENhbGxiYWNrIGZ1bmN0aW9ucyB3aGljaCBhcmUgYXJyYXkgZHJpdmVuICovXG5cdFx0XHRfZm5DYWxsYmFja1JlZyggb1NldHRpbmdzLCAnYW9EcmF3Q2FsbGJhY2snLCAgICAgICBvSW5pdC5mbkRyYXdDYWxsYmFjaywgICAgICAndXNlcicgKTtcblx0XHRcdF9mbkNhbGxiYWNrUmVnKCBvU2V0dGluZ3MsICdhb1NlcnZlclBhcmFtcycsICAgICAgIG9Jbml0LmZuU2VydmVyUGFyYW1zLCAgICAgICd1c2VyJyApO1xuXHRcdFx0X2ZuQ2FsbGJhY2tSZWcoIG9TZXR0aW5ncywgJ2FvU3RhdGVTYXZlUGFyYW1zJywgICAgb0luaXQuZm5TdGF0ZVNhdmVQYXJhbXMsICAgJ3VzZXInICk7XG5cdFx0XHRfZm5DYWxsYmFja1JlZyggb1NldHRpbmdzLCAnYW9TdGF0ZUxvYWRQYXJhbXMnLCAgICBvSW5pdC5mblN0YXRlTG9hZFBhcmFtcywgICAndXNlcicgKTtcblx0XHRcdF9mbkNhbGxiYWNrUmVnKCBvU2V0dGluZ3MsICdhb1N0YXRlTG9hZGVkJywgICAgICAgIG9Jbml0LmZuU3RhdGVMb2FkZWQsICAgICAgICd1c2VyJyApO1xuXHRcdFx0X2ZuQ2FsbGJhY2tSZWcoIG9TZXR0aW5ncywgJ2FvUm93Q2FsbGJhY2snLCAgICAgICAgb0luaXQuZm5Sb3dDYWxsYmFjaywgICAgICAgJ3VzZXInICk7XG5cdFx0XHRfZm5DYWxsYmFja1JlZyggb1NldHRpbmdzLCAnYW9Sb3dDcmVhdGVkQ2FsbGJhY2snLCBvSW5pdC5mbkNyZWF0ZWRSb3csICAgICAgICAndXNlcicgKTtcblx0XHRcdF9mbkNhbGxiYWNrUmVnKCBvU2V0dGluZ3MsICdhb0hlYWRlckNhbGxiYWNrJywgICAgIG9Jbml0LmZuSGVhZGVyQ2FsbGJhY2ssICAgICd1c2VyJyApO1xuXHRcdFx0X2ZuQ2FsbGJhY2tSZWcoIG9TZXR0aW5ncywgJ2FvRm9vdGVyQ2FsbGJhY2snLCAgICAgb0luaXQuZm5Gb290ZXJDYWxsYmFjaywgICAgJ3VzZXInICk7XG5cdFx0XHRfZm5DYWxsYmFja1JlZyggb1NldHRpbmdzLCAnYW9Jbml0Q29tcGxldGUnLCAgICAgICBvSW5pdC5mbkluaXRDb21wbGV0ZSwgICAgICAndXNlcicgKTtcblx0XHRcdF9mbkNhbGxiYWNrUmVnKCBvU2V0dGluZ3MsICdhb1ByZURyYXdDYWxsYmFjaycsICAgIG9Jbml0LmZuUHJlRHJhd0NhbGxiYWNrLCAgICd1c2VyJyApO1xuXHRcdFx0XG5cdFx0XHRvU2V0dGluZ3Mucm93SWRGbiA9IF9mbkdldE9iamVjdERhdGFGbiggb0luaXQucm93SWQgKTtcblx0XHRcdFxuXHRcdFx0LyogQnJvd3NlciBzdXBwb3J0IGRldGVjdGlvbiAqL1xuXHRcdFx0X2ZuQnJvd3NlckRldGVjdCggb1NldHRpbmdzICk7XG5cdFx0XHRcblx0XHRcdHZhciBvQ2xhc3NlcyA9IG9TZXR0aW5ncy5vQ2xhc3Nlcztcblx0XHRcdFxuXHRcdFx0JC5leHRlbmQoIG9DbGFzc2VzLCBEYXRhVGFibGUuZXh0LmNsYXNzZXMsIG9Jbml0Lm9DbGFzc2VzICk7XG5cdFx0XHQkdGhpcy5hZGRDbGFzcyggb0NsYXNzZXMuc1RhYmxlICk7XG5cdFx0XHRcblx0XHRcdFxuXHRcdFx0aWYgKCBvU2V0dGluZ3MuaUluaXREaXNwbGF5U3RhcnQgPT09IHVuZGVmaW5lZCApXG5cdFx0XHR7XG5cdFx0XHRcdC8qIERpc3BsYXkgc3RhcnQgcG9pbnQsIHRha2luZyBpbnRvIGFjY291bnQgdGhlIHNhdmUgc2F2aW5nICovXG5cdFx0XHRcdG9TZXR0aW5ncy5pSW5pdERpc3BsYXlTdGFydCA9IG9Jbml0LmlEaXNwbGF5U3RhcnQ7XG5cdFx0XHRcdG9TZXR0aW5ncy5faURpc3BsYXlTdGFydCA9IG9Jbml0LmlEaXNwbGF5U3RhcnQ7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGlmICggb0luaXQuaURlZmVyTG9hZGluZyAhPT0gbnVsbCApXG5cdFx0XHR7XG5cdFx0XHRcdG9TZXR0aW5ncy5iRGVmZXJMb2FkaW5nID0gdHJ1ZTtcblx0XHRcdFx0dmFyIHRtcCA9ICQuaXNBcnJheSggb0luaXQuaURlZmVyTG9hZGluZyApO1xuXHRcdFx0XHRvU2V0dGluZ3MuX2lSZWNvcmRzRGlzcGxheSA9IHRtcCA/IG9Jbml0LmlEZWZlckxvYWRpbmdbMF0gOiBvSW5pdC5pRGVmZXJMb2FkaW5nO1xuXHRcdFx0XHRvU2V0dGluZ3MuX2lSZWNvcmRzVG90YWwgPSB0bXAgPyBvSW5pdC5pRGVmZXJMb2FkaW5nWzFdIDogb0luaXQuaURlZmVyTG9hZGluZztcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0LyogTGFuZ3VhZ2UgZGVmaW5pdGlvbnMgKi9cblx0XHRcdHZhciBvTGFuZ3VhZ2UgPSBvU2V0dGluZ3Mub0xhbmd1YWdlO1xuXHRcdFx0JC5leHRlbmQoIHRydWUsIG9MYW5ndWFnZSwgb0luaXQub0xhbmd1YWdlICk7XG5cdFx0XHRcblx0XHRcdGlmICggb0xhbmd1YWdlLnNVcmwgKVxuXHRcdFx0e1xuXHRcdFx0XHQvKiBHZXQgdGhlIGxhbmd1YWdlIGRlZmluaXRpb25zIGZyb20gYSBmaWxlIC0gYmVjYXVzZSB0aGlzIEFqYXggY2FsbCBtYWtlcyB0aGUgbGFuZ3VhZ2Vcblx0XHRcdFx0ICogZ2V0IGFzeW5jIHRvIHRoZSByZW1haW5kZXIgb2YgdGhpcyBmdW5jdGlvbiB3ZSB1c2UgYkluaXRIYW5kZWRPZmYgdG8gaW5kaWNhdGUgdGhhdFxuXHRcdFx0XHQgKiBfZm5Jbml0aWFsaXNlIHdpbGwgYmUgZmlyZWQgYnkgdGhlIHJldHVybmVkIEFqYXggaGFuZGxlciwgcmF0aGVyIHRoYW4gdGhlIGNvbnN0cnVjdG9yXG5cdFx0XHRcdCAqL1xuXHRcdFx0XHQkLmFqYXgoIHtcblx0XHRcdFx0XHRkYXRhVHlwZTogJ2pzb24nLFxuXHRcdFx0XHRcdHVybDogb0xhbmd1YWdlLnNVcmwsXG5cdFx0XHRcdFx0c3VjY2VzczogZnVuY3Rpb24gKCBqc29uICkge1xuXHRcdFx0XHRcdFx0X2ZuTGFuZ3VhZ2VDb21wYXQoIGpzb24gKTtcblx0XHRcdFx0XHRcdF9mbkNhbWVsVG9IdW5nYXJpYW4oIGRlZmF1bHRzLm9MYW5ndWFnZSwganNvbiApO1xuXHRcdFx0XHRcdFx0JC5leHRlbmQoIHRydWUsIG9MYW5ndWFnZSwganNvbiApO1xuXHRcdFx0XHRcdFx0X2ZuSW5pdGlhbGlzZSggb1NldHRpbmdzICk7XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRlcnJvcjogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0Ly8gRXJyb3Igb2NjdXJyZWQgbG9hZGluZyBsYW5ndWFnZSBmaWxlLCBjb250aW51ZSBvbiBhcyBiZXN0IHdlIGNhblxuXHRcdFx0XHRcdFx0X2ZuSW5pdGlhbGlzZSggb1NldHRpbmdzICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdGJJbml0SGFuZGVkT2ZmID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Lypcblx0XHRcdCAqIFN0cmlwZXNcblx0XHRcdCAqL1xuXHRcdFx0aWYgKCBvSW5pdC5hc1N0cmlwZUNsYXNzZXMgPT09IG51bGwgKVxuXHRcdFx0e1xuXHRcdFx0XHRvU2V0dGluZ3MuYXNTdHJpcGVDbGFzc2VzID1bXG5cdFx0XHRcdFx0b0NsYXNzZXMuc1N0cmlwZU9kZCxcblx0XHRcdFx0XHRvQ2xhc3Nlcy5zU3RyaXBlRXZlblxuXHRcdFx0XHRdO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvKiBSZW1vdmUgcm93IHN0cmlwZSBjbGFzc2VzIGlmIHRoZXkgYXJlIGFscmVhZHkgb24gdGhlIHRhYmxlIHJvdyAqL1xuXHRcdFx0dmFyIHN0cmlwZUNsYXNzZXMgPSBvU2V0dGluZ3MuYXNTdHJpcGVDbGFzc2VzO1xuXHRcdFx0dmFyIHJvd09uZSA9ICR0aGlzLmNoaWxkcmVuKCd0Ym9keScpLmZpbmQoJ3RyJykuZXEoMCk7XG5cdFx0XHRpZiAoICQuaW5BcnJheSggdHJ1ZSwgJC5tYXAoIHN0cmlwZUNsYXNzZXMsIGZ1bmN0aW9uKGVsLCBpKSB7XG5cdFx0XHRcdHJldHVybiByb3dPbmUuaGFzQ2xhc3MoZWwpO1xuXHRcdFx0fSApICkgIT09IC0xICkge1xuXHRcdFx0XHQkKCd0Ym9keSB0cicsIHRoaXMpLnJlbW92ZUNsYXNzKCBzdHJpcGVDbGFzc2VzLmpvaW4oJyAnKSApO1xuXHRcdFx0XHRvU2V0dGluZ3MuYXNEZXN0cm95U3RyaXBlcyA9IHN0cmlwZUNsYXNzZXMuc2xpY2UoKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Lypcblx0XHRcdCAqIENvbHVtbnNcblx0XHRcdCAqIFNlZSBpZiB3ZSBzaG91bGQgbG9hZCBjb2x1bW5zIGF1dG9tYXRpY2FsbHkgb3IgdXNlIGRlZmluZWQgb25lc1xuXHRcdFx0ICovXG5cdFx0XHR2YXIgYW5UaHMgPSBbXTtcblx0XHRcdHZhciBhb0NvbHVtbnNJbml0O1xuXHRcdFx0dmFyIG5UaGVhZCA9IHRoaXMuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3RoZWFkJyk7XG5cdFx0XHRpZiAoIG5UaGVhZC5sZW5ndGggIT09IDAgKVxuXHRcdFx0e1xuXHRcdFx0XHRfZm5EZXRlY3RIZWFkZXIoIG9TZXR0aW5ncy5hb0hlYWRlciwgblRoZWFkWzBdICk7XG5cdFx0XHRcdGFuVGhzID0gX2ZuR2V0VW5pcXVlVGhzKCBvU2V0dGluZ3MgKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0LyogSWYgbm90IGdpdmVuIGEgY29sdW1uIGFycmF5LCBnZW5lcmF0ZSBvbmUgd2l0aCBudWxscyAqL1xuXHRcdFx0aWYgKCBvSW5pdC5hb0NvbHVtbnMgPT09IG51bGwgKVxuXHRcdFx0e1xuXHRcdFx0XHRhb0NvbHVtbnNJbml0ID0gW107XG5cdFx0XHRcdGZvciAoIGk9MCwgaUxlbj1hblRocy5sZW5ndGggOyBpPGlMZW4gOyBpKysgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0YW9Db2x1bW5zSW5pdC5wdXNoKCBudWxsICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2Vcblx0XHRcdHtcblx0XHRcdFx0YW9Db2x1bW5zSW5pdCA9IG9Jbml0LmFvQ29sdW1ucztcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0LyogQWRkIHRoZSBjb2x1bW5zICovXG5cdFx0XHRmb3IgKCBpPTAsIGlMZW49YW9Db2x1bW5zSW5pdC5sZW5ndGggOyBpPGlMZW4gOyBpKysgKVxuXHRcdFx0e1xuXHRcdFx0XHRfZm5BZGRDb2x1bW4oIG9TZXR0aW5ncywgYW5UaHMgPyBhblRoc1tpXSA6IG51bGwgKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0LyogQXBwbHkgdGhlIGNvbHVtbiBkZWZpbml0aW9ucyAqL1xuXHRcdFx0X2ZuQXBwbHlDb2x1bW5EZWZzKCBvU2V0dGluZ3MsIG9Jbml0LmFvQ29sdW1uRGVmcywgYW9Db2x1bW5zSW5pdCwgZnVuY3Rpb24gKGlDb2wsIG9EZWYpIHtcblx0XHRcdFx0X2ZuQ29sdW1uT3B0aW9ucyggb1NldHRpbmdzLCBpQ29sLCBvRGVmICk7XG5cdFx0XHR9ICk7XG5cdFx0XHRcblx0XHRcdC8qIEhUTUw1IGF0dHJpYnV0ZSBkZXRlY3Rpb24gLSBidWlsZCBhbiBtRGF0YSBvYmplY3QgYXV0b21hdGljYWxseSBpZiB0aGVcblx0XHRcdCAqIGF0dHJpYnV0ZXMgYXJlIGZvdW5kXG5cdFx0XHQgKi9cblx0XHRcdGlmICggcm93T25lLmxlbmd0aCApIHtcblx0XHRcdFx0dmFyIGEgPSBmdW5jdGlvbiAoIGNlbGwsIG5hbWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGNlbGwuZ2V0QXR0cmlidXRlKCAnZGF0YS0nK25hbWUgKSAhPT0gbnVsbCA/IG5hbWUgOiBudWxsO1xuXHRcdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRcdCQoIHJvd09uZVswXSApLmNoaWxkcmVuKCd0aCwgdGQnKS5lYWNoKCBmdW5jdGlvbiAoaSwgY2VsbCkge1xuXHRcdFx0XHRcdHZhciBjb2wgPSBvU2V0dGluZ3MuYW9Db2x1bW5zW2ldO1xuXHRcdFx0XG5cdFx0XHRcdFx0aWYgKCBjb2wubURhdGEgPT09IGkgKSB7XG5cdFx0XHRcdFx0XHR2YXIgc29ydCA9IGEoIGNlbGwsICdzb3J0JyApIHx8IGEoIGNlbGwsICdvcmRlcicgKTtcblx0XHRcdFx0XHRcdHZhciBmaWx0ZXIgPSBhKCBjZWxsLCAnZmlsdGVyJyApIHx8IGEoIGNlbGwsICdzZWFyY2gnICk7XG5cdFx0XHRcblx0XHRcdFx0XHRcdGlmICggc29ydCAhPT0gbnVsbCB8fCBmaWx0ZXIgIT09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRcdGNvbC5tRGF0YSA9IHtcblx0XHRcdFx0XHRcdFx0XHRfOiAgICAgIGkrJy5kaXNwbGF5Jyxcblx0XHRcdFx0XHRcdFx0XHRzb3J0OiAgIHNvcnQgIT09IG51bGwgICA/IGkrJy5AZGF0YS0nK3NvcnQgICA6IHVuZGVmaW5lZCxcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiAgIHNvcnQgIT09IG51bGwgICA/IGkrJy5AZGF0YS0nK3NvcnQgICA6IHVuZGVmaW5lZCxcblx0XHRcdFx0XHRcdFx0XHRmaWx0ZXI6IGZpbHRlciAhPT0gbnVsbCA/IGkrJy5AZGF0YS0nK2ZpbHRlciA6IHVuZGVmaW5lZFxuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRcdFx0XHRcdF9mbkNvbHVtbk9wdGlvbnMoIG9TZXR0aW5ncywgaSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHR2YXIgZmVhdHVyZXMgPSBvU2V0dGluZ3Mub0ZlYXR1cmVzO1xuXHRcdFx0dmFyIGxvYWRlZEluaXQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdC8qXG5cdFx0XHRcdCAqIFNvcnRpbmdcblx0XHRcdFx0ICogQHRvZG8gRm9yIG1vZHVsYXJpc2F0aW9uICgxLjExKSB0aGlzIG5lZWRzIHRvIGRvIGludG8gYSBzb3J0IHN0YXJ0IHVwIGhhbmRsZXJcblx0XHRcdFx0ICovXG5cdFx0XHRcblx0XHRcdFx0Ly8gSWYgYWFTb3J0aW5nIGlzIG5vdCBkZWZpbmVkLCB0aGVuIHdlIHVzZSB0aGUgZmlyc3QgaW5kaWNhdG9yIGluIGFzU29ydGluZ1xuXHRcdFx0XHQvLyBpbiBjYXNlIHRoYXQgaGFzIGJlZW4gYWx0ZXJlZCwgc28gdGhlIGRlZmF1bHQgc29ydCByZWZsZWN0cyB0aGF0IG9wdGlvblxuXHRcdFx0XHRpZiAoIG9Jbml0LmFhU29ydGluZyA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHZhciBzb3J0aW5nID0gb1NldHRpbmdzLmFhU29ydGluZztcblx0XHRcdFx0XHRmb3IgKCBpPTAsIGlMZW49c29ydGluZy5sZW5ndGggOyBpPGlMZW4gOyBpKysgKSB7XG5cdFx0XHRcdFx0XHRzb3J0aW5nW2ldWzFdID0gb1NldHRpbmdzLmFvQ29sdW1uc1sgaSBdLmFzU29ydGluZ1swXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFxuXHRcdFx0XHQvKiBEbyBhIGZpcnN0IHBhc3Mgb24gdGhlIHNvcnRpbmcgY2xhc3NlcyAoYWxsb3dzIGFueSBzaXplIGNoYW5nZXMgdG8gYmUgdGFrZW4gaW50b1xuXHRcdFx0XHQgKiBhY2NvdW50LCBhbmQgYWxzbyB3aWxsIGFwcGx5IHNvcnRpbmcgZGlzYWJsZWQgY2xhc3NlcyBpZiBkaXNhYmxlZFxuXHRcdFx0XHQgKi9cblx0XHRcdFx0X2ZuU29ydGluZ0NsYXNzZXMoIG9TZXR0aW5ncyApO1xuXHRcdFx0XG5cdFx0XHRcdGlmICggZmVhdHVyZXMuYlNvcnQgKSB7XG5cdFx0XHRcdFx0X2ZuQ2FsbGJhY2tSZWcoIG9TZXR0aW5ncywgJ2FvRHJhd0NhbGxiYWNrJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0aWYgKCBvU2V0dGluZ3MuYlNvcnRlZCApIHtcblx0XHRcdFx0XHRcdFx0dmFyIGFTb3J0ID0gX2ZuU29ydEZsYXR0ZW4oIG9TZXR0aW5ncyApO1xuXHRcdFx0XHRcdFx0XHR2YXIgc29ydGVkQ29sdW1ucyA9IHt9O1xuXHRcdFx0XG5cdFx0XHRcdFx0XHRcdCQuZWFjaCggYVNvcnQsIGZ1bmN0aW9uIChpLCB2YWwpIHtcblx0XHRcdFx0XHRcdFx0XHRzb3J0ZWRDb2x1bW5zWyB2YWwuc3JjIF0gPSB2YWwuZGlyO1xuXHRcdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcblx0XHRcdFx0XHRcdFx0X2ZuQ2FsbGJhY2tGaXJlKCBvU2V0dGluZ3MsIG51bGwsICdvcmRlcicsIFtvU2V0dGluZ3MsIGFTb3J0LCBzb3J0ZWRDb2x1bW5zXSApO1xuXHRcdFx0XHRcdFx0XHRfZm5Tb3J0QXJpYSggb1NldHRpbmdzICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcblx0XHRcdFx0X2ZuQ2FsbGJhY2tSZWcoIG9TZXR0aW5ncywgJ2FvRHJhd0NhbGxiYWNrJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdGlmICggb1NldHRpbmdzLmJTb3J0ZWQgfHwgX2ZuRGF0YVNvdXJjZSggb1NldHRpbmdzICkgPT09ICdzc3AnIHx8IGZlYXR1cmVzLmJEZWZlclJlbmRlciApIHtcblx0XHRcdFx0XHRcdF9mblNvcnRpbmdDbGFzc2VzKCBvU2V0dGluZ3MgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sICdzYycgKTtcblx0XHRcdFxuXHRcdFx0XG5cdFx0XHRcdC8qXG5cdFx0XHRcdCAqIEZpbmFsIGluaXRcblx0XHRcdFx0ICogQ2FjaGUgdGhlIGhlYWRlciwgYm9keSBhbmQgZm9vdGVyIGFzIHJlcXVpcmVkLCBjcmVhdGluZyB0aGVtIGlmIG5lZWRlZFxuXHRcdFx0XHQgKi9cblx0XHRcdFxuXHRcdFx0XHQvLyBXb3JrIGFyb3VuZCBmb3IgV2Via2l0IGJ1ZyA4Mzg2NyAtIHN0b3JlIHRoZSBjYXB0aW9uLXNpZGUgYmVmb3JlIHJlbW92aW5nIGZyb20gZG9jXG5cdFx0XHRcdHZhciBjYXB0aW9ucyA9ICR0aGlzLmNoaWxkcmVuKCdjYXB0aW9uJykuZWFjaCggZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHRoaXMuX2NhcHRpb25TaWRlID0gJCh0aGlzKS5jc3MoJ2NhcHRpb24tc2lkZScpO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHRcblx0XHRcdFx0dmFyIHRoZWFkID0gJHRoaXMuY2hpbGRyZW4oJ3RoZWFkJyk7XG5cdFx0XHRcdGlmICggdGhlYWQubGVuZ3RoID09PSAwICkge1xuXHRcdFx0XHRcdHRoZWFkID0gJCgnPHRoZWFkLz4nKS5hcHBlbmRUbygkdGhpcyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0b1NldHRpbmdzLm5USGVhZCA9IHRoZWFkWzBdO1xuXHRcdFx0XG5cdFx0XHRcdHZhciB0Ym9keSA9ICR0aGlzLmNoaWxkcmVuKCd0Ym9keScpO1xuXHRcdFx0XHRpZiAoIHRib2R5Lmxlbmd0aCA9PT0gMCApIHtcblx0XHRcdFx0XHR0Ym9keSA9ICQoJzx0Ym9keS8+JykuYXBwZW5kVG8oJHRoaXMpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG9TZXR0aW5ncy5uVEJvZHkgPSB0Ym9keVswXTtcblx0XHRcdFxuXHRcdFx0XHR2YXIgdGZvb3QgPSAkdGhpcy5jaGlsZHJlbigndGZvb3QnKTtcblx0XHRcdFx0aWYgKCB0Zm9vdC5sZW5ndGggPT09IDAgJiYgY2FwdGlvbnMubGVuZ3RoID4gMCAmJiAob1NldHRpbmdzLm9TY3JvbGwuc1ggIT09IFwiXCIgfHwgb1NldHRpbmdzLm9TY3JvbGwuc1kgIT09IFwiXCIpICkge1xuXHRcdFx0XHRcdC8vIElmIHdlIGFyZSBhIHNjcm9sbGluZyB0YWJsZSwgYW5kIG5vIGZvb3RlciBoYXMgYmVlbiBnaXZlbiwgdGhlbiB3ZSBuZWVkIHRvIGNyZWF0ZVxuXHRcdFx0XHRcdC8vIGEgdGZvb3QgZWxlbWVudCBmb3IgdGhlIGNhcHRpb24gZWxlbWVudCB0byBiZSBhcHBlbmRlZCB0b1xuXHRcdFx0XHRcdHRmb290ID0gJCgnPHRmb290Lz4nKS5hcHBlbmRUbygkdGhpcyk7XG5cdFx0XHRcdH1cblx0XHRcdFxuXHRcdFx0XHRpZiAoIHRmb290Lmxlbmd0aCA9PT0gMCB8fCB0Zm9vdC5jaGlsZHJlbigpLmxlbmd0aCA9PT0gMCApIHtcblx0XHRcdFx0XHQkdGhpcy5hZGRDbGFzcyggb0NsYXNzZXMuc05vRm9vdGVyICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAoIHRmb290Lmxlbmd0aCA+IDAgKSB7XG5cdFx0XHRcdFx0b1NldHRpbmdzLm5URm9vdCA9IHRmb290WzBdO1xuXHRcdFx0XHRcdF9mbkRldGVjdEhlYWRlciggb1NldHRpbmdzLmFvRm9vdGVyLCBvU2V0dGluZ3MublRGb290ICk7XG5cdFx0XHRcdH1cblx0XHRcdFxuXHRcdFx0XHQvKiBDaGVjayBpZiB0aGVyZSBpcyBkYXRhIHBhc3NpbmcgaW50byB0aGUgY29uc3RydWN0b3IgKi9cblx0XHRcdFx0aWYgKCBvSW5pdC5hYURhdGEgKSB7XG5cdFx0XHRcdFx0Zm9yICggaT0wIDsgaTxvSW5pdC5hYURhdGEubGVuZ3RoIDsgaSsrICkge1xuXHRcdFx0XHRcdFx0X2ZuQWRkRGF0YSggb1NldHRpbmdzLCBvSW5pdC5hYURhdGFbIGkgXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmICggb1NldHRpbmdzLmJEZWZlckxvYWRpbmcgfHwgX2ZuRGF0YVNvdXJjZSggb1NldHRpbmdzICkgPT0gJ2RvbScgKSB7XG5cdFx0XHRcdFx0LyogR3JhYiB0aGUgZGF0YSBmcm9tIHRoZSBwYWdlIC0gb25seSBkbyB0aGlzIHdoZW4gZGVmZXJyZWQgbG9hZGluZyBvciBubyBBamF4XG5cdFx0XHRcdFx0ICogc291cmNlIHNpbmNlIHRoZXJlIGlzIG5vIHBvaW50IGluIHJlYWRpbmcgdGhlIERPTSBkYXRhIGlmIHdlIGFyZSB0aGVuIGdvaW5nXG5cdFx0XHRcdFx0ICogdG8gcmVwbGFjZSBpdCB3aXRoIEFqYXggZGF0YVxuXHRcdFx0XHRcdCAqL1xuXHRcdFx0XHRcdF9mbkFkZFRyKCBvU2V0dGluZ3MsICQob1NldHRpbmdzLm5UQm9keSkuY2hpbGRyZW4oJ3RyJykgKTtcblx0XHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRcdC8qIENvcHkgdGhlIGRhdGEgaW5kZXggYXJyYXkgKi9cblx0XHRcdFx0b1NldHRpbmdzLmFpRGlzcGxheSA9IG9TZXR0aW5ncy5haURpc3BsYXlNYXN0ZXIuc2xpY2UoKTtcblx0XHRcdFxuXHRcdFx0XHQvKiBJbml0aWFsaXNhdGlvbiBjb21wbGV0ZSAtIHRhYmxlIGNhbiBiZSBkcmF3biAqL1xuXHRcdFx0XHRvU2V0dGluZ3MuYkluaXRpYWxpc2VkID0gdHJ1ZTtcblx0XHRcdFxuXHRcdFx0XHQvKiBDaGVjayBpZiB3ZSBuZWVkIHRvIGluaXRpYWxpc2UgdGhlIHRhYmxlIChpdCBtaWdodCBub3QgaGF2ZSBiZWVuIGhhbmRlZCBvZmYgdG8gdGhlXG5cdFx0XHRcdCAqIGxhbmd1YWdlIHByb2Nlc3Nvcilcblx0XHRcdFx0ICovXG5cdFx0XHRcdGlmICggYkluaXRIYW5kZWRPZmYgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdF9mbkluaXRpYWxpc2UoIG9TZXR0aW5ncyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHQvKiBNdXN0IGJlIGRvbmUgYWZ0ZXIgZXZlcnl0aGluZyB3aGljaCBjYW4gYmUgb3ZlcnJpZGRlbiBieSB0aGUgc3RhdGUgc2F2aW5nISAqL1xuXHRcdFx0aWYgKCBvSW5pdC5iU3RhdGVTYXZlIClcblx0XHRcdHtcblx0XHRcdFx0ZmVhdHVyZXMuYlN0YXRlU2F2ZSA9IHRydWU7XG5cdFx0XHRcdF9mbkNhbGxiYWNrUmVnKCBvU2V0dGluZ3MsICdhb0RyYXdDYWxsYmFjaycsIF9mblNhdmVTdGF0ZSwgJ3N0YXRlX3NhdmUnICk7XG5cdFx0XHRcdF9mbkxvYWRTdGF0ZSggb1NldHRpbmdzLCBvSW5pdCwgbG9hZGVkSW5pdCApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGxvYWRlZEluaXQoKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdH0gKTtcblx0XHRfdGhhdCA9IG51bGw7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0XG5cdC8qXG5cdCAqIEl0IGlzIHVzZWZ1bCB0byBoYXZlIHZhcmlhYmxlcyB3aGljaCBhcmUgc2NvcGVkIGxvY2FsbHkgc28gb25seSB0aGVcblx0ICogRGF0YVRhYmxlcyBmdW5jdGlvbnMgY2FuIGFjY2VzcyB0aGVtIGFuZCB0aGV5IGRvbid0IGxlYWsgaW50byBnbG9iYWwgc3BhY2UuXG5cdCAqIEF0IHRoZSBzYW1lIHRpbWUgdGhlc2UgZnVuY3Rpb25zIGFyZSBvZnRlbiB1c2VmdWwgb3ZlciBtdWx0aXBsZSBmaWxlcyBpbiB0aGVcblx0ICogY29yZSBhbmQgQVBJLCBzbyB3ZSBsaXN0LCBvciBhdCBsZWFzdCBkb2N1bWVudCwgYWxsIHZhcmlhYmxlcyB3aGljaCBhcmUgdXNlZFxuXHQgKiBieSBEYXRhVGFibGVzIGFzIHByaXZhdGUgdmFyaWFibGVzIGhlcmUuIFRoaXMgYWxzbyBlbnN1cmVzIHRoYXQgdGhlcmUgaXMgbm9cblx0ICogY2xhc2hpbmcgb2YgdmFyaWFibGUgbmFtZXMgYW5kIHRoYXQgdGhleSBjYW4gZWFzaWx5IHJlZmVyZW5jZWQgZm9yIHJldXNlLlxuXHQgKi9cblx0XG5cdFxuXHQvLyBEZWZpbmVkIGVsc2Ugd2hlcmVcblx0Ly8gIF9zZWxlY3Rvcl9ydW5cblx0Ly8gIF9zZWxlY3Rvcl9vcHRzXG5cdC8vICBfc2VsZWN0b3JfZmlyc3Rcblx0Ly8gIF9zZWxlY3Rvcl9yb3dfaW5kZXhlc1xuXHRcblx0dmFyIF9leHQ7IC8vIERhdGFUYWJsZS5leHRcblx0dmFyIF9BcGk7IC8vIERhdGFUYWJsZS5BcGlcblx0dmFyIF9hcGlfcmVnaXN0ZXI7IC8vIERhdGFUYWJsZS5BcGkucmVnaXN0ZXJcblx0dmFyIF9hcGlfcmVnaXN0ZXJQbHVyYWw7IC8vIERhdGFUYWJsZS5BcGkucmVnaXN0ZXJQbHVyYWxcblx0XG5cdHZhciBfcmVfZGljID0ge307XG5cdHZhciBfcmVfbmV3X2xpbmVzID0gL1tcXHJcXG5cXHUyMDI4XS9nO1xuXHR2YXIgX3JlX2h0bWwgPSAvPC4qPz4vZztcblx0XG5cdC8vIFRoaXMgaXMgbm90IHN0cmljdCBJU084NjAxIC0gRGF0ZS5wYXJzZSgpIGlzIHF1aXRlIGxheCwgYWx0aG91Z2hcblx0Ly8gaW1wbGVtZW50YXRpb25zIGRpZmZlciBiZXR3ZWVuIGJyb3dzZXJzLlxuXHR2YXIgX3JlX2RhdGUgPSAvXlxcZHsyLDR9W1xcLlxcL1xcLV1cXGR7MSwyfVtcXC5cXC9cXC1dXFxkezEsMn0oW1QgXXsxfVxcZHsxLDJ9WzpcXC5dXFxkezJ9KFtcXC46XVxcZHsyfSk/KT8kLztcblx0XG5cdC8vIEVzY2FwZSByZWd1bGFyIGV4cHJlc3Npb24gc3BlY2lhbCBjaGFyYWN0ZXJzXG5cdHZhciBfcmVfZXNjYXBlX3JlZ2V4ID0gbmV3IFJlZ0V4cCggJyhcXFxcJyArIFsgJy8nLCAnLicsICcqJywgJysnLCAnPycsICd8JywgJygnLCAnKScsICdbJywgJ10nLCAneycsICd9JywgJ1xcXFwnLCAnJCcsICdeJywgJy0nIF0uam9pbignfFxcXFwnKSArICcpJywgJ2cnICk7XG5cdFxuXHQvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0ZvcmVpZ25fZXhjaGFuZ2VfbWFya2V0XG5cdC8vIC0gXFx1MjBCRCAtIFJ1c3NpYW4gcnVibGUuXG5cdC8vIC0gXFx1MjBhOSAtIFNvdXRoIEtvcmVhbiBXb25cblx0Ly8gLSBcXHUyMEJBIC0gVHVya2lzaCBMaXJhXG5cdC8vIC0gXFx1MjBCOSAtIEluZGlhbiBSdXBlZVxuXHQvLyAtIFIgLSBCcmF6aWwgKFIkKSBhbmQgU291dGggQWZyaWNhXG5cdC8vIC0gZnIgLSBTd2lzcyBGcmFuY1xuXHQvLyAtIGtyIC0gU3dlZGlzaCBrcm9uYSwgTm9yd2VnaWFuIGtyb25lIGFuZCBEYW5pc2gga3JvbmVcblx0Ly8gLSBcXHUyMDA5IGlzIHRoaW4gc3BhY2UgYW5kIFxcdTIwMkYgaXMgbmFycm93IG5vLWJyZWFrIHNwYWNlLCBib3RoIHVzZWQgaW4gbWFueVxuXHQvLyAtIMmDIC0gQml0Y29pblxuXHQvLyAtIM6eIC0gRXRoZXJldW1cblx0Ly8gICBzdGFuZGFyZHMgYXMgdGhvdXNhbmRzIHNlcGFyYXRvcnMuXG5cdHZhciBfcmVfZm9ybWF0dGVkX251bWVyaWMgPSAvWycsJMKj4oKswqUlXFx1MjAwOVxcdTIwMkZcXHUyMEJEXFx1MjBhOVxcdTIwQkFyZmvJg86eXS9naTtcblx0XG5cdFxuXHR2YXIgX2VtcHR5ID0gZnVuY3Rpb24gKCBkICkge1xuXHRcdHJldHVybiAhZCB8fCBkID09PSB0cnVlIHx8IGQgPT09ICctJyA/IHRydWUgOiBmYWxzZTtcblx0fTtcblx0XG5cdFxuXHR2YXIgX2ludFZhbCA9IGZ1bmN0aW9uICggcyApIHtcblx0XHR2YXIgaW50ZWdlciA9IHBhcnNlSW50KCBzLCAxMCApO1xuXHRcdHJldHVybiAhaXNOYU4oaW50ZWdlcikgJiYgaXNGaW5pdGUocykgPyBpbnRlZ2VyIDogbnVsbDtcblx0fTtcblx0XG5cdC8vIENvbnZlcnQgZnJvbSBhIGZvcm1hdHRlZCBudW1iZXIgd2l0aCBjaGFyYWN0ZXJzIG90aGVyIHRoYW4gYC5gIGFzIHRoZVxuXHQvLyBkZWNpbWFsIHBsYWNlLCB0byBhIEphdmFzY3JpcHQgbnVtYmVyXG5cdHZhciBfbnVtVG9EZWNpbWFsID0gZnVuY3Rpb24gKCBudW0sIGRlY2ltYWxQb2ludCApIHtcblx0XHQvLyBDYWNoZSBjcmVhdGVkIHJlZ3VsYXIgZXhwcmVzc2lvbnMgZm9yIHNwZWVkIGFzIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIG9mdGVuXG5cdFx0aWYgKCAhIF9yZV9kaWNbIGRlY2ltYWxQb2ludCBdICkge1xuXHRcdFx0X3JlX2RpY1sgZGVjaW1hbFBvaW50IF0gPSBuZXcgUmVnRXhwKCBfZm5Fc2NhcGVSZWdleCggZGVjaW1hbFBvaW50ICksICdnJyApO1xuXHRcdH1cblx0XHRyZXR1cm4gdHlwZW9mIG51bSA9PT0gJ3N0cmluZycgJiYgZGVjaW1hbFBvaW50ICE9PSAnLicgP1xuXHRcdFx0bnVtLnJlcGxhY2UoIC9cXC4vZywgJycgKS5yZXBsYWNlKCBfcmVfZGljWyBkZWNpbWFsUG9pbnQgXSwgJy4nICkgOlxuXHRcdFx0bnVtO1xuXHR9O1xuXHRcblx0XG5cdHZhciBfaXNOdW1iZXIgPSBmdW5jdGlvbiAoIGQsIGRlY2ltYWxQb2ludCwgZm9ybWF0dGVkICkge1xuXHRcdHZhciBzdHJUeXBlID0gdHlwZW9mIGQgPT09ICdzdHJpbmcnO1xuXHRcblx0XHQvLyBJZiBlbXB0eSByZXR1cm4gaW1tZWRpYXRlbHkgc28gdGhlcmUgbXVzdCBiZSBhIG51bWJlciBpZiBpdCBpcyBhXG5cdFx0Ly8gZm9ybWF0dGVkIHN0cmluZyAodGhpcyBzdG9wcyB0aGUgc3RyaW5nIFwia1wiLCBvciBcImtyXCIsIGV0YyBiZWluZyBkZXRlY3RlZFxuXHRcdC8vIGFzIGEgZm9ybWF0dGVkIG51bWJlciBmb3IgY3VycmVuY3lcblx0XHRpZiAoIF9lbXB0eSggZCApICkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcblx0XHRpZiAoIGRlY2ltYWxQb2ludCAmJiBzdHJUeXBlICkge1xuXHRcdFx0ZCA9IF9udW1Ub0RlY2ltYWwoIGQsIGRlY2ltYWxQb2ludCApO1xuXHRcdH1cblx0XG5cdFx0aWYgKCBmb3JtYXR0ZWQgJiYgc3RyVHlwZSApIHtcblx0XHRcdGQgPSBkLnJlcGxhY2UoIF9yZV9mb3JtYXR0ZWRfbnVtZXJpYywgJycgKTtcblx0XHR9XG5cdFxuXHRcdHJldHVybiAhaXNOYU4oIHBhcnNlRmxvYXQoZCkgKSAmJiBpc0Zpbml0ZSggZCApO1xuXHR9O1xuXHRcblx0XG5cdC8vIEEgc3RyaW5nIHdpdGhvdXQgSFRNTCBpbiBpdCBjYW4gYmUgY29uc2lkZXJlZCB0byBiZSBIVE1MIHN0aWxsXG5cdHZhciBfaXNIdG1sID0gZnVuY3Rpb24gKCBkICkge1xuXHRcdHJldHVybiBfZW1wdHkoIGQgKSB8fCB0eXBlb2YgZCA9PT0gJ3N0cmluZyc7XG5cdH07XG5cdFxuXHRcblx0dmFyIF9odG1sTnVtZXJpYyA9IGZ1bmN0aW9uICggZCwgZGVjaW1hbFBvaW50LCBmb3JtYXR0ZWQgKSB7XG5cdFx0aWYgKCBfZW1wdHkoIGQgKSApIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XG5cdFx0dmFyIGh0bWwgPSBfaXNIdG1sKCBkICk7XG5cdFx0cmV0dXJuICEgaHRtbCA/XG5cdFx0XHRudWxsIDpcblx0XHRcdF9pc051bWJlciggX3N0cmlwSHRtbCggZCApLCBkZWNpbWFsUG9pbnQsIGZvcm1hdHRlZCApID9cblx0XHRcdFx0dHJ1ZSA6XG5cdFx0XHRcdG51bGw7XG5cdH07XG5cdFxuXHRcblx0dmFyIF9wbHVjayA9IGZ1bmN0aW9uICggYSwgcHJvcCwgcHJvcDIgKSB7XG5cdFx0dmFyIG91dCA9IFtdO1xuXHRcdHZhciBpPTAsIGllbj1hLmxlbmd0aDtcblx0XG5cdFx0Ly8gQ291bGQgaGF2ZSB0aGUgdGVzdCBpbiB0aGUgbG9vcCBmb3Igc2xpZ2h0bHkgc21hbGxlciBjb2RlLCBidXQgc3BlZWRcblx0XHQvLyBpcyBlc3NlbnRpYWwgaGVyZVxuXHRcdGlmICggcHJvcDIgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGZvciAoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdGlmICggYVtpXSAmJiBhW2ldWyBwcm9wIF0gKSB7XG5cdFx0XHRcdFx0b3V0LnB1c2goIGFbaV1bIHByb3AgXVsgcHJvcDIgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0Zm9yICggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBhW2ldICkge1xuXHRcdFx0XHRcdG91dC5wdXNoKCBhW2ldWyBwcm9wIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0cmV0dXJuIG91dDtcblx0fTtcblx0XG5cdFxuXHQvLyBCYXNpY2FsbHkgdGhlIHNhbWUgYXMgX3BsdWNrLCBidXQgcmF0aGVyIHRoYW4gbG9vcGluZyBvdmVyIGBhYCB3ZSB1c2UgYG9yZGVyYFxuXHQvLyBhcyB0aGUgaW5kZXhlcyB0byBwaWNrIGZyb20gYGFgXG5cdHZhciBfcGx1Y2tfb3JkZXIgPSBmdW5jdGlvbiAoIGEsIG9yZGVyLCBwcm9wLCBwcm9wMiApXG5cdHtcblx0XHR2YXIgb3V0ID0gW107XG5cdFx0dmFyIGk9MCwgaWVuPW9yZGVyLmxlbmd0aDtcblx0XG5cdFx0Ly8gQ291bGQgaGF2ZSB0aGUgdGVzdCBpbiB0aGUgbG9vcCBmb3Igc2xpZ2h0bHkgc21hbGxlciBjb2RlLCBidXQgc3BlZWRcblx0XHQvLyBpcyBlc3NlbnRpYWwgaGVyZVxuXHRcdGlmICggcHJvcDIgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGZvciAoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdGlmICggYVsgb3JkZXJbaV0gXVsgcHJvcCBdICkge1xuXHRcdFx0XHRcdG91dC5wdXNoKCBhWyBvcmRlcltpXSBdWyBwcm9wIF1bIHByb3AyIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGZvciAoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdG91dC5wdXNoKCBhWyBvcmRlcltpXSBdWyBwcm9wIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cdFxuXHRcdHJldHVybiBvdXQ7XG5cdH07XG5cdFxuXHRcblx0dmFyIF9yYW5nZSA9IGZ1bmN0aW9uICggbGVuLCBzdGFydCApXG5cdHtcblx0XHR2YXIgb3V0ID0gW107XG5cdFx0dmFyIGVuZDtcblx0XG5cdFx0aWYgKCBzdGFydCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0c3RhcnQgPSAwO1xuXHRcdFx0ZW5kID0gbGVuO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGVuZCA9IHN0YXJ0O1xuXHRcdFx0c3RhcnQgPSBsZW47XG5cdFx0fVxuXHRcblx0XHRmb3IgKCB2YXIgaT1zdGFydCA7IGk8ZW5kIDsgaSsrICkge1xuXHRcdFx0b3V0LnB1c2goIGkgKTtcblx0XHR9XG5cdFxuXHRcdHJldHVybiBvdXQ7XG5cdH07XG5cdFxuXHRcblx0dmFyIF9yZW1vdmVFbXB0eSA9IGZ1bmN0aW9uICggYSApXG5cdHtcblx0XHR2YXIgb3V0ID0gW107XG5cdFxuXHRcdGZvciAoIHZhciBpPTAsIGllbj1hLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0aWYgKCBhW2ldICkgeyAvLyBjYXJlZnVsIC0gd2lsbCByZW1vdmUgYWxsIGZhbHN5IHZhbHVlcyFcblx0XHRcdFx0b3V0LnB1c2goIGFbaV0gKTtcblx0XHRcdH1cblx0XHR9XG5cdFxuXHRcdHJldHVybiBvdXQ7XG5cdH07XG5cdFxuXHRcblx0dmFyIF9zdHJpcEh0bWwgPSBmdW5jdGlvbiAoIGQgKSB7XG5cdFx0cmV0dXJuIGQucmVwbGFjZSggX3JlX2h0bWwsICcnICk7XG5cdH07XG5cdFxuXHRcblx0LyoqXG5cdCAqIERldGVybWluZSBpZiBhbGwgdmFsdWVzIGluIHRoZSBhcnJheSBhcmUgdW5pcXVlLiBUaGlzIG1lYW5zIHdlIGNhbiBzaG9ydFxuXHQgKiBjdXQgdGhlIF91bmlxdWUgbWV0aG9kIGF0IHRoZSBjb3N0IG9mIGEgc2luZ2xlIGxvb3AuIEEgc29ydGVkIGFycmF5IGlzIHVzZWRcblx0ICogdG8gZWFzaWx5IGNoZWNrIHRoZSB2YWx1ZXMuXG5cdCAqXG5cdCAqIEBwYXJhbSAge2FycmF5fSBzcmMgU291cmNlIGFycmF5XG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgYWxsIHVuaXF1ZSwgZmFsc2Ugb3RoZXJ3aXNlXG5cdCAqIEBpZ25vcmVcblx0ICovXG5cdHZhciBfYXJlQWxsVW5pcXVlID0gZnVuY3Rpb24gKCBzcmMgKSB7XG5cdFx0aWYgKCBzcmMubGVuZ3RoIDwgMiApIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XG5cdFx0dmFyIHNvcnRlZCA9IHNyYy5zbGljZSgpLnNvcnQoKTtcblx0XHR2YXIgbGFzdCA9IHNvcnRlZFswXTtcblx0XG5cdFx0Zm9yICggdmFyIGk9MSwgaWVuPXNvcnRlZC5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdGlmICggc29ydGVkW2ldID09PSBsYXN0ICkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFxuXHRcdFx0bGFzdCA9IHNvcnRlZFtpXTtcblx0XHR9XG5cdFxuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXHRcblx0XG5cdC8qKlxuXHQgKiBGaW5kIHRoZSB1bmlxdWUgZWxlbWVudHMgaW4gYSBzb3VyY2UgYXJyYXkuXG5cdCAqXG5cdCAqIEBwYXJhbSAge2FycmF5fSBzcmMgU291cmNlIGFycmF5XG5cdCAqIEByZXR1cm4ge2FycmF5fSBBcnJheSBvZiB1bmlxdWUgaXRlbXNcblx0ICogQGlnbm9yZVxuXHQgKi9cblx0dmFyIF91bmlxdWUgPSBmdW5jdGlvbiAoIHNyYyApXG5cdHtcblx0XHRpZiAoIF9hcmVBbGxVbmlxdWUoIHNyYyApICkge1xuXHRcdFx0cmV0dXJuIHNyYy5zbGljZSgpO1xuXHRcdH1cblx0XG5cdFx0Ly8gQSBmYXN0ZXIgdW5pcXVlIG1ldGhvZCBpcyB0byB1c2Ugb2JqZWN0IGtleXMgdG8gaWRlbnRpZnkgdXNlZCB2YWx1ZXMsXG5cdFx0Ly8gYnV0IHRoaXMgZG9lc24ndCB3b3JrIHdpdGggYXJyYXlzIG9yIG9iamVjdHMsIHdoaWNoIHdlIG11c3QgYWxzb1xuXHRcdC8vIGNvbnNpZGVyLiBTZWUganNwZXJmLmNvbS9jb21wYXJlLWFycmF5LXVuaXF1ZS12ZXJzaW9ucy80IGZvciBtb3JlXG5cdFx0Ly8gaW5mb3JtYXRpb24uXG5cdFx0dmFyXG5cdFx0XHRvdXQgPSBbXSxcblx0XHRcdHZhbCxcblx0XHRcdGksIGllbj1zcmMubGVuZ3RoLFxuXHRcdFx0aiwgaz0wO1xuXHRcblx0XHRhZ2FpbjogZm9yICggaT0wIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHR2YWwgPSBzcmNbaV07XG5cdFxuXHRcdFx0Zm9yICggaj0wIDsgajxrIDsgaisrICkge1xuXHRcdFx0XHRpZiAoIG91dFtqXSA9PT0gdmFsICkge1xuXHRcdFx0XHRcdGNvbnRpbnVlIGFnYWluO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFxuXHRcdFx0b3V0LnB1c2goIHZhbCApO1xuXHRcdFx0aysrO1xuXHRcdH1cblx0XG5cdFx0cmV0dXJuIG91dDtcblx0fTtcblx0XG5cdFxuXHQvKipcblx0ICogRGF0YVRhYmxlcyB1dGlsaXR5IG1ldGhvZHNcblx0ICogXG5cdCAqIFRoaXMgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBtZXRob2RzIHRoYXQgRGF0YVRhYmxlcyB1c2VzIGludGVybmFsbHkgdG9cblx0ICogY3JlYXRlIGEgRGF0YVRhYmxlLCBidXQgd2hpY2ggYXJlIG5vdCBleGNsdXNpdmVseSB1c2VkIG9ubHkgZm9yIERhdGFUYWJsZXMuXG5cdCAqIFRoZXNlIG1ldGhvZHMgY2FuIGJlIHVzZWQgYnkgZXh0ZW5zaW9uIGF1dGhvcnMgdG8gc2F2ZSB0aGUgZHVwbGljYXRpb24gb2Zcblx0ICogY29kZS5cblx0ICpcblx0ICogIEBuYW1lc3BhY2Vcblx0ICovXG5cdERhdGFUYWJsZS51dGlsID0ge1xuXHRcdC8qKlxuXHRcdCAqIFRocm90dGxlIHRoZSBjYWxscyB0byBhIGZ1bmN0aW9uLiBBcmd1bWVudHMgYW5kIGNvbnRleHQgYXJlIG1haW50YWluZWRcblx0XHQgKiBmb3IgdGhlIHRocm90dGxlZCBmdW5jdGlvbi5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGJlIGNhbGxlZFxuXHRcdCAqIEBwYXJhbSB7aW50ZWdlcn0gZnJlcSBDYWxsIGZyZXF1ZW5jeSBpbiBtU1xuXHRcdCAqIEByZXR1cm4ge2Z1bmN0aW9ufSBXcmFwcGVkIGZ1bmN0aW9uXG5cdFx0ICovXG5cdFx0dGhyb3R0bGU6IGZ1bmN0aW9uICggZm4sIGZyZXEgKSB7XG5cdFx0XHR2YXJcblx0XHRcdFx0ZnJlcXVlbmN5ID0gZnJlcSAhPT0gdW5kZWZpbmVkID8gZnJlcSA6IDIwMCxcblx0XHRcdFx0bGFzdCxcblx0XHRcdFx0dGltZXI7XG5cdFxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dmFyXG5cdFx0XHRcdFx0dGhhdCA9IHRoaXMsXG5cdFx0XHRcdFx0bm93ICA9ICtuZXcgRGF0ZSgpLFxuXHRcdFx0XHRcdGFyZ3MgPSBhcmd1bWVudHM7XG5cdFxuXHRcdFx0XHRpZiAoIGxhc3QgJiYgbm93IDwgbGFzdCArIGZyZXF1ZW5jeSApIHtcblx0XHRcdFx0XHRjbGVhclRpbWVvdXQoIHRpbWVyICk7XG5cdFxuXHRcdFx0XHRcdHRpbWVyID0gc2V0VGltZW91dCggZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0bGFzdCA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdGZuLmFwcGx5KCB0aGF0LCBhcmdzICk7XG5cdFx0XHRcdFx0fSwgZnJlcXVlbmN5ICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0bGFzdCA9IG5vdztcblx0XHRcdFx0XHRmbi5hcHBseSggdGhhdCwgYXJncyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH0sXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBFc2NhcGUgYSBzdHJpbmcgc3VjaCB0aGF0IGl0IGNhbiBiZSB1c2VkIGluIGEgcmVndWxhciBleHByZXNzaW9uXG5cdFx0ICpcblx0XHQgKiAgQHBhcmFtIHtzdHJpbmd9IHZhbCBzdHJpbmcgdG8gZXNjYXBlXG5cdFx0ICogIEByZXR1cm5zIHtzdHJpbmd9IGVzY2FwZWQgc3RyaW5nXG5cdFx0ICovXG5cdFx0ZXNjYXBlUmVnZXg6IGZ1bmN0aW9uICggdmFsICkge1xuXHRcdFx0cmV0dXJuIHZhbC5yZXBsYWNlKCBfcmVfZXNjYXBlX3JlZ2V4LCAnXFxcXCQxJyApO1xuXHRcdH1cblx0fTtcblx0XG5cdFxuXHRcblx0LyoqXG5cdCAqIENyZWF0ZSBhIG1hcHBpbmcgb2JqZWN0IHRoYXQgYWxsb3dzIGNhbWVsIGNhc2UgcGFyYW1ldGVycyB0byBiZSBsb29rZWQgdXBcblx0ICogZm9yIHRoZWlyIEh1bmdhcmlhbiBjb3VudGVycGFydHMuIFRoZSBtYXBwaW5nIGlzIHN0b3JlZCBpbiBhIHByaXZhdGVcblx0ICogcGFyYW1ldGVyIGNhbGxlZCBgX2h1bmdhcmlhbk1hcGAgd2hpY2ggY2FuIGJlIGFjY2Vzc2VkIG9uIHRoZSBzb3VyY2Ugb2JqZWN0LlxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9cblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuSHVuZ2FyaWFuTWFwICggbyApXG5cdHtcblx0XHR2YXJcblx0XHRcdGh1bmdhcmlhbiA9ICdhIGFhIGFpIGFvIGFzIGIgZm4gaSBtIG8gcyAnLFxuXHRcdFx0bWF0Y2gsXG5cdFx0XHRuZXdLZXksXG5cdFx0XHRtYXAgPSB7fTtcblx0XG5cdFx0JC5lYWNoKCBvLCBmdW5jdGlvbiAoa2V5LCB2YWwpIHtcblx0XHRcdG1hdGNoID0ga2V5Lm1hdGNoKC9eKFteQS1aXSs/KShbQS1aXSkvKTtcblx0XG5cdFx0XHRpZiAoIG1hdGNoICYmIGh1bmdhcmlhbi5pbmRleE9mKG1hdGNoWzFdKycgJykgIT09IC0xIClcblx0XHRcdHtcblx0XHRcdFx0bmV3S2V5ID0ga2V5LnJlcGxhY2UoIG1hdGNoWzBdLCBtYXRjaFsyXS50b0xvd2VyQ2FzZSgpICk7XG5cdFx0XHRcdG1hcFsgbmV3S2V5IF0gPSBrZXk7XG5cdFxuXHRcdFx0XHRpZiAoIG1hdGNoWzFdID09PSAnbycgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0X2ZuSHVuZ2FyaWFuTWFwKCBvW2tleV0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0XG5cdFx0by5faHVuZ2FyaWFuTWFwID0gbWFwO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIENvbnZlcnQgZnJvbSBjYW1lbCBjYXNlIHBhcmFtZXRlcnMgdG8gSHVuZ2FyaWFuLCBiYXNlZCBvbiBhIEh1bmdhcmlhbiBtYXBcblx0ICogY3JlYXRlZCBieSBfZm5IdW5nYXJpYW5NYXAuXG5cdCAqICBAcGFyYW0ge29iamVjdH0gc3JjIFRoZSBtb2RlbCBvYmplY3Qgd2hpY2ggaG9sZHMgYWxsIHBhcmFtZXRlcnMgdGhhdCBjYW4gYmVcblx0ICogICAgbWFwcGVkLlxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IHVzZXIgVGhlIG9iamVjdCB0byBjb252ZXJ0IGZyb20gY2FtZWwgY2FzZSB0byBIdW5nYXJpYW4uXG5cdCAqICBAcGFyYW0ge2Jvb2xlYW59IGZvcmNlIFdoZW4gc2V0IHRvIGB0cnVlYCwgcHJvcGVydGllcyB3aGljaCBhbHJlYWR5IGhhdmUgYVxuXHQgKiAgICBIdW5nYXJpYW4gdmFsdWUgaW4gdGhlIGB1c2VyYCBvYmplY3Qgd2lsbCBiZSBvdmVyd3JpdHRlbi4gT3RoZXJ3aXNlIHRoZXlcblx0ICogICAgd29uJ3QgYmUuXG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkNhbWVsVG9IdW5nYXJpYW4gKCBzcmMsIHVzZXIsIGZvcmNlIClcblx0e1xuXHRcdGlmICggISBzcmMuX2h1bmdhcmlhbk1hcCApIHtcblx0XHRcdF9mbkh1bmdhcmlhbk1hcCggc3JjICk7XG5cdFx0fVxuXHRcblx0XHR2YXIgaHVuZ2FyaWFuS2V5O1xuXHRcblx0XHQkLmVhY2goIHVzZXIsIGZ1bmN0aW9uIChrZXksIHZhbCkge1xuXHRcdFx0aHVuZ2FyaWFuS2V5ID0gc3JjLl9odW5nYXJpYW5NYXBbIGtleSBdO1xuXHRcblx0XHRcdGlmICggaHVuZ2FyaWFuS2V5ICE9PSB1bmRlZmluZWQgJiYgKGZvcmNlIHx8IHVzZXJbaHVuZ2FyaWFuS2V5XSA9PT0gdW5kZWZpbmVkKSApXG5cdFx0XHR7XG5cdFx0XHRcdC8vIEZvciBvYmplY3RzLCB3ZSBuZWVkIHRvIGJ1enogZG93biBpbnRvIHRoZSBvYmplY3QgdG8gY29weSBwYXJhbWV0ZXJzXG5cdFx0XHRcdGlmICggaHVuZ2FyaWFuS2V5LmNoYXJBdCgwKSA9PT0gJ28nIClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdC8vIENvcHkgdGhlIGNhbWVsQ2FzZSBvcHRpb25zIG92ZXIgdG8gdGhlIGh1bmdhcmlhblxuXHRcdFx0XHRcdGlmICggISB1c2VyWyBodW5nYXJpYW5LZXkgXSApIHtcblx0XHRcdFx0XHRcdHVzZXJbIGh1bmdhcmlhbktleSBdID0ge307XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdCQuZXh0ZW5kKCB0cnVlLCB1c2VyW2h1bmdhcmlhbktleV0sIHVzZXJba2V5XSApO1xuXHRcblx0XHRcdFx0XHRfZm5DYW1lbFRvSHVuZ2FyaWFuKCBzcmNbaHVuZ2FyaWFuS2V5XSwgdXNlcltodW5nYXJpYW5LZXldLCBmb3JjZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHVzZXJbaHVuZ2FyaWFuS2V5XSA9IHVzZXJbIGtleSBdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIExhbmd1YWdlIGNvbXBhdGliaWxpdHkgLSB3aGVuIGNlcnRhaW4gb3B0aW9ucyBhcmUgZ2l2ZW4sIGFuZCBvdGhlcnMgYXJlbid0LCB3ZVxuXHQgKiBuZWVkIHRvIGR1cGxpY2F0ZSB0aGUgdmFsdWVzIG92ZXIsIGluIG9yZGVyIHRvIHByb3ZpZGUgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblx0ICogd2l0aCBvbGRlciBsYW5ndWFnZSBmaWxlcy5cblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuTGFuZ3VhZ2VDb21wYXQoIGxhbmcgKVxuXHR7XG5cdFx0Ly8gTm90ZSB0aGUgdXNlIG9mIHRoZSBIdW5nYXJpYW4gbm90YXRpb24gZm9yIHRoZSBwYXJhbWV0ZXJzIGluIHRoaXMgbWV0aG9kIGFzXG5cdFx0Ly8gdGhpcyBpcyBjYWxsZWQgYWZ0ZXIgdGhlIG1hcHBpbmcgb2YgY2FtZWxDYXNlIHRvIEh1bmdhcmlhblxuXHRcdHZhciBkZWZhdWx0cyA9IERhdGFUYWJsZS5kZWZhdWx0cy5vTGFuZ3VhZ2U7XG5cdFxuXHRcdC8vIERlZmF1bHQgbWFwcGluZ1xuXHRcdHZhciBkZWZhdWx0RGVjaW1hbCA9IGRlZmF1bHRzLnNEZWNpbWFsO1xuXHRcdGlmICggZGVmYXVsdERlY2ltYWwgKSB7XG5cdFx0XHRfYWRkTnVtZXJpY1NvcnQoIGRlZmF1bHREZWNpbWFsICk7XG5cdFx0fVxuXHRcblx0XHRpZiAoIGxhbmcgKSB7XG5cdFx0XHR2YXIgemVyb1JlY29yZHMgPSBsYW5nLnNaZXJvUmVjb3Jkcztcblx0XG5cdFx0XHQvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eSAtIGlmIHRoZXJlIGlzIG5vIHNFbXB0eVRhYmxlIGdpdmVuLCB0aGVuIHVzZSB0aGUgc2FtZSBhc1xuXHRcdFx0Ly8gc1plcm9SZWNvcmRzIC0gYXNzdW1pbmcgdGhhdCBpcyBnaXZlbi5cblx0XHRcdGlmICggISBsYW5nLnNFbXB0eVRhYmxlICYmIHplcm9SZWNvcmRzICYmXG5cdFx0XHRcdGRlZmF1bHRzLnNFbXB0eVRhYmxlID09PSBcIk5vIGRhdGEgYXZhaWxhYmxlIGluIHRhYmxlXCIgKVxuXHRcdFx0e1xuXHRcdFx0XHRfZm5NYXAoIGxhbmcsIGxhbmcsICdzWmVyb1JlY29yZHMnLCAnc0VtcHR5VGFibGUnICk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gTGlrZXdpc2Ugd2l0aCBsb2FkaW5nIHJlY29yZHNcblx0XHRcdGlmICggISBsYW5nLnNMb2FkaW5nUmVjb3JkcyAmJiB6ZXJvUmVjb3JkcyAmJlxuXHRcdFx0XHRkZWZhdWx0cy5zTG9hZGluZ1JlY29yZHMgPT09IFwiTG9hZGluZy4uLlwiIClcblx0XHRcdHtcblx0XHRcdFx0X2ZuTWFwKCBsYW5nLCBsYW5nLCAnc1plcm9SZWNvcmRzJywgJ3NMb2FkaW5nUmVjb3JkcycgKTtcblx0XHRcdH1cblx0XG5cdFx0XHQvLyBPbGQgcGFyYW1ldGVyIG5hbWUgb2YgdGhlIHRob3VzYW5kcyBzZXBhcmF0b3IgbWFwcGVkIG9udG8gdGhlIG5ld1xuXHRcdFx0aWYgKCBsYW5nLnNJbmZvVGhvdXNhbmRzICkge1xuXHRcdFx0XHRsYW5nLnNUaG91c2FuZHMgPSBsYW5nLnNJbmZvVGhvdXNhbmRzO1xuXHRcdFx0fVxuXHRcblx0XHRcdHZhciBkZWNpbWFsID0gbGFuZy5zRGVjaW1hbDtcblx0XHRcdGlmICggZGVjaW1hbCAmJiBkZWZhdWx0RGVjaW1hbCAhPT0gZGVjaW1hbCApIHtcblx0XHRcdFx0X2FkZE51bWVyaWNTb3J0KCBkZWNpbWFsICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIE1hcCBvbmUgcGFyYW1ldGVyIG9udG8gYW5vdGhlclxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG8gT2JqZWN0IHRvIG1hcFxuXHQgKiAgQHBhcmFtIHsqfSBrbmV3IFRoZSBuZXcgcGFyYW1ldGVyIG5hbWVcblx0ICogIEBwYXJhbSB7Kn0gb2xkIFRoZSBvbGQgcGFyYW1ldGVyIG5hbWVcblx0ICovXG5cdHZhciBfZm5Db21wYXRNYXAgPSBmdW5jdGlvbiAoIG8sIGtuZXcsIG9sZCApIHtcblx0XHRpZiAoIG9bIGtuZXcgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0b1sgb2xkIF0gPSBvWyBrbmV3IF07XG5cdFx0fVxuXHR9O1xuXHRcblx0XG5cdC8qKlxuXHQgKiBQcm92aWRlIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IGZvciB0aGUgbWFpbiBEVCBvcHRpb25zLiBOb3RlIHRoYXQgdGhlIG5ld1xuXHQgKiBvcHRpb25zIGFyZSBtYXBwZWQgb250byB0aGUgb2xkIHBhcmFtZXRlcnMsIHNvIHRoaXMgaXMgYW4gZXh0ZXJuYWwgaW50ZXJmYWNlXG5cdCAqIGNoYW5nZSBvbmx5LlxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IGluaXQgT2JqZWN0IHRvIG1hcFxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuQ29tcGF0T3B0cyAoIGluaXQgKVxuXHR7XG5cdFx0X2ZuQ29tcGF0TWFwKCBpbml0LCAnb3JkZXJpbmcnLCAgICAgICdiU29ydCcgKTtcblx0XHRfZm5Db21wYXRNYXAoIGluaXQsICdvcmRlck11bHRpJywgICAgJ2JTb3J0TXVsdGknICk7XG5cdFx0X2ZuQ29tcGF0TWFwKCBpbml0LCAnb3JkZXJDbGFzc2VzJywgICdiU29ydENsYXNzZXMnICk7XG5cdFx0X2ZuQ29tcGF0TWFwKCBpbml0LCAnb3JkZXJDZWxsc1RvcCcsICdiU29ydENlbGxzVG9wJyApO1xuXHRcdF9mbkNvbXBhdE1hcCggaW5pdCwgJ29yZGVyJywgICAgICAgICAnYWFTb3J0aW5nJyApO1xuXHRcdF9mbkNvbXBhdE1hcCggaW5pdCwgJ29yZGVyRml4ZWQnLCAgICAnYWFTb3J0aW5nRml4ZWQnICk7XG5cdFx0X2ZuQ29tcGF0TWFwKCBpbml0LCAncGFnaW5nJywgICAgICAgICdiUGFnaW5hdGUnICk7XG5cdFx0X2ZuQ29tcGF0TWFwKCBpbml0LCAncGFnaW5nVHlwZScsICAgICdzUGFnaW5hdGlvblR5cGUnICk7XG5cdFx0X2ZuQ29tcGF0TWFwKCBpbml0LCAncGFnZUxlbmd0aCcsICAgICdpRGlzcGxheUxlbmd0aCcgKTtcblx0XHRfZm5Db21wYXRNYXAoIGluaXQsICdzZWFyY2hpbmcnLCAgICAgJ2JGaWx0ZXInICk7XG5cdFxuXHRcdC8vIEJvb2xlYW4gaW5pdGlhbGlzYXRpb24gb2YgeC1zY3JvbGxpbmdcblx0XHRpZiAoIHR5cGVvZiBpbml0LnNTY3JvbGxYID09PSAnYm9vbGVhbicgKSB7XG5cdFx0XHRpbml0LnNTY3JvbGxYID0gaW5pdC5zU2Nyb2xsWCA/ICcxMDAlJyA6ICcnO1xuXHRcdH1cblx0XHRpZiAoIHR5cGVvZiBpbml0LnNjcm9sbFggPT09ICdib29sZWFuJyApIHtcblx0XHRcdGluaXQuc2Nyb2xsWCA9IGluaXQuc2Nyb2xsWCA/ICcxMDAlJyA6ICcnO1xuXHRcdH1cblx0XG5cdFx0Ly8gQ29sdW1uIHNlYXJjaCBvYmplY3RzIGFyZSBpbiBhbiBhcnJheSwgc28gaXQgbmVlZHMgdG8gYmUgY29udmVydGVkXG5cdFx0Ly8gZWxlbWVudCBieSBlbGVtZW50XG5cdFx0dmFyIHNlYXJjaENvbHMgPSBpbml0LmFvU2VhcmNoQ29scztcblx0XG5cdFx0aWYgKCBzZWFyY2hDb2xzICkge1xuXHRcdFx0Zm9yICggdmFyIGk9MCwgaWVuPXNlYXJjaENvbHMubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdGlmICggc2VhcmNoQ29sc1tpXSApIHtcblx0XHRcdFx0XHRfZm5DYW1lbFRvSHVuZ2FyaWFuKCBEYXRhVGFibGUubW9kZWxzLm9TZWFyY2gsIHNlYXJjaENvbHNbaV0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBQcm92aWRlIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IGZvciBjb2x1bW4gb3B0aW9ucy4gTm90ZSB0aGF0IHRoZSBuZXcgb3B0aW9uc1xuXHQgKiBhcmUgbWFwcGVkIG9udG8gdGhlIG9sZCBwYXJhbWV0ZXJzLCBzbyB0aGlzIGlzIGFuIGV4dGVybmFsIGludGVyZmFjZSBjaGFuZ2Vcblx0ICogb25seS5cblx0ICogIEBwYXJhbSB7b2JqZWN0fSBpbml0IE9iamVjdCB0byBtYXBcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkNvbXBhdENvbHMgKCBpbml0IClcblx0e1xuXHRcdF9mbkNvbXBhdE1hcCggaW5pdCwgJ29yZGVyYWJsZScsICAgICAnYlNvcnRhYmxlJyApO1xuXHRcdF9mbkNvbXBhdE1hcCggaW5pdCwgJ29yZGVyRGF0YScsICAgICAnYURhdGFTb3J0JyApO1xuXHRcdF9mbkNvbXBhdE1hcCggaW5pdCwgJ29yZGVyU2VxdWVuY2UnLCAnYXNTb3J0aW5nJyApO1xuXHRcdF9mbkNvbXBhdE1hcCggaW5pdCwgJ29yZGVyRGF0YVR5cGUnLCAnc29ydERhdGFUeXBlJyApO1xuXHRcblx0XHQvLyBvcmRlckRhdGEgY2FuIGJlIGdpdmVuIGFzIGFuIGludGVnZXJcblx0XHR2YXIgZGF0YVNvcnQgPSBpbml0LmFEYXRhU29ydDtcblx0XHRpZiAoIHR5cGVvZiBkYXRhU29ydCA9PT0gJ251bWJlcicgJiYgISAkLmlzQXJyYXkoIGRhdGFTb3J0ICkgKSB7XG5cdFx0XHRpbml0LmFEYXRhU29ydCA9IFsgZGF0YVNvcnQgXTtcblx0XHR9XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogQnJvd3NlciBmZWF0dXJlIGRldGVjdGlvbiBmb3IgY2FwYWJpbGl0aWVzLCBxdWlya3Ncblx0ICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5Ccm93c2VyRGV0ZWN0KCBzZXR0aW5ncyApXG5cdHtcblx0XHQvLyBXZSBkb24ndCBuZWVkIHRvIGRvIHRoaXMgZXZlcnkgdGltZSBEYXRhVGFibGVzIGlzIGNvbnN0cnVjdGVkLCB0aGUgdmFsdWVzXG5cdFx0Ly8gY2FsY3VsYXRlZCBhcmUgc3BlY2lmaWMgdG8gdGhlIGJyb3dzZXIgYW5kIE9TIGNvbmZpZ3VyYXRpb24gd2hpY2ggd2Vcblx0XHQvLyBkb24ndCBleHBlY3QgdG8gY2hhbmdlIGJldHdlZW4gaW5pdGlhbGlzYXRpb25zXG5cdFx0aWYgKCAhIERhdGFUYWJsZS5fX2Jyb3dzZXIgKSB7XG5cdFx0XHR2YXIgYnJvd3NlciA9IHt9O1xuXHRcdFx0RGF0YVRhYmxlLl9fYnJvd3NlciA9IGJyb3dzZXI7XG5cdFxuXHRcdFx0Ly8gU2Nyb2xsaW5nIGZlYXR1cmUgLyBxdWlya3MgZGV0ZWN0aW9uXG5cdFx0XHR2YXIgbiA9ICQoJzxkaXYvPicpXG5cdFx0XHRcdC5jc3MoIHtcblx0XHRcdFx0XHRwb3NpdGlvbjogJ2ZpeGVkJyxcblx0XHRcdFx0XHR0b3A6IDAsXG5cdFx0XHRcdFx0bGVmdDogJCh3aW5kb3cpLnNjcm9sbExlZnQoKSotMSwgLy8gYWxsb3cgZm9yIHNjcm9sbGluZ1xuXHRcdFx0XHRcdGhlaWdodDogMSxcblx0XHRcdFx0XHR3aWR0aDogMSxcblx0XHRcdFx0XHRvdmVyZmxvdzogJ2hpZGRlbidcblx0XHRcdFx0fSApXG5cdFx0XHRcdC5hcHBlbmQoXG5cdFx0XHRcdFx0JCgnPGRpdi8+Jylcblx0XHRcdFx0XHRcdC5jc3MoIHtcblx0XHRcdFx0XHRcdFx0cG9zaXRpb246ICdhYnNvbHV0ZScsXG5cdFx0XHRcdFx0XHRcdHRvcDogMSxcblx0XHRcdFx0XHRcdFx0bGVmdDogMSxcblx0XHRcdFx0XHRcdFx0d2lkdGg6IDEwMCxcblx0XHRcdFx0XHRcdFx0b3ZlcmZsb3c6ICdzY3JvbGwnXG5cdFx0XHRcdFx0XHR9IClcblx0XHRcdFx0XHRcdC5hcHBlbmQoXG5cdFx0XHRcdFx0XHRcdCQoJzxkaXYvPicpXG5cdFx0XHRcdFx0XHRcdFx0LmNzcygge1xuXHRcdFx0XHRcdFx0XHRcdFx0d2lkdGg6ICcxMDAlJyxcblx0XHRcdFx0XHRcdFx0XHRcdGhlaWdodDogMTBcblx0XHRcdFx0XHRcdFx0XHR9IClcblx0XHRcdFx0XHRcdClcblx0XHRcdFx0KVxuXHRcdFx0XHQuYXBwZW5kVG8oICdib2R5JyApO1xuXHRcblx0XHRcdHZhciBvdXRlciA9IG4uY2hpbGRyZW4oKTtcblx0XHRcdHZhciBpbm5lciA9IG91dGVyLmNoaWxkcmVuKCk7XG5cdFxuXHRcdFx0Ly8gTnVtYmVycyBiZWxvdywgaW4gb3JkZXIsIGFyZTpcblx0XHRcdC8vIGlubmVyLm9mZnNldFdpZHRoLCBpbm5lci5jbGllbnRXaWR0aCwgb3V0ZXIub2Zmc2V0V2lkdGgsIG91dGVyLmNsaWVudFdpZHRoXG5cdFx0XHQvL1xuXHRcdFx0Ly8gSUU2IFhQOiAgICAgICAgICAgICAgICAgICAgICAgICAgIDEwMCAxMDAgMTAwICA4M1xuXHRcdFx0Ly8gSUU3IFZpc3RhOiAgICAgICAgICAgICAgICAgICAgICAgIDEwMCAxMDAgMTAwICA4M1xuXHRcdFx0Ly8gSUUgOCsgV2luZG93czogICAgICAgICAgICAgICAgICAgICA4MyAgODMgMTAwICA4M1xuXHRcdFx0Ly8gRXZlcmdyZWVuIFdpbmRvd3M6ICAgICAgICAgICAgICAgICA4MyAgODMgMTAwICA4M1xuXHRcdFx0Ly8gRXZlcmdyZWVuIE1hYyB3aXRoIHNjcm9sbGJhcnM6ICAgICA4NSAgODUgMTAwICA4NVxuXHRcdFx0Ly8gRXZlcmdyZWVuIE1hYyB3aXRob3V0IHNjcm9sbGJhcnM6IDEwMCAxMDAgMTAwIDEwMFxuXHRcblx0XHRcdC8vIEdldCBzY3JvbGxiYXIgd2lkdGhcblx0XHRcdGJyb3dzZXIuYmFyV2lkdGggPSBvdXRlclswXS5vZmZzZXRXaWR0aCAtIG91dGVyWzBdLmNsaWVudFdpZHRoO1xuXHRcblx0XHRcdC8vIElFNi83IHdpbGwgb3ZlcnNpemUgYSB3aWR0aCAxMDAlIGVsZW1lbnQgaW5zaWRlIGEgc2Nyb2xsaW5nIGVsZW1lbnQsIHRvXG5cdFx0XHQvLyBpbmNsdWRlIHRoZSB3aWR0aCBvZiB0aGUgc2Nyb2xsYmFyLCB3aGlsZSBvdGhlciBicm93c2VycyBlbnN1cmUgdGhlIGlubmVyXG5cdFx0XHQvLyBlbGVtZW50IGlzIGNvbnRhaW5lZCB3aXRob3V0IGZvcmNpbmcgc2Nyb2xsaW5nXG5cdFx0XHRicm93c2VyLmJTY3JvbGxPdmVyc2l6ZSA9IGlubmVyWzBdLm9mZnNldFdpZHRoID09PSAxMDAgJiYgb3V0ZXJbMF0uY2xpZW50V2lkdGggIT09IDEwMDtcblx0XG5cdFx0XHQvLyBJbiBydGwgdGV4dCBsYXlvdXQsIHNvbWUgYnJvd3NlcnMgKG1vc3QsIGJ1dCBub3QgYWxsKSB3aWxsIHBsYWNlIHRoZVxuXHRcdFx0Ly8gc2Nyb2xsYmFyIG9uIHRoZSBsZWZ0LCByYXRoZXIgdGhhbiB0aGUgcmlnaHQuXG5cdFx0XHRicm93c2VyLmJTY3JvbGxiYXJMZWZ0ID0gTWF0aC5yb3VuZCggaW5uZXIub2Zmc2V0KCkubGVmdCApICE9PSAxO1xuXHRcblx0XHRcdC8vIElFOC0gZG9uJ3QgcHJvdmlkZSBoZWlnaHQgYW5kIHdpZHRoIGZvciBnZXRCb3VuZGluZ0NsaWVudFJlY3Rcblx0XHRcdGJyb3dzZXIuYkJvdW5kaW5nID0gblswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCA/IHRydWUgOiBmYWxzZTtcblx0XG5cdFx0XHRuLnJlbW92ZSgpO1xuXHRcdH1cblx0XG5cdFx0JC5leHRlbmQoIHNldHRpbmdzLm9Ccm93c2VyLCBEYXRhVGFibGUuX19icm93c2VyICk7XG5cdFx0c2V0dGluZ3Mub1Njcm9sbC5pQmFyV2lkdGggPSBEYXRhVGFibGUuX19icm93c2VyLmJhcldpZHRoO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIEFycmF5LnByb3RvdHlwZSByZWR1Y2VbUmlnaHRdIG1ldGhvZCwgdXNlZCBmb3IgYnJvd3NlcnMgd2hpY2ggZG9uJ3Qgc3VwcG9ydFxuXHQgKiBKUyAxLjYuIERvbmUgdGhpcyB3YXkgdG8gcmVkdWNlIGNvZGUgc2l6ZSwgc2luY2Ugd2UgaXRlcmF0ZSBlaXRoZXIgd2F5XG5cdCAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuUmVkdWNlICggdGhhdCwgZm4sIGluaXQsIHN0YXJ0LCBlbmQsIGluYyApXG5cdHtcblx0XHR2YXJcblx0XHRcdGkgPSBzdGFydCxcblx0XHRcdHZhbHVlLFxuXHRcdFx0aXNTZXQgPSBmYWxzZTtcblx0XG5cdFx0aWYgKCBpbml0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR2YWx1ZSA9IGluaXQ7XG5cdFx0XHRpc1NldCA9IHRydWU7XG5cdFx0fVxuXHRcblx0XHR3aGlsZSAoIGkgIT09IGVuZCApIHtcblx0XHRcdGlmICggISB0aGF0Lmhhc093blByb3BlcnR5KGkpICkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XG5cdFx0XHR2YWx1ZSA9IGlzU2V0ID9cblx0XHRcdFx0Zm4oIHZhbHVlLCB0aGF0W2ldLCBpLCB0aGF0ICkgOlxuXHRcdFx0XHR0aGF0W2ldO1xuXHRcblx0XHRcdGlzU2V0ID0gdHJ1ZTtcblx0XHRcdGkgKz0gaW5jO1xuXHRcdH1cblx0XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9XG5cdFxuXHQvKipcblx0ICogQWRkIGEgY29sdW1uIHRvIHRoZSBsaXN0IHVzZWQgZm9yIHRoZSB0YWJsZSB3aXRoIGRlZmF1bHQgdmFsdWVzXG5cdCAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcGFyYW0ge25vZGV9IG5UaCBUaGUgdGggZWxlbWVudCBmb3IgdGhpcyBjb2x1bW5cblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuQWRkQ29sdW1uKCBvU2V0dGluZ3MsIG5UaCApXG5cdHtcblx0XHQvLyBBZGQgY29sdW1uIHRvIGFvQ29sdW1ucyBhcnJheVxuXHRcdHZhciBvRGVmYXVsdHMgPSBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uO1xuXHRcdHZhciBpQ29sID0gb1NldHRpbmdzLmFvQ29sdW1ucy5sZW5ndGg7XG5cdFx0dmFyIG9Db2wgPSAkLmV4dGVuZCgge30sIERhdGFUYWJsZS5tb2RlbHMub0NvbHVtbiwgb0RlZmF1bHRzLCB7XG5cdFx0XHRcIm5UaFwiOiBuVGggPyBuVGggOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0aCcpLFxuXHRcdFx0XCJzVGl0bGVcIjogICAgb0RlZmF1bHRzLnNUaXRsZSAgICA/IG9EZWZhdWx0cy5zVGl0bGUgICAgOiBuVGggPyBuVGguaW5uZXJIVE1MIDogJycsXG5cdFx0XHRcImFEYXRhU29ydFwiOiBvRGVmYXVsdHMuYURhdGFTb3J0ID8gb0RlZmF1bHRzLmFEYXRhU29ydCA6IFtpQ29sXSxcblx0XHRcdFwibURhdGFcIjogb0RlZmF1bHRzLm1EYXRhID8gb0RlZmF1bHRzLm1EYXRhIDogaUNvbCxcblx0XHRcdGlkeDogaUNvbFxuXHRcdH0gKTtcblx0XHRvU2V0dGluZ3MuYW9Db2x1bW5zLnB1c2goIG9Db2wgKTtcblx0XG5cdFx0Ly8gQWRkIHNlYXJjaCBvYmplY3QgZm9yIGNvbHVtbiBzcGVjaWZpYyBzZWFyY2guIE5vdGUgdGhhdCB0aGUgYHNlYXJjaENvbHNbIGlDb2wgXWBcblx0XHQvLyBwYXNzZWQgaW50byBleHRlbmQgY2FuIGJlIHVuZGVmaW5lZC4gVGhpcyBhbGxvd3MgdGhlIHVzZXIgdG8gZ2l2ZSBhIGRlZmF1bHRcblx0XHQvLyB3aXRoIG9ubHkgc29tZSBvZiB0aGUgcGFyYW1ldGVycyBkZWZpbmVkLCBhbmQgYWxzbyBub3QgZ2l2ZSBhIGRlZmF1bHRcblx0XHR2YXIgc2VhcmNoQ29scyA9IG9TZXR0aW5ncy5hb1ByZVNlYXJjaENvbHM7XG5cdFx0c2VhcmNoQ29sc1sgaUNvbCBdID0gJC5leHRlbmQoIHt9LCBEYXRhVGFibGUubW9kZWxzLm9TZWFyY2gsIHNlYXJjaENvbHNbIGlDb2wgXSApO1xuXHRcblx0XHQvLyBVc2UgdGhlIGRlZmF1bHQgY29sdW1uIG9wdGlvbnMgZnVuY3Rpb24gdG8gaW5pdGlhbGlzZSBjbGFzc2VzIGV0Y1xuXHRcdF9mbkNvbHVtbk9wdGlvbnMoIG9TZXR0aW5ncywgaUNvbCwgJChuVGgpLmRhdGEoKSApO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIEFwcGx5IG9wdGlvbnMgZm9yIGEgY29sdW1uXG5cdCAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcGFyYW0ge2ludH0gaUNvbCBjb2x1bW4gaW5kZXggdG8gY29uc2lkZXJcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvT3B0aW9ucyBvYmplY3Qgd2l0aCBzVHlwZSwgYlZpc2libGUgYW5kIGJTZWFyY2hhYmxlIGV0Y1xuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5Db2x1bW5PcHRpb25zKCBvU2V0dGluZ3MsIGlDb2wsIG9PcHRpb25zIClcblx0e1xuXHRcdHZhciBvQ29sID0gb1NldHRpbmdzLmFvQ29sdW1uc1sgaUNvbCBdO1xuXHRcdHZhciBvQ2xhc3NlcyA9IG9TZXR0aW5ncy5vQ2xhc3Nlcztcblx0XHR2YXIgdGggPSAkKG9Db2wublRoKTtcblx0XG5cdFx0Ly8gVHJ5IHRvIGdldCB3aWR0aCBpbmZvcm1hdGlvbiBmcm9tIHRoZSBET00uIFdlIGNhbid0IGdldCBpdCBmcm9tIENTU1xuXHRcdC8vIGFzIHdlJ2QgbmVlZCB0byBwYXJzZSB0aGUgQ1NTIHN0eWxlc2hlZXQuIGB3aWR0aGAgb3B0aW9uIGNhbiBvdmVycmlkZVxuXHRcdGlmICggISBvQ29sLnNXaWR0aE9yaWcgKSB7XG5cdFx0XHQvLyBXaWR0aCBhdHRyaWJ1dGVcblx0XHRcdG9Db2wuc1dpZHRoT3JpZyA9IHRoLmF0dHIoJ3dpZHRoJykgfHwgbnVsbDtcblx0XG5cdFx0XHQvLyBTdHlsZSBhdHRyaWJ1dGVcblx0XHRcdHZhciB0ID0gKHRoLmF0dHIoJ3N0eWxlJykgfHwgJycpLm1hdGNoKC93aWR0aDpcXHMqKFxcZCtbcHhlbSVdKykvKTtcblx0XHRcdGlmICggdCApIHtcblx0XHRcdFx0b0NvbC5zV2lkdGhPcmlnID0gdFsxXTtcblx0XHRcdH1cblx0XHR9XG5cdFxuXHRcdC8qIFVzZXIgc3BlY2lmaWVkIGNvbHVtbiBvcHRpb25zICovXG5cdFx0aWYgKCBvT3B0aW9ucyAhPT0gdW5kZWZpbmVkICYmIG9PcHRpb25zICE9PSBudWxsIClcblx0XHR7XG5cdFx0XHQvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuXHRcdFx0X2ZuQ29tcGF0Q29scyggb09wdGlvbnMgKTtcblx0XG5cdFx0XHQvLyBNYXAgY2FtZWwgY2FzZSBwYXJhbWV0ZXJzIHRvIHRoZWlyIEh1bmdhcmlhbiBjb3VudGVycGFydHNcblx0XHRcdF9mbkNhbWVsVG9IdW5nYXJpYW4oIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4sIG9PcHRpb25zLCB0cnVlICk7XG5cdFxuXHRcdFx0LyogQmFja3dhcmRzIGNvbXBhdGliaWxpdHkgZm9yIG1EYXRhUHJvcCAqL1xuXHRcdFx0aWYgKCBvT3B0aW9ucy5tRGF0YVByb3AgIT09IHVuZGVmaW5lZCAmJiAhb09wdGlvbnMubURhdGEgKVxuXHRcdFx0e1xuXHRcdFx0XHRvT3B0aW9ucy5tRGF0YSA9IG9PcHRpb25zLm1EYXRhUHJvcDtcblx0XHRcdH1cblx0XG5cdFx0XHRpZiAoIG9PcHRpb25zLnNUeXBlIClcblx0XHRcdHtcblx0XHRcdFx0b0NvbC5fc01hbnVhbFR5cGUgPSBvT3B0aW9ucy5zVHlwZTtcblx0XHRcdH1cblx0XG5cdFx0XHQvLyBgY2xhc3NgIGlzIGEgcmVzZXJ2ZWQgd29yZCBpbiBKYXZhc2NyaXB0LCBzbyB3ZSBuZWVkIHRvIHByb3ZpZGVcblx0XHRcdC8vIHRoZSBhYmlsaXR5IHRvIHVzZSBhIHZhbGlkIG5hbWUgZm9yIHRoZSBjYW1lbCBjYXNlIGlucHV0XG5cdFx0XHRpZiAoIG9PcHRpb25zLmNsYXNzTmFtZSAmJiAhIG9PcHRpb25zLnNDbGFzcyApXG5cdFx0XHR7XG5cdFx0XHRcdG9PcHRpb25zLnNDbGFzcyA9IG9PcHRpb25zLmNsYXNzTmFtZTtcblx0XHRcdH1cblx0XHRcdGlmICggb09wdGlvbnMuc0NsYXNzICkge1xuXHRcdFx0XHR0aC5hZGRDbGFzcyggb09wdGlvbnMuc0NsYXNzICk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0JC5leHRlbmQoIG9Db2wsIG9PcHRpb25zICk7XG5cdFx0XHRfZm5NYXAoIG9Db2wsIG9PcHRpb25zLCBcInNXaWR0aFwiLCBcInNXaWR0aE9yaWdcIiApO1xuXHRcblx0XHRcdC8qIGlEYXRhU29ydCB0byBiZSBhcHBsaWVkIChiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSksIGJ1dCBhRGF0YVNvcnQgd2lsbCB0YWtlXG5cdFx0XHQgKiBwcmlvcml0eSBpZiBkZWZpbmVkXG5cdFx0XHQgKi9cblx0XHRcdGlmICggb09wdGlvbnMuaURhdGFTb3J0ICE9PSB1bmRlZmluZWQgKVxuXHRcdFx0e1xuXHRcdFx0XHRvQ29sLmFEYXRhU29ydCA9IFsgb09wdGlvbnMuaURhdGFTb3J0IF07XG5cdFx0XHR9XG5cdFx0XHRfZm5NYXAoIG9Db2wsIG9PcHRpb25zLCBcImFEYXRhU29ydFwiICk7XG5cdFx0fVxuXHRcblx0XHQvKiBDYWNoZSB0aGUgZGF0YSBnZXQgYW5kIHNldCBmdW5jdGlvbnMgZm9yIHNwZWVkICovXG5cdFx0dmFyIG1EYXRhU3JjID0gb0NvbC5tRGF0YTtcblx0XHR2YXIgbURhdGEgPSBfZm5HZXRPYmplY3REYXRhRm4oIG1EYXRhU3JjICk7XG5cdFx0dmFyIG1SZW5kZXIgPSBvQ29sLm1SZW5kZXIgPyBfZm5HZXRPYmplY3REYXRhRm4oIG9Db2wubVJlbmRlciApIDogbnVsbDtcblx0XG5cdFx0dmFyIGF0dHJUZXN0ID0gZnVuY3Rpb24oIHNyYyApIHtcblx0XHRcdHJldHVybiB0eXBlb2Ygc3JjID09PSAnc3RyaW5nJyAmJiBzcmMuaW5kZXhPZignQCcpICE9PSAtMTtcblx0XHR9O1xuXHRcdG9Db2wuX2JBdHRyU3JjID0gJC5pc1BsYWluT2JqZWN0KCBtRGF0YVNyYyApICYmIChcblx0XHRcdGF0dHJUZXN0KG1EYXRhU3JjLnNvcnQpIHx8IGF0dHJUZXN0KG1EYXRhU3JjLnR5cGUpIHx8IGF0dHJUZXN0KG1EYXRhU3JjLmZpbHRlcilcblx0XHQpO1xuXHRcdG9Db2wuX3NldHRlciA9IG51bGw7XG5cdFxuXHRcdG9Db2wuZm5HZXREYXRhID0gZnVuY3Rpb24gKHJvd0RhdGEsIHR5cGUsIG1ldGEpIHtcblx0XHRcdHZhciBpbm5lckRhdGEgPSBtRGF0YSggcm93RGF0YSwgdHlwZSwgdW5kZWZpbmVkLCBtZXRhICk7XG5cdFxuXHRcdFx0cmV0dXJuIG1SZW5kZXIgJiYgdHlwZSA/XG5cdFx0XHRcdG1SZW5kZXIoIGlubmVyRGF0YSwgdHlwZSwgcm93RGF0YSwgbWV0YSApIDpcblx0XHRcdFx0aW5uZXJEYXRhO1xuXHRcdH07XG5cdFx0b0NvbC5mblNldERhdGEgPSBmdW5jdGlvbiAoIHJvd0RhdGEsIHZhbCwgbWV0YSApIHtcblx0XHRcdHJldHVybiBfZm5TZXRPYmplY3REYXRhRm4oIG1EYXRhU3JjICkoIHJvd0RhdGEsIHZhbCwgbWV0YSApO1xuXHRcdH07XG5cdFxuXHRcdC8vIEluZGljYXRlIGlmIERhdGFUYWJsZXMgc2hvdWxkIHJlYWQgRE9NIGRhdGEgYXMgYW4gb2JqZWN0IG9yIGFycmF5XG5cdFx0Ly8gVXNlZCBpbiBfZm5HZXRSb3dFbGVtZW50c1xuXHRcdGlmICggdHlwZW9mIG1EYXRhU3JjICE9PSAnbnVtYmVyJyApIHtcblx0XHRcdG9TZXR0aW5ncy5fcm93UmVhZE9iamVjdCA9IHRydWU7XG5cdFx0fVxuXHRcblx0XHQvKiBGZWF0dXJlIHNvcnRpbmcgb3ZlcnJpZGVzIGNvbHVtbiBzcGVjaWZpYyB3aGVuIG9mZiAqL1xuXHRcdGlmICggIW9TZXR0aW5ncy5vRmVhdHVyZXMuYlNvcnQgKVxuXHRcdHtcblx0XHRcdG9Db2wuYlNvcnRhYmxlID0gZmFsc2U7XG5cdFx0XHR0aC5hZGRDbGFzcyggb0NsYXNzZXMuc1NvcnRhYmxlTm9uZSApOyAvLyBIYXZlIHRvIGFkZCBjbGFzcyBoZXJlIGFzIG9yZGVyIGV2ZW50IGlzbid0IGNhbGxlZFxuXHRcdH1cblx0XG5cdFx0LyogQ2hlY2sgdGhhdCB0aGUgY2xhc3MgYXNzaWdubWVudCBpcyBjb3JyZWN0IGZvciBzb3J0aW5nICovXG5cdFx0dmFyIGJBc2MgPSAkLmluQXJyYXkoJ2FzYycsIG9Db2wuYXNTb3J0aW5nKSAhPT0gLTE7XG5cdFx0dmFyIGJEZXNjID0gJC5pbkFycmF5KCdkZXNjJywgb0NvbC5hc1NvcnRpbmcpICE9PSAtMTtcblx0XHRpZiAoICFvQ29sLmJTb3J0YWJsZSB8fCAoIWJBc2MgJiYgIWJEZXNjKSApXG5cdFx0e1xuXHRcdFx0b0NvbC5zU29ydGluZ0NsYXNzID0gb0NsYXNzZXMuc1NvcnRhYmxlTm9uZTtcblx0XHRcdG9Db2wuc1NvcnRpbmdDbGFzc0pVSSA9IFwiXCI7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCBiQXNjICYmICFiRGVzYyApXG5cdFx0e1xuXHRcdFx0b0NvbC5zU29ydGluZ0NsYXNzID0gb0NsYXNzZXMuc1NvcnRhYmxlQXNjO1xuXHRcdFx0b0NvbC5zU29ydGluZ0NsYXNzSlVJID0gb0NsYXNzZXMuc1NvcnRKVUlBc2NBbGxvd2VkO1xuXHRcdH1cblx0XHRlbHNlIGlmICggIWJBc2MgJiYgYkRlc2MgKVxuXHRcdHtcblx0XHRcdG9Db2wuc1NvcnRpbmdDbGFzcyA9IG9DbGFzc2VzLnNTb3J0YWJsZURlc2M7XG5cdFx0XHRvQ29sLnNTb3J0aW5nQ2xhc3NKVUkgPSBvQ2xhc3Nlcy5zU29ydEpVSURlc2NBbGxvd2VkO1xuXHRcdH1cblx0XHRlbHNlXG5cdFx0e1xuXHRcdFx0b0NvbC5zU29ydGluZ0NsYXNzID0gb0NsYXNzZXMuc1NvcnRhYmxlO1xuXHRcdFx0b0NvbC5zU29ydGluZ0NsYXNzSlVJID0gb0NsYXNzZXMuc1NvcnRKVUk7XG5cdFx0fVxuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIEFkanVzdCB0aGUgdGFibGUgY29sdW1uIHdpZHRocyBmb3IgbmV3IGRhdGEuIE5vdGU6IHlvdSB3b3VsZCBwcm9iYWJseSB3YW50IHRvXG5cdCAqIGRvIGEgcmVkcmF3IGFmdGVyIGNhbGxpbmcgdGhpcyBmdW5jdGlvbiFcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5BZGp1c3RDb2x1bW5TaXppbmcgKCBzZXR0aW5ncyApXG5cdHtcblx0XHQvKiBOb3QgaW50ZXJlc3RlZCBpbiBkb2luZyBjb2x1bW4gd2lkdGggY2FsY3VsYXRpb24gaWYgYXV0by13aWR0aCBpcyBkaXNhYmxlZCAqL1xuXHRcdGlmICggc2V0dGluZ3Mub0ZlYXR1cmVzLmJBdXRvV2lkdGggIT09IGZhbHNlIClcblx0XHR7XG5cdFx0XHR2YXIgY29sdW1ucyA9IHNldHRpbmdzLmFvQ29sdW1ucztcblx0XG5cdFx0XHRfZm5DYWxjdWxhdGVDb2x1bW5XaWR0aHMoIHNldHRpbmdzICk7XG5cdFx0XHRmb3IgKCB2YXIgaT0wICwgaUxlbj1jb2x1bW5zLmxlbmd0aCA7IGk8aUxlbiA7IGkrKyApXG5cdFx0XHR7XG5cdFx0XHRcdGNvbHVtbnNbaV0ublRoLnN0eWxlLndpZHRoID0gY29sdW1uc1tpXS5zV2lkdGg7XG5cdFx0XHR9XG5cdFx0fVxuXHRcblx0XHR2YXIgc2Nyb2xsID0gc2V0dGluZ3Mub1Njcm9sbDtcblx0XHRpZiAoIHNjcm9sbC5zWSAhPT0gJycgfHwgc2Nyb2xsLnNYICE9PSAnJylcblx0XHR7XG5cdFx0XHRfZm5TY3JvbGxEcmF3KCBzZXR0aW5ncyApO1xuXHRcdH1cblx0XG5cdFx0X2ZuQ2FsbGJhY2tGaXJlKCBzZXR0aW5ncywgbnVsbCwgJ2NvbHVtbi1zaXppbmcnLCBbc2V0dGluZ3NdICk7XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogQ292ZXJ0IHRoZSBpbmRleCBvZiBhIHZpc2libGUgY29sdW1uIHRvIHRoZSBpbmRleCBpbiB0aGUgZGF0YSBhcnJheSAodGFrZSBhY2NvdW50XG5cdCAqIG9mIGhpZGRlbiBjb2x1bW5zKVxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHtpbnR9IGlNYXRjaCBWaXNpYmxlIGNvbHVtbiBpbmRleCB0byBsb29rdXBcblx0ICogIEByZXR1cm5zIHtpbnR9IGkgdGhlIGRhdGEgaW5kZXhcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuVmlzaWJsZVRvQ29sdW1uSW5kZXgoIG9TZXR0aW5ncywgaU1hdGNoIClcblx0e1xuXHRcdHZhciBhaVZpcyA9IF9mbkdldENvbHVtbnMoIG9TZXR0aW5ncywgJ2JWaXNpYmxlJyApO1xuXHRcblx0XHRyZXR1cm4gdHlwZW9mIGFpVmlzW2lNYXRjaF0gPT09ICdudW1iZXInID9cblx0XHRcdGFpVmlzW2lNYXRjaF0gOlxuXHRcdFx0bnVsbDtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBDb3ZlcnQgdGhlIGluZGV4IG9mIGFuIGluZGV4IGluIHRoZSBkYXRhIGFycmF5IGFuZCBjb252ZXJ0IGl0IHRvIHRoZSB2aXNpYmxlXG5cdCAqICAgY29sdW1uIGluZGV4ICh0YWtlIGFjY291bnQgb2YgaGlkZGVuIGNvbHVtbnMpXG5cdCAqICBAcGFyYW0ge2ludH0gaU1hdGNoIENvbHVtbiBpbmRleCB0byBsb29rdXBcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEByZXR1cm5zIHtpbnR9IGkgdGhlIGRhdGEgaW5kZXhcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuQ29sdW1uSW5kZXhUb1Zpc2libGUoIG9TZXR0aW5ncywgaU1hdGNoIClcblx0e1xuXHRcdHZhciBhaVZpcyA9IF9mbkdldENvbHVtbnMoIG9TZXR0aW5ncywgJ2JWaXNpYmxlJyApO1xuXHRcdHZhciBpUG9zID0gJC5pbkFycmF5KCBpTWF0Y2gsIGFpVmlzICk7XG5cdFxuXHRcdHJldHVybiBpUG9zICE9PSAtMSA/IGlQb3MgOiBudWxsO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIEdldCB0aGUgbnVtYmVyIG9mIHZpc2libGUgY29sdW1uc1xuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHJldHVybnMge2ludH0gaSB0aGUgbnVtYmVyIG9mIHZpc2libGUgY29sdW1uc1xuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5WaXNibGVDb2x1bW5zKCBvU2V0dGluZ3MgKVxuXHR7XG5cdFx0dmFyIHZpcyA9IDA7XG5cdFxuXHRcdC8vIE5vIHJlZHVjZSBpbiBJRTgsIHVzZSBhIGxvb3AgZm9yIG5vd1xuXHRcdCQuZWFjaCggb1NldHRpbmdzLmFvQ29sdW1ucywgZnVuY3Rpb24gKCBpLCBjb2wgKSB7XG5cdFx0XHRpZiAoIGNvbC5iVmlzaWJsZSAmJiAkKGNvbC5uVGgpLmNzcygnZGlzcGxheScpICE9PSAnbm9uZScgKSB7XG5cdFx0XHRcdHZpcysrO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XG5cdFx0cmV0dXJuIHZpcztcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBHZXQgYW4gYXJyYXkgb2YgY29sdW1uIGluZGV4ZXMgdGhhdCBtYXRjaCBhIGdpdmVuIHByb3BlcnR5XG5cdCAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcGFyYW0ge3N0cmluZ30gc1BhcmFtIFBhcmFtZXRlciBpbiBhb0NvbHVtbnMgdG8gbG9vayBmb3IgLSB0eXBpY2FsbHlcblx0ICogICAgYlZpc2libGUgb3IgYlNlYXJjaGFibGVcblx0ICogIEByZXR1cm5zIHthcnJheX0gQXJyYXkgb2YgaW5kZXhlcyB3aXRoIG1hdGNoZWQgcHJvcGVydGllc1xuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5HZXRDb2x1bW5zKCBvU2V0dGluZ3MsIHNQYXJhbSApXG5cdHtcblx0XHR2YXIgYSA9IFtdO1xuXHRcblx0XHQkLm1hcCggb1NldHRpbmdzLmFvQ29sdW1ucywgZnVuY3Rpb24odmFsLCBpKSB7XG5cdFx0XHRpZiAoIHZhbFtzUGFyYW1dICkge1xuXHRcdFx0XHRhLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdFxuXHRcdHJldHVybiBhO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIENhbGN1bGF0ZSB0aGUgJ3R5cGUnIG9mIGEgY29sdW1uXG5cdCAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuQ29sdW1uVHlwZXMgKCBzZXR0aW5ncyApXG5cdHtcblx0XHR2YXIgY29sdW1ucyA9IHNldHRpbmdzLmFvQ29sdW1ucztcblx0XHR2YXIgZGF0YSA9IHNldHRpbmdzLmFvRGF0YTtcblx0XHR2YXIgdHlwZXMgPSBEYXRhVGFibGUuZXh0LnR5cGUuZGV0ZWN0O1xuXHRcdHZhciBpLCBpZW4sIGosIGplbiwgaywga2VuO1xuXHRcdHZhciBjb2wsIGNlbGwsIGRldGVjdGVkVHlwZSwgY2FjaGU7XG5cdFxuXHRcdC8vIEZvciBlYWNoIGNvbHVtbiwgc3BpbiBvdmVyIHRoZSBcblx0XHRmb3IgKCBpPTAsIGllbj1jb2x1bW5zLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0Y29sID0gY29sdW1uc1tpXTtcblx0XHRcdGNhY2hlID0gW107XG5cdFxuXHRcdFx0aWYgKCAhIGNvbC5zVHlwZSAmJiBjb2wuX3NNYW51YWxUeXBlICkge1xuXHRcdFx0XHRjb2wuc1R5cGUgPSBjb2wuX3NNYW51YWxUeXBlO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoICEgY29sLnNUeXBlICkge1xuXHRcdFx0XHRmb3IgKCBqPTAsIGplbj10eXBlcy5sZW5ndGggOyBqPGplbiA7IGorKyApIHtcblx0XHRcdFx0XHRmb3IgKCBrPTAsIGtlbj1kYXRhLmxlbmd0aCA7IGs8a2VuIDsgaysrICkge1xuXHRcdFx0XHRcdFx0Ly8gVXNlIGEgY2FjaGUgYXJyYXkgc28gd2Ugb25seSBuZWVkIHRvIGdldCB0aGUgdHlwZSBkYXRhXG5cdFx0XHRcdFx0XHQvLyBmcm9tIHRoZSBmb3JtYXR0ZXIgb25jZSAod2hlbiB1c2luZyBtdWx0aXBsZSBkZXRlY3RvcnMpXG5cdFx0XHRcdFx0XHRpZiAoIGNhY2hlW2tdID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRcdGNhY2hlW2tdID0gX2ZuR2V0Q2VsbERhdGEoIHNldHRpbmdzLCBrLCBpLCAndHlwZScgKTtcblx0XHRcdFx0XHRcdH1cblx0XG5cdFx0XHRcdFx0XHRkZXRlY3RlZFR5cGUgPSB0eXBlc1tqXSggY2FjaGVba10sIHNldHRpbmdzICk7XG5cdFxuXHRcdFx0XHRcdFx0Ly8gSWYgbnVsbCwgdGhlbiB0aGlzIHR5cGUgY2FuJ3QgYXBwbHkgdG8gdGhpcyBjb2x1bW4sIHNvXG5cdFx0XHRcdFx0XHQvLyByYXRoZXIgdGhhbiB0ZXN0aW5nIGFsbCBjZWxscywgYnJlYWsgb3V0LiBUaGVyZSBpcyBhblxuXHRcdFx0XHRcdFx0Ly8gZXhjZXB0aW9uIGZvciB0aGUgbGFzdCB0eXBlIHdoaWNoIGlzIGBodG1sYC4gV2UgbmVlZCB0b1xuXHRcdFx0XHRcdFx0Ly8gc2NhbiBhbGwgcm93cyBzaW5jZSBpdCBpcyBwb3NzaWJsZSB0byBtaXggc3RyaW5nIGFuZCBIVE1MXG5cdFx0XHRcdFx0XHQvLyB0eXBlc1xuXHRcdFx0XHRcdFx0aWYgKCAhIGRldGVjdGVkVHlwZSAmJiBqICE9PSB0eXBlcy5sZW5ndGgtMSApIHtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRcdFx0Ly8gT25seSBhIHNpbmdsZSBtYXRjaCBpcyBuZWVkZWQgZm9yIGh0bWwgdHlwZSBzaW5jZSBpdCBpc1xuXHRcdFx0XHRcdFx0Ly8gYm90dG9tIG9mIHRoZSBwaWxlIGFuZCB2ZXJ5IHNpbWlsYXIgdG8gc3RyaW5nXG5cdFx0XHRcdFx0XHRpZiAoIGRldGVjdGVkVHlwZSA9PT0gJ2h0bWwnICkge1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRcdC8vIFR5cGUgaXMgdmFsaWQgZm9yIGFsbCBkYXRhIHBvaW50cyBpbiB0aGUgY29sdW1uIC0gdXNlIHRoaXNcblx0XHRcdFx0XHQvLyB0eXBlXG5cdFx0XHRcdFx0aWYgKCBkZXRlY3RlZFR5cGUgKSB7XG5cdFx0XHRcdFx0XHRjb2wuc1R5cGUgPSBkZXRlY3RlZFR5cGU7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdC8vIEZhbGwgYmFjayAtIGlmIG5vIHR5cGUgd2FzIGRldGVjdGVkLCBhbHdheXMgdXNlIHN0cmluZ1xuXHRcdFx0XHRpZiAoICEgY29sLnNUeXBlICkge1xuXHRcdFx0XHRcdGNvbC5zVHlwZSA9ICdzdHJpbmcnO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIFRha2UgdGhlIGNvbHVtbiBkZWZpbml0aW9ucyBhbmQgc3RhdGljIGNvbHVtbnMgYXJyYXlzIGFuZCBjYWxjdWxhdGUgaG93XG5cdCAqIHRoZXkgcmVsYXRlIHRvIGNvbHVtbiBpbmRleGVzLiBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gd2lsbCB0aGVuIGFwcGx5IHRoZVxuXHQgKiBkZWZpbml0aW9uIGZvdW5kIGZvciBhIGNvbHVtbiB0byBhIHN1aXRhYmxlIGNvbmZpZ3VyYXRpb24gb2JqZWN0LlxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHthcnJheX0gYW9Db2xEZWZzIFRoZSBhb0NvbHVtbkRlZnMgYXJyYXkgdGhhdCBpcyB0byBiZSBhcHBsaWVkXG5cdCAqICBAcGFyYW0ge2FycmF5fSBhb0NvbHMgVGhlIGFvQ29sdW1ucyBhcnJheSB0aGF0IGRlZmluZXMgY29sdW1ucyBpbmRpdmlkdWFsbHlcblx0ICogIEBwYXJhbSB7ZnVuY3Rpb259IGZuIENhbGxiYWNrIGZ1bmN0aW9uIC0gdGFrZXMgdHdvIHBhcmFtZXRlcnMsIHRoZSBjYWxjdWxhdGVkXG5cdCAqICAgIGNvbHVtbiBpbmRleCBhbmQgdGhlIGRlZmluaXRpb24gZm9yIHRoYXQgY29sdW1uLlxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5BcHBseUNvbHVtbkRlZnMoIG9TZXR0aW5ncywgYW9Db2xEZWZzLCBhb0NvbHMsIGZuIClcblx0e1xuXHRcdHZhciBpLCBpTGVuLCBqLCBqTGVuLCBrLCBrTGVuLCBkZWY7XG5cdFx0dmFyIGNvbHVtbnMgPSBvU2V0dGluZ3MuYW9Db2x1bW5zO1xuXHRcblx0XHQvLyBDb2x1bW4gZGVmaW5pdGlvbnMgd2l0aCBhVGFyZ2V0c1xuXHRcdGlmICggYW9Db2xEZWZzIClcblx0XHR7XG5cdFx0XHQvKiBMb29wIG92ZXIgdGhlIGRlZmluaXRpb25zIGFycmF5IC0gbG9vcCBpbiByZXZlcnNlIHNvIGZpcnN0IGluc3RhbmNlIGhhcyBwcmlvcml0eSAqL1xuXHRcdFx0Zm9yICggaT1hb0NvbERlZnMubGVuZ3RoLTEgOyBpPj0wIDsgaS0tIClcblx0XHRcdHtcblx0XHRcdFx0ZGVmID0gYW9Db2xEZWZzW2ldO1xuXHRcblx0XHRcdFx0LyogRWFjaCBkZWZpbml0aW9uIGNhbiB0YXJnZXQgbXVsdGlwbGUgY29sdW1ucywgYXMgaXQgaXMgYW4gYXJyYXkgKi9cblx0XHRcdFx0dmFyIGFUYXJnZXRzID0gZGVmLnRhcmdldHMgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdFx0ZGVmLnRhcmdldHMgOlxuXHRcdFx0XHRcdGRlZi5hVGFyZ2V0cztcblx0XG5cdFx0XHRcdGlmICggISAkLmlzQXJyYXkoIGFUYXJnZXRzICkgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0YVRhcmdldHMgPSBbIGFUYXJnZXRzIF07XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdGZvciAoIGo9MCwgakxlbj1hVGFyZ2V0cy5sZW5ndGggOyBqPGpMZW4gOyBqKysgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0aWYgKCB0eXBlb2YgYVRhcmdldHNbal0gPT09ICdudW1iZXInICYmIGFUYXJnZXRzW2pdID49IDAgKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdC8qIEFkZCBjb2x1bW5zIHRoYXQgd2UgZG9uJ3QgeWV0IGtub3cgYWJvdXQgKi9cblx0XHRcdFx0XHRcdHdoaWxlKCBjb2x1bW5zLmxlbmd0aCA8PSBhVGFyZ2V0c1tqXSApXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdF9mbkFkZENvbHVtbiggb1NldHRpbmdzICk7XG5cdFx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRcdFx0LyogSW50ZWdlciwgYmFzaWMgaW5kZXggKi9cblx0XHRcdFx0XHRcdGZuKCBhVGFyZ2V0c1tqXSwgZGVmICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2UgaWYgKCB0eXBlb2YgYVRhcmdldHNbal0gPT09ICdudW1iZXInICYmIGFUYXJnZXRzW2pdIDwgMCApXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0LyogTmVnYXRpdmUgaW50ZWdlciwgcmlnaHQgdG8gbGVmdCBjb2x1bW4gY291bnRpbmcgKi9cblx0XHRcdFx0XHRcdGZuKCBjb2x1bW5zLmxlbmd0aCthVGFyZ2V0c1tqXSwgZGVmICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2UgaWYgKCB0eXBlb2YgYVRhcmdldHNbal0gPT09ICdzdHJpbmcnIClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHQvKiBDbGFzcyBuYW1lIG1hdGNoaW5nIG9uIFRIIGVsZW1lbnQgKi9cblx0XHRcdFx0XHRcdGZvciAoIGs9MCwga0xlbj1jb2x1bW5zLmxlbmd0aCA7IGs8a0xlbiA7IGsrKyApXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdGlmICggYVRhcmdldHNbal0gPT0gXCJfYWxsXCIgfHxcblx0XHRcdFx0XHRcdFx0ICAgICAkKGNvbHVtbnNba10ublRoKS5oYXNDbGFzcyggYVRhcmdldHNbal0gKSApXG5cdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHRmbiggaywgZGVmICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFxuXHRcdC8vIFN0YXRpY2FsbHkgZGVmaW5lZCBjb2x1bW5zIGFycmF5XG5cdFx0aWYgKCBhb0NvbHMgKVxuXHRcdHtcblx0XHRcdGZvciAoIGk9MCwgaUxlbj1hb0NvbHMubGVuZ3RoIDsgaTxpTGVuIDsgaSsrIClcblx0XHRcdHtcblx0XHRcdFx0Zm4oIGksIGFvQ29sc1tpXSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRcblx0LyoqXG5cdCAqIEFkZCBhIGRhdGEgYXJyYXkgdG8gdGhlIHRhYmxlLCBjcmVhdGluZyBET00gbm9kZSBldGMuIFRoaXMgaXMgdGhlIHBhcmFsbGVsIHRvXG5cdCAqIF9mbkdhdGhlckRhdGEsIGJ1dCBmb3IgYWRkaW5nIHJvd3MgZnJvbSBhIEphdmFzY3JpcHQgc291cmNlLCByYXRoZXIgdGhhbiBhXG5cdCAqIERPTSBzb3VyY2UuXG5cdCAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcGFyYW0ge2FycmF5fSBhRGF0YSBkYXRhIGFycmF5IHRvIGJlIGFkZGVkXG5cdCAqICBAcGFyYW0ge25vZGV9IFtuVHJdIFRSIGVsZW1lbnQgdG8gYWRkIHRvIHRoZSB0YWJsZSAtIG9wdGlvbmFsLiBJZiBub3QgZ2l2ZW4sXG5cdCAqICAgIERhdGFUYWJsZXMgd2lsbCBjcmVhdGUgYSByb3cgYXV0b21hdGljYWxseVxuXHQgKiAgQHBhcmFtIHthcnJheX0gW2FuVGRzXSBBcnJheSBvZiBURHxUSCBlbGVtZW50cyBmb3IgdGhlIHJvdyAtIG11c3QgYmUgZ2l2ZW5cblx0ICogICAgaWYgblRyIGlzLlxuXHQgKiAgQHJldHVybnMge2ludH0gPj0wIGlmIHN1Y2Nlc3NmdWwgKGluZGV4IG9mIG5ldyBhb0RhdGEgZW50cnkpLCAtMSBpZiBmYWlsZWRcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuQWRkRGF0YSAoIG9TZXR0aW5ncywgYURhdGFJbiwgblRyLCBhblRkcyApXG5cdHtcblx0XHQvKiBDcmVhdGUgdGhlIG9iamVjdCBmb3Igc3RvcmluZyBpbmZvcm1hdGlvbiBhYm91dCB0aGlzIG5ldyByb3cgKi9cblx0XHR2YXIgaVJvdyA9IG9TZXR0aW5ncy5hb0RhdGEubGVuZ3RoO1xuXHRcdHZhciBvRGF0YSA9ICQuZXh0ZW5kKCB0cnVlLCB7fSwgRGF0YVRhYmxlLm1vZGVscy5vUm93LCB7XG5cdFx0XHRzcmM6IG5UciA/ICdkb20nIDogJ2RhdGEnLFxuXHRcdFx0aWR4OiBpUm93XG5cdFx0fSApO1xuXHRcblx0XHRvRGF0YS5fYURhdGEgPSBhRGF0YUluO1xuXHRcdG9TZXR0aW5ncy5hb0RhdGEucHVzaCggb0RhdGEgKTtcblx0XG5cdFx0LyogQ3JlYXRlIHRoZSBjZWxscyAqL1xuXHRcdHZhciBuVGQsIHNUaGlzVHlwZTtcblx0XHR2YXIgY29sdW1ucyA9IG9TZXR0aW5ncy5hb0NvbHVtbnM7XG5cdFxuXHRcdC8vIEludmFsaWRhdGUgdGhlIGNvbHVtbiB0eXBlcyBhcyB0aGUgbmV3IGRhdGEgbmVlZHMgdG8gYmUgcmV2YWxpZGF0ZWRcblx0XHRmb3IgKCB2YXIgaT0wLCBpTGVuPWNvbHVtbnMubGVuZ3RoIDsgaTxpTGVuIDsgaSsrIClcblx0XHR7XG5cdFx0XHRjb2x1bW5zW2ldLnNUeXBlID0gbnVsbDtcblx0XHR9XG5cdFxuXHRcdC8qIEFkZCB0byB0aGUgZGlzcGxheSBhcnJheSAqL1xuXHRcdG9TZXR0aW5ncy5haURpc3BsYXlNYXN0ZXIucHVzaCggaVJvdyApO1xuXHRcblx0XHR2YXIgaWQgPSBvU2V0dGluZ3Mucm93SWRGbiggYURhdGFJbiApO1xuXHRcdGlmICggaWQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdG9TZXR0aW5ncy5hSWRzWyBpZCBdID0gb0RhdGE7XG5cdFx0fVxuXHRcblx0XHQvKiBDcmVhdGUgdGhlIERPTSBpbmZvcm1hdGlvbiwgb3IgcmVnaXN0ZXIgaXQgaWYgYWxyZWFkeSBwcmVzZW50ICovXG5cdFx0aWYgKCBuVHIgfHwgISBvU2V0dGluZ3Mub0ZlYXR1cmVzLmJEZWZlclJlbmRlciApXG5cdFx0e1xuXHRcdFx0X2ZuQ3JlYXRlVHIoIG9TZXR0aW5ncywgaVJvdywgblRyLCBhblRkcyApO1xuXHRcdH1cblx0XG5cdFx0cmV0dXJuIGlSb3c7XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogQWRkIG9uZSBvciBtb3JlIFRSIGVsZW1lbnRzIHRvIHRoZSB0YWJsZS4gR2VuZXJhbGx5IHdlJ2QgZXhwZWN0IHRvXG5cdCAqIHVzZSB0aGlzIGZvciByZWFkaW5nIGRhdGEgZnJvbSBhIERPTSBzb3VyY2VkIHRhYmxlLCBidXQgaXQgY291bGQgYmVcblx0ICogdXNlZCBmb3IgYW4gVFIgZWxlbWVudC4gTm90ZSB0aGF0IGlmIGEgVFIgaXMgZ2l2ZW4sIGl0IGlzIHVzZWQgKGkuZS5cblx0ICogaXQgaXMgbm90IGNsb25lZCkuXG5cdCAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBwYXJhbSB7YXJyYXl8bm9kZXxqUXVlcnl9IHRycyBUaGUgVFIgZWxlbWVudChzKSB0byBhZGQgdG8gdGhlIHRhYmxlXG5cdCAqICBAcmV0dXJucyB7YXJyYXl9IEFycmF5IG9mIGluZGV4ZXMgZm9yIHRoZSBhZGRlZCByb3dzXG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkFkZFRyKCBzZXR0aW5ncywgdHJzIClcblx0e1xuXHRcdHZhciByb3c7XG5cdFxuXHRcdC8vIEFsbG93IGFuIGluZGl2aWR1YWwgbm9kZSB0byBiZSBwYXNzZWQgaW5cblx0XHRpZiAoICEgKHRycyBpbnN0YW5jZW9mICQpICkge1xuXHRcdFx0dHJzID0gJCh0cnMpO1xuXHRcdH1cblx0XG5cdFx0cmV0dXJuIHRycy5tYXAoIGZ1bmN0aW9uIChpLCBlbCkge1xuXHRcdFx0cm93ID0gX2ZuR2V0Um93RWxlbWVudHMoIHNldHRpbmdzLCBlbCApO1xuXHRcdFx0cmV0dXJuIF9mbkFkZERhdGEoIHNldHRpbmdzLCByb3cuZGF0YSwgZWwsIHJvdy5jZWxscyApO1xuXHRcdH0gKTtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBUYWtlIGEgVFIgZWxlbWVudCBhbmQgY29udmVydCBpdCB0byBhbiBpbmRleCBpbiBhb0RhdGFcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBwYXJhbSB7bm9kZX0gbiB0aGUgVFIgZWxlbWVudCB0byBmaW5kXG5cdCAqICBAcmV0dXJucyB7aW50fSBpbmRleCBpZiB0aGUgbm9kZSBpcyBmb3VuZCwgbnVsbCBpZiBub3Rcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuTm9kZVRvRGF0YUluZGV4KCBvU2V0dGluZ3MsIG4gKVxuXHR7XG5cdFx0cmV0dXJuIChuLl9EVF9Sb3dJbmRleCE9PXVuZGVmaW5lZCkgPyBuLl9EVF9Sb3dJbmRleCA6IG51bGw7XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogVGFrZSBhIFREIGVsZW1lbnQgYW5kIGNvbnZlcnQgaXQgaW50byBhIGNvbHVtbiBkYXRhIGluZGV4IChub3QgdGhlIHZpc2libGUgaW5kZXgpXG5cdCAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcGFyYW0ge2ludH0gaVJvdyBUaGUgcm93IG51bWJlciB0aGUgVEQvVEggY2FuIGJlIGZvdW5kIGluXG5cdCAqICBAcGFyYW0ge25vZGV9IG4gVGhlIFREL1RIIGVsZW1lbnQgdG8gZmluZFxuXHQgKiAgQHJldHVybnMge2ludH0gaW5kZXggaWYgdGhlIG5vZGUgaXMgZm91bmQsIC0xIGlmIG5vdFxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5Ob2RlVG9Db2x1bW5JbmRleCggb1NldHRpbmdzLCBpUm93LCBuIClcblx0e1xuXHRcdHJldHVybiAkLmluQXJyYXkoIG4sIG9TZXR0aW5ncy5hb0RhdGFbIGlSb3cgXS5hbkNlbGxzICk7XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogR2V0IHRoZSBkYXRhIGZvciBhIGdpdmVuIGNlbGwgZnJvbSB0aGUgaW50ZXJuYWwgY2FjaGUsIHRha2luZyBpbnRvIGFjY291bnQgZGF0YSBtYXBwaW5nXG5cdCAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBwYXJhbSB7aW50fSByb3dJZHggYW9EYXRhIHJvdyBpZFxuXHQgKiAgQHBhcmFtIHtpbnR9IGNvbElkeCBDb2x1bW4gaW5kZXhcblx0ICogIEBwYXJhbSB7c3RyaW5nfSB0eXBlIGRhdGEgZ2V0IHR5cGUgKCdkaXNwbGF5JywgJ3R5cGUnICdmaWx0ZXInICdzb3J0Jylcblx0ICogIEByZXR1cm5zIHsqfSBDZWxsIGRhdGFcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuR2V0Q2VsbERhdGEoIHNldHRpbmdzLCByb3dJZHgsIGNvbElkeCwgdHlwZSApXG5cdHtcblx0XHR2YXIgZHJhdyAgICAgICAgICAgPSBzZXR0aW5ncy5pRHJhdztcblx0XHR2YXIgY29sICAgICAgICAgICAgPSBzZXR0aW5ncy5hb0NvbHVtbnNbY29sSWR4XTtcblx0XHR2YXIgcm93RGF0YSAgICAgICAgPSBzZXR0aW5ncy5hb0RhdGFbcm93SWR4XS5fYURhdGE7XG5cdFx0dmFyIGRlZmF1bHRDb250ZW50ID0gY29sLnNEZWZhdWx0Q29udGVudDtcblx0XHR2YXIgY2VsbERhdGEgICAgICAgPSBjb2wuZm5HZXREYXRhKCByb3dEYXRhLCB0eXBlLCB7XG5cdFx0XHRzZXR0aW5nczogc2V0dGluZ3MsXG5cdFx0XHRyb3c6ICAgICAgcm93SWR4LFxuXHRcdFx0Y29sOiAgICAgIGNvbElkeFxuXHRcdH0gKTtcblx0XG5cdFx0aWYgKCBjZWxsRGF0YSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCBzZXR0aW5ncy5pRHJhd0Vycm9yICE9IGRyYXcgJiYgZGVmYXVsdENvbnRlbnQgPT09IG51bGwgKSB7XG5cdFx0XHRcdF9mbkxvZyggc2V0dGluZ3MsIDAsIFwiUmVxdWVzdGVkIHVua25vd24gcGFyYW1ldGVyIFwiK1xuXHRcdFx0XHRcdCh0eXBlb2YgY29sLm1EYXRhPT0nZnVuY3Rpb24nID8gJ3tmdW5jdGlvbn0nIDogXCInXCIrY29sLm1EYXRhK1wiJ1wiKStcblx0XHRcdFx0XHRcIiBmb3Igcm93IFwiK3Jvd0lkeCtcIiwgY29sdW1uIFwiK2NvbElkeCwgNCApO1xuXHRcdFx0XHRzZXR0aW5ncy5pRHJhd0Vycm9yID0gZHJhdztcblx0XHRcdH1cblx0XHRcdHJldHVybiBkZWZhdWx0Q29udGVudDtcblx0XHR9XG5cdFxuXHRcdC8vIFdoZW4gdGhlIGRhdGEgc291cmNlIGlzIG51bGwgYW5kIGEgc3BlY2lmaWMgZGF0YSB0eXBlIGlzIHJlcXVlc3RlZCAoaS5lLlxuXHRcdC8vIG5vdCB0aGUgb3JpZ2luYWwgZGF0YSksIHdlIGNhbiB1c2UgZGVmYXVsdCBjb2x1bW4gZGF0YVxuXHRcdGlmICggKGNlbGxEYXRhID09PSByb3dEYXRhIHx8IGNlbGxEYXRhID09PSBudWxsKSAmJiBkZWZhdWx0Q29udGVudCAhPT0gbnVsbCAmJiB0eXBlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRjZWxsRGF0YSA9IGRlZmF1bHRDb250ZW50O1xuXHRcdH1cblx0XHRlbHNlIGlmICggdHlwZW9mIGNlbGxEYXRhID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0Ly8gSWYgdGhlIGRhdGEgc291cmNlIGlzIGEgZnVuY3Rpb24sIHRoZW4gd2UgcnVuIGl0IGFuZCB1c2UgdGhlIHJldHVybixcblx0XHRcdC8vIGV4ZWN1dGluZyBpbiB0aGUgc2NvcGUgb2YgdGhlIGRhdGEgb2JqZWN0IChmb3IgaW5zdGFuY2VzKVxuXHRcdFx0cmV0dXJuIGNlbGxEYXRhLmNhbGwoIHJvd0RhdGEgKTtcblx0XHR9XG5cdFxuXHRcdGlmICggY2VsbERhdGEgPT09IG51bGwgJiYgdHlwZSA9PSAnZGlzcGxheScgKSB7XG5cdFx0XHRyZXR1cm4gJyc7XG5cdFx0fVxuXHRcdHJldHVybiBjZWxsRGF0YTtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBTZXQgdGhlIHZhbHVlIGZvciBhIHNwZWNpZmljIGNlbGwsIGludG8gdGhlIGludGVybmFsIGRhdGEgY2FjaGVcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHtpbnR9IHJvd0lkeCBhb0RhdGEgcm93IGlkXG5cdCAqICBAcGFyYW0ge2ludH0gY29sSWR4IENvbHVtbiBpbmRleFxuXHQgKiAgQHBhcmFtIHsqfSB2YWwgVmFsdWUgdG8gc2V0XG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mblNldENlbGxEYXRhKCBzZXR0aW5ncywgcm93SWR4LCBjb2xJZHgsIHZhbCApXG5cdHtcblx0XHR2YXIgY29sICAgICA9IHNldHRpbmdzLmFvQ29sdW1uc1tjb2xJZHhdO1xuXHRcdHZhciByb3dEYXRhID0gc2V0dGluZ3MuYW9EYXRhW3Jvd0lkeF0uX2FEYXRhO1xuXHRcblx0XHRjb2wuZm5TZXREYXRhKCByb3dEYXRhLCB2YWwsIHtcblx0XHRcdHNldHRpbmdzOiBzZXR0aW5ncyxcblx0XHRcdHJvdzogICAgICByb3dJZHgsXG5cdFx0XHRjb2w6ICAgICAgY29sSWR4XG5cdFx0fSAgKTtcblx0fVxuXHRcblx0XG5cdC8vIFByaXZhdGUgdmFyaWFibGUgdGhhdCBpcyB1c2VkIHRvIG1hdGNoIGFjdGlvbiBzeW50YXggaW4gdGhlIGRhdGEgcHJvcGVydHkgb2JqZWN0XG5cdHZhciBfX3JlQXJyYXkgPSAvXFxbLio/XFxdJC87XG5cdHZhciBfX3JlRm4gPSAvXFwoXFwpJC87XG5cdFxuXHQvKipcblx0ICogU3BsaXQgc3RyaW5nIG9uIHBlcmlvZHMsIHRha2luZyBpbnRvIGFjY291bnQgZXNjYXBlZCBwZXJpb2RzXG5cdCAqIEBwYXJhbSAge3N0cmluZ30gc3RyIFN0cmluZyB0byBzcGxpdFxuXHQgKiBAcmV0dXJuIHthcnJheX0gU3BsaXQgc3RyaW5nXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5TcGxpdE9iak5vdGF0aW9uKCBzdHIgKVxuXHR7XG5cdFx0cmV0dXJuICQubWFwKCBzdHIubWF0Y2goLyhcXFxcLnxbXlxcLl0pKy9nKSB8fCBbJyddLCBmdW5jdGlvbiAoIHMgKSB7XG5cdFx0XHRyZXR1cm4gcy5yZXBsYWNlKC9cXFxcXFwuL2csICcuJyk7XG5cdFx0fSApO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIFJldHVybiBhIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gZ2V0IGRhdGEgZnJvbSBhIHNvdXJjZSBvYmplY3QsIHRha2luZ1xuXHQgKiBpbnRvIGFjY291bnQgdGhlIGFiaWxpdHkgdG8gdXNlIG5lc3RlZCBvYmplY3RzIGFzIGEgc291cmNlXG5cdCAqICBAcGFyYW0ge3N0cmluZ3xpbnR8ZnVuY3Rpb259IG1Tb3VyY2UgVGhlIGRhdGEgc291cmNlIGZvciB0aGUgb2JqZWN0XG5cdCAqICBAcmV0dXJucyB7ZnVuY3Rpb259IERhdGEgZ2V0IGZ1bmN0aW9uXG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkdldE9iamVjdERhdGFGbiggbVNvdXJjZSApXG5cdHtcblx0XHRpZiAoICQuaXNQbGFpbk9iamVjdCggbVNvdXJjZSApIClcblx0XHR7XG5cdFx0XHQvKiBCdWlsZCBhbiBvYmplY3Qgb2YgZ2V0IGZ1bmN0aW9ucywgYW5kIHdyYXAgdGhlbSBpbiBhIHNpbmdsZSBjYWxsICovXG5cdFx0XHR2YXIgbyA9IHt9O1xuXHRcdFx0JC5lYWNoKCBtU291cmNlLCBmdW5jdGlvbiAoa2V5LCB2YWwpIHtcblx0XHRcdFx0aWYgKCB2YWwgKSB7XG5cdFx0XHRcdFx0b1trZXldID0gX2ZuR2V0T2JqZWN0RGF0YUZuKCB2YWwgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcblx0XHRcdHJldHVybiBmdW5jdGlvbiAoZGF0YSwgdHlwZSwgcm93LCBtZXRhKSB7XG5cdFx0XHRcdHZhciB0ID0gb1t0eXBlXSB8fCBvLl87XG5cdFx0XHRcdHJldHVybiB0ICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRcdHQoZGF0YSwgdHlwZSwgcm93LCBtZXRhKSA6XG5cdFx0XHRcdFx0ZGF0YTtcblx0XHRcdH07XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCBtU291cmNlID09PSBudWxsIClcblx0XHR7XG5cdFx0XHQvKiBHaXZlIGFuIGVtcHR5IHN0cmluZyBmb3IgcmVuZGVyaW5nIC8gc29ydGluZyBldGMgKi9cblx0XHRcdHJldHVybiBmdW5jdGlvbiAoZGF0YSkgeyAvLyB0eXBlLCByb3cgYW5kIG1ldGEgYWxzbyBwYXNzZWQsIGJ1dCBub3QgdXNlZFxuXHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdH07XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCB0eXBlb2YgbVNvdXJjZSA9PT0gJ2Z1bmN0aW9uJyApXG5cdFx0e1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIChkYXRhLCB0eXBlLCByb3csIG1ldGEpIHtcblx0XHRcdFx0cmV0dXJuIG1Tb3VyY2UoIGRhdGEsIHR5cGUsIHJvdywgbWV0YSApO1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIHR5cGVvZiBtU291cmNlID09PSAnc3RyaW5nJyAmJiAobVNvdXJjZS5pbmRleE9mKCcuJykgIT09IC0xIHx8XG5cdFx0XHQgICAgICBtU291cmNlLmluZGV4T2YoJ1snKSAhPT0gLTEgfHwgbVNvdXJjZS5pbmRleE9mKCcoJykgIT09IC0xKSApXG5cdFx0e1xuXHRcdFx0LyogSWYgdGhlcmUgaXMgYSAuIGluIHRoZSBzb3VyY2Ugc3RyaW5nIHRoZW4gdGhlIGRhdGEgc291cmNlIGlzIGluIGFcblx0XHRcdCAqIG5lc3RlZCBvYmplY3Qgc28gd2UgbG9vcCBvdmVyIHRoZSBkYXRhIGZvciBlYWNoIGxldmVsIHRvIGdldCB0aGUgbmV4dFxuXHRcdFx0ICogbGV2ZWwgZG93bi4gT24gZWFjaCBsb29wIHdlIHRlc3QgZm9yIHVuZGVmaW5lZCwgYW5kIGlmIGZvdW5kIGltbWVkaWF0ZWx5XG5cdFx0XHQgKiByZXR1cm4uIFRoaXMgYWxsb3dzIGVudGlyZSBvYmplY3RzIHRvIGJlIG1pc3NpbmcgYW5kIHNEZWZhdWx0Q29udGVudCB0b1xuXHRcdFx0ICogYmUgdXNlZCBpZiBkZWZpbmVkLCByYXRoZXIgdGhhbiB0aHJvd2luZyBhbiBlcnJvclxuXHRcdFx0ICovXG5cdFx0XHR2YXIgZmV0Y2hEYXRhID0gZnVuY3Rpb24gKGRhdGEsIHR5cGUsIHNyYykge1xuXHRcdFx0XHR2YXIgYXJyYXlOb3RhdGlvbiwgZnVuY05vdGF0aW9uLCBvdXQsIGlubmVyU3JjO1xuXHRcblx0XHRcdFx0aWYgKCBzcmMgIT09IFwiXCIgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0dmFyIGEgPSBfZm5TcGxpdE9iak5vdGF0aW9uKCBzcmMgKTtcblx0XG5cdFx0XHRcdFx0Zm9yICggdmFyIGk9MCwgaUxlbj1hLmxlbmd0aCA7IGk8aUxlbiA7IGkrKyApXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0Ly8gQ2hlY2sgaWYgd2UgYXJlIGRlYWxpbmcgd2l0aCBzcGVjaWFsIG5vdGF0aW9uXG5cdFx0XHRcdFx0XHRhcnJheU5vdGF0aW9uID0gYVtpXS5tYXRjaChfX3JlQXJyYXkpO1xuXHRcdFx0XHRcdFx0ZnVuY05vdGF0aW9uID0gYVtpXS5tYXRjaChfX3JlRm4pO1xuXHRcblx0XHRcdFx0XHRcdGlmICggYXJyYXlOb3RhdGlvbiApXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdC8vIEFycmF5IG5vdGF0aW9uXG5cdFx0XHRcdFx0XHRcdGFbaV0gPSBhW2ldLnJlcGxhY2UoX19yZUFycmF5LCAnJyk7XG5cdFxuXHRcdFx0XHRcdFx0XHQvLyBDb25kaXRpb24gYWxsb3dzIHNpbXBseSBbXSB0byBiZSBwYXNzZWQgaW5cblx0XHRcdFx0XHRcdFx0aWYgKCBhW2ldICE9PSBcIlwiICkge1xuXHRcdFx0XHRcdFx0XHRcdGRhdGEgPSBkYXRhWyBhW2ldIF07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0b3V0ID0gW107XG5cdFxuXHRcdFx0XHRcdFx0XHQvLyBHZXQgdGhlIHJlbWFpbmRlciBvZiB0aGUgbmVzdGVkIG9iamVjdCB0byBnZXRcblx0XHRcdFx0XHRcdFx0YS5zcGxpY2UoIDAsIGkrMSApO1xuXHRcdFx0XHRcdFx0XHRpbm5lclNyYyA9IGEuam9pbignLicpO1xuXHRcblx0XHRcdFx0XHRcdFx0Ly8gVHJhdmVyc2UgZWFjaCBlbnRyeSBpbiB0aGUgYXJyYXkgZ2V0dGluZyB0aGUgcHJvcGVydGllcyByZXF1ZXN0ZWRcblx0XHRcdFx0XHRcdFx0aWYgKCAkLmlzQXJyYXkoIGRhdGEgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRmb3IgKCB2YXIgaj0wLCBqTGVuPWRhdGEubGVuZ3RoIDsgajxqTGVuIDsgaisrICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0b3V0LnB1c2goIGZldGNoRGF0YSggZGF0YVtqXSwgdHlwZSwgaW5uZXJTcmMgKSApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHRcdFx0Ly8gSWYgYSBzdHJpbmcgaXMgZ2l2ZW4gaW4gYmV0d2VlbiB0aGUgYXJyYXkgbm90YXRpb24gaW5kaWNhdG9ycywgdGhhdFxuXHRcdFx0XHRcdFx0XHQvLyBpcyB1c2VkIHRvIGpvaW4gdGhlIHN0cmluZ3MgdG9nZXRoZXIsIG90aGVyd2lzZSBhbiBhcnJheSBpcyByZXR1cm5lZFxuXHRcdFx0XHRcdFx0XHR2YXIgam9pbiA9IGFycmF5Tm90YXRpb25bMF0uc3Vic3RyaW5nKDEsIGFycmF5Tm90YXRpb25bMF0ubGVuZ3RoLTEpO1xuXHRcdFx0XHRcdFx0XHRkYXRhID0gKGpvaW49PT1cIlwiKSA/IG91dCA6IG91dC5qb2luKGpvaW4pO1xuXHRcblx0XHRcdFx0XHRcdFx0Ly8gVGhlIGlubmVyIGNhbGwgdG8gZmV0Y2hEYXRhIGhhcyBhbHJlYWR5IHRyYXZlcnNlZCB0aHJvdWdoIHRoZSByZW1haW5kZXJcblx0XHRcdFx0XHRcdFx0Ly8gb2YgdGhlIHNvdXJjZSByZXF1ZXN0ZWQsIHNvIHdlIGV4aXQgZnJvbSB0aGUgbG9vcFxuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2UgaWYgKCBmdW5jTm90YXRpb24gKVxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHQvLyBGdW5jdGlvbiBjYWxsXG5cdFx0XHRcdFx0XHRcdGFbaV0gPSBhW2ldLnJlcGxhY2UoX19yZUZuLCAnJyk7XG5cdFx0XHRcdFx0XHRcdGRhdGEgPSBkYXRhWyBhW2ldIF0oKTtcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRcdFx0aWYgKCBkYXRhID09PSBudWxsIHx8IGRhdGFbIGFbaV0gXSA9PT0gdW5kZWZpbmVkIClcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGRhdGEgPSBkYXRhWyBhW2ldIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdH07XG5cdFxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIChkYXRhLCB0eXBlKSB7IC8vIHJvdyBhbmQgbWV0YSBhbHNvIHBhc3NlZCwgYnV0IG5vdCB1c2VkXG5cdFx0XHRcdHJldHVybiBmZXRjaERhdGEoIGRhdGEsIHR5cGUsIG1Tb3VyY2UgKTtcblx0XHRcdH07XG5cdFx0fVxuXHRcdGVsc2Vcblx0XHR7XG5cdFx0XHQvKiBBcnJheSBvciBmbGF0IG9iamVjdCBtYXBwaW5nICovXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKGRhdGEsIHR5cGUpIHsgLy8gcm93IGFuZCBtZXRhIGFsc28gcGFzc2VkLCBidXQgbm90IHVzZWRcblx0XHRcdFx0cmV0dXJuIGRhdGFbbVNvdXJjZV07XG5cdFx0XHR9O1xuXHRcdH1cblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBSZXR1cm4gYSBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIHNldCBkYXRhIGZyb20gYSBzb3VyY2Ugb2JqZWN0LCB0YWtpbmdcblx0ICogaW50byBhY2NvdW50IHRoZSBhYmlsaXR5IHRvIHVzZSBuZXN0ZWQgb2JqZWN0cyBhcyBhIHNvdXJjZVxuXHQgKiAgQHBhcmFtIHtzdHJpbmd8aW50fGZ1bmN0aW9ufSBtU291cmNlIFRoZSBkYXRhIHNvdXJjZSBmb3IgdGhlIG9iamVjdFxuXHQgKiAgQHJldHVybnMge2Z1bmN0aW9ufSBEYXRhIHNldCBmdW5jdGlvblxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5TZXRPYmplY3REYXRhRm4oIG1Tb3VyY2UgKVxuXHR7XG5cdFx0aWYgKCAkLmlzUGxhaW5PYmplY3QoIG1Tb3VyY2UgKSApXG5cdFx0e1xuXHRcdFx0LyogVW5saWtlIGdldCwgb25seSB0aGUgdW5kZXJzY29yZSAoZ2xvYmFsKSBvcHRpb24gaXMgdXNlZCBmb3IgZm9yXG5cdFx0XHQgKiBzZXR0aW5nIGRhdGEgc2luY2Ugd2UgZG9uJ3Qga25vdyB0aGUgdHlwZSBoZXJlLiBUaGlzIGlzIHdoeSBhbiBvYmplY3Rcblx0XHRcdCAqIG9wdGlvbiBpcyBub3QgZG9jdW1lbnRlZCBmb3IgYG1EYXRhYCAod2hpY2ggaXMgcmVhZC93cml0ZSksIGJ1dCBpdCBpc1xuXHRcdFx0ICogZm9yIGBtUmVuZGVyYCB3aGljaCBpcyByZWFkIG9ubHkuXG5cdFx0XHQgKi9cblx0XHRcdHJldHVybiBfZm5TZXRPYmplY3REYXRhRm4oIG1Tb3VyY2UuXyApO1xuXHRcdH1cblx0XHRlbHNlIGlmICggbVNvdXJjZSA9PT0gbnVsbCApXG5cdFx0e1xuXHRcdFx0LyogTm90aGluZyB0byBkbyB3aGVuIHRoZSBkYXRhIHNvdXJjZSBpcyBudWxsICovXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge307XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCB0eXBlb2YgbVNvdXJjZSA9PT0gJ2Z1bmN0aW9uJyApXG5cdFx0e1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIChkYXRhLCB2YWwsIG1ldGEpIHtcblx0XHRcdFx0bVNvdXJjZSggZGF0YSwgJ3NldCcsIHZhbCwgbWV0YSApO1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIHR5cGVvZiBtU291cmNlID09PSAnc3RyaW5nJyAmJiAobVNvdXJjZS5pbmRleE9mKCcuJykgIT09IC0xIHx8XG5cdFx0XHQgICAgICBtU291cmNlLmluZGV4T2YoJ1snKSAhPT0gLTEgfHwgbVNvdXJjZS5pbmRleE9mKCcoJykgIT09IC0xKSApXG5cdFx0e1xuXHRcdFx0LyogTGlrZSB0aGUgZ2V0LCB3ZSBuZWVkIHRvIGdldCBkYXRhIGZyb20gYSBuZXN0ZWQgb2JqZWN0ICovXG5cdFx0XHR2YXIgc2V0RGF0YSA9IGZ1bmN0aW9uIChkYXRhLCB2YWwsIHNyYykge1xuXHRcdFx0XHR2YXIgYSA9IF9mblNwbGl0T2JqTm90YXRpb24oIHNyYyApLCBiO1xuXHRcdFx0XHR2YXIgYUxhc3QgPSBhW2EubGVuZ3RoLTFdO1xuXHRcdFx0XHR2YXIgYXJyYXlOb3RhdGlvbiwgZnVuY05vdGF0aW9uLCBvLCBpbm5lclNyYztcblx0XG5cdFx0XHRcdGZvciAoIHZhciBpPTAsIGlMZW49YS5sZW5ndGgtMSA7IGk8aUxlbiA7IGkrKyApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHQvLyBDaGVjayBpZiB3ZSBhcmUgZGVhbGluZyB3aXRoIGFuIGFycmF5IG5vdGF0aW9uIHJlcXVlc3Rcblx0XHRcdFx0XHRhcnJheU5vdGF0aW9uID0gYVtpXS5tYXRjaChfX3JlQXJyYXkpO1xuXHRcdFx0XHRcdGZ1bmNOb3RhdGlvbiA9IGFbaV0ubWF0Y2goX19yZUZuKTtcblx0XG5cdFx0XHRcdFx0aWYgKCBhcnJheU5vdGF0aW9uIClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRhW2ldID0gYVtpXS5yZXBsYWNlKF9fcmVBcnJheSwgJycpO1xuXHRcdFx0XHRcdFx0ZGF0YVsgYVtpXSBdID0gW107XG5cdFxuXHRcdFx0XHRcdFx0Ly8gR2V0IHRoZSByZW1haW5kZXIgb2YgdGhlIG5lc3RlZCBvYmplY3QgdG8gc2V0IHNvIHdlIGNhbiByZWN1cnNlXG5cdFx0XHRcdFx0XHRiID0gYS5zbGljZSgpO1xuXHRcdFx0XHRcdFx0Yi5zcGxpY2UoIDAsIGkrMSApO1xuXHRcdFx0XHRcdFx0aW5uZXJTcmMgPSBiLmpvaW4oJy4nKTtcblx0XG5cdFx0XHRcdFx0XHQvLyBUcmF2ZXJzZSBlYWNoIGVudHJ5IGluIHRoZSBhcnJheSBzZXR0aW5nIHRoZSBwcm9wZXJ0aWVzIHJlcXVlc3RlZFxuXHRcdFx0XHRcdFx0aWYgKCAkLmlzQXJyYXkoIHZhbCApIClcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0Zm9yICggdmFyIGo9MCwgakxlbj12YWwubGVuZ3RoIDsgajxqTGVuIDsgaisrIClcblx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdG8gPSB7fTtcblx0XHRcdFx0XHRcdFx0XHRzZXREYXRhKCBvLCB2YWxbal0sIGlubmVyU3JjICk7XG5cdFx0XHRcdFx0XHRcdFx0ZGF0YVsgYVtpXSBdLnB1c2goIG8gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHQvLyBXZSd2ZSBiZWVuIGFza2VkIHRvIHNhdmUgZGF0YSB0byBhbiBhcnJheSwgYnV0IGl0XG5cdFx0XHRcdFx0XHRcdC8vIGlzbid0IGFycmF5IGRhdGEgdG8gYmUgc2F2ZWQuIEJlc3QgdGhhdCBjYW4gYmUgZG9uZVxuXHRcdFx0XHRcdFx0XHQvLyBpcyB0byBqdXN0IHNhdmUgdGhlIHZhbHVlLlxuXHRcdFx0XHRcdFx0XHRkYXRhWyBhW2ldIF0gPSB2YWw7XG5cdFx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRcdFx0Ly8gVGhlIGlubmVyIGNhbGwgdG8gc2V0RGF0YSBoYXMgYWxyZWFkeSB0cmF2ZXJzZWQgdGhyb3VnaCB0aGUgcmVtYWluZGVyXG5cdFx0XHRcdFx0XHQvLyBvZiB0aGUgc291cmNlIGFuZCBoYXMgc2V0IHRoZSBkYXRhLCB0aHVzIHdlIGNhbiBleGl0IGhlcmVcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSBpZiAoIGZ1bmNOb3RhdGlvbiApXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0Ly8gRnVuY3Rpb24gY2FsbFxuXHRcdFx0XHRcdFx0YVtpXSA9IGFbaV0ucmVwbGFjZShfX3JlRm4sICcnKTtcblx0XHRcdFx0XHRcdGRhdGEgPSBkYXRhWyBhW2ldIF0oIHZhbCApO1xuXHRcdFx0XHRcdH1cblx0XG5cdFx0XHRcdFx0Ly8gSWYgdGhlIG5lc3RlZCBvYmplY3QgZG9lc24ndCBjdXJyZW50bHkgZXhpc3QgLSBzaW5jZSB3ZSBhcmVcblx0XHRcdFx0XHQvLyB0cnlpbmcgdG8gc2V0IHRoZSB2YWx1ZSAtIGNyZWF0ZSBpdFxuXHRcdFx0XHRcdGlmICggZGF0YVsgYVtpXSBdID09PSBudWxsIHx8IGRhdGFbIGFbaV0gXSA9PT0gdW5kZWZpbmVkIClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRkYXRhWyBhW2ldIF0gPSB7fTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZGF0YSA9IGRhdGFbIGFbaV0gXTtcblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0Ly8gTGFzdCBpdGVtIGluIHRoZSBpbnB1dCAtIGkuZSwgdGhlIGFjdHVhbCBzZXRcblx0XHRcdFx0aWYgKCBhTGFzdC5tYXRjaChfX3JlRm4gKSApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHQvLyBGdW5jdGlvbiBjYWxsXG5cdFx0XHRcdFx0ZGF0YSA9IGRhdGFbIGFMYXN0LnJlcGxhY2UoX19yZUZuLCAnJykgXSggdmFsICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Ly8gSWYgYXJyYXkgbm90YXRpb24gaXMgdXNlZCwgd2UganVzdCB3YW50IHRvIHN0cmlwIGl0IGFuZCB1c2UgdGhlIHByb3BlcnR5IG5hbWVcblx0XHRcdFx0XHQvLyBhbmQgYXNzaWduIHRoZSB2YWx1ZS4gSWYgaXQgaXNuJ3QgdXNlZCwgdGhlbiB3ZSBnZXQgdGhlIHJlc3VsdCB3ZSB3YW50IGFueXdheVxuXHRcdFx0XHRcdGRhdGFbIGFMYXN0LnJlcGxhY2UoX19yZUFycmF5LCAnJykgXSA9IHZhbDtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKGRhdGEsIHZhbCkgeyAvLyBtZXRhIGlzIGFsc28gcGFzc2VkIGluLCBidXQgbm90IHVzZWRcblx0XHRcdFx0cmV0dXJuIHNldERhdGEoIGRhdGEsIHZhbCwgbVNvdXJjZSApO1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0ZWxzZVxuXHRcdHtcblx0XHRcdC8qIEFycmF5IG9yIGZsYXQgb2JqZWN0IG1hcHBpbmcgKi9cblx0XHRcdHJldHVybiBmdW5jdGlvbiAoZGF0YSwgdmFsKSB7IC8vIG1ldGEgaXMgYWxzbyBwYXNzZWQgaW4sIGJ1dCBub3QgdXNlZFxuXHRcdFx0XHRkYXRhW21Tb3VyY2VdID0gdmFsO1xuXHRcdFx0fTtcblx0XHR9XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogUmV0dXJuIGFuIGFycmF5IHdpdGggdGhlIGZ1bGwgdGFibGUgZGF0YVxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHJldHVybnMgYXJyYXkge2FycmF5fSBhRGF0YSBNYXN0ZXIgZGF0YSBhcnJheVxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5HZXREYXRhTWFzdGVyICggc2V0dGluZ3MgKVxuXHR7XG5cdFx0cmV0dXJuIF9wbHVjayggc2V0dGluZ3MuYW9EYXRhLCAnX2FEYXRhJyApO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIE51a2UgdGhlIHRhYmxlXG5cdCAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkNsZWFyVGFibGUoIHNldHRpbmdzIClcblx0e1xuXHRcdHNldHRpbmdzLmFvRGF0YS5sZW5ndGggPSAwO1xuXHRcdHNldHRpbmdzLmFpRGlzcGxheU1hc3Rlci5sZW5ndGggPSAwO1xuXHRcdHNldHRpbmdzLmFpRGlzcGxheS5sZW5ndGggPSAwO1xuXHRcdHNldHRpbmdzLmFJZHMgPSB7fTtcblx0fVxuXHRcblx0XG5cdCAvKipcblx0ICogVGFrZSBhbiBhcnJheSBvZiBpbnRlZ2VycyAoaW5kZXggYXJyYXkpIGFuZCByZW1vdmUgYSB0YXJnZXQgaW50ZWdlciAodmFsdWUgLSBub3Rcblx0ICogdGhlIGtleSEpXG5cdCAqICBAcGFyYW0ge2FycmF5fSBhIEluZGV4IGFycmF5IHRvIHRhcmdldFxuXHQgKiAgQHBhcmFtIHtpbnR9IGlUYXJnZXQgdmFsdWUgdG8gZmluZFxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5EZWxldGVJbmRleCggYSwgaVRhcmdldCwgc3BsaWNlIClcblx0e1xuXHRcdHZhciBpVGFyZ2V0SW5kZXggPSAtMTtcblx0XG5cdFx0Zm9yICggdmFyIGk9MCwgaUxlbj1hLmxlbmd0aCA7IGk8aUxlbiA7IGkrKyApXG5cdFx0e1xuXHRcdFx0aWYgKCBhW2ldID09IGlUYXJnZXQgKVxuXHRcdFx0e1xuXHRcdFx0XHRpVGFyZ2V0SW5kZXggPSBpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIGFbaV0gPiBpVGFyZ2V0IClcblx0XHRcdHtcblx0XHRcdFx0YVtpXS0tO1xuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0aWYgKCBpVGFyZ2V0SW5kZXggIT0gLTEgJiYgc3BsaWNlID09PSB1bmRlZmluZWQgKVxuXHRcdHtcblx0XHRcdGEuc3BsaWNlKCBpVGFyZ2V0SW5kZXgsIDEgKTtcblx0XHR9XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogTWFyayBjYWNoZWQgZGF0YSBhcyBpbnZhbGlkIHN1Y2ggdGhhdCBhIHJlLXJlYWQgb2YgdGhlIGRhdGEgd2lsbCBvY2N1ciB3aGVuXG5cdCAqIHRoZSBjYWNoZWQgZGF0YSBpcyBuZXh0IHJlcXVlc3RlZC4gQWxzbyB1cGRhdGUgZnJvbSB0aGUgZGF0YSBzb3VyY2Ugb2JqZWN0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogQHBhcmFtIHtpbnR9ICAgIHJvd0lkeCAgIFJvdyBpbmRleCB0byBpbnZhbGlkYXRlXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbc3JjXSAgICBTb3VyY2UgdG8gaW52YWxpZGF0ZSBmcm9tOiB1bmRlZmluZWQsICdhdXRvJywgJ2RvbSdcblx0ICogICAgIG9yICdkYXRhJ1xuXHQgKiBAcGFyYW0ge2ludH0gICAgW2NvbElkeF0gQ29sdW1uIGluZGV4IHRvIGludmFsaWRhdGUuIElmIHVuZGVmaW5lZCB0aGUgd2hvbGVcblx0ICogICAgIHJvdyB3aWxsIGJlIGludmFsaWRhdGVkXG5cdCAqIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKlxuXHQgKiBAdG9kbyBGb3IgdGhlIG1vZHVsYXJpc2F0aW9uIG9mIHYxLjExIHRoaXMgd2lsbCBuZWVkIHRvIGJlY29tZSBhIGNhbGxiYWNrLCBzb1xuXHQgKiAgIHRoZSBzb3J0IGFuZCBmaWx0ZXIgbWV0aG9kcyBjYW4gc3Vic2NyaWJlIHRvIGl0LiBUaGF0IHdpbGwgcmVxdWlyZWRcblx0ICogICBpbml0aWFsaXNhdGlvbiBvcHRpb25zIGZvciBzb3J0aW5nLCB3aGljaCBpcyB3aHkgaXQgaXMgbm90IGFscmVhZHkgYmFrZWQgaW5cblx0ICovXG5cdGZ1bmN0aW9uIF9mbkludmFsaWRhdGUoIHNldHRpbmdzLCByb3dJZHgsIHNyYywgY29sSWR4IClcblx0e1xuXHRcdHZhciByb3cgPSBzZXR0aW5ncy5hb0RhdGFbIHJvd0lkeCBdO1xuXHRcdHZhciBpLCBpZW47XG5cdFx0dmFyIGNlbGxXcml0ZSA9IGZ1bmN0aW9uICggY2VsbCwgY29sICkge1xuXHRcdFx0Ly8gVGhpcyBpcyB2ZXJ5IGZydXN0cmF0aW5nLCBidXQgaW4gSUUgaWYgeW91IGp1c3Qgd3JpdGUgZGlyZWN0bHlcblx0XHRcdC8vIHRvIGlubmVySFRNTCwgYW5kIGVsZW1lbnRzIHRoYXQgYXJlIG92ZXJ3cml0dGVuIGFyZSBHQydlZCxcblx0XHRcdC8vIGV2ZW4gaWYgdGhlcmUgaXMgYSByZWZlcmVuY2UgdG8gdGhlbSBlbHNld2hlcmVcblx0XHRcdHdoaWxlICggY2VsbC5jaGlsZE5vZGVzLmxlbmd0aCApIHtcblx0XHRcdFx0Y2VsbC5yZW1vdmVDaGlsZCggY2VsbC5maXJzdENoaWxkICk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0Y2VsbC5pbm5lckhUTUwgPSBfZm5HZXRDZWxsRGF0YSggc2V0dGluZ3MsIHJvd0lkeCwgY29sLCAnZGlzcGxheScgKTtcblx0XHR9O1xuXHRcblx0XHQvLyBBcmUgd2UgcmVhZGluZyBsYXN0IGRhdGEgZnJvbSBET00gb3IgdGhlIGRhdGEgb2JqZWN0P1xuXHRcdGlmICggc3JjID09PSAnZG9tJyB8fCAoKCEgc3JjIHx8IHNyYyA9PT0gJ2F1dG8nKSAmJiByb3cuc3JjID09PSAnZG9tJykgKSB7XG5cdFx0XHQvLyBSZWFkIHRoZSBkYXRhIGZyb20gdGhlIERPTVxuXHRcdFx0cm93Ll9hRGF0YSA9IF9mbkdldFJvd0VsZW1lbnRzKFxuXHRcdFx0XHRcdHNldHRpbmdzLCByb3csIGNvbElkeCwgY29sSWR4ID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiByb3cuX2FEYXRhXG5cdFx0XHRcdClcblx0XHRcdFx0LmRhdGE7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0Ly8gUmVhZGluZyBmcm9tIGRhdGEgb2JqZWN0LCB1cGRhdGUgdGhlIERPTVxuXHRcdFx0dmFyIGNlbGxzID0gcm93LmFuQ2VsbHM7XG5cdFxuXHRcdFx0aWYgKCBjZWxscyApIHtcblx0XHRcdFx0aWYgKCBjb2xJZHggIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRjZWxsV3JpdGUoIGNlbGxzW2NvbElkeF0sIGNvbElkeCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGZvciAoIGk9MCwgaWVuPWNlbGxzLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRcdFx0Y2VsbFdyaXRlKCBjZWxsc1tpXSwgaSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0Ly8gRm9yIGJvdGggcm93IGFuZCBjZWxsIGludmFsaWRhdGlvbiwgdGhlIGNhY2hlZCBkYXRhIGZvciBzb3J0aW5nIGFuZFxuXHRcdC8vIGZpbHRlcmluZyBpcyBudWxsZWQgb3V0XG5cdFx0cm93Ll9hU29ydERhdGEgPSBudWxsO1xuXHRcdHJvdy5fYUZpbHRlckRhdGEgPSBudWxsO1xuXHRcblx0XHQvLyBJbnZhbGlkYXRlIHRoZSB0eXBlIGZvciBhIHNwZWNpZmljIGNvbHVtbiAoaWYgZ2l2ZW4pIG9yIGFsbCBjb2x1bW5zIHNpbmNlXG5cdFx0Ly8gdGhlIGRhdGEgbWlnaHQgaGF2ZSBjaGFuZ2VkXG5cdFx0dmFyIGNvbHMgPSBzZXR0aW5ncy5hb0NvbHVtbnM7XG5cdFx0aWYgKCBjb2xJZHggIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGNvbHNbIGNvbElkeCBdLnNUeXBlID0gbnVsbDtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRmb3IgKCBpPTAsIGllbj1jb2xzLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRjb2xzW2ldLnNUeXBlID0gbnVsbDtcblx0XHRcdH1cblx0XG5cdFx0XHQvLyBVcGRhdGUgRGF0YVRhYmxlcyBzcGVjaWFsIGBEVF8qYCBhdHRyaWJ1dGVzIGZvciB0aGUgcm93XG5cdFx0XHRfZm5Sb3dBdHRyaWJ1dGVzKCBzZXR0aW5ncywgcm93ICk7XG5cdFx0fVxuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIEJ1aWxkIGEgZGF0YSBzb3VyY2Ugb2JqZWN0IGZyb20gYW4gSFRNTCByb3csIHJlYWRpbmcgdGhlIGNvbnRlbnRzIG9mIHRoZVxuXHQgKiBjZWxscyB0aGF0IGFyZSBpbiB0aGUgcm93LlxuXHQgKlxuXHQgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogQHBhcmFtIHtub2RlfG9iamVjdH0gVFIgZWxlbWVudCBmcm9tIHdoaWNoIHRvIHJlYWQgZGF0YSBvciBleGlzdGluZyByb3dcblx0ICogICBvYmplY3QgZnJvbSB3aGljaCB0byByZS1yZWFkIHRoZSBkYXRhIGZyb20gdGhlIGNlbGxzXG5cdCAqIEBwYXJhbSB7aW50fSBbY29sSWR4XSBPcHRpb25hbCBjb2x1bW4gaW5kZXhcblx0ICogQHBhcmFtIHthcnJheXxvYmplY3R9IFtkXSBEYXRhIHNvdXJjZSBvYmplY3QuIElmIGBjb2xJZHhgIGlzIGdpdmVuIHRoZW4gdGhpc1xuXHQgKiAgIHBhcmFtZXRlciBzaG91bGQgYWxzbyBiZSBnaXZlbiBhbmQgd2lsbCBiZSB1c2VkIHRvIHdyaXRlIHRoZSBkYXRhIGludG8uXG5cdCAqICAgT25seSB0aGUgY29sdW1uIGluIHF1ZXN0aW9uIHdpbGwgYmUgd3JpdHRlblxuXHQgKiBAcmV0dXJucyB7b2JqZWN0fSBPYmplY3Qgd2l0aCB0d28gcGFyYW1ldGVyczogYGRhdGFgIHRoZSBkYXRhIHJlYWQsIGluXG5cdCAqICAgZG9jdW1lbnQgb3JkZXIsIGFuZCBgY2VsbHNgIGFuZCBhcnJheSBvZiBub2RlcyAodGhleSBjYW4gYmUgdXNlZnVsIHRvIHRoZVxuXHQgKiAgIGNhbGxlciwgc28gcmF0aGVyIHRoYW4gbmVlZGluZyBhIHNlY29uZCB0cmF2ZXJzYWwgdG8gZ2V0IHRoZW0sIGp1c3QgcmV0dXJuXG5cdCAqICAgdGhlbSBmcm9tIGhlcmUpLlxuXHQgKiBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkdldFJvd0VsZW1lbnRzKCBzZXR0aW5ncywgcm93LCBjb2xJZHgsIGQgKVxuXHR7XG5cdFx0dmFyXG5cdFx0XHR0ZHMgPSBbXSxcblx0XHRcdHRkID0gcm93LmZpcnN0Q2hpbGQsXG5cdFx0XHRuYW1lLCBjb2wsIG8sIGk9MCwgY29udGVudHMsXG5cdFx0XHRjb2x1bW5zID0gc2V0dGluZ3MuYW9Db2x1bW5zLFxuXHRcdFx0b2JqZWN0UmVhZCA9IHNldHRpbmdzLl9yb3dSZWFkT2JqZWN0O1xuXHRcblx0XHQvLyBBbGxvdyB0aGUgZGF0YSBvYmplY3QgdG8gYmUgcGFzc2VkIGluLCBvciBjb25zdHJ1Y3Rcblx0XHRkID0gZCAhPT0gdW5kZWZpbmVkID9cblx0XHRcdGQgOlxuXHRcdFx0b2JqZWN0UmVhZCA/XG5cdFx0XHRcdHt9IDpcblx0XHRcdFx0W107XG5cdFxuXHRcdHZhciBhdHRyID0gZnVuY3Rpb24gKCBzdHIsIHRkICApIHtcblx0XHRcdGlmICggdHlwZW9mIHN0ciA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdHZhciBpZHggPSBzdHIuaW5kZXhPZignQCcpO1xuXHRcblx0XHRcdFx0aWYgKCBpZHggIT09IC0xICkge1xuXHRcdFx0XHRcdHZhciBhdHRyID0gc3RyLnN1YnN0cmluZyggaWR4KzEgKTtcblx0XHRcdFx0XHR2YXIgc2V0dGVyID0gX2ZuU2V0T2JqZWN0RGF0YUZuKCBzdHIgKTtcblx0XHRcdFx0XHRzZXR0ZXIoIGQsIHRkLmdldEF0dHJpYnV0ZSggYXR0ciApICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHRcblx0XHQvLyBSZWFkIGRhdGEgZnJvbSBhIGNlbGwgYW5kIHN0b3JlIGludG8gdGhlIGRhdGEgb2JqZWN0XG5cdFx0dmFyIGNlbGxQcm9jZXNzID0gZnVuY3Rpb24gKCBjZWxsICkge1xuXHRcdFx0aWYgKCBjb2xJZHggPT09IHVuZGVmaW5lZCB8fCBjb2xJZHggPT09IGkgKSB7XG5cdFx0XHRcdGNvbCA9IGNvbHVtbnNbaV07XG5cdFx0XHRcdGNvbnRlbnRzID0gJC50cmltKGNlbGwuaW5uZXJIVE1MKTtcblx0XG5cdFx0XHRcdGlmICggY29sICYmIGNvbC5fYkF0dHJTcmMgKSB7XG5cdFx0XHRcdFx0dmFyIHNldHRlciA9IF9mblNldE9iamVjdERhdGFGbiggY29sLm1EYXRhLl8gKTtcblx0XHRcdFx0XHRzZXR0ZXIoIGQsIGNvbnRlbnRzICk7XG5cdFxuXHRcdFx0XHRcdGF0dHIoIGNvbC5tRGF0YS5zb3J0LCBjZWxsICk7XG5cdFx0XHRcdFx0YXR0ciggY29sLm1EYXRhLnR5cGUsIGNlbGwgKTtcblx0XHRcdFx0XHRhdHRyKCBjb2wubURhdGEuZmlsdGVyLCBjZWxsICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0Ly8gRGVwZW5kaW5nIG9uIHRoZSBgZGF0YWAgb3B0aW9uIGZvciB0aGUgY29sdW1ucyB0aGUgZGF0YSBjYW5cblx0XHRcdFx0XHQvLyBiZSByZWFkIHRvIGVpdGhlciBhbiBvYmplY3Qgb3IgYW4gYXJyYXkuXG5cdFx0XHRcdFx0aWYgKCBvYmplY3RSZWFkICkge1xuXHRcdFx0XHRcdFx0aWYgKCAhIGNvbC5fc2V0dGVyICkge1xuXHRcdFx0XHRcdFx0XHQvLyBDYWNoZSB0aGUgc2V0dGVyIGZ1bmN0aW9uXG5cdFx0XHRcdFx0XHRcdGNvbC5fc2V0dGVyID0gX2ZuU2V0T2JqZWN0RGF0YUZuKCBjb2wubURhdGEgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGNvbC5fc2V0dGVyKCBkLCBjb250ZW50cyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdGRbaV0gPSBjb250ZW50cztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XG5cdFx0XHRpKys7XG5cdFx0fTtcblx0XG5cdFx0aWYgKCB0ZCApIHtcblx0XHRcdC8vIGB0cmAgZWxlbWVudCB3YXMgcGFzc2VkIGluXG5cdFx0XHR3aGlsZSAoIHRkICkge1xuXHRcdFx0XHRuYW1lID0gdGQubm9kZU5hbWUudG9VcHBlckNhc2UoKTtcblx0XG5cdFx0XHRcdGlmICggbmFtZSA9PSBcIlREXCIgfHwgbmFtZSA9PSBcIlRIXCIgKSB7XG5cdFx0XHRcdFx0Y2VsbFByb2Nlc3MoIHRkICk7XG5cdFx0XHRcdFx0dGRzLnB1c2goIHRkICk7XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdHRkID0gdGQubmV4dFNpYmxpbmc7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0Ly8gRXhpc3Rpbmcgcm93IG9iamVjdCBwYXNzZWQgaW5cblx0XHRcdHRkcyA9IHJvdy5hbkNlbGxzO1xuXHRcblx0XHRcdGZvciAoIHZhciBqPTAsIGplbj10ZHMubGVuZ3RoIDsgajxqZW4gOyBqKysgKSB7XG5cdFx0XHRcdGNlbGxQcm9jZXNzKCB0ZHNbal0gKTtcblx0XHRcdH1cblx0XHR9XG5cdFxuXHRcdC8vIFJlYWQgdGhlIElEIGZyb20gdGhlIERPTSBpZiBwcmVzZW50XG5cdFx0dmFyIHJvd05vZGUgPSByb3cuZmlyc3RDaGlsZCA/IHJvdyA6IHJvdy5uVHI7XG5cdFxuXHRcdGlmICggcm93Tm9kZSApIHtcblx0XHRcdHZhciBpZCA9IHJvd05vZGUuZ2V0QXR0cmlidXRlKCAnaWQnICk7XG5cdFxuXHRcdFx0aWYgKCBpZCApIHtcblx0XHRcdFx0X2ZuU2V0T2JqZWN0RGF0YUZuKCBzZXR0aW5ncy5yb3dJZCApKCBkLCBpZCApO1xuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0cmV0dXJuIHtcblx0XHRcdGRhdGE6IGQsXG5cdFx0XHRjZWxsczogdGRzXG5cdFx0fTtcblx0fVxuXHQvKipcblx0ICogQ3JlYXRlIGEgbmV3IFRSIGVsZW1lbnQgKGFuZCBpdCdzIFREIGNoaWxkcmVuKSBmb3IgYSByb3dcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBwYXJhbSB7aW50fSBpUm93IFJvdyB0byBjb25zaWRlclxuXHQgKiAgQHBhcmFtIHtub2RlfSBbblRySW5dIFRSIGVsZW1lbnQgdG8gYWRkIHRvIHRoZSB0YWJsZSAtIG9wdGlvbmFsLiBJZiBub3QgZ2l2ZW4sXG5cdCAqICAgIERhdGFUYWJsZXMgd2lsbCBjcmVhdGUgYSByb3cgYXV0b21hdGljYWxseVxuXHQgKiAgQHBhcmFtIHthcnJheX0gW2FuVGRzXSBBcnJheSBvZiBURHxUSCBlbGVtZW50cyBmb3IgdGhlIHJvdyAtIG11c3QgYmUgZ2l2ZW5cblx0ICogICAgaWYgblRyIGlzLlxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5DcmVhdGVUciAoIG9TZXR0aW5ncywgaVJvdywgblRySW4sIGFuVGRzIClcblx0e1xuXHRcdHZhclxuXHRcdFx0cm93ID0gb1NldHRpbmdzLmFvRGF0YVtpUm93XSxcblx0XHRcdHJvd0RhdGEgPSByb3cuX2FEYXRhLFxuXHRcdFx0Y2VsbHMgPSBbXSxcblx0XHRcdG5UciwgblRkLCBvQ29sLFxuXHRcdFx0aSwgaUxlbiwgY3JlYXRlO1xuXHRcblx0XHRpZiAoIHJvdy5uVHIgPT09IG51bGwgKVxuXHRcdHtcblx0XHRcdG5UciA9IG5UckluIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RyJyk7XG5cdFxuXHRcdFx0cm93Lm5UciA9IG5Ucjtcblx0XHRcdHJvdy5hbkNlbGxzID0gY2VsbHM7XG5cdFxuXHRcdFx0LyogVXNlIGEgcHJpdmF0ZSBwcm9wZXJ0eSBvbiB0aGUgbm9kZSB0byBhbGxvdyByZXNlcnZlIG1hcHBpbmcgZnJvbSB0aGUgbm9kZVxuXHRcdFx0ICogdG8gdGhlIGFvRGF0YSBhcnJheSBmb3IgZmFzdCBsb29rIHVwXG5cdFx0XHQgKi9cblx0XHRcdG5Uci5fRFRfUm93SW5kZXggPSBpUm93O1xuXHRcblx0XHRcdC8qIFNwZWNpYWwgcGFyYW1ldGVycyBjYW4gYmUgZ2l2ZW4gYnkgdGhlIGRhdGEgc291cmNlIHRvIGJlIHVzZWQgb24gdGhlIHJvdyAqL1xuXHRcdFx0X2ZuUm93QXR0cmlidXRlcyggb1NldHRpbmdzLCByb3cgKTtcblx0XG5cdFx0XHQvKiBQcm9jZXNzIGVhY2ggY29sdW1uICovXG5cdFx0XHRmb3IgKCBpPTAsIGlMZW49b1NldHRpbmdzLmFvQ29sdW1ucy5sZW5ndGggOyBpPGlMZW4gOyBpKysgKVxuXHRcdFx0e1xuXHRcdFx0XHRvQ29sID0gb1NldHRpbmdzLmFvQ29sdW1uc1tpXTtcblx0XHRcdFx0Y3JlYXRlID0gblRySW4gPyBmYWxzZSA6IHRydWU7XG5cdFxuXHRcdFx0XHRuVGQgPSBjcmVhdGUgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBvQ29sLnNDZWxsVHlwZSApIDogYW5UZHNbaV07XG5cdFx0XHRcdG5UZC5fRFRfQ2VsbEluZGV4ID0ge1xuXHRcdFx0XHRcdHJvdzogaVJvdyxcblx0XHRcdFx0XHRjb2x1bW46IGlcblx0XHRcdFx0fTtcblx0XHRcdFx0XG5cdFx0XHRcdGNlbGxzLnB1c2goIG5UZCApO1xuXHRcblx0XHRcdFx0Ly8gTmVlZCB0byBjcmVhdGUgdGhlIEhUTUwgaWYgbmV3LCBvciBpZiBhIHJlbmRlcmluZyBmdW5jdGlvbiBpcyBkZWZpbmVkXG5cdFx0XHRcdGlmICggY3JlYXRlIHx8ICgoIW5UckluIHx8IG9Db2wubVJlbmRlciB8fCBvQ29sLm1EYXRhICE9PSBpKSAmJlxuXHRcdFx0XHRcdCAoISQuaXNQbGFpbk9iamVjdChvQ29sLm1EYXRhKSB8fCBvQ29sLm1EYXRhLl8gIT09IGkrJy5kaXNwbGF5Jylcblx0XHRcdFx0KSkge1xuXHRcdFx0XHRcdG5UZC5pbm5lckhUTUwgPSBfZm5HZXRDZWxsRGF0YSggb1NldHRpbmdzLCBpUm93LCBpLCAnZGlzcGxheScgKTtcblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0LyogQWRkIHVzZXIgZGVmaW5lZCBjbGFzcyAqL1xuXHRcdFx0XHRpZiAoIG9Db2wuc0NsYXNzIClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG5UZC5jbGFzc05hbWUgKz0gJyAnK29Db2wuc0NsYXNzO1xuXHRcdFx0XHR9XG5cdFxuXHRcdFx0XHQvLyBWaXNpYmlsaXR5IC0gYWRkIG9yIHJlbW92ZSBhcyByZXF1aXJlZFxuXHRcdFx0XHRpZiAoIG9Db2wuYlZpc2libGUgJiYgISBuVHJJbiApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRuVHIuYXBwZW5kQ2hpbGQoIG5UZCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKCAhIG9Db2wuYlZpc2libGUgJiYgblRySW4gKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0blRkLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIG5UZCApO1xuXHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRpZiAoIG9Db2wuZm5DcmVhdGVkQ2VsbCApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRvQ29sLmZuQ3JlYXRlZENlbGwuY2FsbCggb1NldHRpbmdzLm9JbnN0YW5jZSxcblx0XHRcdFx0XHRcdG5UZCwgX2ZuR2V0Q2VsbERhdGEoIG9TZXR0aW5ncywgaVJvdywgaSApLCByb3dEYXRhLCBpUm93LCBpXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcblx0XHRcdF9mbkNhbGxiYWNrRmlyZSggb1NldHRpbmdzLCAnYW9Sb3dDcmVhdGVkQ2FsbGJhY2snLCBudWxsLCBbblRyLCByb3dEYXRhLCBpUm93LCBjZWxsc10gKTtcblx0XHR9XG5cdFxuXHRcdC8vIFJlbW92ZSBvbmNlIHdlYmtpdCBidWcgMTMxODE5IGFuZCBDaHJvbWl1bSBidWcgMzY1NjE5IGhhdmUgYmVlbiByZXNvbHZlZFxuXHRcdC8vIGFuZCBkZXBsb3llZFxuXHRcdHJvdy5uVHIuc2V0QXR0cmlidXRlKCAncm9sZScsICdyb3cnICk7XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogQWRkIGF0dHJpYnV0ZXMgdG8gYSByb3cgYmFzZWQgb24gdGhlIHNwZWNpYWwgYERUXypgIHBhcmFtZXRlcnMgaW4gYSBkYXRhXG5cdCAqIHNvdXJjZSBvYmplY3QuXG5cdCAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBEYXRhVGFibGVzIHJvdyBvYmplY3QgZm9yIHRoZSByb3cgdG8gYmUgbW9kaWZpZWRcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuUm93QXR0cmlidXRlcyggc2V0dGluZ3MsIHJvdyApXG5cdHtcblx0XHR2YXIgdHIgPSByb3cublRyO1xuXHRcdHZhciBkYXRhID0gcm93Ll9hRGF0YTtcblx0XG5cdFx0aWYgKCB0ciApIHtcblx0XHRcdHZhciBpZCA9IHNldHRpbmdzLnJvd0lkRm4oIGRhdGEgKTtcblx0XG5cdFx0XHRpZiAoIGlkICkge1xuXHRcdFx0XHR0ci5pZCA9IGlkO1xuXHRcdFx0fVxuXHRcblx0XHRcdGlmICggZGF0YS5EVF9Sb3dDbGFzcyApIHtcblx0XHRcdFx0Ly8gUmVtb3ZlIGFueSBjbGFzc2VzIGFkZGVkIGJ5IERUX1Jvd0NsYXNzIGJlZm9yZVxuXHRcdFx0XHR2YXIgYSA9IGRhdGEuRFRfUm93Q2xhc3Muc3BsaXQoJyAnKTtcblx0XHRcdFx0cm93Ll9fcm93YyA9IHJvdy5fX3Jvd2MgP1xuXHRcdFx0XHRcdF91bmlxdWUoIHJvdy5fX3Jvd2MuY29uY2F0KCBhICkgKSA6XG5cdFx0XHRcdFx0YTtcblx0XG5cdFx0XHRcdCQodHIpXG5cdFx0XHRcdFx0LnJlbW92ZUNsYXNzKCByb3cuX19yb3djLmpvaW4oJyAnKSApXG5cdFx0XHRcdFx0LmFkZENsYXNzKCBkYXRhLkRUX1Jvd0NsYXNzICk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0aWYgKCBkYXRhLkRUX1Jvd0F0dHIgKSB7XG5cdFx0XHRcdCQodHIpLmF0dHIoIGRhdGEuRFRfUm93QXR0ciApO1xuXHRcdFx0fVxuXHRcblx0XHRcdGlmICggZGF0YS5EVF9Sb3dEYXRhICkge1xuXHRcdFx0XHQkKHRyKS5kYXRhKCBkYXRhLkRUX1Jvd0RhdGEgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogQ3JlYXRlIHRoZSBIVE1MIGhlYWRlciBmb3IgdGhlIHRhYmxlXG5cdCAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkJ1aWxkSGVhZCggb1NldHRpbmdzIClcblx0e1xuXHRcdHZhciBpLCBpZW4sIGNlbGwsIHJvdywgY29sdW1uO1xuXHRcdHZhciB0aGVhZCA9IG9TZXR0aW5ncy5uVEhlYWQ7XG5cdFx0dmFyIHRmb290ID0gb1NldHRpbmdzLm5URm9vdDtcblx0XHR2YXIgY3JlYXRlSGVhZGVyID0gJCgndGgsIHRkJywgdGhlYWQpLmxlbmd0aCA9PT0gMDtcblx0XHR2YXIgY2xhc3NlcyA9IG9TZXR0aW5ncy5vQ2xhc3Nlcztcblx0XHR2YXIgY29sdW1ucyA9IG9TZXR0aW5ncy5hb0NvbHVtbnM7XG5cdFxuXHRcdGlmICggY3JlYXRlSGVhZGVyICkge1xuXHRcdFx0cm93ID0gJCgnPHRyLz4nKS5hcHBlbmRUbyggdGhlYWQgKTtcblx0XHR9XG5cdFxuXHRcdGZvciAoIGk9MCwgaWVuPWNvbHVtbnMubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRjb2x1bW4gPSBjb2x1bW5zW2ldO1xuXHRcdFx0Y2VsbCA9ICQoIGNvbHVtbi5uVGggKS5hZGRDbGFzcyggY29sdW1uLnNDbGFzcyApO1xuXHRcblx0XHRcdGlmICggY3JlYXRlSGVhZGVyICkge1xuXHRcdFx0XHRjZWxsLmFwcGVuZFRvKCByb3cgKTtcblx0XHRcdH1cblx0XG5cdFx0XHQvLyAxLjExIG1vdmUgaW50byBzb3J0aW5nXG5cdFx0XHRpZiAoIG9TZXR0aW5ncy5vRmVhdHVyZXMuYlNvcnQgKSB7XG5cdFx0XHRcdGNlbGwuYWRkQ2xhc3MoIGNvbHVtbi5zU29ydGluZ0NsYXNzICk7XG5cdFxuXHRcdFx0XHRpZiAoIGNvbHVtbi5iU29ydGFibGUgIT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGNlbGxcblx0XHRcdFx0XHRcdC5hdHRyKCAndGFiaW5kZXgnLCBvU2V0dGluZ3MuaVRhYkluZGV4IClcblx0XHRcdFx0XHRcdC5hdHRyKCAnYXJpYS1jb250cm9scycsIG9TZXR0aW5ncy5zVGFibGVJZCApO1xuXHRcblx0XHRcdFx0XHRfZm5Tb3J0QXR0YWNoTGlzdGVuZXIoIG9TZXR0aW5ncywgY29sdW1uLm5UaCwgaSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFxuXHRcdFx0aWYgKCBjb2x1bW4uc1RpdGxlICE9IGNlbGxbMF0uaW5uZXJIVE1MICkge1xuXHRcdFx0XHRjZWxsLmh0bWwoIGNvbHVtbi5zVGl0bGUgKTtcblx0XHRcdH1cblx0XG5cdFx0XHRfZm5SZW5kZXJlciggb1NldHRpbmdzLCAnaGVhZGVyJyApKFxuXHRcdFx0XHRvU2V0dGluZ3MsIGNlbGwsIGNvbHVtbiwgY2xhc3Nlc1xuXHRcdFx0KTtcblx0XHR9XG5cdFxuXHRcdGlmICggY3JlYXRlSGVhZGVyICkge1xuXHRcdFx0X2ZuRGV0ZWN0SGVhZGVyKCBvU2V0dGluZ3MuYW9IZWFkZXIsIHRoZWFkICk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qIEFSSUEgcm9sZSBmb3IgdGhlIHJvd3MgKi9cblx0IFx0JCh0aGVhZCkuZmluZCgnPnRyJykuYXR0cigncm9sZScsICdyb3cnKTtcblx0XG5cdFx0LyogRGVhbCB3aXRoIHRoZSBmb290ZXIgLSBhZGQgY2xhc3NlcyBpZiByZXF1aXJlZCAqL1xuXHRcdCQodGhlYWQpLmZpbmQoJz50cj50aCwgPnRyPnRkJykuYWRkQ2xhc3MoIGNsYXNzZXMuc0hlYWRlclRIICk7XG5cdFx0JCh0Zm9vdCkuZmluZCgnPnRyPnRoLCA+dHI+dGQnKS5hZGRDbGFzcyggY2xhc3Nlcy5zRm9vdGVyVEggKTtcblx0XG5cdFx0Ly8gQ2FjaGUgdGhlIGZvb3RlciBjZWxscy4gTm90ZSB0aGF0IHdlIG9ubHkgdGFrZSB0aGUgY2VsbHMgZnJvbSB0aGUgZmlyc3Rcblx0XHQvLyByb3cgaW4gdGhlIGZvb3Rlci4gSWYgdGhlcmUgaXMgbW9yZSB0aGFuIG9uZSByb3cgdGhlIHVzZXIgd2FudHMgdG9cblx0XHQvLyBpbnRlcmFjdCB3aXRoLCB0aGV5IG5lZWQgdG8gdXNlIHRoZSB0YWJsZSgpLmZvb3QoKSBtZXRob2QuIE5vdGUgYWxzbyB0aGlzXG5cdFx0Ly8gYWxsb3dzIGNlbGxzIHRvIGJlIHVzZWQgZm9yIG11bHRpcGxlIGNvbHVtbnMgdXNpbmcgY29sc3BhblxuXHRcdGlmICggdGZvb3QgIT09IG51bGwgKSB7XG5cdFx0XHR2YXIgY2VsbHMgPSBvU2V0dGluZ3MuYW9Gb290ZXJbMF07XG5cdFxuXHRcdFx0Zm9yICggaT0wLCBpZW49Y2VsbHMubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdGNvbHVtbiA9IGNvbHVtbnNbaV07XG5cdFx0XHRcdGNvbHVtbi5uVGYgPSBjZWxsc1tpXS5jZWxsO1xuXHRcblx0XHRcdFx0aWYgKCBjb2x1bW4uc0NsYXNzICkge1xuXHRcdFx0XHRcdCQoY29sdW1uLm5UZikuYWRkQ2xhc3MoIGNvbHVtbi5zQ2xhc3MgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBEcmF3IHRoZSBoZWFkZXIgKG9yIGZvb3RlcikgZWxlbWVudCBiYXNlZCBvbiB0aGUgY29sdW1uIHZpc2liaWxpdHkgc3RhdGVzLiBUaGVcblx0ICogbWV0aG9kb2xvZ3kgaGVyZSBpcyB0byB1c2UgdGhlIGxheW91dCBhcnJheSBmcm9tIF9mbkRldGVjdEhlYWRlciwgbW9kaWZpZWQgZm9yXG5cdCAqIHRoZSBpbnN0YW50YW5lb3VzIGNvbHVtbiB2aXNpYmlsaXR5LCB0byBjb25zdHJ1Y3QgdGhlIG5ldyBsYXlvdXQuIFRoZSBncmlkIGlzXG5cdCAqIHRyYXZlcnNlZCBvdmVyIGNlbGwgYXQgYSB0aW1lIGluIGEgcm93cyB4IGNvbHVtbnMgZ3JpZCBmYXNoaW9uLCBhbHRob3VnaCBlYWNoXG5cdCAqIGNlbGwgaW5zZXJ0IGNhbiBjb3ZlciBtdWx0aXBsZSBlbGVtZW50cyBpbiB0aGUgZ3JpZCAtIHdoaWNoIGlzIHRyYWNrcyB1c2luZyB0aGVcblx0ICogYUFwcGxpZWQgYXJyYXkuIENlbGwgaW5zZXJ0cyBpbiB0aGUgZ3JpZCB3aWxsIG9ubHkgb2NjdXIgd2hlcmUgdGhlcmUgaXNuJ3Rcblx0ICogYWxyZWFkeSBhIGNlbGwgaW4gdGhhdCBwb3NpdGlvbi5cblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBwYXJhbSBhcnJheSB7b2JqZWN0c30gYW9Tb3VyY2UgTGF5b3V0IGFycmF5IGZyb20gX2ZuRGV0ZWN0SGVhZGVyXG5cdCAqICBAcGFyYW0ge2Jvb2xlYW59IFtiSW5jbHVkZUhpZGRlbj1mYWxzZV0gSWYgdHJ1ZSB0aGVuIGluY2x1ZGUgdGhlIGhpZGRlbiBjb2x1bW5zIGluIHRoZSBjYWxjLFxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5EcmF3SGVhZCggb1NldHRpbmdzLCBhb1NvdXJjZSwgYkluY2x1ZGVIaWRkZW4gKVxuXHR7XG5cdFx0dmFyIGksIGlMZW4sIGosIGpMZW4sIGssIGtMZW4sIG4sIG5Mb2NhbFRyO1xuXHRcdHZhciBhb0xvY2FsID0gW107XG5cdFx0dmFyIGFBcHBsaWVkID0gW107XG5cdFx0dmFyIGlDb2x1bW5zID0gb1NldHRpbmdzLmFvQ29sdW1ucy5sZW5ndGg7XG5cdFx0dmFyIGlSb3dzcGFuLCBpQ29sc3Bhbjtcblx0XG5cdFx0aWYgKCAhIGFvU291cmNlIClcblx0XHR7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcblx0XHRpZiAoICBiSW5jbHVkZUhpZGRlbiA9PT0gdW5kZWZpbmVkIClcblx0XHR7XG5cdFx0XHRiSW5jbHVkZUhpZGRlbiA9IGZhbHNlO1xuXHRcdH1cblx0XG5cdFx0LyogTWFrZSBhIGNvcHkgb2YgdGhlIG1hc3RlciBsYXlvdXQgYXJyYXksIGJ1dCB3aXRob3V0IHRoZSB2aXNpYmxlIGNvbHVtbnMgaW4gaXQgKi9cblx0XHRmb3IgKCBpPTAsIGlMZW49YW9Tb3VyY2UubGVuZ3RoIDsgaTxpTGVuIDsgaSsrIClcblx0XHR7XG5cdFx0XHRhb0xvY2FsW2ldID0gYW9Tb3VyY2VbaV0uc2xpY2UoKTtcblx0XHRcdGFvTG9jYWxbaV0ublRyID0gYW9Tb3VyY2VbaV0ublRyO1xuXHRcblx0XHRcdC8qIFJlbW92ZSBhbnkgY29sdW1ucyB3aGljaCBhcmUgY3VycmVudGx5IGhpZGRlbiAqL1xuXHRcdFx0Zm9yICggaj1pQ29sdW1ucy0xIDsgaj49MCA7IGotLSApXG5cdFx0XHR7XG5cdFx0XHRcdGlmICggIW9TZXR0aW5ncy5hb0NvbHVtbnNbal0uYlZpc2libGUgJiYgIWJJbmNsdWRlSGlkZGVuIClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGFvTG9jYWxbaV0uc3BsaWNlKCBqLCAxICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XG5cdFx0XHQvKiBQcmVwIHRoZSBhcHBsaWVkIGFycmF5IC0gaXQgbmVlZHMgYW4gZWxlbWVudCBmb3IgZWFjaCByb3cgKi9cblx0XHRcdGFBcHBsaWVkLnB1c2goIFtdICk7XG5cdFx0fVxuXHRcblx0XHRmb3IgKCBpPTAsIGlMZW49YW9Mb2NhbC5sZW5ndGggOyBpPGlMZW4gOyBpKysgKVxuXHRcdHtcblx0XHRcdG5Mb2NhbFRyID0gYW9Mb2NhbFtpXS5uVHI7XG5cdFxuXHRcdFx0LyogQWxsIGNlbGxzIGFyZSBnb2luZyB0byBiZSByZXBsYWNlZCwgc28gZW1wdHkgb3V0IHRoZSByb3cgKi9cblx0XHRcdGlmICggbkxvY2FsVHIgKVxuXHRcdFx0e1xuXHRcdFx0XHR3aGlsZSggKG4gPSBuTG9jYWxUci5maXJzdENoaWxkKSApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRuTG9jYWxUci5yZW1vdmVDaGlsZCggbiApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFxuXHRcdFx0Zm9yICggaj0wLCBqTGVuPWFvTG9jYWxbaV0ubGVuZ3RoIDsgajxqTGVuIDsgaisrIClcblx0XHRcdHtcblx0XHRcdFx0aVJvd3NwYW4gPSAxO1xuXHRcdFx0XHRpQ29sc3BhbiA9IDE7XG5cdFxuXHRcdFx0XHQvKiBDaGVjayB0byBzZWUgaWYgdGhlcmUgaXMgYWxyZWFkeSBhIGNlbGwgKHJvdy9jb2xzcGFuKSBjb3ZlcmluZyBvdXIgdGFyZ2V0XG5cdFx0XHRcdCAqIGluc2VydCBwb2ludC4gSWYgdGhlcmUgaXMsIHRoZW4gdGhlcmUgaXMgbm90aGluZyB0byBkby5cblx0XHRcdFx0ICovXG5cdFx0XHRcdGlmICggYUFwcGxpZWRbaV1bal0gPT09IHVuZGVmaW5lZCApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRuTG9jYWxUci5hcHBlbmRDaGlsZCggYW9Mb2NhbFtpXVtqXS5jZWxsICk7XG5cdFx0XHRcdFx0YUFwcGxpZWRbaV1bal0gPSAxO1xuXHRcblx0XHRcdFx0XHQvKiBFeHBhbmQgdGhlIGNlbGwgdG8gY292ZXIgYXMgbWFueSByb3dzIGFzIG5lZWRlZCAqL1xuXHRcdFx0XHRcdHdoaWxlICggYW9Mb2NhbFtpK2lSb3dzcGFuXSAhPT0gdW5kZWZpbmVkICYmXG5cdFx0XHRcdFx0ICAgICAgICBhb0xvY2FsW2ldW2pdLmNlbGwgPT0gYW9Mb2NhbFtpK2lSb3dzcGFuXVtqXS5jZWxsIClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRhQXBwbGllZFtpK2lSb3dzcGFuXVtqXSA9IDE7XG5cdFx0XHRcdFx0XHRpUm93c3BhbisrO1xuXHRcdFx0XHRcdH1cblx0XG5cdFx0XHRcdFx0LyogRXhwYW5kIHRoZSBjZWxsIHRvIGNvdmVyIGFzIG1hbnkgY29sdW1ucyBhcyBuZWVkZWQgKi9cblx0XHRcdFx0XHR3aGlsZSAoIGFvTG9jYWxbaV1baitpQ29sc3Bhbl0gIT09IHVuZGVmaW5lZCAmJlxuXHRcdFx0XHRcdCAgICAgICAgYW9Mb2NhbFtpXVtqXS5jZWxsID09IGFvTG9jYWxbaV1baitpQ29sc3Bhbl0uY2VsbCApXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0LyogTXVzdCB1cGRhdGUgdGhlIGFwcGxpZWQgYXJyYXkgb3ZlciB0aGUgcm93cyBmb3IgdGhlIGNvbHVtbnMgKi9cblx0XHRcdFx0XHRcdGZvciAoIGs9MCA7IGs8aVJvd3NwYW4gOyBrKysgKVxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRhQXBwbGllZFtpK2tdW2oraUNvbHNwYW5dID0gMTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlDb2xzcGFuKys7XG5cdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHQvKiBEbyB0aGUgYWN0dWFsIGV4cGFuc2lvbiBpbiB0aGUgRE9NICovXG5cdFx0XHRcdFx0JChhb0xvY2FsW2ldW2pdLmNlbGwpXG5cdFx0XHRcdFx0XHQuYXR0cigncm93c3BhbicsIGlSb3dzcGFuKVxuXHRcdFx0XHRcdFx0LmF0dHIoJ2NvbHNwYW4nLCBpQ29sc3Bhbik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogSW5zZXJ0IHRoZSByZXF1aXJlZCBUUiBub2RlcyBpbnRvIHRoZSB0YWJsZSBmb3IgZGlzcGxheVxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5EcmF3KCBvU2V0dGluZ3MgKVxuXHR7XG5cdFx0LyogUHJvdmlkZSBhIHByZS1jYWxsYmFjayBmdW5jdGlvbiB3aGljaCBjYW4gYmUgdXNlZCB0byBjYW5jZWwgdGhlIGRyYXcgaXMgZmFsc2UgaXMgcmV0dXJuZWQgKi9cblx0XHR2YXIgYVByZURyYXcgPSBfZm5DYWxsYmFja0ZpcmUoIG9TZXR0aW5ncywgJ2FvUHJlRHJhd0NhbGxiYWNrJywgJ3ByZURyYXcnLCBbb1NldHRpbmdzXSApO1xuXHRcdGlmICggJC5pbkFycmF5KCBmYWxzZSwgYVByZURyYXcgKSAhPT0gLTEgKVxuXHRcdHtcblx0XHRcdF9mblByb2Nlc3NpbmdEaXNwbGF5KCBvU2V0dGluZ3MsIGZhbHNlICk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcblx0XHR2YXIgaSwgaUxlbiwgbjtcblx0XHR2YXIgYW5Sb3dzID0gW107XG5cdFx0dmFyIGlSb3dDb3VudCA9IDA7XG5cdFx0dmFyIGFzU3RyaXBlQ2xhc3NlcyA9IG9TZXR0aW5ncy5hc1N0cmlwZUNsYXNzZXM7XG5cdFx0dmFyIGlTdHJpcGVzID0gYXNTdHJpcGVDbGFzc2VzLmxlbmd0aDtcblx0XHR2YXIgaU9wZW5Sb3dzID0gb1NldHRpbmdzLmFvT3BlblJvd3MubGVuZ3RoO1xuXHRcdHZhciBvTGFuZyA9IG9TZXR0aW5ncy5vTGFuZ3VhZ2U7XG5cdFx0dmFyIGlJbml0RGlzcGxheVN0YXJ0ID0gb1NldHRpbmdzLmlJbml0RGlzcGxheVN0YXJ0O1xuXHRcdHZhciBiU2VydmVyU2lkZSA9IF9mbkRhdGFTb3VyY2UoIG9TZXR0aW5ncyApID09ICdzc3AnO1xuXHRcdHZhciBhaURpc3BsYXkgPSBvU2V0dGluZ3MuYWlEaXNwbGF5O1xuXHRcblx0XHRvU2V0dGluZ3MuYkRyYXdpbmcgPSB0cnVlO1xuXHRcblx0XHQvKiBDaGVjayBhbmQgc2VlIGlmIHdlIGhhdmUgYW4gaW5pdGlhbCBkcmF3IHBvc2l0aW9uIGZyb20gc3RhdGUgc2F2aW5nICovXG5cdFx0aWYgKCBpSW5pdERpc3BsYXlTdGFydCAhPT0gdW5kZWZpbmVkICYmIGlJbml0RGlzcGxheVN0YXJ0ICE9PSAtMSApXG5cdFx0e1xuXHRcdFx0b1NldHRpbmdzLl9pRGlzcGxheVN0YXJ0ID0gYlNlcnZlclNpZGUgP1xuXHRcdFx0XHRpSW5pdERpc3BsYXlTdGFydCA6XG5cdFx0XHRcdGlJbml0RGlzcGxheVN0YXJ0ID49IG9TZXR0aW5ncy5mblJlY29yZHNEaXNwbGF5KCkgP1xuXHRcdFx0XHRcdDAgOlxuXHRcdFx0XHRcdGlJbml0RGlzcGxheVN0YXJ0O1xuXHRcblx0XHRcdG9TZXR0aW5ncy5pSW5pdERpc3BsYXlTdGFydCA9IC0xO1xuXHRcdH1cblx0XG5cdFx0dmFyIGlEaXNwbGF5U3RhcnQgPSBvU2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQ7XG5cdFx0dmFyIGlEaXNwbGF5RW5kID0gb1NldHRpbmdzLmZuRGlzcGxheUVuZCgpO1xuXHRcblx0XHQvKiBTZXJ2ZXItc2lkZSBwcm9jZXNzaW5nIGRyYXcgaW50ZXJjZXB0ICovXG5cdFx0aWYgKCBvU2V0dGluZ3MuYkRlZmVyTG9hZGluZyApXG5cdFx0e1xuXHRcdFx0b1NldHRpbmdzLmJEZWZlckxvYWRpbmcgPSBmYWxzZTtcblx0XHRcdG9TZXR0aW5ncy5pRHJhdysrO1xuXHRcdFx0X2ZuUHJvY2Vzc2luZ0Rpc3BsYXkoIG9TZXR0aW5ncywgZmFsc2UgKTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoICFiU2VydmVyU2lkZSApXG5cdFx0e1xuXHRcdFx0b1NldHRpbmdzLmlEcmF3Kys7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCAhb1NldHRpbmdzLmJEZXN0cm95aW5nICYmICFfZm5BamF4VXBkYXRlKCBvU2V0dGluZ3MgKSApXG5cdFx0e1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XG5cdFx0aWYgKCBhaURpc3BsYXkubGVuZ3RoICE9PSAwIClcblx0XHR7XG5cdFx0XHR2YXIgaVN0YXJ0ID0gYlNlcnZlclNpZGUgPyAwIDogaURpc3BsYXlTdGFydDtcblx0XHRcdHZhciBpRW5kID0gYlNlcnZlclNpZGUgPyBvU2V0dGluZ3MuYW9EYXRhLmxlbmd0aCA6IGlEaXNwbGF5RW5kO1xuXHRcblx0XHRcdGZvciAoIHZhciBqPWlTdGFydCA7IGo8aUVuZCA7IGorKyApXG5cdFx0XHR7XG5cdFx0XHRcdHZhciBpRGF0YUluZGV4ID0gYWlEaXNwbGF5W2pdO1xuXHRcdFx0XHR2YXIgYW9EYXRhID0gb1NldHRpbmdzLmFvRGF0YVsgaURhdGFJbmRleCBdO1xuXHRcdFx0XHRpZiAoIGFvRGF0YS5uVHIgPT09IG51bGwgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0X2ZuQ3JlYXRlVHIoIG9TZXR0aW5ncywgaURhdGFJbmRleCApO1xuXHRcdFx0XHR9XG5cdFxuXHRcdFx0XHR2YXIgblJvdyA9IGFvRGF0YS5uVHI7XG5cdFxuXHRcdFx0XHQvKiBSZW1vdmUgdGhlIG9sZCBzdHJpcGluZyBjbGFzc2VzIGFuZCB0aGVuIGFkZCB0aGUgbmV3IG9uZSAqL1xuXHRcdFx0XHRpZiAoIGlTdHJpcGVzICE9PSAwIClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHZhciBzU3RyaXBlID0gYXNTdHJpcGVDbGFzc2VzWyBpUm93Q291bnQgJSBpU3RyaXBlcyBdO1xuXHRcdFx0XHRcdGlmICggYW9EYXRhLl9zUm93U3RyaXBlICE9IHNTdHJpcGUgKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdCQoblJvdykucmVtb3ZlQ2xhc3MoIGFvRGF0YS5fc1Jvd1N0cmlwZSApLmFkZENsYXNzKCBzU3RyaXBlICk7XG5cdFx0XHRcdFx0XHRhb0RhdGEuX3NSb3dTdHJpcGUgPSBzU3RyaXBlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0Ly8gUm93IGNhbGxiYWNrIGZ1bmN0aW9ucyAtIG1pZ2h0IHdhbnQgdG8gbWFuaXB1bGF0ZSB0aGUgcm93XG5cdFx0XHRcdC8vIGlSb3dDb3VudCBhbmQgaiBhcmUgbm90IGN1cnJlbnRseSBkb2N1bWVudGVkLiBBcmUgdGhleSBhdCBhbGxcblx0XHRcdFx0Ly8gdXNlZnVsP1xuXHRcdFx0XHRfZm5DYWxsYmFja0ZpcmUoIG9TZXR0aW5ncywgJ2FvUm93Q2FsbGJhY2snLCBudWxsLFxuXHRcdFx0XHRcdFtuUm93LCBhb0RhdGEuX2FEYXRhLCBpUm93Q291bnQsIGosIGlEYXRhSW5kZXhdICk7XG5cdFxuXHRcdFx0XHRhblJvd3MucHVzaCggblJvdyApO1xuXHRcdFx0XHRpUm93Q291bnQrKztcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZVxuXHRcdHtcblx0XHRcdC8qIFRhYmxlIGlzIGVtcHR5IC0gY3JlYXRlIGEgcm93IHdpdGggYW4gZW1wdHkgbWVzc2FnZSBpbiBpdCAqL1xuXHRcdFx0dmFyIHNaZXJvID0gb0xhbmcuc1plcm9SZWNvcmRzO1xuXHRcdFx0aWYgKCBvU2V0dGluZ3MuaURyYXcgPT0gMSAmJiAgX2ZuRGF0YVNvdXJjZSggb1NldHRpbmdzICkgPT0gJ2FqYXgnIClcblx0XHRcdHtcblx0XHRcdFx0c1plcm8gPSBvTGFuZy5zTG9hZGluZ1JlY29yZHM7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggb0xhbmcuc0VtcHR5VGFibGUgJiYgb1NldHRpbmdzLmZuUmVjb3Jkc1RvdGFsKCkgPT09IDAgKVxuXHRcdFx0e1xuXHRcdFx0XHRzWmVybyA9IG9MYW5nLnNFbXB0eVRhYmxlO1xuXHRcdFx0fVxuXHRcblx0XHRcdGFuUm93c1sgMCBdID0gJCggJzx0ci8+JywgeyAnY2xhc3MnOiBpU3RyaXBlcyA/IGFzU3RyaXBlQ2xhc3Nlc1swXSA6ICcnIH0gKVxuXHRcdFx0XHQuYXBwZW5kKCAkKCc8dGQgLz4nLCB7XG5cdFx0XHRcdFx0J3ZhbGlnbic6ICAndG9wJyxcblx0XHRcdFx0XHQnY29sU3Bhbic6IF9mblZpc2JsZUNvbHVtbnMoIG9TZXR0aW5ncyApLFxuXHRcdFx0XHRcdCdjbGFzcyc6ICAgb1NldHRpbmdzLm9DbGFzc2VzLnNSb3dFbXB0eVxuXHRcdFx0XHR9ICkuaHRtbCggc1plcm8gKSApWzBdO1xuXHRcdH1cblx0XG5cdFx0LyogSGVhZGVyIGFuZCBmb290ZXIgY2FsbGJhY2tzICovXG5cdFx0X2ZuQ2FsbGJhY2tGaXJlKCBvU2V0dGluZ3MsICdhb0hlYWRlckNhbGxiYWNrJywgJ2hlYWRlcicsIFsgJChvU2V0dGluZ3MublRIZWFkKS5jaGlsZHJlbigndHInKVswXSxcblx0XHRcdF9mbkdldERhdGFNYXN0ZXIoIG9TZXR0aW5ncyApLCBpRGlzcGxheVN0YXJ0LCBpRGlzcGxheUVuZCwgYWlEaXNwbGF5IF0gKTtcblx0XG5cdFx0X2ZuQ2FsbGJhY2tGaXJlKCBvU2V0dGluZ3MsICdhb0Zvb3RlckNhbGxiYWNrJywgJ2Zvb3RlcicsIFsgJChvU2V0dGluZ3MublRGb290KS5jaGlsZHJlbigndHInKVswXSxcblx0XHRcdF9mbkdldERhdGFNYXN0ZXIoIG9TZXR0aW5ncyApLCBpRGlzcGxheVN0YXJ0LCBpRGlzcGxheUVuZCwgYWlEaXNwbGF5IF0gKTtcblx0XG5cdFx0dmFyIGJvZHkgPSAkKG9TZXR0aW5ncy5uVEJvZHkpO1xuXHRcblx0XHRib2R5LmNoaWxkcmVuKCkuZGV0YWNoKCk7XG5cdFx0Ym9keS5hcHBlbmQoICQoYW5Sb3dzKSApO1xuXHRcblx0XHQvKiBDYWxsIGFsbCByZXF1aXJlZCBjYWxsYmFjayBmdW5jdGlvbnMgZm9yIHRoZSBlbmQgb2YgYSBkcmF3ICovXG5cdFx0X2ZuQ2FsbGJhY2tGaXJlKCBvU2V0dGluZ3MsICdhb0RyYXdDYWxsYmFjaycsICdkcmF3JywgW29TZXR0aW5nc10gKTtcblx0XG5cdFx0LyogRHJhdyBpcyBjb21wbGV0ZSwgc29ydGluZyBhbmQgZmlsdGVyaW5nIG11c3QgYmUgYXMgd2VsbCAqL1xuXHRcdG9TZXR0aW5ncy5iU29ydGVkID0gZmFsc2U7XG5cdFx0b1NldHRpbmdzLmJGaWx0ZXJlZCA9IGZhbHNlO1xuXHRcdG9TZXR0aW5ncy5iRHJhd2luZyA9IGZhbHNlO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIFJlZHJhdyB0aGUgdGFibGUgLSB0YWtpbmcgYWNjb3VudCBvZiB0aGUgdmFyaW91cyBmZWF0dXJlcyB3aGljaCBhcmUgZW5hYmxlZFxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHtib29sZWFufSBbaG9sZFBvc2l0aW9uXSBLZWVwIHRoZSBjdXJyZW50IHBhZ2luZyBwb3NpdGlvbi4gQnkgZGVmYXVsdFxuXHQgKiAgICB0aGUgcGFnaW5nIGlzIHJlc2V0IHRvIHRoZSBmaXJzdCBwYWdlXG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mblJlRHJhdyggc2V0dGluZ3MsIGhvbGRQb3NpdGlvbiApXG5cdHtcblx0XHR2YXJcblx0XHRcdGZlYXR1cmVzID0gc2V0dGluZ3Mub0ZlYXR1cmVzLFxuXHRcdFx0c29ydCAgICAgPSBmZWF0dXJlcy5iU29ydCxcblx0XHRcdGZpbHRlciAgID0gZmVhdHVyZXMuYkZpbHRlcjtcblx0XG5cdFx0aWYgKCBzb3J0ICkge1xuXHRcdFx0X2ZuU29ydCggc2V0dGluZ3MgKTtcblx0XHR9XG5cdFxuXHRcdGlmICggZmlsdGVyICkge1xuXHRcdFx0X2ZuRmlsdGVyQ29tcGxldGUoIHNldHRpbmdzLCBzZXR0aW5ncy5vUHJldmlvdXNTZWFyY2ggKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHQvLyBObyBmaWx0ZXJpbmcsIHNvIHdlIHdhbnQgdG8ganVzdCB1c2UgdGhlIGRpc3BsYXkgbWFzdGVyXG5cdFx0XHRzZXR0aW5ncy5haURpc3BsYXkgPSBzZXR0aW5ncy5haURpc3BsYXlNYXN0ZXIuc2xpY2UoKTtcblx0XHR9XG5cdFxuXHRcdGlmICggaG9sZFBvc2l0aW9uICE9PSB0cnVlICkge1xuXHRcdFx0c2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQgPSAwO1xuXHRcdH1cblx0XG5cdFx0Ly8gTGV0IGFueSBtb2R1bGVzIGtub3cgYWJvdXQgdGhlIGRyYXcgaG9sZCBwb3NpdGlvbiBzdGF0ZSAodXNlZCBieVxuXHRcdC8vIHNjcm9sbGluZyBpbnRlcm5hbGx5KVxuXHRcdHNldHRpbmdzLl9kcmF3SG9sZCA9IGhvbGRQb3NpdGlvbjtcblx0XG5cdFx0X2ZuRHJhdyggc2V0dGluZ3MgKTtcblx0XG5cdFx0c2V0dGluZ3MuX2RyYXdIb2xkID0gZmFsc2U7XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogQWRkIHRoZSBvcHRpb25zIHRvIHRoZSBwYWdlIEhUTUwgZm9yIHRoZSB0YWJsZVxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5BZGRPcHRpb25zSHRtbCAoIG9TZXR0aW5ncyApXG5cdHtcblx0XHR2YXIgY2xhc3NlcyA9IG9TZXR0aW5ncy5vQ2xhc3Nlcztcblx0XHR2YXIgdGFibGUgPSAkKG9TZXR0aW5ncy5uVGFibGUpO1xuXHRcdHZhciBob2xkaW5nID0gJCgnPGRpdi8+JykuaW5zZXJ0QmVmb3JlKCB0YWJsZSApOyAvLyBIb2xkaW5nIGVsZW1lbnQgZm9yIHNwZWVkXG5cdFx0dmFyIGZlYXR1cmVzID0gb1NldHRpbmdzLm9GZWF0dXJlcztcblx0XG5cdFx0Ly8gQWxsIERhdGFUYWJsZXMgYXJlIHdyYXBwZWQgaW4gYSBkaXZcblx0XHR2YXIgaW5zZXJ0ID0gJCgnPGRpdi8+Jywge1xuXHRcdFx0aWQ6ICAgICAgb1NldHRpbmdzLnNUYWJsZUlkKydfd3JhcHBlcicsXG5cdFx0XHQnY2xhc3MnOiBjbGFzc2VzLnNXcmFwcGVyICsgKG9TZXR0aW5ncy5uVEZvb3QgPyAnJyA6ICcgJytjbGFzc2VzLnNOb0Zvb3Rlcilcblx0XHR9ICk7XG5cdFxuXHRcdG9TZXR0aW5ncy5uSG9sZGluZyA9IGhvbGRpbmdbMF07XG5cdFx0b1NldHRpbmdzLm5UYWJsZVdyYXBwZXIgPSBpbnNlcnRbMF07XG5cdFx0b1NldHRpbmdzLm5UYWJsZVJlaW5zZXJ0QmVmb3JlID0gb1NldHRpbmdzLm5UYWJsZS5uZXh0U2libGluZztcblx0XG5cdFx0LyogTG9vcCBvdmVyIHRoZSB1c2VyIHNldCBwb3NpdGlvbmluZyBhbmQgcGxhY2UgdGhlIGVsZW1lbnRzIGFzIG5lZWRlZCAqL1xuXHRcdHZhciBhRG9tID0gb1NldHRpbmdzLnNEb20uc3BsaXQoJycpO1xuXHRcdHZhciBmZWF0dXJlTm9kZSwgY09wdGlvbiwgbk5ld05vZGUsIGNOZXh0LCBzQXR0ciwgajtcblx0XHRmb3IgKCB2YXIgaT0wIDsgaTxhRG9tLmxlbmd0aCA7IGkrKyApXG5cdFx0e1xuXHRcdFx0ZmVhdHVyZU5vZGUgPSBudWxsO1xuXHRcdFx0Y09wdGlvbiA9IGFEb21baV07XG5cdFxuXHRcdFx0aWYgKCBjT3B0aW9uID09ICc8JyApXG5cdFx0XHR7XG5cdFx0XHRcdC8qIE5ldyBjb250YWluZXIgZGl2ICovXG5cdFx0XHRcdG5OZXdOb2RlID0gJCgnPGRpdi8+JylbMF07XG5cdFxuXHRcdFx0XHQvKiBDaGVjayB0byBzZWUgaWYgd2Ugc2hvdWxkIGFwcGVuZCBhbiBpZCBhbmQvb3IgYSBjbGFzcyBuYW1lIHRvIHRoZSBjb250YWluZXIgKi9cblx0XHRcdFx0Y05leHQgPSBhRG9tW2krMV07XG5cdFx0XHRcdGlmICggY05leHQgPT0gXCInXCIgfHwgY05leHQgPT0gJ1wiJyApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRzQXR0ciA9IFwiXCI7XG5cdFx0XHRcdFx0aiA9IDI7XG5cdFx0XHRcdFx0d2hpbGUgKCBhRG9tW2kral0gIT0gY05leHQgKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHNBdHRyICs9IGFEb21baStqXTtcblx0XHRcdFx0XHRcdGorKztcblx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRcdC8qIFJlcGxhY2UgalF1ZXJ5IFVJIGNvbnN0YW50cyBAdG9kbyBkZXByZWNpYXRlZCAqL1xuXHRcdFx0XHRcdGlmICggc0F0dHIgPT0gXCJIXCIgKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHNBdHRyID0gY2xhc3Nlcy5zSlVJSGVhZGVyO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIGlmICggc0F0dHIgPT0gXCJGXCIgKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHNBdHRyID0gY2xhc3Nlcy5zSlVJRm9vdGVyO1xuXHRcdFx0XHRcdH1cblx0XG5cdFx0XHRcdFx0LyogVGhlIGF0dHJpYnV0ZSBjYW4gYmUgaW4gdGhlIGZvcm1hdCBvZiBcIiNpZC5jbGFzc1wiLCBcIiNpZFwiIG9yIFwiY2xhc3NcIiBUaGlzIGxvZ2ljXG5cdFx0XHRcdFx0ICogYnJlYWtzIHRoZSBzdHJpbmcgaW50byBwYXJ0cyBhbmQgYXBwbGllcyB0aGVtIGFzIG5lZWRlZFxuXHRcdFx0XHRcdCAqL1xuXHRcdFx0XHRcdGlmICggc0F0dHIuaW5kZXhPZignLicpICE9IC0xIClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHR2YXIgYVNwbGl0ID0gc0F0dHIuc3BsaXQoJy4nKTtcblx0XHRcdFx0XHRcdG5OZXdOb2RlLmlkID0gYVNwbGl0WzBdLnN1YnN0cigxLCBhU3BsaXRbMF0ubGVuZ3RoLTEpO1xuXHRcdFx0XHRcdFx0bk5ld05vZGUuY2xhc3NOYW1lID0gYVNwbGl0WzFdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIGlmICggc0F0dHIuY2hhckF0KDApID09IFwiI1wiIClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRuTmV3Tm9kZS5pZCA9IHNBdHRyLnN1YnN0cigxLCBzQXR0ci5sZW5ndGgtMSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRuTmV3Tm9kZS5jbGFzc05hbWUgPSBzQXR0cjtcblx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRcdGkgKz0gajsgLyogTW92ZSBhbG9uZyB0aGUgcG9zaXRpb24gYXJyYXkgKi9cblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0aW5zZXJ0LmFwcGVuZCggbk5ld05vZGUgKTtcblx0XHRcdFx0aW5zZXJ0ID0gJChuTmV3Tm9kZSk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggY09wdGlvbiA9PSAnPicgKVxuXHRcdFx0e1xuXHRcdFx0XHQvKiBFbmQgY29udGFpbmVyIGRpdiAqL1xuXHRcdFx0XHRpbnNlcnQgPSBpbnNlcnQucGFyZW50KCk7XG5cdFx0XHR9XG5cdFx0XHQvLyBAdG9kbyBNb3ZlIG9wdGlvbnMgaW50byB0aGVpciBvd24gcGx1Z2lucz9cblx0XHRcdGVsc2UgaWYgKCBjT3B0aW9uID09ICdsJyAmJiBmZWF0dXJlcy5iUGFnaW5hdGUgJiYgZmVhdHVyZXMuYkxlbmd0aENoYW5nZSApXG5cdFx0XHR7XG5cdFx0XHRcdC8qIExlbmd0aCAqL1xuXHRcdFx0XHRmZWF0dXJlTm9kZSA9IF9mbkZlYXR1cmVIdG1sTGVuZ3RoKCBvU2V0dGluZ3MgKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCBjT3B0aW9uID09ICdmJyAmJiBmZWF0dXJlcy5iRmlsdGVyIClcblx0XHRcdHtcblx0XHRcdFx0LyogRmlsdGVyICovXG5cdFx0XHRcdGZlYXR1cmVOb2RlID0gX2ZuRmVhdHVyZUh0bWxGaWx0ZXIoIG9TZXR0aW5ncyApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIGNPcHRpb24gPT0gJ3InICYmIGZlYXR1cmVzLmJQcm9jZXNzaW5nIClcblx0XHRcdHtcblx0XHRcdFx0LyogcFJvY2Vzc2luZyAqL1xuXHRcdFx0XHRmZWF0dXJlTm9kZSA9IF9mbkZlYXR1cmVIdG1sUHJvY2Vzc2luZyggb1NldHRpbmdzICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggY09wdGlvbiA9PSAndCcgKVxuXHRcdFx0e1xuXHRcdFx0XHQvKiBUYWJsZSAqL1xuXHRcdFx0XHRmZWF0dXJlTm9kZSA9IF9mbkZlYXR1cmVIdG1sVGFibGUoIG9TZXR0aW5ncyApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIGNPcHRpb24gPT0gICdpJyAmJiBmZWF0dXJlcy5iSW5mbyApXG5cdFx0XHR7XG5cdFx0XHRcdC8qIEluZm8gKi9cblx0XHRcdFx0ZmVhdHVyZU5vZGUgPSBfZm5GZWF0dXJlSHRtbEluZm8oIG9TZXR0aW5ncyApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIGNPcHRpb24gPT0gJ3AnICYmIGZlYXR1cmVzLmJQYWdpbmF0ZSApXG5cdFx0XHR7XG5cdFx0XHRcdC8qIFBhZ2luYXRpb24gKi9cblx0XHRcdFx0ZmVhdHVyZU5vZGUgPSBfZm5GZWF0dXJlSHRtbFBhZ2luYXRlKCBvU2V0dGluZ3MgKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCBEYXRhVGFibGUuZXh0LmZlYXR1cmUubGVuZ3RoICE9PSAwIClcblx0XHRcdHtcblx0XHRcdFx0LyogUGx1Zy1pbiBmZWF0dXJlcyAqL1xuXHRcdFx0XHR2YXIgYW9GZWF0dXJlcyA9IERhdGFUYWJsZS5leHQuZmVhdHVyZTtcblx0XHRcdFx0Zm9yICggdmFyIGs9MCwga0xlbj1hb0ZlYXR1cmVzLmxlbmd0aCA7IGs8a0xlbiA7IGsrKyApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRpZiAoIGNPcHRpb24gPT0gYW9GZWF0dXJlc1trXS5jRmVhdHVyZSApXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0ZmVhdHVyZU5vZGUgPSBhb0ZlYXR1cmVzW2tdLmZuSW5pdCggb1NldHRpbmdzICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XG5cdFx0XHQvKiBBZGQgdG8gdGhlIDJEIGZlYXR1cmVzIGFycmF5ICovXG5cdFx0XHRpZiAoIGZlYXR1cmVOb2RlIClcblx0XHRcdHtcblx0XHRcdFx0dmFyIGFhbkZlYXR1cmVzID0gb1NldHRpbmdzLmFhbkZlYXR1cmVzO1xuXHRcblx0XHRcdFx0aWYgKCAhIGFhbkZlYXR1cmVzW2NPcHRpb25dIClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGFhbkZlYXR1cmVzW2NPcHRpb25dID0gW107XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdGFhbkZlYXR1cmVzW2NPcHRpb25dLnB1c2goIGZlYXR1cmVOb2RlICk7XG5cdFx0XHRcdGluc2VydC5hcHBlbmQoIGZlYXR1cmVOb2RlICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcblx0XHQvKiBCdWlsdCBvdXIgRE9NIHN0cnVjdHVyZSAtIHJlcGxhY2UgdGhlIGhvbGRpbmcgZGl2IHdpdGggd2hhdCB3ZSB3YW50ICovXG5cdFx0aG9sZGluZy5yZXBsYWNlV2l0aCggaW5zZXJ0ICk7XG5cdFx0b1NldHRpbmdzLm5Ib2xkaW5nID0gbnVsbDtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBVc2UgdGhlIERPTSBzb3VyY2UgdG8gY3JlYXRlIHVwIGFuIGFycmF5IG9mIGhlYWRlciBjZWxscy4gVGhlIGlkZWEgaGVyZSBpcyB0b1xuXHQgKiBjcmVhdGUgYSBsYXlvdXQgZ3JpZCAoYXJyYXkpIG9mIHJvd3MgeCBjb2x1bW5zLCB3aGljaCBjb250YWlucyBhIHJlZmVyZW5jZVxuXHQgKiB0byB0aGUgY2VsbCB0aGF0IHRoYXQgcG9pbnQgaW4gdGhlIGdyaWQgKHJlZ2FyZGxlc3Mgb2YgY29sL3Jvd3NwYW4pLCBzdWNoIHRoYXRcblx0ICogYW55IGNvbHVtbiAvIHJvdyBjb3VsZCBiZSByZW1vdmVkIGFuZCB0aGUgbmV3IGdyaWQgY29uc3RydWN0ZWRcblx0ICogIEBwYXJhbSBhcnJheSB7b2JqZWN0fSBhTGF5b3V0IEFycmF5IHRvIHN0b3JlIHRoZSBjYWxjdWxhdGVkIGxheW91dCBpblxuXHQgKiAgQHBhcmFtIHtub2RlfSBuVGhlYWQgVGhlIGhlYWRlci9mb290ZXIgZWxlbWVudCBmb3IgdGhlIHRhYmxlXG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkRldGVjdEhlYWRlciAoIGFMYXlvdXQsIG5UaGVhZCApXG5cdHtcblx0XHR2YXIgblRycyA9ICQoblRoZWFkKS5jaGlsZHJlbigndHInKTtcblx0XHR2YXIgblRyLCBuQ2VsbDtcblx0XHR2YXIgaSwgaywgbCwgaUxlbiwgakxlbiwgaUNvbFNoaWZ0ZWQsIGlDb2x1bW4sIGlDb2xzcGFuLCBpUm93c3Bhbjtcblx0XHR2YXIgYlVuaXF1ZTtcblx0XHR2YXIgZm5TaGlmdENvbCA9IGZ1bmN0aW9uICggYSwgaSwgaiApIHtcblx0XHRcdHZhciBrID0gYVtpXTtcblx0ICAgICAgICAgICAgICAgIHdoaWxlICgga1tqXSApIHtcblx0XHRcdFx0aisrO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGo7XG5cdFx0fTtcblx0XG5cdFx0YUxheW91dC5zcGxpY2UoIDAsIGFMYXlvdXQubGVuZ3RoICk7XG5cdFxuXHRcdC8qIFdlIGtub3cgaG93IG1hbnkgcm93cyB0aGVyZSBhcmUgaW4gdGhlIGxheW91dCAtIHNvIHByZXAgaXQgKi9cblx0XHRmb3IgKCBpPTAsIGlMZW49blRycy5sZW5ndGggOyBpPGlMZW4gOyBpKysgKVxuXHRcdHtcblx0XHRcdGFMYXlvdXQucHVzaCggW10gKTtcblx0XHR9XG5cdFxuXHRcdC8qIENhbGN1bGF0ZSBhIGxheW91dCBhcnJheSAqL1xuXHRcdGZvciAoIGk9MCwgaUxlbj1uVHJzLmxlbmd0aCA7IGk8aUxlbiA7IGkrKyApXG5cdFx0e1xuXHRcdFx0blRyID0gblRyc1tpXTtcblx0XHRcdGlDb2x1bW4gPSAwO1xuXHRcblx0XHRcdC8qIEZvciBldmVyeSBjZWxsIGluIHRoZSByb3cuLi4gKi9cblx0XHRcdG5DZWxsID0gblRyLmZpcnN0Q2hpbGQ7XG5cdFx0XHR3aGlsZSAoIG5DZWxsICkge1xuXHRcdFx0XHRpZiAoIG5DZWxsLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgPT0gXCJURFwiIHx8XG5cdFx0XHRcdCAgICAgbkNlbGwubm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PSBcIlRIXCIgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0LyogR2V0IHRoZSBjb2wgYW5kIHJvd3NwYW4gYXR0cmlidXRlcyBmcm9tIHRoZSBET00gYW5kIHNhbml0aXNlIHRoZW0gKi9cblx0XHRcdFx0XHRpQ29sc3BhbiA9IG5DZWxsLmdldEF0dHJpYnV0ZSgnY29sc3BhbicpICogMTtcblx0XHRcdFx0XHRpUm93c3BhbiA9IG5DZWxsLmdldEF0dHJpYnV0ZSgncm93c3BhbicpICogMTtcblx0XHRcdFx0XHRpQ29sc3BhbiA9ICghaUNvbHNwYW4gfHwgaUNvbHNwYW49PT0wIHx8IGlDb2xzcGFuPT09MSkgPyAxIDogaUNvbHNwYW47XG5cdFx0XHRcdFx0aVJvd3NwYW4gPSAoIWlSb3dzcGFuIHx8IGlSb3dzcGFuPT09MCB8fCBpUm93c3Bhbj09PTEpID8gMSA6IGlSb3dzcGFuO1xuXHRcblx0XHRcdFx0XHQvKiBUaGVyZSBtaWdodCBiZSBjb2xzcGFuIGNlbGxzIGFscmVhZHkgaW4gdGhpcyByb3csIHNvIHNoaWZ0IG91ciB0YXJnZXRcblx0XHRcdFx0XHQgKiBhY2NvcmRpbmdseVxuXHRcdFx0XHRcdCAqL1xuXHRcdFx0XHRcdGlDb2xTaGlmdGVkID0gZm5TaGlmdENvbCggYUxheW91dCwgaSwgaUNvbHVtbiApO1xuXHRcblx0XHRcdFx0XHQvKiBDYWNoZSBjYWxjdWxhdGlvbiBmb3IgdW5pcXVlIGNvbHVtbnMgKi9cblx0XHRcdFx0XHRiVW5pcXVlID0gaUNvbHNwYW4gPT09IDEgPyB0cnVlIDogZmFsc2U7XG5cdFxuXHRcdFx0XHRcdC8qIElmIHRoZXJlIGlzIGNvbCAvIHJvd3NwYW4sIGNvcHkgdGhlIGluZm9ybWF0aW9uIGludG8gdGhlIGxheW91dCBncmlkICovXG5cdFx0XHRcdFx0Zm9yICggbD0wIDsgbDxpQ29sc3BhbiA7IGwrKyApXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0Zm9yICggaz0wIDsgazxpUm93c3BhbiA7IGsrKyApXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdGFMYXlvdXRbaStrXVtpQ29sU2hpZnRlZCtsXSA9IHtcblx0XHRcdFx0XHRcdFx0XHRcImNlbGxcIjogbkNlbGwsXG5cdFx0XHRcdFx0XHRcdFx0XCJ1bmlxdWVcIjogYlVuaXF1ZVxuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0XHRhTGF5b3V0W2kra10ublRyID0gblRyO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRuQ2VsbCA9IG5DZWxsLm5leHRTaWJsaW5nO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBHZXQgYW4gYXJyYXkgb2YgdW5pcXVlIHRoIGVsZW1lbnRzLCBvbmUgZm9yIGVhY2ggY29sdW1uXG5cdCAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcGFyYW0ge25vZGV9IG5IZWFkZXIgYXV0b21hdGljYWxseSBkZXRlY3QgdGhlIGxheW91dCBmcm9tIHRoaXMgbm9kZSAtIG9wdGlvbmFsXG5cdCAqICBAcGFyYW0ge2FycmF5fSBhTGF5b3V0IHRoZWFkL3Rmb290IGxheW91dCBmcm9tIF9mbkRldGVjdEhlYWRlciAtIG9wdGlvbmFsXG5cdCAqICBAcmV0dXJucyBhcnJheSB7bm9kZX0gYVJldHVybiBsaXN0IG9mIHVuaXF1ZSB0aCdzXG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkdldFVuaXF1ZVRocyAoIG9TZXR0aW5ncywgbkhlYWRlciwgYUxheW91dCApXG5cdHtcblx0XHR2YXIgYVJldHVybiA9IFtdO1xuXHRcdGlmICggIWFMYXlvdXQgKVxuXHRcdHtcblx0XHRcdGFMYXlvdXQgPSBvU2V0dGluZ3MuYW9IZWFkZXI7XG5cdFx0XHRpZiAoIG5IZWFkZXIgKVxuXHRcdFx0e1xuXHRcdFx0XHRhTGF5b3V0ID0gW107XG5cdFx0XHRcdF9mbkRldGVjdEhlYWRlciggYUxheW91dCwgbkhlYWRlciApO1xuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0Zm9yICggdmFyIGk9MCwgaUxlbj1hTGF5b3V0Lmxlbmd0aCA7IGk8aUxlbiA7IGkrKyApXG5cdFx0e1xuXHRcdFx0Zm9yICggdmFyIGo9MCwgakxlbj1hTGF5b3V0W2ldLmxlbmd0aCA7IGo8akxlbiA7IGorKyApXG5cdFx0XHR7XG5cdFx0XHRcdGlmICggYUxheW91dFtpXVtqXS51bmlxdWUgJiZcblx0XHRcdFx0XHQgKCFhUmV0dXJuW2pdIHx8ICFvU2V0dGluZ3MuYlNvcnRDZWxsc1RvcCkgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0YVJldHVybltqXSA9IGFMYXlvdXRbaV1bal0uY2VsbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0cmV0dXJuIGFSZXR1cm47XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBDcmVhdGUgYW4gQWpheCBjYWxsIGJhc2VkIG9uIHRoZSB0YWJsZSdzIHNldHRpbmdzLCB0YWtpbmcgaW50byBhY2NvdW50IHRoYXRcblx0ICogcGFyYW1ldGVycyBjYW4gaGF2ZSBtdWx0aXBsZSBmb3JtcywgYW5kIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuXHQgKlxuXHQgKiBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqIEBwYXJhbSB7YXJyYXl9IGRhdGEgRGF0YSB0byBzZW5kIHRvIHRoZSBzZXJ2ZXIsIHJlcXVpcmVkIGJ5XG5cdCAqICAgICBEYXRhVGFibGVzIC0gbWF5IGJlIGF1Z21lbnRlZCBieSBkZXZlbG9wZXIgY2FsbGJhY2tzXG5cdCAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIENhbGxiYWNrIGZ1bmN0aW9uIHRvIHJ1biB3aGVuIGRhdGEgaXMgb2J0YWluZWRcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkJ1aWxkQWpheCggb1NldHRpbmdzLCBkYXRhLCBmbiApXG5cdHtcblx0XHQvLyBDb21wYXRpYmlsaXR5IHdpdGggMS45LSwgYWxsb3cgZm5TZXJ2ZXJEYXRhIGFuZCBldmVudCB0byBtYW5pcHVsYXRlXG5cdFx0X2ZuQ2FsbGJhY2tGaXJlKCBvU2V0dGluZ3MsICdhb1NlcnZlclBhcmFtcycsICdzZXJ2ZXJQYXJhbXMnLCBbZGF0YV0gKTtcblx0XG5cdFx0Ly8gQ29udmVydCB0byBvYmplY3QgYmFzZWQgZm9yIDEuMTArIGlmIHVzaW5nIHRoZSBvbGQgYXJyYXkgc2NoZW1lIHdoaWNoIGNhblxuXHRcdC8vIGNvbWUgZnJvbSBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nIG9yIHNlcnZlclBhcmFtc1xuXHRcdGlmICggZGF0YSAmJiAkLmlzQXJyYXkoZGF0YSkgKSB7XG5cdFx0XHR2YXIgdG1wID0ge307XG5cdFx0XHR2YXIgcmJyYWNrZXQgPSAvKC4qPylcXFtcXF0kLztcblx0XG5cdFx0XHQkLmVhY2goIGRhdGEsIGZ1bmN0aW9uIChrZXksIHZhbCkge1xuXHRcdFx0XHR2YXIgbWF0Y2ggPSB2YWwubmFtZS5tYXRjaChyYnJhY2tldCk7XG5cdFxuXHRcdFx0XHRpZiAoIG1hdGNoICkge1xuXHRcdFx0XHRcdC8vIFN1cHBvcnQgZm9yIGFycmF5c1xuXHRcdFx0XHRcdHZhciBuYW1lID0gbWF0Y2hbMF07XG5cdFxuXHRcdFx0XHRcdGlmICggISB0bXBbIG5hbWUgXSApIHtcblx0XHRcdFx0XHRcdHRtcFsgbmFtZSBdID0gW107XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRtcFsgbmFtZSBdLnB1c2goIHZhbC52YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHRtcFt2YWwubmFtZV0gPSB2YWwudmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHRcdGRhdGEgPSB0bXA7XG5cdFx0fVxuXHRcblx0XHR2YXIgYWpheERhdGE7XG5cdFx0dmFyIGFqYXggPSBvU2V0dGluZ3MuYWpheDtcblx0XHR2YXIgaW5zdGFuY2UgPSBvU2V0dGluZ3Mub0luc3RhbmNlO1xuXHRcdHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uICgganNvbiApIHtcblx0XHRcdF9mbkNhbGxiYWNrRmlyZSggb1NldHRpbmdzLCBudWxsLCAneGhyJywgW29TZXR0aW5ncywganNvbiwgb1NldHRpbmdzLmpxWEhSXSApO1xuXHRcdFx0Zm4oIGpzb24gKTtcblx0XHR9O1xuXHRcblx0XHRpZiAoICQuaXNQbGFpbk9iamVjdCggYWpheCApICYmIGFqYXguZGF0YSApXG5cdFx0e1xuXHRcdFx0YWpheERhdGEgPSBhamF4LmRhdGE7XG5cdFxuXHRcdFx0dmFyIG5ld0RhdGEgPSB0eXBlb2YgYWpheERhdGEgPT09ICdmdW5jdGlvbicgP1xuXHRcdFx0XHRhamF4RGF0YSggZGF0YSwgb1NldHRpbmdzICkgOiAgLy8gZm4gY2FuIG1hbmlwdWxhdGUgZGF0YSBvciByZXR1cm5cblx0XHRcdFx0YWpheERhdGE7ICAgICAgICAgICAgICAgICAgICAgIC8vIGFuIG9iamVjdCBvYmplY3Qgb3IgYXJyYXkgdG8gbWVyZ2Vcblx0XG5cdFx0XHQvLyBJZiB0aGUgZnVuY3Rpb24gcmV0dXJuZWQgc29tZXRoaW5nLCB1c2UgdGhhdCBhbG9uZVxuXHRcdFx0ZGF0YSA9IHR5cGVvZiBhamF4RGF0YSA9PT0gJ2Z1bmN0aW9uJyAmJiBuZXdEYXRhID9cblx0XHRcdFx0bmV3RGF0YSA6XG5cdFx0XHRcdCQuZXh0ZW5kKCB0cnVlLCBkYXRhLCBuZXdEYXRhICk7XG5cdFxuXHRcdFx0Ly8gUmVtb3ZlIHRoZSBkYXRhIHByb3BlcnR5IGFzIHdlJ3ZlIHJlc29sdmVkIGl0IGFscmVhZHkgYW5kIGRvbid0IHdhbnRcblx0XHRcdC8vIGpRdWVyeSB0byBkbyBpdCBhZ2FpbiAoaXQgaXMgcmVzdG9yZWQgYXQgdGhlIGVuZCBvZiB0aGUgZnVuY3Rpb24pXG5cdFx0XHRkZWxldGUgYWpheC5kYXRhO1xuXHRcdH1cblx0XG5cdFx0dmFyIGJhc2VBamF4ID0ge1xuXHRcdFx0XCJkYXRhXCI6IGRhdGEsXG5cdFx0XHRcInN1Y2Nlc3NcIjogZnVuY3Rpb24gKGpzb24pIHtcblx0XHRcdFx0dmFyIGVycm9yID0ganNvbi5lcnJvciB8fCBqc29uLnNFcnJvcjtcblx0XHRcdFx0aWYgKCBlcnJvciApIHtcblx0XHRcdFx0XHRfZm5Mb2coIG9TZXR0aW5ncywgMCwgZXJyb3IgKTtcblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0b1NldHRpbmdzLmpzb24gPSBqc29uO1xuXHRcdFx0XHRjYWxsYmFjaygganNvbiApO1xuXHRcdFx0fSxcblx0XHRcdFwiZGF0YVR5cGVcIjogXCJqc29uXCIsXG5cdFx0XHRcImNhY2hlXCI6IGZhbHNlLFxuXHRcdFx0XCJ0eXBlXCI6IG9TZXR0aW5ncy5zU2VydmVyTWV0aG9kLFxuXHRcdFx0XCJlcnJvclwiOiBmdW5jdGlvbiAoeGhyLCBlcnJvciwgdGhyb3duKSB7XG5cdFx0XHRcdHZhciByZXQgPSBfZm5DYWxsYmFja0ZpcmUoIG9TZXR0aW5ncywgbnVsbCwgJ3hocicsIFtvU2V0dGluZ3MsIG51bGwsIG9TZXR0aW5ncy5qcVhIUl0gKTtcblx0XG5cdFx0XHRcdGlmICggJC5pbkFycmF5KCB0cnVlLCByZXQgKSA9PT0gLTEgKSB7XG5cdFx0XHRcdFx0aWYgKCBlcnJvciA9PSBcInBhcnNlcmVycm9yXCIgKSB7XG5cdFx0XHRcdFx0XHRfZm5Mb2coIG9TZXR0aW5ncywgMCwgJ0ludmFsaWQgSlNPTiByZXNwb25zZScsIDEgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSBpZiAoIHhoci5yZWFkeVN0YXRlID09PSA0ICkge1xuXHRcdFx0XHRcdFx0X2ZuTG9nKCBvU2V0dGluZ3MsIDAsICdBamF4IGVycm9yJywgNyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0X2ZuUHJvY2Vzc2luZ0Rpc3BsYXkoIG9TZXR0aW5ncywgZmFsc2UgKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcblx0XHQvLyBTdG9yZSB0aGUgZGF0YSBzdWJtaXR0ZWQgZm9yIHRoZSBBUElcblx0XHRvU2V0dGluZ3Mub0FqYXhEYXRhID0gZGF0YTtcblx0XG5cdFx0Ly8gQWxsb3cgcGx1Zy1pbnMgYW5kIGV4dGVybmFsIHByb2Nlc3NlcyB0byBtb2RpZnkgdGhlIGRhdGFcblx0XHRfZm5DYWxsYmFja0ZpcmUoIG9TZXR0aW5ncywgbnVsbCwgJ3ByZVhocicsIFtvU2V0dGluZ3MsIGRhdGFdICk7XG5cdFxuXHRcdGlmICggb1NldHRpbmdzLmZuU2VydmVyRGF0YSApXG5cdFx0e1xuXHRcdFx0Ly8gRGF0YVRhYmxlcyAxLjktIGNvbXBhdGliaWxpdHlcblx0XHRcdG9TZXR0aW5ncy5mblNlcnZlckRhdGEuY2FsbCggaW5zdGFuY2UsXG5cdFx0XHRcdG9TZXR0aW5ncy5zQWpheFNvdXJjZSxcblx0XHRcdFx0JC5tYXAoIGRhdGEsIGZ1bmN0aW9uICh2YWwsIGtleSkgeyAvLyBOZWVkIHRvIGNvbnZlcnQgYmFjayB0byAxLjkgdHJhZCBmb3JtYXRcblx0XHRcdFx0XHRyZXR1cm4geyBuYW1lOiBrZXksIHZhbHVlOiB2YWwgfTtcblx0XHRcdFx0fSApLFxuXHRcdFx0XHRjYWxsYmFjayxcblx0XHRcdFx0b1NldHRpbmdzXG5cdFx0XHQpO1xuXHRcdH1cblx0XHRlbHNlIGlmICggb1NldHRpbmdzLnNBamF4U291cmNlIHx8IHR5cGVvZiBhamF4ID09PSAnc3RyaW5nJyApXG5cdFx0e1xuXHRcdFx0Ly8gRGF0YVRhYmxlcyAxLjktIGNvbXBhdGliaWxpdHlcblx0XHRcdG9TZXR0aW5ncy5qcVhIUiA9ICQuYWpheCggJC5leHRlbmQoIGJhc2VBamF4LCB7XG5cdFx0XHRcdHVybDogYWpheCB8fCBvU2V0dGluZ3Muc0FqYXhTb3VyY2Vcblx0XHRcdH0gKSApO1xuXHRcdH1cblx0XHRlbHNlIGlmICggdHlwZW9mIGFqYXggPT09ICdmdW5jdGlvbicgKVxuXHRcdHtcblx0XHRcdC8vIElzIGEgZnVuY3Rpb24gLSBsZXQgdGhlIGNhbGxlciBkZWZpbmUgd2hhdCBuZWVkcyB0byBiZSBkb25lXG5cdFx0XHRvU2V0dGluZ3MuanFYSFIgPSBhamF4LmNhbGwoIGluc3RhbmNlLCBkYXRhLCBjYWxsYmFjaywgb1NldHRpbmdzICk7XG5cdFx0fVxuXHRcdGVsc2Vcblx0XHR7XG5cdFx0XHQvLyBPYmplY3QgdG8gZXh0ZW5kIHRoZSBiYXNlIHNldHRpbmdzXG5cdFx0XHRvU2V0dGluZ3MuanFYSFIgPSAkLmFqYXgoICQuZXh0ZW5kKCBiYXNlQWpheCwgYWpheCApICk7XG5cdFxuXHRcdFx0Ly8gUmVzdG9yZSBmb3IgbmV4dCB0aW1lIGFyb3VuZFxuXHRcdFx0YWpheC5kYXRhID0gYWpheERhdGE7XG5cdFx0fVxuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIFVwZGF0ZSB0aGUgdGFibGUgdXNpbmcgYW4gQWpheCBjYWxsXG5cdCAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEByZXR1cm5zIHtib29sZWFufSBCbG9jayB0aGUgdGFibGUgZHJhd2luZyBvciBub3Rcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuQWpheFVwZGF0ZSggc2V0dGluZ3MgKVxuXHR7XG5cdFx0aWYgKCBzZXR0aW5ncy5iQWpheERhdGFHZXQgKSB7XG5cdFx0XHRzZXR0aW5ncy5pRHJhdysrO1xuXHRcdFx0X2ZuUHJvY2Vzc2luZ0Rpc3BsYXkoIHNldHRpbmdzLCB0cnVlICk7XG5cdFxuXHRcdFx0X2ZuQnVpbGRBamF4KFxuXHRcdFx0XHRzZXR0aW5ncyxcblx0XHRcdFx0X2ZuQWpheFBhcmFtZXRlcnMoIHNldHRpbmdzICksXG5cdFx0XHRcdGZ1bmN0aW9uKGpzb24pIHtcblx0XHRcdFx0XHRfZm5BamF4VXBkYXRlRHJhdyggc2V0dGluZ3MsIGpzb24gKTtcblx0XHRcdFx0fVxuXHRcdFx0KTtcblx0XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIEJ1aWxkIHVwIHRoZSBwYXJhbWV0ZXJzIGluIGFuIG9iamVjdCBuZWVkZWQgZm9yIGEgc2VydmVyLXNpZGUgcHJvY2Vzc2luZ1xuXHQgKiByZXF1ZXN0LiBOb3RlIHRoYXQgdGhpcyBpcyBiYXNpY2FsbHkgZG9uZSB0d2ljZSwgaXMgZGlmZmVyZW50IHdheXMgLSBhIG1vZGVyblxuXHQgKiBtZXRob2Qgd2hpY2ggaXMgdXNlZCBieSBkZWZhdWx0IGluIERhdGFUYWJsZXMgMS4xMCB3aGljaCB1c2VzIG9iamVjdHMgYW5kXG5cdCAqIGFycmF5cywgb3IgdGhlIDEuOS0gbWV0aG9kIHdpdGggaXMgbmFtZSAvIHZhbHVlIHBhaXJzLiAxLjkgbWV0aG9kIGlzIHVzZWQgaWZcblx0ICogdGhlIHNBamF4U291cmNlIG9wdGlvbiBpcyB1c2VkIGluIHRoZSBpbml0aWFsaXNhdGlvbiwgb3IgdGhlIGxlZ2FjeUFqYXhcblx0ICogb3B0aW9uIGlzIHNldC5cblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEByZXR1cm5zIHtib29sfSBibG9jayB0aGUgdGFibGUgZHJhd2luZyBvciBub3Rcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuQWpheFBhcmFtZXRlcnMoIHNldHRpbmdzIClcblx0e1xuXHRcdHZhclxuXHRcdFx0Y29sdW1ucyA9IHNldHRpbmdzLmFvQ29sdW1ucyxcblx0XHRcdGNvbHVtbkNvdW50ID0gY29sdW1ucy5sZW5ndGgsXG5cdFx0XHRmZWF0dXJlcyA9IHNldHRpbmdzLm9GZWF0dXJlcyxcblx0XHRcdHByZVNlYXJjaCA9IHNldHRpbmdzLm9QcmV2aW91c1NlYXJjaCxcblx0XHRcdHByZUNvbFNlYXJjaCA9IHNldHRpbmdzLmFvUHJlU2VhcmNoQ29scyxcblx0XHRcdGksIGRhdGEgPSBbXSwgZGF0YVByb3AsIGNvbHVtbiwgY29sdW1uU2VhcmNoLFxuXHRcdFx0c29ydCA9IF9mblNvcnRGbGF0dGVuKCBzZXR0aW5ncyApLFxuXHRcdFx0ZGlzcGxheVN0YXJ0ID0gc2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQsXG5cdFx0XHRkaXNwbGF5TGVuZ3RoID0gZmVhdHVyZXMuYlBhZ2luYXRlICE9PSBmYWxzZSA/XG5cdFx0XHRcdHNldHRpbmdzLl9pRGlzcGxheUxlbmd0aCA6XG5cdFx0XHRcdC0xO1xuXHRcblx0XHR2YXIgcGFyYW0gPSBmdW5jdGlvbiAoIG5hbWUsIHZhbHVlICkge1xuXHRcdFx0ZGF0YS5wdXNoKCB7ICduYW1lJzogbmFtZSwgJ3ZhbHVlJzogdmFsdWUgfSApO1xuXHRcdH07XG5cdFxuXHRcdC8vIERhdGFUYWJsZXMgMS45LSBjb21wYXRpYmxlIG1ldGhvZFxuXHRcdHBhcmFtKCAnc0VjaG8nLCAgICAgICAgICBzZXR0aW5ncy5pRHJhdyApO1xuXHRcdHBhcmFtKCAnaUNvbHVtbnMnLCAgICAgICBjb2x1bW5Db3VudCApO1xuXHRcdHBhcmFtKCAnc0NvbHVtbnMnLCAgICAgICBfcGx1Y2soIGNvbHVtbnMsICdzTmFtZScgKS5qb2luKCcsJykgKTtcblx0XHRwYXJhbSggJ2lEaXNwbGF5U3RhcnQnLCAgZGlzcGxheVN0YXJ0ICk7XG5cdFx0cGFyYW0oICdpRGlzcGxheUxlbmd0aCcsIGRpc3BsYXlMZW5ndGggKTtcblx0XG5cdFx0Ly8gRGF0YVRhYmxlcyAxLjEwKyBtZXRob2Rcblx0XHR2YXIgZCA9IHtcblx0XHRcdGRyYXc6ICAgIHNldHRpbmdzLmlEcmF3LFxuXHRcdFx0Y29sdW1uczogW10sXG5cdFx0XHRvcmRlcjogICBbXSxcblx0XHRcdHN0YXJ0OiAgIGRpc3BsYXlTdGFydCxcblx0XHRcdGxlbmd0aDogIGRpc3BsYXlMZW5ndGgsXG5cdFx0XHRzZWFyY2g6ICB7XG5cdFx0XHRcdHZhbHVlOiBwcmVTZWFyY2guc1NlYXJjaCxcblx0XHRcdFx0cmVnZXg6IHByZVNlYXJjaC5iUmVnZXhcblx0XHRcdH1cblx0XHR9O1xuXHRcblx0XHRmb3IgKCBpPTAgOyBpPGNvbHVtbkNvdW50IDsgaSsrICkge1xuXHRcdFx0Y29sdW1uID0gY29sdW1uc1tpXTtcblx0XHRcdGNvbHVtblNlYXJjaCA9IHByZUNvbFNlYXJjaFtpXTtcblx0XHRcdGRhdGFQcm9wID0gdHlwZW9mIGNvbHVtbi5tRGF0YT09XCJmdW5jdGlvblwiID8gJ2Z1bmN0aW9uJyA6IGNvbHVtbi5tRGF0YSA7XG5cdFxuXHRcdFx0ZC5jb2x1bW5zLnB1c2goIHtcblx0XHRcdFx0ZGF0YTogICAgICAgZGF0YVByb3AsXG5cdFx0XHRcdG5hbWU6ICAgICAgIGNvbHVtbi5zTmFtZSxcblx0XHRcdFx0c2VhcmNoYWJsZTogY29sdW1uLmJTZWFyY2hhYmxlLFxuXHRcdFx0XHRvcmRlcmFibGU6ICBjb2x1bW4uYlNvcnRhYmxlLFxuXHRcdFx0XHRzZWFyY2g6ICAgICB7XG5cdFx0XHRcdFx0dmFsdWU6IGNvbHVtblNlYXJjaC5zU2VhcmNoLFxuXHRcdFx0XHRcdHJlZ2V4OiBjb2x1bW5TZWFyY2guYlJlZ2V4XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XG5cdFx0XHRwYXJhbSggXCJtRGF0YVByb3BfXCIraSwgZGF0YVByb3AgKTtcblx0XG5cdFx0XHRpZiAoIGZlYXR1cmVzLmJGaWx0ZXIgKSB7XG5cdFx0XHRcdHBhcmFtKCAnc1NlYXJjaF8nK2ksICAgICBjb2x1bW5TZWFyY2guc1NlYXJjaCApO1xuXHRcdFx0XHRwYXJhbSggJ2JSZWdleF8nK2ksICAgICAgY29sdW1uU2VhcmNoLmJSZWdleCApO1xuXHRcdFx0XHRwYXJhbSggJ2JTZWFyY2hhYmxlXycraSwgY29sdW1uLmJTZWFyY2hhYmxlICk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0aWYgKCBmZWF0dXJlcy5iU29ydCApIHtcblx0XHRcdFx0cGFyYW0oICdiU29ydGFibGVfJytpLCBjb2x1bW4uYlNvcnRhYmxlICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcblx0XHRpZiAoIGZlYXR1cmVzLmJGaWx0ZXIgKSB7XG5cdFx0XHRwYXJhbSggJ3NTZWFyY2gnLCBwcmVTZWFyY2guc1NlYXJjaCApO1xuXHRcdFx0cGFyYW0oICdiUmVnZXgnLCBwcmVTZWFyY2guYlJlZ2V4ICk7XG5cdFx0fVxuXHRcblx0XHRpZiAoIGZlYXR1cmVzLmJTb3J0ICkge1xuXHRcdFx0JC5lYWNoKCBzb3J0LCBmdW5jdGlvbiAoIGksIHZhbCApIHtcblx0XHRcdFx0ZC5vcmRlci5wdXNoKCB7IGNvbHVtbjogdmFsLmNvbCwgZGlyOiB2YWwuZGlyIH0gKTtcblx0XG5cdFx0XHRcdHBhcmFtKCAnaVNvcnRDb2xfJytpLCB2YWwuY29sICk7XG5cdFx0XHRcdHBhcmFtKCAnc1NvcnREaXJfJytpLCB2YWwuZGlyICk7XG5cdFx0XHR9ICk7XG5cdFxuXHRcdFx0cGFyYW0oICdpU29ydGluZ0NvbHMnLCBzb3J0Lmxlbmd0aCApO1xuXHRcdH1cblx0XG5cdFx0Ly8gSWYgdGhlIGxlZ2FjeS5hamF4IHBhcmFtZXRlciBpcyBudWxsLCB0aGVuIHdlIGF1dG9tYXRpY2FsbHkgZGVjaWRlIHdoaWNoXG5cdFx0Ly8gZm9ybSB0byB1c2UsIGJhc2VkIG9uIHNBamF4U291cmNlXG5cdFx0dmFyIGxlZ2FjeSA9IERhdGFUYWJsZS5leHQubGVnYWN5LmFqYXg7XG5cdFx0aWYgKCBsZWdhY3kgPT09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gc2V0dGluZ3Muc0FqYXhTb3VyY2UgPyBkYXRhIDogZDtcblx0XHR9XG5cdFxuXHRcdC8vIE90aGVyd2lzZSwgaWYgbGVnYWN5IGhhcyBiZWVuIHNwZWNpZmllZCB0aGVuIHdlIHVzZSB0aGF0IHRvIGRlY2lkZSBvbiB0aGVcblx0XHQvLyBmb3JtXG5cdFx0cmV0dXJuIGxlZ2FjeSA/IGRhdGEgOiBkO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIERhdGEgdGhlIGRhdGEgZnJvbSB0aGUgc2VydmVyIChudWtpbmcgdGhlIG9sZCkgYW5kIHJlZHJhdyB0aGUgdGFibGVcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBqc29uIGpzb24gZGF0YSByZXR1cm4gZnJvbSB0aGUgc2VydmVyLlxuXHQgKiAgQHBhcmFtIHtzdHJpbmd9IGpzb24uc0VjaG8gVHJhY2tpbmcgZmxhZyBmb3IgRGF0YVRhYmxlcyB0byBtYXRjaCByZXF1ZXN0c1xuXHQgKiAgQHBhcmFtIHtpbnR9IGpzb24uaVRvdGFsUmVjb3JkcyBOdW1iZXIgb2YgcmVjb3JkcyBpbiB0aGUgZGF0YSBzZXQsIG5vdCBhY2NvdW50aW5nIGZvciBmaWx0ZXJpbmdcblx0ICogIEBwYXJhbSB7aW50fSBqc29uLmlUb3RhbERpc3BsYXlSZWNvcmRzIE51bWJlciBvZiByZWNvcmRzIGluIHRoZSBkYXRhIHNldCwgYWNjb3VudGluZyBmb3IgZmlsdGVyaW5nXG5cdCAqICBAcGFyYW0ge2FycmF5fSBqc29uLmFhRGF0YSBUaGUgZGF0YSB0byBkaXNwbGF5IG9uIHRoaXMgcGFnZVxuXHQgKiAgQHBhcmFtIHtzdHJpbmd9IFtqc29uLnNDb2x1bW5zXSBDb2x1bW4gb3JkZXJpbmcgKHNOYW1lLCBjb21tYSBzZXBhcmF0ZWQpXG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkFqYXhVcGRhdGVEcmF3ICggc2V0dGluZ3MsIGpzb24gKVxuXHR7XG5cdFx0Ly8gdjEuMTAgdXNlcyBjYW1lbENhc2UgdmFyaWFibGVzLCB3aGlsZSAxLjkgdXNlcyBIdW5nYXJpYW4gbm90YXRpb24uXG5cdFx0Ly8gU3VwcG9ydCBib3RoXG5cdFx0dmFyIGNvbXBhdCA9IGZ1bmN0aW9uICggb2xkLCBtb2Rlcm4gKSB7XG5cdFx0XHRyZXR1cm4ganNvbltvbGRdICE9PSB1bmRlZmluZWQgPyBqc29uW29sZF0gOiBqc29uW21vZGVybl07XG5cdFx0fTtcblx0XG5cdFx0dmFyIGRhdGEgPSBfZm5BamF4RGF0YVNyYyggc2V0dGluZ3MsIGpzb24gKTtcblx0XHR2YXIgZHJhdyAgICAgICAgICAgID0gY29tcGF0KCAnc0VjaG8nLCAgICAgICAgICAgICAgICAnZHJhdycgKTtcblx0XHR2YXIgcmVjb3Jkc1RvdGFsICAgID0gY29tcGF0KCAnaVRvdGFsUmVjb3JkcycsICAgICAgICAncmVjb3Jkc1RvdGFsJyApO1xuXHRcdHZhciByZWNvcmRzRmlsdGVyZWQgPSBjb21wYXQoICdpVG90YWxEaXNwbGF5UmVjb3JkcycsICdyZWNvcmRzRmlsdGVyZWQnICk7XG5cdFxuXHRcdGlmICggZHJhdyAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0Ly8gUHJvdGVjdCBhZ2FpbnN0IG91dCBvZiBzZXF1ZW5jZSByZXR1cm5zXG5cdFx0XHRpZiAoIGRyYXcqMSA8IHNldHRpbmdzLmlEcmF3ICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRzZXR0aW5ncy5pRHJhdyA9IGRyYXcgKiAxO1xuXHRcdH1cblx0XG5cdFx0X2ZuQ2xlYXJUYWJsZSggc2V0dGluZ3MgKTtcblx0XHRzZXR0aW5ncy5faVJlY29yZHNUb3RhbCAgID0gcGFyc2VJbnQocmVjb3Jkc1RvdGFsLCAxMCk7XG5cdFx0c2V0dGluZ3MuX2lSZWNvcmRzRGlzcGxheSA9IHBhcnNlSW50KHJlY29yZHNGaWx0ZXJlZCwgMTApO1xuXHRcblx0XHRmb3IgKCB2YXIgaT0wLCBpZW49ZGF0YS5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdF9mbkFkZERhdGEoIHNldHRpbmdzLCBkYXRhW2ldICk7XG5cdFx0fVxuXHRcdHNldHRpbmdzLmFpRGlzcGxheSA9IHNldHRpbmdzLmFpRGlzcGxheU1hc3Rlci5zbGljZSgpO1xuXHRcblx0XHRzZXR0aW5ncy5iQWpheERhdGFHZXQgPSBmYWxzZTtcblx0XHRfZm5EcmF3KCBzZXR0aW5ncyApO1xuXHRcblx0XHRpZiAoICEgc2V0dGluZ3MuX2JJbml0Q29tcGxldGUgKSB7XG5cdFx0XHRfZm5Jbml0Q29tcGxldGUoIHNldHRpbmdzLCBqc29uICk7XG5cdFx0fVxuXHRcblx0XHRzZXR0aW5ncy5iQWpheERhdGFHZXQgPSB0cnVlO1xuXHRcdF9mblByb2Nlc3NpbmdEaXNwbGF5KCBzZXR0aW5ncywgZmFsc2UgKTtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBHZXQgdGhlIGRhdGEgZnJvbSB0aGUgSlNPTiBkYXRhIHNvdXJjZSB0byB1c2UgZm9yIGRyYXdpbmcgYSB0YWJsZS4gVXNpbmdcblx0ICogYF9mbkdldE9iamVjdERhdGFGbmAgYWxsb3dzIHRoZSBkYXRhIHRvIGJlIHNvdXJjZWQgZnJvbSBhIHByb3BlcnR5IG9mIHRoZVxuXHQgKiBzb3VyY2Ugb2JqZWN0LCBvciBmcm9tIGEgcHJvY2Vzc2luZyBmdW5jdGlvbi5cblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBwYXJhbSAge29iamVjdH0ganNvbiBEYXRhIHNvdXJjZSBvYmplY3QgLyBhcnJheSBmcm9tIHRoZSBzZXJ2ZXJcblx0ICogIEByZXR1cm4ge2FycmF5fSBBcnJheSBvZiBkYXRhIHRvIHVzZVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuQWpheERhdGFTcmMgKCBvU2V0dGluZ3MsIGpzb24gKVxuXHR7XG5cdFx0dmFyIGRhdGFTcmMgPSAkLmlzUGxhaW5PYmplY3QoIG9TZXR0aW5ncy5hamF4ICkgJiYgb1NldHRpbmdzLmFqYXguZGF0YVNyYyAhPT0gdW5kZWZpbmVkID9cblx0XHRcdG9TZXR0aW5ncy5hamF4LmRhdGFTcmMgOlxuXHRcdFx0b1NldHRpbmdzLnNBamF4RGF0YVByb3A7IC8vIENvbXBhdGliaWxpdHkgd2l0aCAxLjktLlxuXHRcblx0XHQvLyBDb21wYXRpYmlsaXR5IHdpdGggMS45LS4gSW4gb3JkZXIgdG8gcmVhZCBmcm9tIGFhRGF0YSwgY2hlY2sgaWYgdGhlXG5cdFx0Ly8gZGVmYXVsdCBoYXMgYmVlbiBjaGFuZ2VkLCBpZiBub3QsIGNoZWNrIGZvciBhYURhdGFcblx0XHRpZiAoIGRhdGFTcmMgPT09ICdkYXRhJyApIHtcblx0XHRcdHJldHVybiBqc29uLmFhRGF0YSB8fCBqc29uW2RhdGFTcmNdO1xuXHRcdH1cblx0XG5cdFx0cmV0dXJuIGRhdGFTcmMgIT09IFwiXCIgP1xuXHRcdFx0X2ZuR2V0T2JqZWN0RGF0YUZuKCBkYXRhU3JjICkoIGpzb24gKSA6XG5cdFx0XHRqc29uO1xuXHR9XG5cdFxuXHQvKipcblx0ICogR2VuZXJhdGUgdGhlIG5vZGUgcmVxdWlyZWQgZm9yIGZpbHRlcmluZyB0ZXh0XG5cdCAqICBAcmV0dXJucyB7bm9kZX0gRmlsdGVyIGNvbnRyb2wgZWxlbWVudFxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5GZWF0dXJlSHRtbEZpbHRlciAoIHNldHRpbmdzIClcblx0e1xuXHRcdHZhciBjbGFzc2VzID0gc2V0dGluZ3Mub0NsYXNzZXM7XG5cdFx0dmFyIHRhYmxlSWQgPSBzZXR0aW5ncy5zVGFibGVJZDtcblx0XHR2YXIgbGFuZ3VhZ2UgPSBzZXR0aW5ncy5vTGFuZ3VhZ2U7XG5cdFx0dmFyIHByZXZpb3VzU2VhcmNoID0gc2V0dGluZ3Mub1ByZXZpb3VzU2VhcmNoO1xuXHRcdHZhciBmZWF0dXJlcyA9IHNldHRpbmdzLmFhbkZlYXR1cmVzO1xuXHRcdHZhciBpbnB1dCA9ICc8aW5wdXQgdHlwZT1cInNlYXJjaFwiIGNsYXNzPVwiJytjbGFzc2VzLnNGaWx0ZXJJbnB1dCsnXCIvPic7XG5cdFxuXHRcdHZhciBzdHIgPSBsYW5ndWFnZS5zU2VhcmNoO1xuXHRcdHN0ciA9IHN0ci5tYXRjaCgvX0lOUFVUXy8pID9cblx0XHRcdHN0ci5yZXBsYWNlKCdfSU5QVVRfJywgaW5wdXQpIDpcblx0XHRcdHN0citpbnB1dDtcblx0XG5cdFx0dmFyIGZpbHRlciA9ICQoJzxkaXYvPicsIHtcblx0XHRcdFx0J2lkJzogISBmZWF0dXJlcy5mID8gdGFibGVJZCsnX2ZpbHRlcicgOiBudWxsLFxuXHRcdFx0XHQnY2xhc3MnOiBjbGFzc2VzLnNGaWx0ZXJcblx0XHRcdH0gKVxuXHRcdFx0LmFwcGVuZCggJCgnPGxhYmVsLz4nICkuYXBwZW5kKCBzdHIgKSApO1xuXHRcblx0XHR2YXIgc2VhcmNoRm4gPSBmdW5jdGlvbigpIHtcblx0XHRcdC8qIFVwZGF0ZSBhbGwgb3RoZXIgZmlsdGVyIGlucHV0IGVsZW1lbnRzIGZvciB0aGUgbmV3IGRpc3BsYXkgKi9cblx0XHRcdHZhciBuID0gZmVhdHVyZXMuZjtcblx0XHRcdHZhciB2YWwgPSAhdGhpcy52YWx1ZSA/IFwiXCIgOiB0aGlzLnZhbHVlOyAvLyBtZW50YWwgSUU4IGZpeCA6LShcblx0XG5cdFx0XHQvKiBOb3cgZG8gdGhlIGZpbHRlciAqL1xuXHRcdFx0aWYgKCB2YWwgIT0gcHJldmlvdXNTZWFyY2guc1NlYXJjaCApIHtcblx0XHRcdFx0X2ZuRmlsdGVyQ29tcGxldGUoIHNldHRpbmdzLCB7XG5cdFx0XHRcdFx0XCJzU2VhcmNoXCI6IHZhbCxcblx0XHRcdFx0XHRcImJSZWdleFwiOiBwcmV2aW91c1NlYXJjaC5iUmVnZXgsXG5cdFx0XHRcdFx0XCJiU21hcnRcIjogcHJldmlvdXNTZWFyY2guYlNtYXJ0ICxcblx0XHRcdFx0XHRcImJDYXNlSW5zZW5zaXRpdmVcIjogcHJldmlvdXNTZWFyY2guYkNhc2VJbnNlbnNpdGl2ZVxuXHRcdFx0XHR9ICk7XG5cdFxuXHRcdFx0XHQvLyBOZWVkIHRvIHJlZHJhdywgd2l0aG91dCByZXNvcnRpbmdcblx0XHRcdFx0c2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQgPSAwO1xuXHRcdFx0XHRfZm5EcmF3KCBzZXR0aW5ncyApO1xuXHRcdFx0fVxuXHRcdH07XG5cdFxuXHRcdHZhciBzZWFyY2hEZWxheSA9IHNldHRpbmdzLnNlYXJjaERlbGF5ICE9PSBudWxsID9cblx0XHRcdHNldHRpbmdzLnNlYXJjaERlbGF5IDpcblx0XHRcdF9mbkRhdGFTb3VyY2UoIHNldHRpbmdzICkgPT09ICdzc3AnID9cblx0XHRcdFx0NDAwIDpcblx0XHRcdFx0MDtcblx0XG5cdFx0dmFyIGpxRmlsdGVyID0gJCgnaW5wdXQnLCBmaWx0ZXIpXG5cdFx0XHQudmFsKCBwcmV2aW91c1NlYXJjaC5zU2VhcmNoIClcblx0XHRcdC5hdHRyKCAncGxhY2Vob2xkZXInLCBsYW5ndWFnZS5zU2VhcmNoUGxhY2Vob2xkZXIgKVxuXHRcdFx0Lm9uKFxuXHRcdFx0XHQna2V5dXAuRFQgc2VhcmNoLkRUIGlucHV0LkRUIHBhc3RlLkRUIGN1dC5EVCcsXG5cdFx0XHRcdHNlYXJjaERlbGF5ID9cblx0XHRcdFx0XHRfZm5UaHJvdHRsZSggc2VhcmNoRm4sIHNlYXJjaERlbGF5ICkgOlxuXHRcdFx0XHRcdHNlYXJjaEZuXG5cdFx0XHQpXG5cdFx0XHQub24oICdtb3VzZXVwJywgZnVuY3Rpb24oZSkge1xuXHRcdFx0XHQvLyBFZGdlIGZpeCEgRWRnZSAxNyBkb2VzIG5vdCB0cmlnZ2VyIGFueXRoaW5nIG90aGVyIHRoYW4gbW91c2UgZXZlbnRzIHdoZW4gY2xpY2tpbmdcblx0XHRcdFx0Ly8gb24gdGhlIGNsZWFyIGljb24gKEVkZ2UgYnVnIDE3NTg0NTE1KS4gVGhpcyBpcyBzYWZlIGluIG90aGVyIGJyb3dzZXJzIGFzIGBzZWFyY2hGbmBcblx0XHRcdFx0Ly8gY2hlY2tzIHRoZSB2YWx1ZSB0byBzZWUgaWYgaXQgaGFzIGNoYW5nZWQuIEluIG90aGVyIGJyb3dzZXJzIGl0IHdvbid0IGhhdmUuXG5cdFx0XHRcdHNldFRpbWVvdXQoIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRzZWFyY2hGbi5jYWxsKGpxRmlsdGVyWzBdKTtcblx0XHRcdFx0fSwgMTApO1xuXHRcdFx0fSApXG5cdFx0XHQub24oICdrZXlwcmVzcy5EVCcsIGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0LyogUHJldmVudCBmb3JtIHN1Ym1pc3Npb24gKi9cblx0XHRcdFx0aWYgKCBlLmtleUNvZGUgPT0gMTMgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9IClcblx0XHRcdC5hdHRyKCdhcmlhLWNvbnRyb2xzJywgdGFibGVJZCk7XG5cdFxuXHRcdC8vIFVwZGF0ZSB0aGUgaW5wdXQgZWxlbWVudHMgd2hlbmV2ZXIgdGhlIHRhYmxlIGlzIGZpbHRlcmVkXG5cdFx0JChzZXR0aW5ncy5uVGFibGUpLm9uKCAnc2VhcmNoLmR0LkRUJywgZnVuY3Rpb24gKCBldiwgcyApIHtcblx0XHRcdGlmICggc2V0dGluZ3MgPT09IHMgKSB7XG5cdFx0XHRcdC8vIElFOSB0aHJvd3MgYW4gJ3Vua25vd24gZXJyb3InIGlmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgaXMgdXNlZFxuXHRcdFx0XHQvLyBpbnNpZGUgYW4gaWZyYW1lIG9yIGZyYW1lLi4uXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0aWYgKCBqcUZpbHRlclswXSAhPT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCApIHtcblx0XHRcdFx0XHRcdGpxRmlsdGVyLnZhbCggcHJldmlvdXNTZWFyY2guc1NlYXJjaCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRjYXRjaCAoIGUgKSB7fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0XG5cdFx0cmV0dXJuIGZpbHRlclswXTtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBGaWx0ZXIgdGhlIHRhYmxlIHVzaW5nIGJvdGggdGhlIGdsb2JhbCBmaWx0ZXIgYW5kIGNvbHVtbiBiYXNlZCBmaWx0ZXJpbmdcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2VhcmNoIHNlYXJjaCBpbmZvcm1hdGlvblxuXHQgKiAgQHBhcmFtIHtpbnR9IFtpRm9yY2VdIGZvcmNlIGEgcmVzZWFyY2ggb2YgdGhlIG1hc3RlciBhcnJheSAoMSkgb3Igbm90ICh1bmRlZmluZWQgb3IgMClcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuRmlsdGVyQ29tcGxldGUgKCBvU2V0dGluZ3MsIG9JbnB1dCwgaUZvcmNlIClcblx0e1xuXHRcdHZhciBvUHJldlNlYXJjaCA9IG9TZXR0aW5ncy5vUHJldmlvdXNTZWFyY2g7XG5cdFx0dmFyIGFvUHJldlNlYXJjaCA9IG9TZXR0aW5ncy5hb1ByZVNlYXJjaENvbHM7XG5cdFx0dmFyIGZuU2F2ZUZpbHRlciA9IGZ1bmN0aW9uICggb0ZpbHRlciApIHtcblx0XHRcdC8qIFNhdmUgdGhlIGZpbHRlcmluZyB2YWx1ZXMgKi9cblx0XHRcdG9QcmV2U2VhcmNoLnNTZWFyY2ggPSBvRmlsdGVyLnNTZWFyY2g7XG5cdFx0XHRvUHJldlNlYXJjaC5iUmVnZXggPSBvRmlsdGVyLmJSZWdleDtcblx0XHRcdG9QcmV2U2VhcmNoLmJTbWFydCA9IG9GaWx0ZXIuYlNtYXJ0O1xuXHRcdFx0b1ByZXZTZWFyY2guYkNhc2VJbnNlbnNpdGl2ZSA9IG9GaWx0ZXIuYkNhc2VJbnNlbnNpdGl2ZTtcblx0XHR9O1xuXHRcdHZhciBmblJlZ2V4ID0gZnVuY3Rpb24gKCBvICkge1xuXHRcdFx0Ly8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2l0aCB0aGUgYkVzY2FwZVJlZ2V4IG9wdGlvblxuXHRcdFx0cmV0dXJuIG8uYkVzY2FwZVJlZ2V4ICE9PSB1bmRlZmluZWQgPyAhby5iRXNjYXBlUmVnZXggOiBvLmJSZWdleDtcblx0XHR9O1xuXHRcblx0XHQvLyBSZXNvbHZlIGFueSBjb2x1bW4gdHlwZXMgdGhhdCBhcmUgdW5rbm93biBkdWUgdG8gYWRkaXRpb24gb3IgaW52YWxpZGF0aW9uXG5cdFx0Ly8gQHRvZG8gQXMgcGVyIHNvcnQgLSBjYW4gdGhpcyBiZSBtb3ZlZCBpbnRvIGFuIGV2ZW50IGhhbmRsZXI/XG5cdFx0X2ZuQ29sdW1uVHlwZXMoIG9TZXR0aW5ncyApO1xuXHRcblx0XHQvKiBJbiBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nIGFsbCBmaWx0ZXJpbmcgaXMgZG9uZSBieSB0aGUgc2VydmVyLCBzbyBubyBwb2ludCBoYW5naW5nIGFyb3VuZCBoZXJlICovXG5cdFx0aWYgKCBfZm5EYXRhU291cmNlKCBvU2V0dGluZ3MgKSAhPSAnc3NwJyApXG5cdFx0e1xuXHRcdFx0LyogR2xvYmFsIGZpbHRlciAqL1xuXHRcdFx0X2ZuRmlsdGVyKCBvU2V0dGluZ3MsIG9JbnB1dC5zU2VhcmNoLCBpRm9yY2UsIGZuUmVnZXgob0lucHV0KSwgb0lucHV0LmJTbWFydCwgb0lucHV0LmJDYXNlSW5zZW5zaXRpdmUgKTtcblx0XHRcdGZuU2F2ZUZpbHRlciggb0lucHV0ICk7XG5cdFxuXHRcdFx0LyogTm93IGRvIHRoZSBpbmRpdmlkdWFsIGNvbHVtbiBmaWx0ZXIgKi9cblx0XHRcdGZvciAoIHZhciBpPTAgOyBpPGFvUHJldlNlYXJjaC5sZW5ndGggOyBpKysgKVxuXHRcdFx0e1xuXHRcdFx0XHRfZm5GaWx0ZXJDb2x1bW4oIG9TZXR0aW5ncywgYW9QcmV2U2VhcmNoW2ldLnNTZWFyY2gsIGksIGZuUmVnZXgoYW9QcmV2U2VhcmNoW2ldKSxcblx0XHRcdFx0XHRhb1ByZXZTZWFyY2hbaV0uYlNtYXJ0LCBhb1ByZXZTZWFyY2hbaV0uYkNhc2VJbnNlbnNpdGl2ZSApO1xuXHRcdFx0fVxuXHRcblx0XHRcdC8qIEN1c3RvbSBmaWx0ZXJpbmcgKi9cblx0XHRcdF9mbkZpbHRlckN1c3RvbSggb1NldHRpbmdzICk7XG5cdFx0fVxuXHRcdGVsc2Vcblx0XHR7XG5cdFx0XHRmblNhdmVGaWx0ZXIoIG9JbnB1dCApO1xuXHRcdH1cblx0XG5cdFx0LyogVGVsbCB0aGUgZHJhdyBmdW5jdGlvbiB3ZSBoYXZlIGJlZW4gZmlsdGVyaW5nICovXG5cdFx0b1NldHRpbmdzLmJGaWx0ZXJlZCA9IHRydWU7XG5cdFx0X2ZuQ2FsbGJhY2tGaXJlKCBvU2V0dGluZ3MsIG51bGwsICdzZWFyY2gnLCBbb1NldHRpbmdzXSApO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIEFwcGx5IGN1c3RvbSBmaWx0ZXJpbmcgZnVuY3Rpb25zXG5cdCAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkZpbHRlckN1c3RvbSggc2V0dGluZ3MgKVxuXHR7XG5cdFx0dmFyIGZpbHRlcnMgPSBEYXRhVGFibGUuZXh0LnNlYXJjaDtcblx0XHR2YXIgZGlzcGxheVJvd3MgPSBzZXR0aW5ncy5haURpc3BsYXk7XG5cdFx0dmFyIHJvdywgcm93SWR4O1xuXHRcblx0XHRmb3IgKCB2YXIgaT0wLCBpZW49ZmlsdGVycy5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdHZhciByb3dzID0gW107XG5cdFxuXHRcdFx0Ly8gTG9vcCBvdmVyIGVhY2ggcm93IGFuZCBzZWUgaWYgaXQgc2hvdWxkIGJlIGluY2x1ZGVkXG5cdFx0XHRmb3IgKCB2YXIgaj0wLCBqZW49ZGlzcGxheVJvd3MubGVuZ3RoIDsgajxqZW4gOyBqKysgKSB7XG5cdFx0XHRcdHJvd0lkeCA9IGRpc3BsYXlSb3dzWyBqIF07XG5cdFx0XHRcdHJvdyA9IHNldHRpbmdzLmFvRGF0YVsgcm93SWR4IF07XG5cdFxuXHRcdFx0XHRpZiAoIGZpbHRlcnNbaV0oIHNldHRpbmdzLCByb3cuX2FGaWx0ZXJEYXRhLCByb3dJZHgsIHJvdy5fYURhdGEsIGogKSApIHtcblx0XHRcdFx0XHRyb3dzLnB1c2goIHJvd0lkeCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gU28gdGhlIGFycmF5IHJlZmVyZW5jZSBkb2Vzbid0IGJyZWFrIHNldCB0aGUgcmVzdWx0cyBpbnRvIHRoZVxuXHRcdFx0Ly8gZXhpc3RpbmcgYXJyYXlcblx0XHRcdGRpc3BsYXlSb3dzLmxlbmd0aCA9IDA7XG5cdFx0XHQkLm1lcmdlKCBkaXNwbGF5Um93cywgcm93cyApO1xuXHRcdH1cblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBGaWx0ZXIgdGhlIHRhYmxlIG9uIGEgcGVyLWNvbHVtbiBiYXNpc1xuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHtzdHJpbmd9IHNJbnB1dCBzdHJpbmcgdG8gZmlsdGVyIG9uXG5cdCAqICBAcGFyYW0ge2ludH0gaUNvbHVtbiBjb2x1bW4gdG8gZmlsdGVyXG5cdCAqICBAcGFyYW0ge2Jvb2x9IGJSZWdleCB0cmVhdCBzZWFyY2ggc3RyaW5nIGFzIGEgcmVndWxhciBleHByZXNzaW9uIG9yIG5vdFxuXHQgKiAgQHBhcmFtIHtib29sfSBiU21hcnQgdXNlIHNtYXJ0IGZpbHRlcmluZyBvciBub3Rcblx0ICogIEBwYXJhbSB7Ym9vbH0gYkNhc2VJbnNlbnNpdGl2ZSBEbyBjYXNlIGluc2Vuc3RpdmUgbWF0Y2hpbmcgb3Igbm90XG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkZpbHRlckNvbHVtbiAoIHNldHRpbmdzLCBzZWFyY2hTdHIsIGNvbElkeCwgcmVnZXgsIHNtYXJ0LCBjYXNlSW5zZW5zaXRpdmUgKVxuXHR7XG5cdFx0aWYgKCBzZWFyY2hTdHIgPT09ICcnICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XG5cdFx0dmFyIGRhdGE7XG5cdFx0dmFyIG91dCA9IFtdO1xuXHRcdHZhciBkaXNwbGF5ID0gc2V0dGluZ3MuYWlEaXNwbGF5O1xuXHRcdHZhciBycFNlYXJjaCA9IF9mbkZpbHRlckNyZWF0ZVNlYXJjaCggc2VhcmNoU3RyLCByZWdleCwgc21hcnQsIGNhc2VJbnNlbnNpdGl2ZSApO1xuXHRcblx0XHRmb3IgKCB2YXIgaT0wIDsgaTxkaXNwbGF5Lmxlbmd0aCA7IGkrKyApIHtcblx0XHRcdGRhdGEgPSBzZXR0aW5ncy5hb0RhdGFbIGRpc3BsYXlbaV0gXS5fYUZpbHRlckRhdGFbIGNvbElkeCBdO1xuXHRcblx0XHRcdGlmICggcnBTZWFyY2gudGVzdCggZGF0YSApICkge1xuXHRcdFx0XHRvdXQucHVzaCggZGlzcGxheVtpXSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0c2V0dGluZ3MuYWlEaXNwbGF5ID0gb3V0O1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIEZpbHRlciB0aGUgZGF0YSB0YWJsZSBiYXNlZCBvbiB1c2VyIGlucHV0IGFuZCBkcmF3IHRoZSB0YWJsZVxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcGFyYW0ge3N0cmluZ30gaW5wdXQgc3RyaW5nIHRvIGZpbHRlciBvblxuXHQgKiAgQHBhcmFtIHtpbnR9IGZvcmNlIG9wdGlvbmFsIC0gZm9yY2UgYSByZXNlYXJjaCBvZiB0aGUgbWFzdGVyIGFycmF5ICgxKSBvciBub3QgKHVuZGVmaW5lZCBvciAwKVxuXHQgKiAgQHBhcmFtIHtib29sfSByZWdleCB0cmVhdCBhcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBvciBub3Rcblx0ICogIEBwYXJhbSB7Ym9vbH0gc21hcnQgcGVyZm9ybSBzbWFydCBmaWx0ZXJpbmcgb3Igbm90XG5cdCAqICBAcGFyYW0ge2Jvb2x9IGNhc2VJbnNlbnNpdGl2ZSBEbyBjYXNlIGluc2Vuc3RpdmUgbWF0Y2hpbmcgb3Igbm90XG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkZpbHRlciggc2V0dGluZ3MsIGlucHV0LCBmb3JjZSwgcmVnZXgsIHNtYXJ0LCBjYXNlSW5zZW5zaXRpdmUgKVxuXHR7XG5cdFx0dmFyIHJwU2VhcmNoID0gX2ZuRmlsdGVyQ3JlYXRlU2VhcmNoKCBpbnB1dCwgcmVnZXgsIHNtYXJ0LCBjYXNlSW5zZW5zaXRpdmUgKTtcblx0XHR2YXIgcHJldlNlYXJjaCA9IHNldHRpbmdzLm9QcmV2aW91c1NlYXJjaC5zU2VhcmNoO1xuXHRcdHZhciBkaXNwbGF5TWFzdGVyID0gc2V0dGluZ3MuYWlEaXNwbGF5TWFzdGVyO1xuXHRcdHZhciBkaXNwbGF5LCBpbnZhbGlkYXRlZCwgaTtcblx0XHR2YXIgZmlsdGVyZWQgPSBbXTtcblx0XG5cdFx0Ly8gTmVlZCB0byB0YWtlIGFjY291bnQgb2YgY3VzdG9tIGZpbHRlcmluZyBmdW5jdGlvbnMgLSBhbHdheXMgZmlsdGVyXG5cdFx0aWYgKCBEYXRhVGFibGUuZXh0LnNlYXJjaC5sZW5ndGggIT09IDAgKSB7XG5cdFx0XHRmb3JjZSA9IHRydWU7XG5cdFx0fVxuXHRcblx0XHQvLyBDaGVjayBpZiBhbnkgb2YgdGhlIHJvd3Mgd2VyZSBpbnZhbGlkYXRlZFxuXHRcdGludmFsaWRhdGVkID0gX2ZuRmlsdGVyRGF0YSggc2V0dGluZ3MgKTtcblx0XG5cdFx0Ly8gSWYgdGhlIGlucHV0IGlzIGJsYW5rIC0gd2UganVzdCB3YW50IHRoZSBmdWxsIGRhdGEgc2V0XG5cdFx0aWYgKCBpbnB1dC5sZW5ndGggPD0gMCApIHtcblx0XHRcdHNldHRpbmdzLmFpRGlzcGxheSA9IGRpc3BsYXlNYXN0ZXIuc2xpY2UoKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHQvLyBOZXcgc2VhcmNoIC0gc3RhcnQgZnJvbSB0aGUgbWFzdGVyIGFycmF5XG5cdFx0XHRpZiAoIGludmFsaWRhdGVkIHx8XG5cdFx0XHRcdCBmb3JjZSB8fFxuXHRcdFx0XHQgcmVnZXggfHxcblx0XHRcdFx0IHByZXZTZWFyY2gubGVuZ3RoID4gaW5wdXQubGVuZ3RoIHx8XG5cdFx0XHRcdCBpbnB1dC5pbmRleE9mKHByZXZTZWFyY2gpICE9PSAwIHx8XG5cdFx0XHRcdCBzZXR0aW5ncy5iU29ydGVkIC8vIE9uIHJlc29ydCwgdGhlIGRpc3BsYXkgbWFzdGVyIG5lZWRzIHRvIGJlXG5cdFx0XHRcdCAgICAgICAgICAgICAgICAgIC8vIHJlLWZpbHRlcmVkIHNpbmNlIGluZGV4ZXMgd2lsbCBoYXZlIGNoYW5nZWRcblx0XHRcdCkge1xuXHRcdFx0XHRzZXR0aW5ncy5haURpc3BsYXkgPSBkaXNwbGF5TWFzdGVyLnNsaWNlKCk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gU2VhcmNoIHRoZSBkaXNwbGF5IGFycmF5XG5cdFx0XHRkaXNwbGF5ID0gc2V0dGluZ3MuYWlEaXNwbGF5O1xuXHRcblx0XHRcdGZvciAoIGk9MCA7IGk8ZGlzcGxheS5sZW5ndGggOyBpKysgKSB7XG5cdFx0XHRcdGlmICggcnBTZWFyY2gudGVzdCggc2V0dGluZ3MuYW9EYXRhWyBkaXNwbGF5W2ldIF0uX3NGaWx0ZXJSb3cgKSApIHtcblx0XHRcdFx0XHRmaWx0ZXJlZC5wdXNoKCBkaXNwbGF5W2ldICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XG5cdFx0XHRzZXR0aW5ncy5haURpc3BsYXkgPSBmaWx0ZXJlZDtcblx0XHR9XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogQnVpbGQgYSByZWd1bGFyIGV4cHJlc3Npb24gb2JqZWN0IHN1aXRhYmxlIGZvciBzZWFyY2hpbmcgYSB0YWJsZVxuXHQgKiAgQHBhcmFtIHtzdHJpbmd9IHNTZWFyY2ggc3RyaW5nIHRvIHNlYXJjaCBmb3Jcblx0ICogIEBwYXJhbSB7Ym9vbH0gYlJlZ2V4IHRyZWF0IGFzIGEgcmVndWxhciBleHByZXNzaW9uIG9yIG5vdFxuXHQgKiAgQHBhcmFtIHtib29sfSBiU21hcnQgcGVyZm9ybSBzbWFydCBmaWx0ZXJpbmcgb3Igbm90XG5cdCAqICBAcGFyYW0ge2Jvb2x9IGJDYXNlSW5zZW5zaXRpdmUgRG8gY2FzZSBpbnNlbnNpdGl2ZSBtYXRjaGluZyBvciBub3Rcblx0ICogIEByZXR1cm5zIHtSZWdFeHB9IGNvbnN0cnVjdGVkIG9iamVjdFxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5GaWx0ZXJDcmVhdGVTZWFyY2goIHNlYXJjaCwgcmVnZXgsIHNtYXJ0LCBjYXNlSW5zZW5zaXRpdmUgKVxuXHR7XG5cdFx0c2VhcmNoID0gcmVnZXggP1xuXHRcdFx0c2VhcmNoIDpcblx0XHRcdF9mbkVzY2FwZVJlZ2V4KCBzZWFyY2ggKTtcblx0XHRcblx0XHRpZiAoIHNtYXJ0ICkge1xuXHRcdFx0LyogRm9yIHNtYXJ0IGZpbHRlcmluZyB3ZSB3YW50IHRvIGFsbG93IHRoZSBzZWFyY2ggdG8gd29yayByZWdhcmRsZXNzIG9mXG5cdFx0XHQgKiB3b3JkIG9yZGVyLiBXZSBhbHNvIHdhbnQgZG91YmxlIHF1b3RlZCB0ZXh0IHRvIGJlIHByZXNlcnZlZCwgc28gd29yZFxuXHRcdFx0ICogb3JkZXIgaXMgaW1wb3J0YW50IC0gYSBsYSBnb29nbGUuIFNvIHRoaXMgaXMgd2hhdCB3ZSB3YW50IHRvXG5cdFx0XHQgKiBnZW5lcmF0ZTpcblx0XHRcdCAqIFxuXHRcdFx0ICogXig/PS4qP1xcYm9uZVxcYikoPz0uKj9cXGJ0d28gdGhyZWVcXGIpKD89Lio/XFxiZm91clxcYikuKiRcblx0XHRcdCAqL1xuXHRcdFx0dmFyIGEgPSAkLm1hcCggc2VhcmNoLm1hdGNoKCAvXCJbXlwiXStcInxbXiBdKy9nICkgfHwgWycnXSwgZnVuY3Rpb24gKCB3b3JkICkge1xuXHRcdFx0XHRpZiAoIHdvcmQuY2hhckF0KDApID09PSAnXCInICkge1xuXHRcdFx0XHRcdHZhciBtID0gd29yZC5tYXRjaCggL15cIiguKilcIiQvICk7XG5cdFx0XHRcdFx0d29yZCA9IG0gPyBtWzFdIDogd29yZDtcblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0cmV0dXJuIHdvcmQucmVwbGFjZSgnXCInLCAnJyk7XG5cdFx0XHR9ICk7XG5cdFxuXHRcdFx0c2VhcmNoID0gJ14oPz0uKj8nK2Euam9pbiggJykoPz0uKj8nICkrJykuKiQnO1xuXHRcdH1cblx0XG5cdFx0cmV0dXJuIG5ldyBSZWdFeHAoIHNlYXJjaCwgY2FzZUluc2Vuc2l0aXZlID8gJ2knIDogJycgKTtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBFc2NhcGUgYSBzdHJpbmcgc3VjaCB0aGF0IGl0IGNhbiBiZSB1c2VkIGluIGEgcmVndWxhciBleHByZXNzaW9uXG5cdCAqICBAcGFyYW0ge3N0cmluZ30gc1ZhbCBzdHJpbmcgdG8gZXNjYXBlXG5cdCAqICBAcmV0dXJucyB7c3RyaW5nfSBlc2NhcGVkIHN0cmluZ1xuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHR2YXIgX2ZuRXNjYXBlUmVnZXggPSBEYXRhVGFibGUudXRpbC5lc2NhcGVSZWdleDtcblx0XG5cdHZhciBfX2ZpbHRlcl9kaXYgPSAkKCc8ZGl2PicpWzBdO1xuXHR2YXIgX19maWx0ZXJfZGl2X3RleHRDb250ZW50ID0gX19maWx0ZXJfZGl2LnRleHRDb250ZW50ICE9PSB1bmRlZmluZWQ7XG5cdFxuXHQvLyBVcGRhdGUgdGhlIGZpbHRlcmluZyBkYXRhIGZvciBlYWNoIHJvdyBpZiBuZWVkZWQgKGJ5IGludmFsaWRhdGlvbiBvciBmaXJzdCBydW4pXG5cdGZ1bmN0aW9uIF9mbkZpbHRlckRhdGEgKCBzZXR0aW5ncyApXG5cdHtcblx0XHR2YXIgY29sdW1ucyA9IHNldHRpbmdzLmFvQ29sdW1ucztcblx0XHR2YXIgY29sdW1uO1xuXHRcdHZhciBpLCBqLCBpZW4sIGplbiwgZmlsdGVyRGF0YSwgY2VsbERhdGEsIHJvdztcblx0XHR2YXIgZm9tYXR0ZXJzID0gRGF0YVRhYmxlLmV4dC50eXBlLnNlYXJjaDtcblx0XHR2YXIgd2FzSW52YWxpZGF0ZWQgPSBmYWxzZTtcblx0XG5cdFx0Zm9yICggaT0wLCBpZW49c2V0dGluZ3MuYW9EYXRhLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0cm93ID0gc2V0dGluZ3MuYW9EYXRhW2ldO1xuXHRcblx0XHRcdGlmICggISByb3cuX2FGaWx0ZXJEYXRhICkge1xuXHRcdFx0XHRmaWx0ZXJEYXRhID0gW107XG5cdFxuXHRcdFx0XHRmb3IgKCBqPTAsIGplbj1jb2x1bW5zLmxlbmd0aCA7IGo8amVuIDsgaisrICkge1xuXHRcdFx0XHRcdGNvbHVtbiA9IGNvbHVtbnNbal07XG5cdFxuXHRcdFx0XHRcdGlmICggY29sdW1uLmJTZWFyY2hhYmxlICkge1xuXHRcdFx0XHRcdFx0Y2VsbERhdGEgPSBfZm5HZXRDZWxsRGF0YSggc2V0dGluZ3MsIGksIGosICdmaWx0ZXInICk7XG5cdFxuXHRcdFx0XHRcdFx0aWYgKCBmb21hdHRlcnNbIGNvbHVtbi5zVHlwZSBdICkge1xuXHRcdFx0XHRcdFx0XHRjZWxsRGF0YSA9IGZvbWF0dGVyc1sgY29sdW1uLnNUeXBlIF0oIGNlbGxEYXRhICk7XG5cdFx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRcdFx0Ly8gU2VhcmNoIGluIERhdGFUYWJsZXMgMS4xMCBpcyBzdHJpbmcgYmFzZWQuIEluIDEuMTEgdGhpc1xuXHRcdFx0XHRcdFx0Ly8gc2hvdWxkIGJlIGFsdGVyZWQgdG8gYWxzbyBhbGxvdyBzdHJpY3QgdHlwZSBjaGVja2luZy5cblx0XHRcdFx0XHRcdGlmICggY2VsbERhdGEgPT09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRcdGNlbGxEYXRhID0gJyc7XG5cdFx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRcdFx0aWYgKCB0eXBlb2YgY2VsbERhdGEgIT09ICdzdHJpbmcnICYmIGNlbGxEYXRhLnRvU3RyaW5nICkge1xuXHRcdFx0XHRcdFx0XHRjZWxsRGF0YSA9IGNlbGxEYXRhLnRvU3RyaW5nKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0Y2VsbERhdGEgPSAnJztcblx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRcdC8vIElmIGl0IGxvb2tzIGxpa2UgdGhlcmUgaXMgYW4gSFRNTCBlbnRpdHkgaW4gdGhlIHN0cmluZyxcblx0XHRcdFx0XHQvLyBhdHRlbXB0IHRvIGRlY29kZSBpdCBzbyBzb3J0aW5nIHdvcmtzIGFzIGV4cGVjdGVkLiBOb3RlIHRoYXRcblx0XHRcdFx0XHQvLyB3ZSBjb3VsZCB1c2UgYSBzaW5nbGUgbGluZSBvZiBqUXVlcnkgdG8gZG8gdGhpcywgYnV0IHRoZSBET01cblx0XHRcdFx0XHQvLyBtZXRob2QgdXNlZCBoZXJlIGlzIG11Y2ggZmFzdGVyIGh0dHA6Ly9qc3BlcmYuY29tL2h0bWwtZGVjb2RlXG5cdFx0XHRcdFx0aWYgKCBjZWxsRGF0YS5pbmRleE9mICYmIGNlbGxEYXRhLmluZGV4T2YoJyYnKSAhPT0gLTEgKSB7XG5cdFx0XHRcdFx0XHRfX2ZpbHRlcl9kaXYuaW5uZXJIVE1MID0gY2VsbERhdGE7XG5cdFx0XHRcdFx0XHRjZWxsRGF0YSA9IF9fZmlsdGVyX2Rpdl90ZXh0Q29udGVudCA/XG5cdFx0XHRcdFx0XHRcdF9fZmlsdGVyX2Rpdi50ZXh0Q29udGVudCA6XG5cdFx0XHRcdFx0XHRcdF9fZmlsdGVyX2Rpdi5pbm5lclRleHQ7XG5cdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHRpZiAoIGNlbGxEYXRhLnJlcGxhY2UgKSB7XG5cdFx0XHRcdFx0XHRjZWxsRGF0YSA9IGNlbGxEYXRhLnJlcGxhY2UoL1tcXHJcXG5cXHUyMDI4XS9nLCAnJyk7XG5cdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHRmaWx0ZXJEYXRhLnB1c2goIGNlbGxEYXRhICk7XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdHJvdy5fYUZpbHRlckRhdGEgPSBmaWx0ZXJEYXRhO1xuXHRcdFx0XHRyb3cuX3NGaWx0ZXJSb3cgPSBmaWx0ZXJEYXRhLmpvaW4oJyAgJyk7XG5cdFx0XHRcdHdhc0ludmFsaWRhdGVkID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFxuXHRcdHJldHVybiB3YXNJbnZhbGlkYXRlZDtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBDb252ZXJ0IGZyb20gdGhlIGludGVybmFsIEh1bmdhcmlhbiBub3RhdGlvbiB0byBjYW1lbENhc2UgZm9yIGV4dGVybmFsXG5cdCAqIGludGVyYWN0aW9uXG5cdCAqICBAcGFyYW0ge29iamVjdH0gb2JqIE9iamVjdCB0byBjb252ZXJ0XG5cdCAqICBAcmV0dXJucyB7b2JqZWN0fSBJbnZlcnRlZCBvYmplY3Rcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuU2VhcmNoVG9DYW1lbCAoIG9iaiApXG5cdHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0c2VhcmNoOiAgICAgICAgICBvYmouc1NlYXJjaCxcblx0XHRcdHNtYXJ0OiAgICAgICAgICAgb2JqLmJTbWFydCxcblx0XHRcdHJlZ2V4OiAgICAgICAgICAgb2JqLmJSZWdleCxcblx0XHRcdGNhc2VJbnNlbnNpdGl2ZTogb2JqLmJDYXNlSW5zZW5zaXRpdmVcblx0XHR9O1xuXHR9XG5cdFxuXHRcblx0XG5cdC8qKlxuXHQgKiBDb252ZXJ0IGZyb20gY2FtZWxDYXNlIG5vdGF0aW9uIHRvIHRoZSBpbnRlcm5hbCBIdW5nYXJpYW4uIFdlIGNvdWxkIHVzZSB0aGVcblx0ICogSHVuZ2FyaWFuIGNvbnZlcnQgZnVuY3Rpb24gaGVyZSwgYnV0IHRoaXMgaXMgY2xlYW5lclxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9iaiBPYmplY3QgdG8gY29udmVydFxuXHQgKiAgQHJldHVybnMge29iamVjdH0gSW52ZXJ0ZWQgb2JqZWN0XG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mblNlYXJjaFRvSHVuZyAoIG9iaiApXG5cdHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0c1NlYXJjaDogICAgICAgICAgb2JqLnNlYXJjaCxcblx0XHRcdGJTbWFydDogICAgICAgICAgIG9iai5zbWFydCxcblx0XHRcdGJSZWdleDogICAgICAgICAgIG9iai5yZWdleCxcblx0XHRcdGJDYXNlSW5zZW5zaXRpdmU6IG9iai5jYXNlSW5zZW5zaXRpdmVcblx0XHR9O1xuXHR9XG5cdFxuXHQvKipcblx0ICogR2VuZXJhdGUgdGhlIG5vZGUgcmVxdWlyZWQgZm9yIHRoZSBpbmZvIGRpc3BsYXlcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEByZXR1cm5zIHtub2RlfSBJbmZvcm1hdGlvbiBlbGVtZW50XG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkZlYXR1cmVIdG1sSW5mbyAoIHNldHRpbmdzIClcblx0e1xuXHRcdHZhclxuXHRcdFx0dGlkID0gc2V0dGluZ3Muc1RhYmxlSWQsXG5cdFx0XHRub2RlcyA9IHNldHRpbmdzLmFhbkZlYXR1cmVzLmksXG5cdFx0XHRuID0gJCgnPGRpdi8+Jywge1xuXHRcdFx0XHQnY2xhc3MnOiBzZXR0aW5ncy5vQ2xhc3Nlcy5zSW5mbyxcblx0XHRcdFx0J2lkJzogISBub2RlcyA/IHRpZCsnX2luZm8nIDogbnVsbFxuXHRcdFx0fSApO1xuXHRcblx0XHRpZiAoICEgbm9kZXMgKSB7XG5cdFx0XHQvLyBVcGRhdGUgZGlzcGxheSBvbiBlYWNoIGRyYXdcblx0XHRcdHNldHRpbmdzLmFvRHJhd0NhbGxiYWNrLnB1c2goIHtcblx0XHRcdFx0XCJmblwiOiBfZm5VcGRhdGVJbmZvLFxuXHRcdFx0XHRcInNOYW1lXCI6IFwiaW5mb3JtYXRpb25cIlxuXHRcdFx0fSApO1xuXHRcblx0XHRcdG5cblx0XHRcdFx0LmF0dHIoICdyb2xlJywgJ3N0YXR1cycgKVxuXHRcdFx0XHQuYXR0ciggJ2FyaWEtbGl2ZScsICdwb2xpdGUnICk7XG5cdFxuXHRcdFx0Ly8gVGFibGUgaXMgZGVzY3JpYmVkIGJ5IG91ciBpbmZvIGRpdlxuXHRcdFx0JChzZXR0aW5ncy5uVGFibGUpLmF0dHIoICdhcmlhLWRlc2NyaWJlZGJ5JywgdGlkKydfaW5mbycgKTtcblx0XHR9XG5cdFxuXHRcdHJldHVybiBuWzBdO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIFVwZGF0ZSB0aGUgaW5mb3JtYXRpb24gZWxlbWVudHMgaW4gdGhlIGRpc3BsYXlcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5VcGRhdGVJbmZvICggc2V0dGluZ3MgKVxuXHR7XG5cdFx0LyogU2hvdyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgdGFibGUgKi9cblx0XHR2YXIgbm9kZXMgPSBzZXR0aW5ncy5hYW5GZWF0dXJlcy5pO1xuXHRcdGlmICggbm9kZXMubGVuZ3RoID09PSAwICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XG5cdFx0dmFyXG5cdFx0XHRsYW5nICA9IHNldHRpbmdzLm9MYW5ndWFnZSxcblx0XHRcdHN0YXJ0ID0gc2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQrMSxcblx0XHRcdGVuZCAgID0gc2V0dGluZ3MuZm5EaXNwbGF5RW5kKCksXG5cdFx0XHRtYXggICA9IHNldHRpbmdzLmZuUmVjb3Jkc1RvdGFsKCksXG5cdFx0XHR0b3RhbCA9IHNldHRpbmdzLmZuUmVjb3Jkc0Rpc3BsYXkoKSxcblx0XHRcdG91dCAgID0gdG90YWwgP1xuXHRcdFx0XHRsYW5nLnNJbmZvIDpcblx0XHRcdFx0bGFuZy5zSW5mb0VtcHR5O1xuXHRcblx0XHRpZiAoIHRvdGFsICE9PSBtYXggKSB7XG5cdFx0XHQvKiBSZWNvcmQgc2V0IGFmdGVyIGZpbHRlcmluZyAqL1xuXHRcdFx0b3V0ICs9ICcgJyArIGxhbmcuc0luZm9GaWx0ZXJlZDtcblx0XHR9XG5cdFxuXHRcdC8vIENvbnZlcnQgdGhlIG1hY3Jvc1xuXHRcdG91dCArPSBsYW5nLnNJbmZvUG9zdEZpeDtcblx0XHRvdXQgPSBfZm5JbmZvTWFjcm9zKCBzZXR0aW5ncywgb3V0ICk7XG5cdFxuXHRcdHZhciBjYWxsYmFjayA9IGxhbmcuZm5JbmZvQ2FsbGJhY2s7XG5cdFx0aWYgKCBjYWxsYmFjayAhPT0gbnVsbCApIHtcblx0XHRcdG91dCA9IGNhbGxiYWNrLmNhbGwoIHNldHRpbmdzLm9JbnN0YW5jZSxcblx0XHRcdFx0c2V0dGluZ3MsIHN0YXJ0LCBlbmQsIG1heCwgdG90YWwsIG91dFxuXHRcdFx0KTtcblx0XHR9XG5cdFxuXHRcdCQobm9kZXMpLmh0bWwoIG91dCApO1xuXHR9XG5cdFxuXHRcblx0ZnVuY3Rpb24gX2ZuSW5mb01hY3JvcyAoIHNldHRpbmdzLCBzdHIgKVxuXHR7XG5cdFx0Ly8gV2hlbiBpbmZpbml0ZSBzY3JvbGxpbmcsIHdlIGFyZSBhbHdheXMgc3RhcnRpbmcgYXQgMS4gX2lEaXNwbGF5U3RhcnQgaXMgdXNlZCBvbmx5XG5cdFx0Ly8gaW50ZXJuYWxseVxuXHRcdHZhclxuXHRcdFx0Zm9ybWF0dGVyICA9IHNldHRpbmdzLmZuRm9ybWF0TnVtYmVyLFxuXHRcdFx0c3RhcnQgICAgICA9IHNldHRpbmdzLl9pRGlzcGxheVN0YXJ0KzEsXG5cdFx0XHRsZW4gICAgICAgID0gc2V0dGluZ3MuX2lEaXNwbGF5TGVuZ3RoLFxuXHRcdFx0dmlzICAgICAgICA9IHNldHRpbmdzLmZuUmVjb3Jkc0Rpc3BsYXkoKSxcblx0XHRcdGFsbCAgICAgICAgPSBsZW4gPT09IC0xO1xuXHRcblx0XHRyZXR1cm4gc3RyLlxuXHRcdFx0cmVwbGFjZSgvX1NUQVJUXy9nLCBmb3JtYXR0ZXIuY2FsbCggc2V0dGluZ3MsIHN0YXJ0ICkgKS5cblx0XHRcdHJlcGxhY2UoL19FTkRfL2csICAgZm9ybWF0dGVyLmNhbGwoIHNldHRpbmdzLCBzZXR0aW5ncy5mbkRpc3BsYXlFbmQoKSApICkuXG5cdFx0XHRyZXBsYWNlKC9fTUFYXy9nLCAgIGZvcm1hdHRlci5jYWxsKCBzZXR0aW5ncywgc2V0dGluZ3MuZm5SZWNvcmRzVG90YWwoKSApICkuXG5cdFx0XHRyZXBsYWNlKC9fVE9UQUxfL2csIGZvcm1hdHRlci5jYWxsKCBzZXR0aW5ncywgdmlzICkgKS5cblx0XHRcdHJlcGxhY2UoL19QQUdFXy9nLCAgZm9ybWF0dGVyLmNhbGwoIHNldHRpbmdzLCBhbGwgPyAxIDogTWF0aC5jZWlsKCBzdGFydCAvIGxlbiApICkgKS5cblx0XHRcdHJlcGxhY2UoL19QQUdFU18vZywgZm9ybWF0dGVyLmNhbGwoIHNldHRpbmdzLCBhbGwgPyAxIDogTWF0aC5jZWlsKCB2aXMgLyBsZW4gKSApICk7XG5cdH1cblx0XG5cdFxuXHRcblx0LyoqXG5cdCAqIERyYXcgdGhlIHRhYmxlIGZvciB0aGUgZmlyc3QgdGltZSwgYWRkaW5nIGFsbCByZXF1aXJlZCBmZWF0dXJlc1xuXHQgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkluaXRpYWxpc2UgKCBzZXR0aW5ncyApXG5cdHtcblx0XHR2YXIgaSwgaUxlbiwgaUFqYXhTdGFydD1zZXR0aW5ncy5pSW5pdERpc3BsYXlTdGFydDtcblx0XHR2YXIgY29sdW1ucyA9IHNldHRpbmdzLmFvQ29sdW1ucywgY29sdW1uO1xuXHRcdHZhciBmZWF0dXJlcyA9IHNldHRpbmdzLm9GZWF0dXJlcztcblx0XHR2YXIgZGVmZXJMb2FkaW5nID0gc2V0dGluZ3MuYkRlZmVyTG9hZGluZzsgLy8gdmFsdWUgbW9kaWZpZWQgYnkgdGhlIGRyYXdcblx0XG5cdFx0LyogRW5zdXJlIHRoYXQgdGhlIHRhYmxlIGRhdGEgaXMgZnVsbHkgaW5pdGlhbGlzZWQgKi9cblx0XHRpZiAoICEgc2V0dGluZ3MuYkluaXRpYWxpc2VkICkge1xuXHRcdFx0c2V0VGltZW91dCggZnVuY3Rpb24oKXsgX2ZuSW5pdGlhbGlzZSggc2V0dGluZ3MgKTsgfSwgMjAwICk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcblx0XHQvKiBTaG93IHRoZSBkaXNwbGF5IEhUTUwgb3B0aW9ucyAqL1xuXHRcdF9mbkFkZE9wdGlvbnNIdG1sKCBzZXR0aW5ncyApO1xuXHRcblx0XHQvKiBCdWlsZCBhbmQgZHJhdyB0aGUgaGVhZGVyIC8gZm9vdGVyIGZvciB0aGUgdGFibGUgKi9cblx0XHRfZm5CdWlsZEhlYWQoIHNldHRpbmdzICk7XG5cdFx0X2ZuRHJhd0hlYWQoIHNldHRpbmdzLCBzZXR0aW5ncy5hb0hlYWRlciApO1xuXHRcdF9mbkRyYXdIZWFkKCBzZXR0aW5ncywgc2V0dGluZ3MuYW9Gb290ZXIgKTtcblx0XG5cdFx0LyogT2theSB0byBzaG93IHRoYXQgc29tZXRoaW5nIGlzIGdvaW5nIG9uIG5vdyAqL1xuXHRcdF9mblByb2Nlc3NpbmdEaXNwbGF5KCBzZXR0aW5ncywgdHJ1ZSApO1xuXHRcblx0XHQvKiBDYWxjdWxhdGUgc2l6ZXMgZm9yIGNvbHVtbnMgKi9cblx0XHRpZiAoIGZlYXR1cmVzLmJBdXRvV2lkdGggKSB7XG5cdFx0XHRfZm5DYWxjdWxhdGVDb2x1bW5XaWR0aHMoIHNldHRpbmdzICk7XG5cdFx0fVxuXHRcblx0XHRmb3IgKCBpPTAsIGlMZW49Y29sdW1ucy5sZW5ndGggOyBpPGlMZW4gOyBpKysgKSB7XG5cdFx0XHRjb2x1bW4gPSBjb2x1bW5zW2ldO1xuXHRcblx0XHRcdGlmICggY29sdW1uLnNXaWR0aCApIHtcblx0XHRcdFx0Y29sdW1uLm5UaC5zdHlsZS53aWR0aCA9IF9mblN0cmluZ1RvQ3NzKCBjb2x1bW4uc1dpZHRoICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcblx0XHRfZm5DYWxsYmFja0ZpcmUoIHNldHRpbmdzLCBudWxsLCAncHJlSW5pdCcsIFtzZXR0aW5nc10gKTtcblx0XG5cdFx0Ly8gSWYgdGhlcmUgaXMgZGVmYXVsdCBzb3J0aW5nIHJlcXVpcmVkIC0gbGV0J3MgZG8gaXQuIFRoZSBzb3J0IGZ1bmN0aW9uXG5cdFx0Ly8gd2lsbCBkbyB0aGUgZHJhd2luZyBmb3IgdXMuIE90aGVyd2lzZSB3ZSBkcmF3IHRoZSB0YWJsZSByZWdhcmRsZXNzIG9mIHRoZVxuXHRcdC8vIEFqYXggc291cmNlIC0gdGhpcyBhbGxvd3MgdGhlIHRhYmxlIHRvIGxvb2sgaW5pdGlhbGlzZWQgZm9yIEFqYXggc291cmNpbmdcblx0XHQvLyBkYXRhIChzaG93ICdsb2FkaW5nJyBtZXNzYWdlIHBvc3NpYmx5KVxuXHRcdF9mblJlRHJhdyggc2V0dGluZ3MgKTtcblx0XG5cdFx0Ly8gU2VydmVyLXNpZGUgcHJvY2Vzc2luZyBpbml0IGNvbXBsZXRlIGlzIGRvbmUgYnkgX2ZuQWpheFVwZGF0ZURyYXdcblx0XHR2YXIgZGF0YVNyYyA9IF9mbkRhdGFTb3VyY2UoIHNldHRpbmdzICk7XG5cdFx0aWYgKCBkYXRhU3JjICE9ICdzc3AnIHx8IGRlZmVyTG9hZGluZyApIHtcblx0XHRcdC8vIGlmIHRoZXJlIGlzIGFuIGFqYXggc291cmNlIGxvYWQgdGhlIGRhdGFcblx0XHRcdGlmICggZGF0YVNyYyA9PSAnYWpheCcgKSB7XG5cdFx0XHRcdF9mbkJ1aWxkQWpheCggc2V0dGluZ3MsIFtdLCBmdW5jdGlvbihqc29uKSB7XG5cdFx0XHRcdFx0dmFyIGFEYXRhID0gX2ZuQWpheERhdGFTcmMoIHNldHRpbmdzLCBqc29uICk7XG5cdFxuXHRcdFx0XHRcdC8vIEdvdCB0aGUgZGF0YSAtIGFkZCBpdCB0byB0aGUgdGFibGVcblx0XHRcdFx0XHRmb3IgKCBpPTAgOyBpPGFEYXRhLmxlbmd0aCA7IGkrKyApIHtcblx0XHRcdFx0XHRcdF9mbkFkZERhdGEoIHNldHRpbmdzLCBhRGF0YVtpXSApO1xuXHRcdFx0XHRcdH1cblx0XG5cdFx0XHRcdFx0Ly8gUmVzZXQgdGhlIGluaXQgZGlzcGxheSBmb3IgY29va2llIHNhdmluZy4gV2UndmUgYWxyZWFkeSBkb25lXG5cdFx0XHRcdFx0Ly8gYSBmaWx0ZXIsIGFuZCB0aGVyZWZvcmUgY2xlYXJlZCBpdCBiZWZvcmUuIFNvIHdlIG5lZWQgdG8gbWFrZVxuXHRcdFx0XHRcdC8vIGl0IGFwcGVhciAnZnJlc2gnXG5cdFx0XHRcdFx0c2V0dGluZ3MuaUluaXREaXNwbGF5U3RhcnQgPSBpQWpheFN0YXJ0O1xuXHRcblx0XHRcdFx0XHRfZm5SZURyYXcoIHNldHRpbmdzICk7XG5cdFxuXHRcdFx0XHRcdF9mblByb2Nlc3NpbmdEaXNwbGF5KCBzZXR0aW5ncywgZmFsc2UgKTtcblx0XHRcdFx0XHRfZm5Jbml0Q29tcGxldGUoIHNldHRpbmdzLCBqc29uICk7XG5cdFx0XHRcdH0sIHNldHRpbmdzICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0X2ZuUHJvY2Vzc2luZ0Rpc3BsYXkoIHNldHRpbmdzLCBmYWxzZSApO1xuXHRcdFx0XHRfZm5Jbml0Q29tcGxldGUoIHNldHRpbmdzICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIERyYXcgdGhlIHRhYmxlIGZvciB0aGUgZmlyc3QgdGltZSwgYWRkaW5nIGFsbCByZXF1aXJlZCBmZWF0dXJlc1xuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IFtqc29uXSBKU09OIGZyb20gdGhlIHNlcnZlciB0aGF0IGNvbXBsZXRlZCB0aGUgdGFibGUsIGlmIHVzaW5nIEFqYXggc291cmNlXG5cdCAqICAgIHdpdGggY2xpZW50LXNpZGUgcHJvY2Vzc2luZyAob3B0aW9uYWwpXG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkluaXRDb21wbGV0ZSAoIHNldHRpbmdzLCBqc29uIClcblx0e1xuXHRcdHNldHRpbmdzLl9iSW5pdENvbXBsZXRlID0gdHJ1ZTtcblx0XG5cdFx0Ly8gV2hlbiBkYXRhIHdhcyBhZGRlZCBhZnRlciB0aGUgaW5pdGlhbGlzYXRpb24gKGRhdGEgb3IgQWpheCkgd2UgbmVlZCB0b1xuXHRcdC8vIGNhbGN1bGF0ZSB0aGUgY29sdW1uIHNpemluZ1xuXHRcdGlmICgganNvbiB8fCBzZXR0aW5ncy5vSW5pdC5hYURhdGEgKSB7XG5cdFx0XHRfZm5BZGp1c3RDb2x1bW5TaXppbmcoIHNldHRpbmdzICk7XG5cdFx0fVxuXHRcblx0XHRfZm5DYWxsYmFja0ZpcmUoIHNldHRpbmdzLCBudWxsLCAncGx1Z2luLWluaXQnLCBbc2V0dGluZ3MsIGpzb25dICk7XG5cdFx0X2ZuQ2FsbGJhY2tGaXJlKCBzZXR0aW5ncywgJ2FvSW5pdENvbXBsZXRlJywgJ2luaXQnLCBbc2V0dGluZ3MsIGpzb25dICk7XG5cdH1cblx0XG5cdFxuXHRmdW5jdGlvbiBfZm5MZW5ndGhDaGFuZ2UgKCBzZXR0aW5ncywgdmFsIClcblx0e1xuXHRcdHZhciBsZW4gPSBwYXJzZUludCggdmFsLCAxMCApO1xuXHRcdHNldHRpbmdzLl9pRGlzcGxheUxlbmd0aCA9IGxlbjtcblx0XG5cdFx0X2ZuTGVuZ3RoT3ZlcmZsb3coIHNldHRpbmdzICk7XG5cdFxuXHRcdC8vIEZpcmUgbGVuZ3RoIGNoYW5nZSBldmVudFxuXHRcdF9mbkNhbGxiYWNrRmlyZSggc2V0dGluZ3MsIG51bGwsICdsZW5ndGgnLCBbc2V0dGluZ3MsIGxlbl0gKTtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBHZW5lcmF0ZSB0aGUgbm9kZSByZXF1aXJlZCBmb3IgdXNlciBkaXNwbGF5IGxlbmd0aCBjaGFuZ2luZ1xuXHQgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcmV0dXJucyB7bm9kZX0gRGlzcGxheSBsZW5ndGggZmVhdHVyZSBub2RlXG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkZlYXR1cmVIdG1sTGVuZ3RoICggc2V0dGluZ3MgKVxuXHR7XG5cdFx0dmFyXG5cdFx0XHRjbGFzc2VzICA9IHNldHRpbmdzLm9DbGFzc2VzLFxuXHRcdFx0dGFibGVJZCAgPSBzZXR0aW5ncy5zVGFibGVJZCxcblx0XHRcdG1lbnUgICAgID0gc2V0dGluZ3MuYUxlbmd0aE1lbnUsXG5cdFx0XHRkMiAgICAgICA9ICQuaXNBcnJheSggbWVudVswXSApLFxuXHRcdFx0bGVuZ3RocyAgPSBkMiA/IG1lbnVbMF0gOiBtZW51LFxuXHRcdFx0bGFuZ3VhZ2UgPSBkMiA/IG1lbnVbMV0gOiBtZW51O1xuXHRcblx0XHR2YXIgc2VsZWN0ID0gJCgnPHNlbGVjdC8+Jywge1xuXHRcdFx0J25hbWUnOiAgICAgICAgICB0YWJsZUlkKydfbGVuZ3RoJyxcblx0XHRcdCdhcmlhLWNvbnRyb2xzJzogdGFibGVJZCxcblx0XHRcdCdjbGFzcyc6ICAgICAgICAgY2xhc3Nlcy5zTGVuZ3RoU2VsZWN0XG5cdFx0fSApO1xuXHRcblx0XHRmb3IgKCB2YXIgaT0wLCBpZW49bGVuZ3Rocy5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdHNlbGVjdFswXVsgaSBdID0gbmV3IE9wdGlvbihcblx0XHRcdFx0dHlwZW9mIGxhbmd1YWdlW2ldID09PSAnbnVtYmVyJyA/XG5cdFx0XHRcdFx0c2V0dGluZ3MuZm5Gb3JtYXROdW1iZXIoIGxhbmd1YWdlW2ldICkgOlxuXHRcdFx0XHRcdGxhbmd1YWdlW2ldLFxuXHRcdFx0XHRsZW5ndGhzW2ldXG5cdFx0XHQpO1xuXHRcdH1cblx0XG5cdFx0dmFyIGRpdiA9ICQoJzxkaXY+PGxhYmVsLz48L2Rpdj4nKS5hZGRDbGFzcyggY2xhc3Nlcy5zTGVuZ3RoICk7XG5cdFx0aWYgKCAhIHNldHRpbmdzLmFhbkZlYXR1cmVzLmwgKSB7XG5cdFx0XHRkaXZbMF0uaWQgPSB0YWJsZUlkKydfbGVuZ3RoJztcblx0XHR9XG5cdFxuXHRcdGRpdi5jaGlsZHJlbigpLmFwcGVuZChcblx0XHRcdHNldHRpbmdzLm9MYW5ndWFnZS5zTGVuZ3RoTWVudS5yZXBsYWNlKCAnX01FTlVfJywgc2VsZWN0WzBdLm91dGVySFRNTCApXG5cdFx0KTtcblx0XG5cdFx0Ly8gQ2FuJ3QgdXNlIGBzZWxlY3RgIHZhcmlhYmxlIGFzIHVzZXIgbWlnaHQgcHJvdmlkZSB0aGVpciBvd24gYW5kIHRoZVxuXHRcdC8vIHJlZmVyZW5jZSBpcyBicm9rZW4gYnkgdGhlIHVzZSBvZiBvdXRlckhUTUxcblx0XHQkKCdzZWxlY3QnLCBkaXYpXG5cdFx0XHQudmFsKCBzZXR0aW5ncy5faURpc3BsYXlMZW5ndGggKVxuXHRcdFx0Lm9uKCAnY2hhbmdlLkRUJywgZnVuY3Rpb24oZSkge1xuXHRcdFx0XHRfZm5MZW5ndGhDaGFuZ2UoIHNldHRpbmdzLCAkKHRoaXMpLnZhbCgpICk7XG5cdFx0XHRcdF9mbkRyYXcoIHNldHRpbmdzICk7XG5cdFx0XHR9ICk7XG5cdFxuXHRcdC8vIFVwZGF0ZSBub2RlIHZhbHVlIHdoZW5ldmVyIGFueXRoaW5nIGNoYW5nZXMgdGhlIHRhYmxlJ3MgbGVuZ3RoXG5cdFx0JChzZXR0aW5ncy5uVGFibGUpLm9uKCAnbGVuZ3RoLmR0LkRUJywgZnVuY3Rpb24gKGUsIHMsIGxlbikge1xuXHRcdFx0aWYgKCBzZXR0aW5ncyA9PT0gcyApIHtcblx0XHRcdFx0JCgnc2VsZWN0JywgZGl2KS52YWwoIGxlbiApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XG5cdFx0cmV0dXJuIGRpdlswXTtcblx0fVxuXHRcblx0XG5cdFxuXHQvKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKlxuXHQgKiBOb3RlIHRoYXQgbW9zdCBvZiB0aGUgcGFnaW5nIGxvZ2ljIGlzIGRvbmUgaW5cblx0ICogRGF0YVRhYmxlLmV4dC5wYWdlclxuXHQgKi9cblx0XG5cdC8qKlxuXHQgKiBHZW5lcmF0ZSB0aGUgbm9kZSByZXF1aXJlZCBmb3IgZGVmYXVsdCBwYWdpbmF0aW9uXG5cdCAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcmV0dXJucyB7bm9kZX0gUGFnaW5hdGlvbiBmZWF0dXJlIG5vZGVcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuRmVhdHVyZUh0bWxQYWdpbmF0ZSAoIHNldHRpbmdzIClcblx0e1xuXHRcdHZhclxuXHRcdFx0dHlwZSAgID0gc2V0dGluZ3Muc1BhZ2luYXRpb25UeXBlLFxuXHRcdFx0cGx1Z2luID0gRGF0YVRhYmxlLmV4dC5wYWdlclsgdHlwZSBdLFxuXHRcdFx0bW9kZXJuID0gdHlwZW9mIHBsdWdpbiA9PT0gJ2Z1bmN0aW9uJyxcblx0XHRcdHJlZHJhdyA9IGZ1bmN0aW9uKCBzZXR0aW5ncyApIHtcblx0XHRcdFx0X2ZuRHJhdyggc2V0dGluZ3MgKTtcblx0XHRcdH0sXG5cdFx0XHRub2RlID0gJCgnPGRpdi8+JykuYWRkQ2xhc3MoIHNldHRpbmdzLm9DbGFzc2VzLnNQYWdpbmcgKyB0eXBlIClbMF0sXG5cdFx0XHRmZWF0dXJlcyA9IHNldHRpbmdzLmFhbkZlYXR1cmVzO1xuXHRcblx0XHRpZiAoICEgbW9kZXJuICkge1xuXHRcdFx0cGx1Z2luLmZuSW5pdCggc2V0dGluZ3MsIG5vZGUsIHJlZHJhdyApO1xuXHRcdH1cblx0XG5cdFx0LyogQWRkIGEgZHJhdyBjYWxsYmFjayBmb3IgdGhlIHBhZ2luYXRpb24gb24gZmlyc3QgaW5zdGFuY2UsIHRvIHVwZGF0ZSB0aGUgcGFnaW5nIGRpc3BsYXkgKi9cblx0XHRpZiAoICEgZmVhdHVyZXMucCApXG5cdFx0e1xuXHRcdFx0bm9kZS5pZCA9IHNldHRpbmdzLnNUYWJsZUlkKydfcGFnaW5hdGUnO1xuXHRcblx0XHRcdHNldHRpbmdzLmFvRHJhd0NhbGxiYWNrLnB1c2goIHtcblx0XHRcdFx0XCJmblwiOiBmdW5jdGlvbiggc2V0dGluZ3MgKSB7XG5cdFx0XHRcdFx0aWYgKCBtb2Rlcm4gKSB7XG5cdFx0XHRcdFx0XHR2YXJcblx0XHRcdFx0XHRcdFx0c3RhcnQgICAgICA9IHNldHRpbmdzLl9pRGlzcGxheVN0YXJ0LFxuXHRcdFx0XHRcdFx0XHRsZW4gICAgICAgID0gc2V0dGluZ3MuX2lEaXNwbGF5TGVuZ3RoLFxuXHRcdFx0XHRcdFx0XHR2aXNSZWNvcmRzID0gc2V0dGluZ3MuZm5SZWNvcmRzRGlzcGxheSgpLFxuXHRcdFx0XHRcdFx0XHRhbGwgICAgICAgID0gbGVuID09PSAtMSxcblx0XHRcdFx0XHRcdFx0cGFnZSA9IGFsbCA/IDAgOiBNYXRoLmNlaWwoIHN0YXJ0IC8gbGVuICksXG5cdFx0XHRcdFx0XHRcdHBhZ2VzID0gYWxsID8gMSA6IE1hdGguY2VpbCggdmlzUmVjb3JkcyAvIGxlbiApLFxuXHRcdFx0XHRcdFx0XHRidXR0b25zID0gcGx1Z2luKHBhZ2UsIHBhZ2VzKSxcblx0XHRcdFx0XHRcdFx0aSwgaWVuO1xuXHRcblx0XHRcdFx0XHRcdGZvciAoIGk9MCwgaWVuPWZlYXR1cmVzLnAubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdFx0XHRcdF9mblJlbmRlcmVyKCBzZXR0aW5ncywgJ3BhZ2VCdXR0b24nICkoXG5cdFx0XHRcdFx0XHRcdFx0c2V0dGluZ3MsIGZlYXR1cmVzLnBbaV0sIGksIGJ1dHRvbnMsIHBhZ2UsIHBhZ2VzXG5cdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0cGx1Z2luLmZuVXBkYXRlKCBzZXR0aW5ncywgcmVkcmF3ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRcInNOYW1lXCI6IFwicGFnaW5hdGlvblwiXG5cdFx0XHR9ICk7XG5cdFx0fVxuXHRcblx0XHRyZXR1cm4gbm9kZTtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBBbHRlciB0aGUgZGlzcGxheSBzZXR0aW5ncyB0byBjaGFuZ2UgdGhlIHBhZ2Vcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHtzdHJpbmd8aW50fSBhY3Rpb24gUGFnaW5nIGFjdGlvbiB0byB0YWtlOiBcImZpcnN0XCIsIFwicHJldmlvdXNcIixcblx0ICogICAgXCJuZXh0XCIgb3IgXCJsYXN0XCIgb3IgcGFnZSBudW1iZXIgdG8ganVtcCB0byAoaW50ZWdlcilcblx0ICogIEBwYXJhbSBbYm9vbF0gcmVkcmF3IEF1dG9tYXRpY2FsbHkgZHJhdyB0aGUgdXBkYXRlIG9yIG5vdFxuXHQgKiAgQHJldHVybnMge2Jvb2x9IHRydWUgcGFnZSBoYXMgY2hhbmdlZCwgZmFsc2UgLSBubyBjaGFuZ2Vcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuUGFnZUNoYW5nZSAoIHNldHRpbmdzLCBhY3Rpb24sIHJlZHJhdyApXG5cdHtcblx0XHR2YXJcblx0XHRcdHN0YXJ0ICAgICA9IHNldHRpbmdzLl9pRGlzcGxheVN0YXJ0LFxuXHRcdFx0bGVuICAgICAgID0gc2V0dGluZ3MuX2lEaXNwbGF5TGVuZ3RoLFxuXHRcdFx0cmVjb3JkcyAgID0gc2V0dGluZ3MuZm5SZWNvcmRzRGlzcGxheSgpO1xuXHRcblx0XHRpZiAoIHJlY29yZHMgPT09IDAgfHwgbGVuID09PSAtMSApXG5cdFx0e1xuXHRcdFx0c3RhcnQgPSAwO1xuXHRcdH1cblx0XHRlbHNlIGlmICggdHlwZW9mIGFjdGlvbiA9PT0gXCJudW1iZXJcIiApXG5cdFx0e1xuXHRcdFx0c3RhcnQgPSBhY3Rpb24gKiBsZW47XG5cdFxuXHRcdFx0aWYgKCBzdGFydCA+IHJlY29yZHMgKVxuXHRcdFx0e1xuXHRcdFx0XHRzdGFydCA9IDA7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCBhY3Rpb24gPT0gXCJmaXJzdFwiIClcblx0XHR7XG5cdFx0XHRzdGFydCA9IDA7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCBhY3Rpb24gPT0gXCJwcmV2aW91c1wiIClcblx0XHR7XG5cdFx0XHRzdGFydCA9IGxlbiA+PSAwID9cblx0XHRcdFx0c3RhcnQgLSBsZW4gOlxuXHRcdFx0XHQwO1xuXHRcblx0XHRcdGlmICggc3RhcnQgPCAwIClcblx0XHRcdHtcblx0XHRcdCAgc3RhcnQgPSAwO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIGlmICggYWN0aW9uID09IFwibmV4dFwiIClcblx0XHR7XG5cdFx0XHRpZiAoIHN0YXJ0ICsgbGVuIDwgcmVjb3JkcyApXG5cdFx0XHR7XG5cdFx0XHRcdHN0YXJ0ICs9IGxlbjtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSBpZiAoIGFjdGlvbiA9PSBcImxhc3RcIiApXG5cdFx0e1xuXHRcdFx0c3RhcnQgPSBNYXRoLmZsb29yKCAocmVjb3Jkcy0xKSAvIGxlbikgKiBsZW47XG5cdFx0fVxuXHRcdGVsc2Vcblx0XHR7XG5cdFx0XHRfZm5Mb2coIHNldHRpbmdzLCAwLCBcIlVua25vd24gcGFnaW5nIGFjdGlvbjogXCIrYWN0aW9uLCA1ICk7XG5cdFx0fVxuXHRcblx0XHR2YXIgY2hhbmdlZCA9IHNldHRpbmdzLl9pRGlzcGxheVN0YXJ0ICE9PSBzdGFydDtcblx0XHRzZXR0aW5ncy5faURpc3BsYXlTdGFydCA9IHN0YXJ0O1xuXHRcblx0XHRpZiAoIGNoYW5nZWQgKSB7XG5cdFx0XHRfZm5DYWxsYmFja0ZpcmUoIHNldHRpbmdzLCBudWxsLCAncGFnZScsIFtzZXR0aW5nc10gKTtcblx0XG5cdFx0XHRpZiAoIHJlZHJhdyApIHtcblx0XHRcdFx0X2ZuRHJhdyggc2V0dGluZ3MgKTtcblx0XHRcdH1cblx0XHR9XG5cdFxuXHRcdHJldHVybiBjaGFuZ2VkO1xuXHR9XG5cdFxuXHRcblx0XG5cdC8qKlxuXHQgKiBHZW5lcmF0ZSB0aGUgbm9kZSByZXF1aXJlZCBmb3IgdGhlIHByb2Nlc3Npbmcgbm9kZVxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcmV0dXJucyB7bm9kZX0gUHJvY2Vzc2luZyBlbGVtZW50XG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkZlYXR1cmVIdG1sUHJvY2Vzc2luZyAoIHNldHRpbmdzIClcblx0e1xuXHRcdHJldHVybiAkKCc8ZGl2Lz4nLCB7XG5cdFx0XHRcdCdpZCc6ICEgc2V0dGluZ3MuYWFuRmVhdHVyZXMuciA/IHNldHRpbmdzLnNUYWJsZUlkKydfcHJvY2Vzc2luZycgOiBudWxsLFxuXHRcdFx0XHQnY2xhc3MnOiBzZXR0aW5ncy5vQ2xhc3Nlcy5zUHJvY2Vzc2luZ1xuXHRcdFx0fSApXG5cdFx0XHQuaHRtbCggc2V0dGluZ3Mub0xhbmd1YWdlLnNQcm9jZXNzaW5nIClcblx0XHRcdC5pbnNlcnRCZWZvcmUoIHNldHRpbmdzLm5UYWJsZSApWzBdO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIERpc3BsYXkgb3IgaGlkZSB0aGUgcHJvY2Vzc2luZyBpbmRpY2F0b3Jcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHtib29sfSBzaG93IFNob3cgdGhlIHByb2Nlc3NpbmcgaW5kaWNhdG9yICh0cnVlKSBvciBub3QgKGZhbHNlKVxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5Qcm9jZXNzaW5nRGlzcGxheSAoIHNldHRpbmdzLCBzaG93IClcblx0e1xuXHRcdGlmICggc2V0dGluZ3Mub0ZlYXR1cmVzLmJQcm9jZXNzaW5nICkge1xuXHRcdFx0JChzZXR0aW5ncy5hYW5GZWF0dXJlcy5yKS5jc3MoICdkaXNwbGF5Jywgc2hvdyA/ICdibG9jaycgOiAnbm9uZScgKTtcblx0XHR9XG5cdFxuXHRcdF9mbkNhbGxiYWNrRmlyZSggc2V0dGluZ3MsIG51bGwsICdwcm9jZXNzaW5nJywgW3NldHRpbmdzLCBzaG93XSApO1xuXHR9XG5cdFxuXHQvKipcblx0ICogQWRkIGFueSBjb250cm9sIGVsZW1lbnRzIGZvciB0aGUgdGFibGUgLSBzcGVjaWZpY2FsbHkgc2Nyb2xsaW5nXG5cdCAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEByZXR1cm5zIHtub2RlfSBOb2RlIHRvIGFkZCB0byB0aGUgRE9NXG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkZlYXR1cmVIdG1sVGFibGUgKCBzZXR0aW5ncyApXG5cdHtcblx0XHR2YXIgdGFibGUgPSAkKHNldHRpbmdzLm5UYWJsZSk7XG5cdFxuXHRcdC8vIEFkZCB0aGUgQVJJQSBncmlkIHJvbGUgdG8gdGhlIHRhYmxlXG5cdFx0dGFibGUuYXR0ciggJ3JvbGUnLCAnZ3JpZCcgKTtcblx0XG5cdFx0Ly8gU2Nyb2xsaW5nIGZyb20gaGVyZSBvbiBpblxuXHRcdHZhciBzY3JvbGwgPSBzZXR0aW5ncy5vU2Nyb2xsO1xuXHRcblx0XHRpZiAoIHNjcm9sbC5zWCA9PT0gJycgJiYgc2Nyb2xsLnNZID09PSAnJyApIHtcblx0XHRcdHJldHVybiBzZXR0aW5ncy5uVGFibGU7XG5cdFx0fVxuXHRcblx0XHR2YXIgc2Nyb2xsWCA9IHNjcm9sbC5zWDtcblx0XHR2YXIgc2Nyb2xsWSA9IHNjcm9sbC5zWTtcblx0XHR2YXIgY2xhc3NlcyA9IHNldHRpbmdzLm9DbGFzc2VzO1xuXHRcdHZhciBjYXB0aW9uID0gdGFibGUuY2hpbGRyZW4oJ2NhcHRpb24nKTtcblx0XHR2YXIgY2FwdGlvblNpZGUgPSBjYXB0aW9uLmxlbmd0aCA/IGNhcHRpb25bMF0uX2NhcHRpb25TaWRlIDogbnVsbDtcblx0XHR2YXIgaGVhZGVyQ2xvbmUgPSAkKCB0YWJsZVswXS5jbG9uZU5vZGUoZmFsc2UpICk7XG5cdFx0dmFyIGZvb3RlckNsb25lID0gJCggdGFibGVbMF0uY2xvbmVOb2RlKGZhbHNlKSApO1xuXHRcdHZhciBmb290ZXIgPSB0YWJsZS5jaGlsZHJlbigndGZvb3QnKTtcblx0XHR2YXIgX2RpdiA9ICc8ZGl2Lz4nO1xuXHRcdHZhciBzaXplID0gZnVuY3Rpb24gKCBzICkge1xuXHRcdFx0cmV0dXJuICFzID8gbnVsbCA6IF9mblN0cmluZ1RvQ3NzKCBzICk7XG5cdFx0fTtcblx0XG5cdFx0aWYgKCAhIGZvb3Rlci5sZW5ndGggKSB7XG5cdFx0XHRmb290ZXIgPSBudWxsO1xuXHRcdH1cblx0XG5cdFx0Lypcblx0XHQgKiBUaGUgSFRNTCBzdHJ1Y3R1cmUgdGhhdCB3ZSB3YW50IHRvIGdlbmVyYXRlIGluIHRoaXMgZnVuY3Rpb24gaXM6XG5cdFx0ICogIGRpdiAtIHNjcm9sbGVyXG5cdFx0ICogICAgZGl2IC0gc2Nyb2xsIGhlYWRcblx0XHQgKiAgICAgIGRpdiAtIHNjcm9sbCBoZWFkIGlubmVyXG5cdFx0ICogICAgICAgIHRhYmxlIC0gc2Nyb2xsIGhlYWQgdGFibGVcblx0XHQgKiAgICAgICAgICB0aGVhZCAtIHRoZWFkXG5cdFx0ICogICAgZGl2IC0gc2Nyb2xsIGJvZHlcblx0XHQgKiAgICAgIHRhYmxlIC0gdGFibGUgKG1hc3RlciB0YWJsZSlcblx0XHQgKiAgICAgICAgdGhlYWQgLSB0aGVhZCBjbG9uZSBmb3Igc2l6aW5nXG5cdFx0ICogICAgICAgIHRib2R5IC0gdGJvZHlcblx0XHQgKiAgICBkaXYgLSBzY3JvbGwgZm9vdFxuXHRcdCAqICAgICAgZGl2IC0gc2Nyb2xsIGZvb3QgaW5uZXJcblx0XHQgKiAgICAgICAgdGFibGUgLSBzY3JvbGwgZm9vdCB0YWJsZVxuXHRcdCAqICAgICAgICAgIHRmb290IC0gdGZvb3Rcblx0XHQgKi9cblx0XHR2YXIgc2Nyb2xsZXIgPSAkKCBfZGl2LCB7ICdjbGFzcyc6IGNsYXNzZXMuc1Njcm9sbFdyYXBwZXIgfSApXG5cdFx0XHQuYXBwZW5kKFxuXHRcdFx0XHQkKF9kaXYsIHsgJ2NsYXNzJzogY2xhc3Nlcy5zU2Nyb2xsSGVhZCB9IClcblx0XHRcdFx0XHQuY3NzKCB7XG5cdFx0XHRcdFx0XHRvdmVyZmxvdzogJ2hpZGRlbicsXG5cdFx0XHRcdFx0XHRwb3NpdGlvbjogJ3JlbGF0aXZlJyxcblx0XHRcdFx0XHRcdGJvcmRlcjogMCxcblx0XHRcdFx0XHRcdHdpZHRoOiBzY3JvbGxYID8gc2l6ZShzY3JvbGxYKSA6ICcxMDAlJ1xuXHRcdFx0XHRcdH0gKVxuXHRcdFx0XHRcdC5hcHBlbmQoXG5cdFx0XHRcdFx0XHQkKF9kaXYsIHsgJ2NsYXNzJzogY2xhc3Nlcy5zU2Nyb2xsSGVhZElubmVyIH0gKVxuXHRcdFx0XHRcdFx0XHQuY3NzKCB7XG5cdFx0XHRcdFx0XHRcdFx0J2JveC1zaXppbmcnOiAnY29udGVudC1ib3gnLFxuXHRcdFx0XHRcdFx0XHRcdHdpZHRoOiBzY3JvbGwuc1hJbm5lciB8fCAnMTAwJSdcblx0XHRcdFx0XHRcdFx0fSApXG5cdFx0XHRcdFx0XHRcdC5hcHBlbmQoXG5cdFx0XHRcdFx0XHRcdFx0aGVhZGVyQ2xvbmVcblx0XHRcdFx0XHRcdFx0XHRcdC5yZW1vdmVBdHRyKCdpZCcpXG5cdFx0XHRcdFx0XHRcdFx0XHQuY3NzKCAnbWFyZ2luLWxlZnQnLCAwIClcblx0XHRcdFx0XHRcdFx0XHRcdC5hcHBlbmQoIGNhcHRpb25TaWRlID09PSAndG9wJyA/IGNhcHRpb24gOiBudWxsIClcblx0XHRcdFx0XHRcdFx0XHRcdC5hcHBlbmQoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRhYmxlLmNoaWxkcmVuKCd0aGVhZCcpXG5cdFx0XHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHQpXG5cdFx0XHQpXG5cdFx0XHQuYXBwZW5kKFxuXHRcdFx0XHQkKF9kaXYsIHsgJ2NsYXNzJzogY2xhc3Nlcy5zU2Nyb2xsQm9keSB9IClcblx0XHRcdFx0XHQuY3NzKCB7XG5cdFx0XHRcdFx0XHRwb3NpdGlvbjogJ3JlbGF0aXZlJyxcblx0XHRcdFx0XHRcdG92ZXJmbG93OiAnYXV0bycsXG5cdFx0XHRcdFx0XHR3aWR0aDogc2l6ZSggc2Nyb2xsWCApXG5cdFx0XHRcdFx0fSApXG5cdFx0XHRcdFx0LmFwcGVuZCggdGFibGUgKVxuXHRcdFx0KTtcblx0XG5cdFx0aWYgKCBmb290ZXIgKSB7XG5cdFx0XHRzY3JvbGxlci5hcHBlbmQoXG5cdFx0XHRcdCQoX2RpdiwgeyAnY2xhc3MnOiBjbGFzc2VzLnNTY3JvbGxGb290IH0gKVxuXHRcdFx0XHRcdC5jc3MoIHtcblx0XHRcdFx0XHRcdG92ZXJmbG93OiAnaGlkZGVuJyxcblx0XHRcdFx0XHRcdGJvcmRlcjogMCxcblx0XHRcdFx0XHRcdHdpZHRoOiBzY3JvbGxYID8gc2l6ZShzY3JvbGxYKSA6ICcxMDAlJ1xuXHRcdFx0XHRcdH0gKVxuXHRcdFx0XHRcdC5hcHBlbmQoXG5cdFx0XHRcdFx0XHQkKF9kaXYsIHsgJ2NsYXNzJzogY2xhc3Nlcy5zU2Nyb2xsRm9vdElubmVyIH0gKVxuXHRcdFx0XHRcdFx0XHQuYXBwZW5kKFxuXHRcdFx0XHRcdFx0XHRcdGZvb3RlckNsb25lXG5cdFx0XHRcdFx0XHRcdFx0XHQucmVtb3ZlQXR0cignaWQnKVxuXHRcdFx0XHRcdFx0XHRcdFx0LmNzcyggJ21hcmdpbi1sZWZ0JywgMCApXG5cdFx0XHRcdFx0XHRcdFx0XHQuYXBwZW5kKCBjYXB0aW9uU2lkZSA9PT0gJ2JvdHRvbScgPyBjYXB0aW9uIDogbnVsbCApXG5cdFx0XHRcdFx0XHRcdFx0XHQuYXBwZW5kKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0YWJsZS5jaGlsZHJlbigndGZvb3QnKVxuXHRcdFx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0KVxuXHRcdFx0KTtcblx0XHR9XG5cdFxuXHRcdHZhciBjaGlsZHJlbiA9IHNjcm9sbGVyLmNoaWxkcmVuKCk7XG5cdFx0dmFyIHNjcm9sbEhlYWQgPSBjaGlsZHJlblswXTtcblx0XHR2YXIgc2Nyb2xsQm9keSA9IGNoaWxkcmVuWzFdO1xuXHRcdHZhciBzY3JvbGxGb290ID0gZm9vdGVyID8gY2hpbGRyZW5bMl0gOiBudWxsO1xuXHRcblx0XHQvLyBXaGVuIHRoZSBib2R5IGlzIHNjcm9sbGVkLCB0aGVuIHdlIGFsc28gd2FudCB0byBzY3JvbGwgdGhlIGhlYWRlcnNcblx0XHRpZiAoIHNjcm9sbFggKSB7XG5cdFx0XHQkKHNjcm9sbEJvZHkpLm9uKCAnc2Nyb2xsLkRUJywgZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0dmFyIHNjcm9sbExlZnQgPSB0aGlzLnNjcm9sbExlZnQ7XG5cdFxuXHRcdFx0XHRzY3JvbGxIZWFkLnNjcm9sbExlZnQgPSBzY3JvbGxMZWZ0O1xuXHRcblx0XHRcdFx0aWYgKCBmb290ZXIgKSB7XG5cdFx0XHRcdFx0c2Nyb2xsRm9vdC5zY3JvbGxMZWZ0ID0gc2Nyb2xsTGVmdDtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH1cblx0XG5cdFx0JChzY3JvbGxCb2R5KS5jc3MoJ21heC1oZWlnaHQnLCBzY3JvbGxZKTtcblx0XHRpZiAoISBzY3JvbGwuYkNvbGxhcHNlKSB7XG5cdFx0XHQkKHNjcm9sbEJvZHkpLmNzcygnaGVpZ2h0Jywgc2Nyb2xsWSk7XG5cdFx0fVxuXHRcblx0XHRzZXR0aW5ncy5uU2Nyb2xsSGVhZCA9IHNjcm9sbEhlYWQ7XG5cdFx0c2V0dGluZ3MublNjcm9sbEJvZHkgPSBzY3JvbGxCb2R5O1xuXHRcdHNldHRpbmdzLm5TY3JvbGxGb290ID0gc2Nyb2xsRm9vdDtcblx0XG5cdFx0Ly8gT24gcmVkcmF3IC0gYWxpZ24gY29sdW1uc1xuXHRcdHNldHRpbmdzLmFvRHJhd0NhbGxiYWNrLnB1c2goIHtcblx0XHRcdFwiZm5cIjogX2ZuU2Nyb2xsRHJhdyxcblx0XHRcdFwic05hbWVcIjogXCJzY3JvbGxpbmdcIlxuXHRcdH0gKTtcblx0XG5cdFx0cmV0dXJuIHNjcm9sbGVyWzBdO1xuXHR9XG5cdFxuXHRcblx0XG5cdC8qKlxuXHQgKiBVcGRhdGUgdGhlIGhlYWRlciwgZm9vdGVyIGFuZCBib2R5IHRhYmxlcyBmb3IgcmVzaXppbmcgLSBpLmUuIGNvbHVtblxuXHQgKiBhbGlnbm1lbnQuXG5cdCAqXG5cdCAqIFdlbGNvbWUgdG8gdGhlIG1vc3QgaG9ycmlibGUgZnVuY3Rpb24gRGF0YVRhYmxlcy4gVGhlIHByb2Nlc3MgdGhhdCB0aGlzXG5cdCAqIGZ1bmN0aW9uIGZvbGxvd3MgaXMgYmFzaWNhbGx5OlxuXHQgKiAgIDEuIFJlLWNyZWF0ZSB0aGUgdGFibGUgaW5zaWRlIHRoZSBzY3JvbGxpbmcgZGl2XG5cdCAqICAgMi4gVGFrZSBsaXZlIG1lYXN1cmVtZW50cyBmcm9tIHRoZSBET01cblx0ICogICAzLiBBcHBseSB0aGUgbWVhc3VyZW1lbnRzIHRvIGFsaWduIHRoZSBjb2x1bW5zXG5cdCAqICAgNC4gQ2xlYW4gdXBcblx0ICpcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5TY3JvbGxEcmF3ICggc2V0dGluZ3MgKVxuXHR7XG5cdFx0Ly8gR2l2ZW4gdGhhdCB0aGlzIGlzIHN1Y2ggYSBtb25zdGVyIGZ1bmN0aW9uLCBhIGxvdCBvZiB2YXJpYWJsZXMgYXJlIHVzZVxuXHRcdC8vIHRvIHRyeSBhbmQga2VlcCB0aGUgbWluaW1pc2VkIHNpemUgYXMgc21hbGwgYXMgcG9zc2libGVcblx0XHR2YXJcblx0XHRcdHNjcm9sbCAgICAgICAgID0gc2V0dGluZ3Mub1Njcm9sbCxcblx0XHRcdHNjcm9sbFggICAgICAgID0gc2Nyb2xsLnNYLFxuXHRcdFx0c2Nyb2xsWElubmVyICAgPSBzY3JvbGwuc1hJbm5lcixcblx0XHRcdHNjcm9sbFkgICAgICAgID0gc2Nyb2xsLnNZLFxuXHRcdFx0YmFyV2lkdGggICAgICAgPSBzY3JvbGwuaUJhcldpZHRoLFxuXHRcdFx0ZGl2SGVhZGVyICAgICAgPSAkKHNldHRpbmdzLm5TY3JvbGxIZWFkKSxcblx0XHRcdGRpdkhlYWRlclN0eWxlID0gZGl2SGVhZGVyWzBdLnN0eWxlLFxuXHRcdFx0ZGl2SGVhZGVySW5uZXIgPSBkaXZIZWFkZXIuY2hpbGRyZW4oJ2RpdicpLFxuXHRcdFx0ZGl2SGVhZGVySW5uZXJTdHlsZSA9IGRpdkhlYWRlcklubmVyWzBdLnN0eWxlLFxuXHRcdFx0ZGl2SGVhZGVyVGFibGUgPSBkaXZIZWFkZXJJbm5lci5jaGlsZHJlbigndGFibGUnKSxcblx0XHRcdGRpdkJvZHlFbCAgICAgID0gc2V0dGluZ3MublNjcm9sbEJvZHksXG5cdFx0XHRkaXZCb2R5ICAgICAgICA9ICQoZGl2Qm9keUVsKSxcblx0XHRcdGRpdkJvZHlTdHlsZSAgID0gZGl2Qm9keUVsLnN0eWxlLFxuXHRcdFx0ZGl2Rm9vdGVyICAgICAgPSAkKHNldHRpbmdzLm5TY3JvbGxGb290KSxcblx0XHRcdGRpdkZvb3RlcklubmVyID0gZGl2Rm9vdGVyLmNoaWxkcmVuKCdkaXYnKSxcblx0XHRcdGRpdkZvb3RlclRhYmxlID0gZGl2Rm9vdGVySW5uZXIuY2hpbGRyZW4oJ3RhYmxlJyksXG5cdFx0XHRoZWFkZXIgICAgICAgICA9ICQoc2V0dGluZ3MublRIZWFkKSxcblx0XHRcdHRhYmxlICAgICAgICAgID0gJChzZXR0aW5ncy5uVGFibGUpLFxuXHRcdFx0dGFibGVFbCAgICAgICAgPSB0YWJsZVswXSxcblx0XHRcdHRhYmxlU3R5bGUgICAgID0gdGFibGVFbC5zdHlsZSxcblx0XHRcdGZvb3RlciAgICAgICAgID0gc2V0dGluZ3MublRGb290ID8gJChzZXR0aW5ncy5uVEZvb3QpIDogbnVsbCxcblx0XHRcdGJyb3dzZXIgICAgICAgID0gc2V0dGluZ3Mub0Jyb3dzZXIsXG5cdFx0XHRpZTY3ICAgICAgICAgICA9IGJyb3dzZXIuYlNjcm9sbE92ZXJzaXplLFxuXHRcdFx0ZHRIZWFkZXJDZWxscyAgPSBfcGx1Y2soIHNldHRpbmdzLmFvQ29sdW1ucywgJ25UaCcgKSxcblx0XHRcdGhlYWRlclRyZ0VscywgZm9vdGVyVHJnRWxzLFxuXHRcdFx0aGVhZGVyU3JjRWxzLCBmb290ZXJTcmNFbHMsXG5cdFx0XHRoZWFkZXJDb3B5LCBmb290ZXJDb3B5LFxuXHRcdFx0aGVhZGVyV2lkdGhzPVtdLCBmb290ZXJXaWR0aHM9W10sXG5cdFx0XHRoZWFkZXJDb250ZW50PVtdLCBmb290ZXJDb250ZW50PVtdLFxuXHRcdFx0aWR4LCBjb3JyZWN0aW9uLCBzYW5pdHlXaWR0aCxcblx0XHRcdHplcm9PdXQgPSBmdW5jdGlvbihuU2l6ZXIpIHtcblx0XHRcdFx0dmFyIHN0eWxlID0gblNpemVyLnN0eWxlO1xuXHRcdFx0XHRzdHlsZS5wYWRkaW5nVG9wID0gXCIwXCI7XG5cdFx0XHRcdHN0eWxlLnBhZGRpbmdCb3R0b20gPSBcIjBcIjtcblx0XHRcdFx0c3R5bGUuYm9yZGVyVG9wV2lkdGggPSBcIjBcIjtcblx0XHRcdFx0c3R5bGUuYm9yZGVyQm90dG9tV2lkdGggPSBcIjBcIjtcblx0XHRcdFx0c3R5bGUuaGVpZ2h0ID0gMDtcblx0XHRcdH07XG5cdFxuXHRcdC8vIElmIHRoZSBzY3JvbGxiYXIgdmlzaWJpbGl0eSBoYXMgY2hhbmdlZCBmcm9tIHRoZSBsYXN0IGRyYXcsIHdlIG5lZWQgdG9cblx0XHQvLyBhZGp1c3QgdGhlIGNvbHVtbiBzaXplcyBhcyB0aGUgdGFibGUgd2lkdGggd2lsbCBoYXZlIGNoYW5nZWQgdG8gYWNjb3VudFxuXHRcdC8vIGZvciB0aGUgc2Nyb2xsYmFyXG5cdFx0dmFyIHNjcm9sbEJhclZpcyA9IGRpdkJvZHlFbC5zY3JvbGxIZWlnaHQgPiBkaXZCb2R5RWwuY2xpZW50SGVpZ2h0O1xuXHRcdFxuXHRcdGlmICggc2V0dGluZ3Muc2Nyb2xsQmFyVmlzICE9PSBzY3JvbGxCYXJWaXMgJiYgc2V0dGluZ3Muc2Nyb2xsQmFyVmlzICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRzZXR0aW5ncy5zY3JvbGxCYXJWaXMgPSBzY3JvbGxCYXJWaXM7XG5cdFx0XHRfZm5BZGp1c3RDb2x1bW5TaXppbmcoIHNldHRpbmdzICk7XG5cdFx0XHRyZXR1cm47IC8vIGFkanVzdCBjb2x1bW4gc2l6aW5nIHdpbGwgY2FsbCB0aGlzIGZ1bmN0aW9uIGFnYWluXG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0c2V0dGluZ3Muc2Nyb2xsQmFyVmlzID0gc2Nyb2xsQmFyVmlzO1xuXHRcdH1cblx0XG5cdFx0Lypcblx0XHQgKiAxLiBSZS1jcmVhdGUgdGhlIHRhYmxlIGluc2lkZSB0aGUgc2Nyb2xsaW5nIGRpdlxuXHRcdCAqL1xuXHRcblx0XHQvLyBSZW1vdmUgdGhlIG9sZCBtaW5pbWlzZWQgdGhlYWQgYW5kIHRmb290IGVsZW1lbnRzIGluIHRoZSBpbm5lciB0YWJsZVxuXHRcdHRhYmxlLmNoaWxkcmVuKCd0aGVhZCwgdGZvb3QnKS5yZW1vdmUoKTtcblx0XG5cdFx0aWYgKCBmb290ZXIgKSB7XG5cdFx0XHRmb290ZXJDb3B5ID0gZm9vdGVyLmNsb25lKCkucHJlcGVuZFRvKCB0YWJsZSApO1xuXHRcdFx0Zm9vdGVyVHJnRWxzID0gZm9vdGVyLmZpbmQoJ3RyJyk7IC8vIHRoZSBvcmlnaW5hbCB0Zm9vdCBpcyBpbiBpdHMgb3duIHRhYmxlIGFuZCBtdXN0IGJlIHNpemVkXG5cdFx0XHRmb290ZXJTcmNFbHMgPSBmb290ZXJDb3B5LmZpbmQoJ3RyJyk7XG5cdFx0fVxuXHRcblx0XHQvLyBDbG9uZSB0aGUgY3VycmVudCBoZWFkZXIgYW5kIGZvb3RlciBlbGVtZW50cyBhbmQgdGhlbiBwbGFjZSBpdCBpbnRvIHRoZSBpbm5lciB0YWJsZVxuXHRcdGhlYWRlckNvcHkgPSBoZWFkZXIuY2xvbmUoKS5wcmVwZW5kVG8oIHRhYmxlICk7XG5cdFx0aGVhZGVyVHJnRWxzID0gaGVhZGVyLmZpbmQoJ3RyJyk7IC8vIG9yaWdpbmFsIGhlYWRlciBpcyBpbiBpdHMgb3duIHRhYmxlXG5cdFx0aGVhZGVyU3JjRWxzID0gaGVhZGVyQ29weS5maW5kKCd0cicpO1xuXHRcdGhlYWRlckNvcHkuZmluZCgndGgsIHRkJykucmVtb3ZlQXR0cigndGFiaW5kZXgnKTtcblx0XG5cdFxuXHRcdC8qXG5cdFx0ICogMi4gVGFrZSBsaXZlIG1lYXN1cmVtZW50cyBmcm9tIHRoZSBET00gLSBkbyBub3QgYWx0ZXIgdGhlIERPTSBpdHNlbGYhXG5cdFx0ICovXG5cdFxuXHRcdC8vIFJlbW92ZSBvbGQgc2l6aW5nIGFuZCBhcHBseSB0aGUgY2FsY3VsYXRlZCBjb2x1bW4gd2lkdGhzXG5cdFx0Ly8gR2V0IHRoZSB1bmlxdWUgY29sdW1uIGhlYWRlcnMgaW4gdGhlIG5ld2x5IGNyZWF0ZWQgKGNsb25lZCkgaGVhZGVyLiBXZSB3YW50IHRvIGFwcGx5IHRoZVxuXHRcdC8vIGNhbGN1bGF0ZWQgc2l6ZXMgdG8gdGhpcyBoZWFkZXJcblx0XHRpZiAoICEgc2Nyb2xsWCApXG5cdFx0e1xuXHRcdFx0ZGl2Qm9keVN0eWxlLndpZHRoID0gJzEwMCUnO1xuXHRcdFx0ZGl2SGVhZGVyWzBdLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuXHRcdH1cblx0XG5cdFx0JC5lYWNoKCBfZm5HZXRVbmlxdWVUaHMoIHNldHRpbmdzLCBoZWFkZXJDb3B5ICksIGZ1bmN0aW9uICggaSwgZWwgKSB7XG5cdFx0XHRpZHggPSBfZm5WaXNpYmxlVG9Db2x1bW5JbmRleCggc2V0dGluZ3MsIGkgKTtcblx0XHRcdGVsLnN0eWxlLndpZHRoID0gc2V0dGluZ3MuYW9Db2x1bW5zW2lkeF0uc1dpZHRoO1xuXHRcdH0gKTtcblx0XG5cdFx0aWYgKCBmb290ZXIgKSB7XG5cdFx0XHRfZm5BcHBseVRvQ2hpbGRyZW4oIGZ1bmN0aW9uKG4pIHtcblx0XHRcdFx0bi5zdHlsZS53aWR0aCA9IFwiXCI7XG5cdFx0XHR9LCBmb290ZXJTcmNFbHMgKTtcblx0XHR9XG5cdFxuXHRcdC8vIFNpemUgdGhlIHRhYmxlIGFzIGEgd2hvbGVcblx0XHRzYW5pdHlXaWR0aCA9IHRhYmxlLm91dGVyV2lkdGgoKTtcblx0XHRpZiAoIHNjcm9sbFggPT09IFwiXCIgKSB7XG5cdFx0XHQvLyBObyB4IHNjcm9sbGluZ1xuXHRcdFx0dGFibGVTdHlsZS53aWR0aCA9IFwiMTAwJVwiO1xuXHRcblx0XHRcdC8vIElFNyB3aWxsIG1ha2UgdGhlIHdpZHRoIG9mIHRoZSB0YWJsZSB3aGVuIDEwMCUgaW5jbHVkZSB0aGUgc2Nyb2xsYmFyXG5cdFx0XHQvLyAtIHdoaWNoIGlzIHNob3VsZG4ndC4gV2hlbiB0aGVyZSBpcyBhIHNjcm9sbGJhciB3ZSBuZWVkIHRvIHRha2UgdGhpc1xuXHRcdFx0Ly8gaW50byBhY2NvdW50LlxuXHRcdFx0aWYgKCBpZTY3ICYmICh0YWJsZS5maW5kKCd0Ym9keScpLmhlaWdodCgpID4gZGl2Qm9keUVsLm9mZnNldEhlaWdodCB8fFxuXHRcdFx0XHRkaXZCb2R5LmNzcygnb3ZlcmZsb3cteScpID09IFwic2Nyb2xsXCIpXG5cdFx0XHQpIHtcblx0XHRcdFx0dGFibGVTdHlsZS53aWR0aCA9IF9mblN0cmluZ1RvQ3NzKCB0YWJsZS5vdXRlcldpZHRoKCkgLSBiYXJXaWR0aCk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gUmVjYWxjdWxhdGUgdGhlIHNhbml0eSB3aWR0aFxuXHRcdFx0c2FuaXR5V2lkdGggPSB0YWJsZS5vdXRlcldpZHRoKCk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCBzY3JvbGxYSW5uZXIgIT09IFwiXCIgKSB7XG5cdFx0XHQvLyBsZWdhY3kgeCBzY3JvbGwgaW5uZXIgaGFzIGJlZW4gZ2l2ZW4gLSB1c2UgaXRcblx0XHRcdHRhYmxlU3R5bGUud2lkdGggPSBfZm5TdHJpbmdUb0NzcyhzY3JvbGxYSW5uZXIpO1xuXHRcblx0XHRcdC8vIFJlY2FsY3VsYXRlIHRoZSBzYW5pdHkgd2lkdGhcblx0XHRcdHNhbml0eVdpZHRoID0gdGFibGUub3V0ZXJXaWR0aCgpO1xuXHRcdH1cblx0XG5cdFx0Ly8gSGlkZGVuIGhlYWRlciBzaG91bGQgaGF2ZSB6ZXJvIGhlaWdodCwgc28gcmVtb3ZlIHBhZGRpbmcgYW5kIGJvcmRlcnMuIFRoZW5cblx0XHQvLyBzZXQgdGhlIHdpZHRoIGJhc2VkIG9uIHRoZSByZWFsIGhlYWRlcnNcblx0XG5cdFx0Ly8gQXBwbHkgYWxsIHN0eWxlcyBpbiBvbmUgcGFzc1xuXHRcdF9mbkFwcGx5VG9DaGlsZHJlbiggemVyb091dCwgaGVhZGVyU3JjRWxzICk7XG5cdFxuXHRcdC8vIFJlYWQgYWxsIHdpZHRocyBpbiBuZXh0IHBhc3Ncblx0XHRfZm5BcHBseVRvQ2hpbGRyZW4oIGZ1bmN0aW9uKG5TaXplcikge1xuXHRcdFx0aGVhZGVyQ29udGVudC5wdXNoKCBuU2l6ZXIuaW5uZXJIVE1MICk7XG5cdFx0XHRoZWFkZXJXaWR0aHMucHVzaCggX2ZuU3RyaW5nVG9Dc3MoICQoblNpemVyKS5jc3MoJ3dpZHRoJykgKSApO1xuXHRcdH0sIGhlYWRlclNyY0VscyApO1xuXHRcblx0XHQvLyBBcHBseSBhbGwgd2lkdGhzIGluIGZpbmFsIHBhc3Ncblx0XHRfZm5BcHBseVRvQ2hpbGRyZW4oIGZ1bmN0aW9uKG5Ub1NpemUsIGkpIHtcblx0XHRcdC8vIE9ubHkgYXBwbHkgd2lkdGhzIHRvIHRoZSBEYXRhVGFibGVzIGRldGVjdGVkIGhlYWRlciBjZWxscyAtIHRoaXNcblx0XHRcdC8vIHByZXZlbnRzIGNvbXBsZXggaGVhZGVycyBmcm9tIGhhdmluZyBjb250cmFkaWN0b3J5IHNpemVzIGFwcGxpZWRcblx0XHRcdGlmICggJC5pbkFycmF5KCBuVG9TaXplLCBkdEhlYWRlckNlbGxzICkgIT09IC0xICkge1xuXHRcdFx0XHRuVG9TaXplLnN0eWxlLndpZHRoID0gaGVhZGVyV2lkdGhzW2ldO1xuXHRcdFx0fVxuXHRcdH0sIGhlYWRlclRyZ0VscyApO1xuXHRcblx0XHQkKGhlYWRlclNyY0VscykuaGVpZ2h0KDApO1xuXHRcblx0XHQvKiBTYW1lIGFnYWluIHdpdGggdGhlIGZvb3RlciBpZiB3ZSBoYXZlIG9uZSAqL1xuXHRcdGlmICggZm9vdGVyIClcblx0XHR7XG5cdFx0XHRfZm5BcHBseVRvQ2hpbGRyZW4oIHplcm9PdXQsIGZvb3RlclNyY0VscyApO1xuXHRcblx0XHRcdF9mbkFwcGx5VG9DaGlsZHJlbiggZnVuY3Rpb24oblNpemVyKSB7XG5cdFx0XHRcdGZvb3RlckNvbnRlbnQucHVzaCggblNpemVyLmlubmVySFRNTCApO1xuXHRcdFx0XHRmb290ZXJXaWR0aHMucHVzaCggX2ZuU3RyaW5nVG9Dc3MoICQoblNpemVyKS5jc3MoJ3dpZHRoJykgKSApO1xuXHRcdFx0fSwgZm9vdGVyU3JjRWxzICk7XG5cdFxuXHRcdFx0X2ZuQXBwbHlUb0NoaWxkcmVuKCBmdW5jdGlvbihuVG9TaXplLCBpKSB7XG5cdFx0XHRcdG5Ub1NpemUuc3R5bGUud2lkdGggPSBmb290ZXJXaWR0aHNbaV07XG5cdFx0XHR9LCBmb290ZXJUcmdFbHMgKTtcblx0XG5cdFx0XHQkKGZvb3RlclNyY0VscykuaGVpZ2h0KDApO1xuXHRcdH1cblx0XG5cdFxuXHRcdC8qXG5cdFx0ICogMy4gQXBwbHkgdGhlIG1lYXN1cmVtZW50c1xuXHRcdCAqL1xuXHRcblx0XHQvLyBcIkhpZGVcIiB0aGUgaGVhZGVyIGFuZCBmb290ZXIgdGhhdCB3ZSB1c2VkIGZvciB0aGUgc2l6aW5nLiBXZSBuZWVkIHRvIGtlZXBcblx0XHQvLyB0aGUgY29udGVudCBvZiB0aGUgY2VsbCBzbyB0aGF0IHRoZSB3aWR0aCBhcHBsaWVkIHRvIHRoZSBoZWFkZXIgYW5kIGJvZHlcblx0XHQvLyBib3RoIG1hdGNoLCBidXQgd2Ugd2FudCB0byBoaWRlIGl0IGNvbXBsZXRlbHkuIFdlIHdhbnQgdG8gYWxzbyBmaXggdGhlaXJcblx0XHQvLyB3aWR0aCB0byB3aGF0IHRoZXkgY3VycmVudGx5IGFyZVxuXHRcdF9mbkFwcGx5VG9DaGlsZHJlbiggZnVuY3Rpb24oblNpemVyLCBpKSB7XG5cdFx0XHRuU2l6ZXIuaW5uZXJIVE1MID0gJzxkaXYgY2xhc3M9XCJkYXRhVGFibGVzX3NpemluZ1wiPicraGVhZGVyQ29udGVudFtpXSsnPC9kaXY+Jztcblx0XHRcdG5TaXplci5jaGlsZE5vZGVzWzBdLnN0eWxlLmhlaWdodCA9IFwiMFwiO1xuXHRcdFx0blNpemVyLmNoaWxkTm9kZXNbMF0uc3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xuXHRcdFx0blNpemVyLnN0eWxlLndpZHRoID0gaGVhZGVyV2lkdGhzW2ldO1xuXHRcdH0sIGhlYWRlclNyY0VscyApO1xuXHRcblx0XHRpZiAoIGZvb3RlciApXG5cdFx0e1xuXHRcdFx0X2ZuQXBwbHlUb0NoaWxkcmVuKCBmdW5jdGlvbihuU2l6ZXIsIGkpIHtcblx0XHRcdFx0blNpemVyLmlubmVySFRNTCA9ICc8ZGl2IGNsYXNzPVwiZGF0YVRhYmxlc19zaXppbmdcIj4nK2Zvb3RlckNvbnRlbnRbaV0rJzwvZGl2Pic7XG5cdFx0XHRcdG5TaXplci5jaGlsZE5vZGVzWzBdLnN0eWxlLmhlaWdodCA9IFwiMFwiO1xuXHRcdFx0XHRuU2l6ZXIuY2hpbGROb2Rlc1swXS5zdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG5cdFx0XHRcdG5TaXplci5zdHlsZS53aWR0aCA9IGZvb3RlcldpZHRoc1tpXTtcblx0XHRcdH0sIGZvb3RlclNyY0VscyApO1xuXHRcdH1cblx0XG5cdFx0Ly8gU2FuaXR5IGNoZWNrIHRoYXQgdGhlIHRhYmxlIGlzIG9mIGEgc2Vuc2libGUgd2lkdGguIElmIG5vdCB0aGVuIHdlIGFyZSBnb2luZyB0byBnZXRcblx0XHQvLyBtaXNhbGlnbm1lbnQgLSB0cnkgdG8gcHJldmVudCB0aGlzIGJ5IG5vdCBhbGxvd2luZyB0aGUgdGFibGUgdG8gc2hyaW5rIGJlbG93IGl0cyBtaW4gd2lkdGhcblx0XHRpZiAoIHRhYmxlLm91dGVyV2lkdGgoKSA8IHNhbml0eVdpZHRoIClcblx0XHR7XG5cdFx0XHQvLyBUaGUgbWluIHdpZHRoIGRlcGVuZHMgdXBvbiBpZiB3ZSBoYXZlIGEgdmVydGljYWwgc2Nyb2xsYmFyIHZpc2libGUgb3Igbm90ICovXG5cdFx0XHRjb3JyZWN0aW9uID0gKChkaXZCb2R5RWwuc2Nyb2xsSGVpZ2h0ID4gZGl2Qm9keUVsLm9mZnNldEhlaWdodCB8fFxuXHRcdFx0XHRkaXZCb2R5LmNzcygnb3ZlcmZsb3cteScpID09IFwic2Nyb2xsXCIpKSA/XG5cdFx0XHRcdFx0c2FuaXR5V2lkdGgrYmFyV2lkdGggOlxuXHRcdFx0XHRcdHNhbml0eVdpZHRoO1xuXHRcblx0XHRcdC8vIElFNi83IGFyZSBhIGxhdyB1bnRvIHRoZW1zZWx2ZXMuLi5cblx0XHRcdGlmICggaWU2NyAmJiAoZGl2Qm9keUVsLnNjcm9sbEhlaWdodCA+XG5cdFx0XHRcdGRpdkJvZHlFbC5vZmZzZXRIZWlnaHQgfHwgZGl2Qm9keS5jc3MoJ292ZXJmbG93LXknKSA9PSBcInNjcm9sbFwiKVxuXHRcdFx0KSB7XG5cdFx0XHRcdHRhYmxlU3R5bGUud2lkdGggPSBfZm5TdHJpbmdUb0NzcyggY29ycmVjdGlvbi1iYXJXaWR0aCApO1xuXHRcdFx0fVxuXHRcblx0XHRcdC8vIEFuZCBnaXZlIHRoZSB1c2VyIGEgd2FybmluZyB0aGF0IHdlJ3ZlIHN0b3BwZWQgdGhlIHRhYmxlIGdldHRpbmcgdG9vIHNtYWxsXG5cdFx0XHRpZiAoIHNjcm9sbFggPT09IFwiXCIgfHwgc2Nyb2xsWElubmVyICE9PSBcIlwiICkge1xuXHRcdFx0XHRfZm5Mb2coIHNldHRpbmdzLCAxLCAnUG9zc2libGUgY29sdW1uIG1pc2FsaWdubWVudCcsIDYgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZVxuXHRcdHtcblx0XHRcdGNvcnJlY3Rpb24gPSAnMTAwJSc7XG5cdFx0fVxuXHRcblx0XHQvLyBBcHBseSB0byB0aGUgY29udGFpbmVyIGVsZW1lbnRzXG5cdFx0ZGl2Qm9keVN0eWxlLndpZHRoID0gX2ZuU3RyaW5nVG9Dc3MoIGNvcnJlY3Rpb24gKTtcblx0XHRkaXZIZWFkZXJTdHlsZS53aWR0aCA9IF9mblN0cmluZ1RvQ3NzKCBjb3JyZWN0aW9uICk7XG5cdFxuXHRcdGlmICggZm9vdGVyICkge1xuXHRcdFx0c2V0dGluZ3MublNjcm9sbEZvb3Quc3R5bGUud2lkdGggPSBfZm5TdHJpbmdUb0NzcyggY29ycmVjdGlvbiApO1xuXHRcdH1cblx0XG5cdFxuXHRcdC8qXG5cdFx0ICogNC4gQ2xlYW4gdXBcblx0XHQgKi9cblx0XHRpZiAoICEgc2Nyb2xsWSApIHtcblx0XHRcdC8qIElFNzwgcHV0cyBhIHZlcnRpY2FsIHNjcm9sbGJhciBpbiBwbGFjZSAod2hlbiBpdCBzaG91bGRuJ3QgYmUpIGR1ZSB0byBzdWJ0cmFjdGluZ1xuXHRcdFx0ICogdGhlIHNjcm9sbGJhciBoZWlnaHQgZnJvbSB0aGUgdmlzaWJsZSBkaXNwbGF5LCByYXRoZXIgdGhhbiBhZGRpbmcgaXQgb24uIFdlIG5lZWQgdG9cblx0XHRcdCAqIHNldCB0aGUgaGVpZ2h0IGluIG9yZGVyIHRvIHNvcnQgdGhpcy4gRG9uJ3Qgd2FudCB0byBkbyBpdCBpbiBhbnkgb3RoZXIgYnJvd3NlcnMuXG5cdFx0XHQgKi9cblx0XHRcdGlmICggaWU2NyApIHtcblx0XHRcdFx0ZGl2Qm9keVN0eWxlLmhlaWdodCA9IF9mblN0cmluZ1RvQ3NzKCB0YWJsZUVsLm9mZnNldEhlaWdodCtiYXJXaWR0aCApO1xuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0LyogRmluYWxseSBzZXQgdGhlIHdpZHRoJ3Mgb2YgdGhlIGhlYWRlciBhbmQgZm9vdGVyIHRhYmxlcyAqL1xuXHRcdHZhciBpT3V0ZXJXaWR0aCA9IHRhYmxlLm91dGVyV2lkdGgoKTtcblx0XHRkaXZIZWFkZXJUYWJsZVswXS5zdHlsZS53aWR0aCA9IF9mblN0cmluZ1RvQ3NzKCBpT3V0ZXJXaWR0aCApO1xuXHRcdGRpdkhlYWRlcklubmVyU3R5bGUud2lkdGggPSBfZm5TdHJpbmdUb0NzcyggaU91dGVyV2lkdGggKTtcblx0XG5cdFx0Ly8gRmlndXJlIG91dCBpZiB0aGVyZSBhcmUgc2Nyb2xsYmFyIHByZXNlbnQgLSBpZiBzbyB0aGVuIHdlIG5lZWQgYSB0aGUgaGVhZGVyIGFuZCBmb290ZXIgdG9cblx0XHQvLyBwcm92aWRlIGEgYml0IG1vcmUgc3BhY2UgdG8gYWxsb3cgXCJvdmVyZmxvd1wiIHNjcm9sbGluZyAoaS5lLiBwYXN0IHRoZSBzY3JvbGxiYXIpXG5cdFx0dmFyIGJTY3JvbGxpbmcgPSB0YWJsZS5oZWlnaHQoKSA+IGRpdkJvZHlFbC5jbGllbnRIZWlnaHQgfHwgZGl2Qm9keS5jc3MoJ292ZXJmbG93LXknKSA9PSBcInNjcm9sbFwiO1xuXHRcdHZhciBwYWRkaW5nID0gJ3BhZGRpbmcnICsgKGJyb3dzZXIuYlNjcm9sbGJhckxlZnQgPyAnTGVmdCcgOiAnUmlnaHQnICk7XG5cdFx0ZGl2SGVhZGVySW5uZXJTdHlsZVsgcGFkZGluZyBdID0gYlNjcm9sbGluZyA/IGJhcldpZHRoK1wicHhcIiA6IFwiMHB4XCI7XG5cdFxuXHRcdGlmICggZm9vdGVyICkge1xuXHRcdFx0ZGl2Rm9vdGVyVGFibGVbMF0uc3R5bGUud2lkdGggPSBfZm5TdHJpbmdUb0NzcyggaU91dGVyV2lkdGggKTtcblx0XHRcdGRpdkZvb3RlcklubmVyWzBdLnN0eWxlLndpZHRoID0gX2ZuU3RyaW5nVG9Dc3MoIGlPdXRlcldpZHRoICk7XG5cdFx0XHRkaXZGb290ZXJJbm5lclswXS5zdHlsZVtwYWRkaW5nXSA9IGJTY3JvbGxpbmcgPyBiYXJXaWR0aCtcInB4XCIgOiBcIjBweFwiO1xuXHRcdH1cblx0XG5cdFx0Ly8gQ29ycmVjdCBET00gb3JkZXJpbmcgZm9yIGNvbGdyb3VwIC0gY29tZXMgYmVmb3JlIHRoZSB0aGVhZFxuXHRcdHRhYmxlLmNoaWxkcmVuKCdjb2xncm91cCcpLmluc2VydEJlZm9yZSggdGFibGUuY2hpbGRyZW4oJ3RoZWFkJykgKTtcblx0XG5cdFx0LyogQWRqdXN0IHRoZSBwb3NpdGlvbiBvZiB0aGUgaGVhZGVyIGluIGNhc2Ugd2UgbG9vc2UgdGhlIHktc2Nyb2xsYmFyICovXG5cdFx0ZGl2Qm9keS50cmlnZ2VyKCdzY3JvbGwnKTtcblx0XG5cdFx0Ly8gSWYgc29ydGluZyBvciBmaWx0ZXJpbmcgaGFzIG9jY3VycmVkLCBqdW1wIHRoZSBzY3JvbGxpbmcgYmFjayB0byB0aGUgdG9wXG5cdFx0Ly8gb25seSBpZiB3ZSBhcmVuJ3QgaG9sZGluZyB0aGUgcG9zaXRpb25cblx0XHRpZiAoIChzZXR0aW5ncy5iU29ydGVkIHx8IHNldHRpbmdzLmJGaWx0ZXJlZCkgJiYgISBzZXR0aW5ncy5fZHJhd0hvbGQgKSB7XG5cdFx0XHRkaXZCb2R5RWwuc2Nyb2xsVG9wID0gMDtcblx0XHR9XG5cdH1cblx0XG5cdFxuXHRcblx0LyoqXG5cdCAqIEFwcGx5IGEgZ2l2ZW4gZnVuY3Rpb24gdG8gdGhlIGRpc3BsYXkgY2hpbGQgbm9kZXMgb2YgYW4gZWxlbWVudCBhcnJheSAodHlwaWNhbGx5XG5cdCAqIFREIGNoaWxkcmVuIG9mIFRSIHJvd3Ncblx0ICogIEBwYXJhbSB7ZnVuY3Rpb259IGZuIE1ldGhvZCB0byBhcHBseSB0byB0aGUgb2JqZWN0c1xuXHQgKiAgQHBhcmFtIGFycmF5IHtub2Rlc30gYW4xIExpc3Qgb2YgZWxlbWVudHMgdG8gbG9vayB0aHJvdWdoIGZvciBkaXNwbGF5IGNoaWxkcmVuXG5cdCAqICBAcGFyYW0gYXJyYXkge25vZGVzfSBhbjIgQW5vdGhlciBsaXN0IChpZGVudGljYWwgc3RydWN0dXJlIHRvIHRoZSBmaXJzdCkgLSBvcHRpb25hbFxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5BcHBseVRvQ2hpbGRyZW4oIGZuLCBhbjEsIGFuMiApXG5cdHtcblx0XHR2YXIgaW5kZXg9MCwgaT0wLCBpTGVuPWFuMS5sZW5ndGg7XG5cdFx0dmFyIG5Ob2RlMSwgbk5vZGUyO1xuXHRcblx0XHR3aGlsZSAoIGkgPCBpTGVuICkge1xuXHRcdFx0bk5vZGUxID0gYW4xW2ldLmZpcnN0Q2hpbGQ7XG5cdFx0XHRuTm9kZTIgPSBhbjIgPyBhbjJbaV0uZmlyc3RDaGlsZCA6IG51bGw7XG5cdFxuXHRcdFx0d2hpbGUgKCBuTm9kZTEgKSB7XG5cdFx0XHRcdGlmICggbk5vZGUxLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdGlmICggYW4yICkge1xuXHRcdFx0XHRcdFx0Zm4oIG5Ob2RlMSwgbk5vZGUyLCBpbmRleCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdGZuKCBuTm9kZTEsIGluZGV4ICk7XG5cdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHRpbmRleCsrO1xuXHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRuTm9kZTEgPSBuTm9kZTEubmV4dFNpYmxpbmc7XG5cdFx0XHRcdG5Ob2RlMiA9IGFuMiA/IG5Ob2RlMi5uZXh0U2libGluZyA6IG51bGw7XG5cdFx0XHR9XG5cdFxuXHRcdFx0aSsrO1xuXHRcdH1cblx0fVxuXHRcblx0XG5cdFxuXHR2YXIgX19yZV9odG1sX3JlbW92ZSA9IC88Lio/Pi9nO1xuXHRcblx0XG5cdC8qKlxuXHQgKiBDYWxjdWxhdGUgdGhlIHdpZHRoIG9mIGNvbHVtbnMgZm9yIHRoZSB0YWJsZVxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5DYWxjdWxhdGVDb2x1bW5XaWR0aHMgKCBvU2V0dGluZ3MgKVxuXHR7XG5cdFx0dmFyXG5cdFx0XHR0YWJsZSA9IG9TZXR0aW5ncy5uVGFibGUsXG5cdFx0XHRjb2x1bW5zID0gb1NldHRpbmdzLmFvQ29sdW1ucyxcblx0XHRcdHNjcm9sbCA9IG9TZXR0aW5ncy5vU2Nyb2xsLFxuXHRcdFx0c2Nyb2xsWSA9IHNjcm9sbC5zWSxcblx0XHRcdHNjcm9sbFggPSBzY3JvbGwuc1gsXG5cdFx0XHRzY3JvbGxYSW5uZXIgPSBzY3JvbGwuc1hJbm5lcixcblx0XHRcdGNvbHVtbkNvdW50ID0gY29sdW1ucy5sZW5ndGgsXG5cdFx0XHR2aXNpYmxlQ29sdW1ucyA9IF9mbkdldENvbHVtbnMoIG9TZXR0aW5ncywgJ2JWaXNpYmxlJyApLFxuXHRcdFx0aGVhZGVyQ2VsbHMgPSAkKCd0aCcsIG9TZXR0aW5ncy5uVEhlYWQpLFxuXHRcdFx0dGFibGVXaWR0aEF0dHIgPSB0YWJsZS5nZXRBdHRyaWJ1dGUoJ3dpZHRoJyksIC8vIGZyb20gRE9NIGVsZW1lbnRcblx0XHRcdHRhYmxlQ29udGFpbmVyID0gdGFibGUucGFyZW50Tm9kZSxcblx0XHRcdHVzZXJJbnB1dHMgPSBmYWxzZSxcblx0XHRcdGksIGNvbHVtbiwgY29sdW1uSWR4LCB3aWR0aCwgb3V0ZXJXaWR0aCxcblx0XHRcdGJyb3dzZXIgPSBvU2V0dGluZ3Mub0Jyb3dzZXIsXG5cdFx0XHRpZTY3ID0gYnJvd3Nlci5iU2Nyb2xsT3ZlcnNpemU7XG5cdFxuXHRcdHZhciBzdHlsZVdpZHRoID0gdGFibGUuc3R5bGUud2lkdGg7XG5cdFx0aWYgKCBzdHlsZVdpZHRoICYmIHN0eWxlV2lkdGguaW5kZXhPZignJScpICE9PSAtMSApIHtcblx0XHRcdHRhYmxlV2lkdGhBdHRyID0gc3R5bGVXaWR0aDtcblx0XHR9XG5cdFxuXHRcdC8qIENvbnZlcnQgYW55IHVzZXIgaW5wdXQgc2l6ZXMgaW50byBwaXhlbCBzaXplcyAqL1xuXHRcdGZvciAoIGk9MCA7IGk8dmlzaWJsZUNvbHVtbnMubGVuZ3RoIDsgaSsrICkge1xuXHRcdFx0Y29sdW1uID0gY29sdW1uc1sgdmlzaWJsZUNvbHVtbnNbaV0gXTtcblx0XG5cdFx0XHRpZiAoIGNvbHVtbi5zV2lkdGggIT09IG51bGwgKSB7XG5cdFx0XHRcdGNvbHVtbi5zV2lkdGggPSBfZm5Db252ZXJ0VG9XaWR0aCggY29sdW1uLnNXaWR0aE9yaWcsIHRhYmxlQ29udGFpbmVyICk7XG5cdFxuXHRcdFx0XHR1c2VySW5wdXRzID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFxuXHRcdC8qIElmIHRoZSBudW1iZXIgb2YgY29sdW1ucyBpbiB0aGUgRE9NIGVxdWFscyB0aGUgbnVtYmVyIHRoYXQgd2UgaGF2ZSB0b1xuXHRcdCAqIHByb2Nlc3MgaW4gRGF0YVRhYmxlcywgdGhlbiB3ZSBjYW4gdXNlIHRoZSBvZmZzZXRzIHRoYXQgYXJlIGNyZWF0ZWQgYnlcblx0XHQgKiB0aGUgd2ViLSBicm93c2VyLiBObyBjdXN0b20gc2l6ZXMgY2FuIGJlIHNldCBpbiBvcmRlciBmb3IgdGhpcyB0byBoYXBwZW4sXG5cdFx0ICogbm9yIHNjcm9sbGluZyB1c2VkXG5cdFx0ICovXG5cdFx0aWYgKCBpZTY3IHx8ICEgdXNlcklucHV0cyAmJiAhIHNjcm9sbFggJiYgISBzY3JvbGxZICYmXG5cdFx0ICAgICBjb2x1bW5Db3VudCA9PSBfZm5WaXNibGVDb2x1bW5zKCBvU2V0dGluZ3MgKSAmJlxuXHRcdCAgICAgY29sdW1uQ291bnQgPT0gaGVhZGVyQ2VsbHMubGVuZ3RoXG5cdFx0KSB7XG5cdFx0XHRmb3IgKCBpPTAgOyBpPGNvbHVtbkNvdW50IDsgaSsrICkge1xuXHRcdFx0XHR2YXIgY29sSWR4ID0gX2ZuVmlzaWJsZVRvQ29sdW1uSW5kZXgoIG9TZXR0aW5ncywgaSApO1xuXHRcblx0XHRcdFx0aWYgKCBjb2xJZHggIT09IG51bGwgKSB7XG5cdFx0XHRcdFx0Y29sdW1uc1sgY29sSWR4IF0uc1dpZHRoID0gX2ZuU3RyaW5nVG9Dc3MoIGhlYWRlckNlbGxzLmVxKGkpLndpZHRoKCkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlXG5cdFx0e1xuXHRcdFx0Ly8gT3RoZXJ3aXNlIGNvbnN0cnVjdCBhIHNpbmdsZSByb3csIHdvcnN0IGNhc2UsIHRhYmxlIHdpdGggdGhlIHdpZGVzdFxuXHRcdFx0Ly8gbm9kZSBpbiB0aGUgZGF0YSwgYXNzaWduIGFueSB1c2VyIGRlZmluZWQgd2lkdGhzLCB0aGVuIGluc2VydCBpdCBpbnRvXG5cdFx0XHQvLyB0aGUgRE9NIGFuZCBhbGxvdyB0aGUgYnJvd3NlciB0byBkbyBhbGwgdGhlIGhhcmQgd29yayBvZiBjYWxjdWxhdGluZ1xuXHRcdFx0Ly8gdGFibGUgd2lkdGhzXG5cdFx0XHR2YXIgdG1wVGFibGUgPSAkKHRhYmxlKS5jbG9uZSgpIC8vIGRvbid0IHVzZSBjbG9uZU5vZGUgLSBJRTggd2lsbCByZW1vdmUgZXZlbnRzIG9uIHRoZSBtYWluIHRhYmxlXG5cdFx0XHRcdC5jc3MoICd2aXNpYmlsaXR5JywgJ2hpZGRlbicgKVxuXHRcdFx0XHQucmVtb3ZlQXR0ciggJ2lkJyApO1xuXHRcblx0XHRcdC8vIENsZWFuIHVwIHRoZSB0YWJsZSBib2R5XG5cdFx0XHR0bXBUYWJsZS5maW5kKCd0Ym9keSB0cicpLnJlbW92ZSgpO1xuXHRcdFx0dmFyIHRyID0gJCgnPHRyLz4nKS5hcHBlbmRUbyggdG1wVGFibGUuZmluZCgndGJvZHknKSApO1xuXHRcblx0XHRcdC8vIENsb25lIHRoZSB0YWJsZSBoZWFkZXIgYW5kIGZvb3RlciAtIHdlIGNhbid0IHVzZSB0aGUgaGVhZGVyIC8gZm9vdGVyXG5cdFx0XHQvLyBmcm9tIHRoZSBjbG9uZWQgdGFibGUsIHNpbmNlIGlmIHNjcm9sbGluZyBpcyBhY3RpdmUsIHRoZSB0YWJsZSdzXG5cdFx0XHQvLyByZWFsIGhlYWRlciBhbmQgZm9vdGVyIGFyZSBjb250YWluZWQgaW4gZGlmZmVyZW50IHRhYmxlIHRhZ3Ncblx0XHRcdHRtcFRhYmxlLmZpbmQoJ3RoZWFkLCB0Zm9vdCcpLnJlbW92ZSgpO1xuXHRcdFx0dG1wVGFibGVcblx0XHRcdFx0LmFwcGVuZCggJChvU2V0dGluZ3MublRIZWFkKS5jbG9uZSgpIClcblx0XHRcdFx0LmFwcGVuZCggJChvU2V0dGluZ3MublRGb290KS5jbG9uZSgpICk7XG5cdFxuXHRcdFx0Ly8gUmVtb3ZlIGFueSBhc3NpZ25lZCB3aWR0aHMgZnJvbSB0aGUgZm9vdGVyIChmcm9tIHNjcm9sbGluZylcblx0XHRcdHRtcFRhYmxlLmZpbmQoJ3Rmb290IHRoLCB0Zm9vdCB0ZCcpLmNzcygnd2lkdGgnLCAnJyk7XG5cdFxuXHRcdFx0Ly8gQXBwbHkgY3VzdG9tIHNpemluZyB0byB0aGUgY2xvbmVkIGhlYWRlclxuXHRcdFx0aGVhZGVyQ2VsbHMgPSBfZm5HZXRVbmlxdWVUaHMoIG9TZXR0aW5ncywgdG1wVGFibGUuZmluZCgndGhlYWQnKVswXSApO1xuXHRcblx0XHRcdGZvciAoIGk9MCA7IGk8dmlzaWJsZUNvbHVtbnMubGVuZ3RoIDsgaSsrICkge1xuXHRcdFx0XHRjb2x1bW4gPSBjb2x1bW5zWyB2aXNpYmxlQ29sdW1uc1tpXSBdO1xuXHRcblx0XHRcdFx0aGVhZGVyQ2VsbHNbaV0uc3R5bGUud2lkdGggPSBjb2x1bW4uc1dpZHRoT3JpZyAhPT0gbnVsbCAmJiBjb2x1bW4uc1dpZHRoT3JpZyAhPT0gJycgP1xuXHRcdFx0XHRcdF9mblN0cmluZ1RvQ3NzKCBjb2x1bW4uc1dpZHRoT3JpZyApIDpcblx0XHRcdFx0XHQnJztcblx0XG5cdFx0XHRcdC8vIEZvciBzY3JvbGxYIHdlIG5lZWQgdG8gZm9yY2UgdGhlIGNvbHVtbiB3aWR0aCBvdGhlcndpc2UgdGhlXG5cdFx0XHRcdC8vIGJyb3dzZXIgd2lsbCBjb2xsYXBzZSBpdC4gSWYgdGhpcyB3aWR0aCBpcyBzbWFsbGVyIHRoYW4gdGhlXG5cdFx0XHRcdC8vIHdpZHRoIHRoZSBjb2x1bW4gcmVxdWlyZXMsIHRoZW4gaXQgd2lsbCBoYXZlIG5vIGVmZmVjdFxuXHRcdFx0XHRpZiAoIGNvbHVtbi5zV2lkdGhPcmlnICYmIHNjcm9sbFggKSB7XG5cdFx0XHRcdFx0JCggaGVhZGVyQ2VsbHNbaV0gKS5hcHBlbmQoICQoJzxkaXYvPicpLmNzcygge1xuXHRcdFx0XHRcdFx0d2lkdGg6IGNvbHVtbi5zV2lkdGhPcmlnLFxuXHRcdFx0XHRcdFx0bWFyZ2luOiAwLFxuXHRcdFx0XHRcdFx0cGFkZGluZzogMCxcblx0XHRcdFx0XHRcdGJvcmRlcjogMCxcblx0XHRcdFx0XHRcdGhlaWdodDogMVxuXHRcdFx0XHRcdH0gKSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gRmluZCB0aGUgd2lkZXN0IGNlbGwgZm9yIGVhY2ggY29sdW1uIGFuZCBwdXQgaXQgaW50byB0aGUgdGFibGVcblx0XHRcdGlmICggb1NldHRpbmdzLmFvRGF0YS5sZW5ndGggKSB7XG5cdFx0XHRcdGZvciAoIGk9MCA7IGk8dmlzaWJsZUNvbHVtbnMubGVuZ3RoIDsgaSsrICkge1xuXHRcdFx0XHRcdGNvbHVtbklkeCA9IHZpc2libGVDb2x1bW5zW2ldO1xuXHRcdFx0XHRcdGNvbHVtbiA9IGNvbHVtbnNbIGNvbHVtbklkeCBdO1xuXHRcblx0XHRcdFx0XHQkKCBfZm5HZXRXaWRlc3ROb2RlKCBvU2V0dGluZ3MsIGNvbHVtbklkeCApIClcblx0XHRcdFx0XHRcdC5jbG9uZSggZmFsc2UgKVxuXHRcdFx0XHRcdFx0LmFwcGVuZCggY29sdW1uLnNDb250ZW50UGFkZGluZyApXG5cdFx0XHRcdFx0XHQuYXBwZW5kVG8oIHRyICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XG5cdFx0XHQvLyBUaWR5IHRoZSB0ZW1wb3JhcnkgdGFibGUgLSByZW1vdmUgbmFtZSBhdHRyaWJ1dGVzIHNvIHRoZXJlIGFyZW4ndFxuXHRcdFx0Ly8gZHVwbGljYXRlZCBpbiB0aGUgZG9tIChyYWRpbyBlbGVtZW50cyBmb3IgZXhhbXBsZSlcblx0XHRcdCQoJ1tuYW1lXScsIHRtcFRhYmxlKS5yZW1vdmVBdHRyKCduYW1lJyk7XG5cdFxuXHRcdFx0Ly8gVGFibGUgaGFzIGJlZW4gYnVpbHQsIGF0dGFjaCB0byB0aGUgZG9jdW1lbnQgc28gd2UgY2FuIHdvcmsgd2l0aCBpdC5cblx0XHRcdC8vIEEgaG9sZGluZyBlbGVtZW50IGlzIHVzZWQsIHBvc2l0aW9uZWQgYXQgdGhlIHRvcCBvZiB0aGUgY29udGFpbmVyXG5cdFx0XHQvLyB3aXRoIG1pbmltYWwgaGVpZ2h0LCBzbyBpdCBoYXMgbm8gZWZmZWN0IG9uIGlmIHRoZSBjb250YWluZXIgc2Nyb2xsc1xuXHRcdFx0Ly8gb3Igbm90LiBPdGhlcndpc2UgaXQgbWlnaHQgdHJpZ2dlciBzY3JvbGxpbmcgd2hlbiBpdCBhY3R1YWxseSBpc24ndFxuXHRcdFx0Ly8gbmVlZGVkXG5cdFx0XHR2YXIgaG9sZGVyID0gJCgnPGRpdi8+JykuY3NzKCBzY3JvbGxYIHx8IHNjcm9sbFkgP1xuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuXHRcdFx0XHRcdFx0dG9wOiAwLFxuXHRcdFx0XHRcdFx0bGVmdDogMCxcblx0XHRcdFx0XHRcdGhlaWdodDogMSxcblx0XHRcdFx0XHRcdHJpZ2h0OiAwLFxuXHRcdFx0XHRcdFx0b3ZlcmZsb3c6ICdoaWRkZW4nXG5cdFx0XHRcdFx0fSA6XG5cdFx0XHRcdFx0e31cblx0XHRcdFx0KVxuXHRcdFx0XHQuYXBwZW5kKCB0bXBUYWJsZSApXG5cdFx0XHRcdC5hcHBlbmRUbyggdGFibGVDb250YWluZXIgKTtcblx0XG5cdFx0XHQvLyBXaGVuIHNjcm9sbGluZyAoWCBvciBZKSB3ZSB3YW50IHRvIHNldCB0aGUgd2lkdGggb2YgdGhlIHRhYmxlIGFzIFxuXHRcdFx0Ly8gYXBwcm9wcmlhdGUuIEhvd2V2ZXIsIHdoZW4gbm90IHNjcm9sbGluZyBsZWF2ZSB0aGUgdGFibGUgd2lkdGggYXMgaXRcblx0XHRcdC8vIGlzLiBUaGlzIHJlc3VsdHMgaW4gc2xpZ2h0bHkgZGlmZmVyZW50LCBidXQgSSB0aGluayBjb3JyZWN0IGJlaGF2aW91clxuXHRcdFx0aWYgKCBzY3JvbGxYICYmIHNjcm9sbFhJbm5lciApIHtcblx0XHRcdFx0dG1wVGFibGUud2lkdGgoIHNjcm9sbFhJbm5lciApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIHNjcm9sbFggKSB7XG5cdFx0XHRcdHRtcFRhYmxlLmNzcyggJ3dpZHRoJywgJ2F1dG8nICk7XG5cdFx0XHRcdHRtcFRhYmxlLnJlbW92ZUF0dHIoJ3dpZHRoJyk7XG5cdFxuXHRcdFx0XHQvLyBJZiB0aGVyZSBpcyBubyB3aWR0aCBhdHRyaWJ1dGUgb3Igc3R5bGUsIHRoZW4gYWxsb3cgdGhlIHRhYmxlIHRvXG5cdFx0XHRcdC8vIGNvbGxhcHNlXG5cdFx0XHRcdGlmICggdG1wVGFibGUud2lkdGgoKSA8IHRhYmxlQ29udGFpbmVyLmNsaWVudFdpZHRoICYmIHRhYmxlV2lkdGhBdHRyICkge1xuXHRcdFx0XHRcdHRtcFRhYmxlLndpZHRoKCB0YWJsZUNvbnRhaW5lci5jbGllbnRXaWR0aCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggc2Nyb2xsWSApIHtcblx0XHRcdFx0dG1wVGFibGUud2lkdGgoIHRhYmxlQ29udGFpbmVyLmNsaWVudFdpZHRoICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggdGFibGVXaWR0aEF0dHIgKSB7XG5cdFx0XHRcdHRtcFRhYmxlLndpZHRoKCB0YWJsZVdpZHRoQXR0ciApO1xuXHRcdFx0fVxuXHRcblx0XHRcdC8vIEdldCB0aGUgd2lkdGggb2YgZWFjaCBjb2x1bW4gaW4gdGhlIGNvbnN0cnVjdGVkIHRhYmxlIC0gd2UgbmVlZCB0b1xuXHRcdFx0Ly8ga25vdyB0aGUgaW5uZXIgd2lkdGggKHNvIGl0IGNhbiBiZSBhc3NpZ25lZCB0byB0aGUgb3RoZXIgdGFibGUnc1xuXHRcdFx0Ly8gY2VsbHMpIGFuZCB0aGUgb3V0ZXIgd2lkdGggc28gd2UgY2FuIGNhbGN1bGF0ZSB0aGUgZnVsbCB3aWR0aCBvZiB0aGVcblx0XHRcdC8vIHRhYmxlLiBUaGlzIGlzIHNhZmUgc2luY2UgRGF0YVRhYmxlcyByZXF1aXJlcyBhIHVuaXF1ZSBjZWxsIGZvciBlYWNoXG5cdFx0XHQvLyBjb2x1bW4sIGJ1dCBpZiBldmVyIGEgaGVhZGVyIGNhbiBzcGFuIG11bHRpcGxlIGNvbHVtbnMsIHRoaXMgd2lsbFxuXHRcdFx0Ly8gbmVlZCB0byBiZSBtb2RpZmllZC5cblx0XHRcdHZhciB0b3RhbCA9IDA7XG5cdFx0XHRmb3IgKCBpPTAgOyBpPHZpc2libGVDb2x1bW5zLmxlbmd0aCA7IGkrKyApIHtcblx0XHRcdFx0dmFyIGNlbGwgPSAkKGhlYWRlckNlbGxzW2ldKTtcblx0XHRcdFx0dmFyIGJvcmRlciA9IGNlbGwub3V0ZXJXaWR0aCgpIC0gY2VsbC53aWR0aCgpO1xuXHRcblx0XHRcdFx0Ly8gVXNlIGdldEJvdW5kaW5nLi4uIHdoZXJlIHBvc3NpYmxlIChub3QgSUU4LSkgYmVjYXVzZSBpdCBjYW4gZ2l2ZVxuXHRcdFx0XHQvLyBzdWItcGl4ZWwgYWNjdXJhY3ksIHdoaWNoIHdlIHRoZW4gd2FudCB0byByb3VuZCB1cCFcblx0XHRcdFx0dmFyIGJvdW5kaW5nID0gYnJvd3Nlci5iQm91bmRpbmcgP1xuXHRcdFx0XHRcdE1hdGguY2VpbCggaGVhZGVyQ2VsbHNbaV0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggKSA6XG5cdFx0XHRcdFx0Y2VsbC5vdXRlcldpZHRoKCk7XG5cdFxuXHRcdFx0XHQvLyBUb3RhbCBpcyB0cmFja2VkIHRvIHJlbW92ZSBhbnkgc3ViLXBpeGVsIGVycm9ycyBhcyB0aGUgb3V0ZXJXaWR0aFxuXHRcdFx0XHQvLyBvZiB0aGUgdGFibGUgbWlnaHQgbm90IGVxdWFsIHRoZSB0b3RhbCBnaXZlbiBoZXJlIChJRSEpLlxuXHRcdFx0XHR0b3RhbCArPSBib3VuZGluZztcblx0XG5cdFx0XHRcdC8vIFdpZHRoIGZvciBlYWNoIGNvbHVtbiB0byB1c2Vcblx0XHRcdFx0Y29sdW1uc1sgdmlzaWJsZUNvbHVtbnNbaV0gXS5zV2lkdGggPSBfZm5TdHJpbmdUb0NzcyggYm91bmRpbmcgLSBib3JkZXIgKTtcblx0XHRcdH1cblx0XG5cdFx0XHR0YWJsZS5zdHlsZS53aWR0aCA9IF9mblN0cmluZ1RvQ3NzKCB0b3RhbCApO1xuXHRcblx0XHRcdC8vIEZpbmlzaGVkIHdpdGggdGhlIHRhYmxlIC0gZGl0Y2ggaXRcblx0XHRcdGhvbGRlci5yZW1vdmUoKTtcblx0XHR9XG5cdFxuXHRcdC8vIElmIHRoZXJlIGlzIGEgd2lkdGggYXR0ciwgd2Ugd2FudCB0byBhdHRhY2ggYW4gZXZlbnQgbGlzdGVuZXIgd2hpY2hcblx0XHQvLyBhbGxvd3MgdGhlIHRhYmxlIHNpemluZyB0byBhdXRvbWF0aWNhbGx5IGFkanVzdCB3aGVuIHRoZSB3aW5kb3cgaXNcblx0XHQvLyByZXNpemVkLiBVc2UgdGhlIHdpZHRoIGF0dHIgcmF0aGVyIHRoYW4gQ1NTLCBzaW5jZSB3ZSBjYW4ndCBrbm93IGlmIHRoZVxuXHRcdC8vIENTUyBpcyBhIHJlbGF0aXZlIHZhbHVlIG9yIGFic29sdXRlIC0gRE9NIHJlYWQgaXMgYWx3YXlzIHB4LlxuXHRcdGlmICggdGFibGVXaWR0aEF0dHIgKSB7XG5cdFx0XHR0YWJsZS5zdHlsZS53aWR0aCA9IF9mblN0cmluZ1RvQ3NzKCB0YWJsZVdpZHRoQXR0ciApO1xuXHRcdH1cblx0XG5cdFx0aWYgKCAodGFibGVXaWR0aEF0dHIgfHwgc2Nyb2xsWCkgJiYgISBvU2V0dGluZ3MuX3Jlc3pFdnQgKSB7XG5cdFx0XHR2YXIgYmluZFJlc2l6ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0JCh3aW5kb3cpLm9uKCdyZXNpemUuRFQtJytvU2V0dGluZ3Muc0luc3RhbmNlLCBfZm5UaHJvdHRsZSggZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdF9mbkFkanVzdENvbHVtblNpemluZyggb1NldHRpbmdzICk7XG5cdFx0XHRcdH0gKSApO1xuXHRcdFx0fTtcblx0XG5cdFx0XHQvLyBJRTYvNyB3aWxsIGNyYXNoIGlmIHdlIGJpbmQgYSByZXNpemUgZXZlbnQgaGFuZGxlciBvbiBwYWdlIGxvYWQuXG5cdFx0XHQvLyBUbyBiZSByZW1vdmVkIGluIDEuMTEgd2hpY2ggZHJvcHMgSUU2Lzcgc3VwcG9ydFxuXHRcdFx0aWYgKCBpZTY3ICkge1xuXHRcdFx0XHRzZXRUaW1lb3V0KCBiaW5kUmVzaXplLCAxMDAwICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0YmluZFJlc2l6ZSgpO1xuXHRcdFx0fVxuXHRcblx0XHRcdG9TZXR0aW5ncy5fcmVzekV2dCA9IHRydWU7XG5cdFx0fVxuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIFRocm90dGxlIHRoZSBjYWxscyB0byBhIGZ1bmN0aW9uLiBBcmd1bWVudHMgYW5kIGNvbnRleHQgYXJlIG1haW50YWluZWQgZm9yXG5cdCAqIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb25cblx0ICogIEBwYXJhbSB7ZnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGJlIGNhbGxlZFxuXHQgKiAgQHBhcmFtIHtpbnR9IFtmcmVxPTIwMF0gY2FsbCBmcmVxdWVuY3kgaW4gbVNcblx0ICogIEByZXR1cm5zIHtmdW5jdGlvbn0gd3JhcHBlZCBmdW5jdGlvblxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHR2YXIgX2ZuVGhyb3R0bGUgPSBEYXRhVGFibGUudXRpbC50aHJvdHRsZTtcblx0XG5cdFxuXHQvKipcblx0ICogQ29udmVydCBhIENTUyB1bml0IHdpZHRoIHRvIHBpeGVscyAoZS5nLiAyZW0pXG5cdCAqICBAcGFyYW0ge3N0cmluZ30gd2lkdGggd2lkdGggdG8gYmUgY29udmVydGVkXG5cdCAqICBAcGFyYW0ge25vZGV9IHBhcmVudCBwYXJlbnQgdG8gZ2V0IHRoZSB3aXRoIGZvciAocmVxdWlyZWQgZm9yIHJlbGF0aXZlIHdpZHRocykgLSBvcHRpb25hbFxuXHQgKiAgQHJldHVybnMge2ludH0gd2lkdGggaW4gcGl4ZWxzXG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkNvbnZlcnRUb1dpZHRoICggd2lkdGgsIHBhcmVudCApXG5cdHtcblx0XHRpZiAoICEgd2lkdGggKSB7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cdFxuXHRcdHZhciBuID0gJCgnPGRpdi8+Jylcblx0XHRcdC5jc3MoICd3aWR0aCcsIF9mblN0cmluZ1RvQ3NzKCB3aWR0aCApIClcblx0XHRcdC5hcHBlbmRUbyggcGFyZW50IHx8IGRvY3VtZW50LmJvZHkgKTtcblx0XG5cdFx0dmFyIHZhbCA9IG5bMF0ub2Zmc2V0V2lkdGg7XG5cdFx0bi5yZW1vdmUoKTtcblx0XG5cdFx0cmV0dXJuIHZhbDtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBHZXQgdGhlIHdpZGVzdCBub2RlXG5cdCAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBwYXJhbSB7aW50fSBjb2xJZHggY29sdW1uIG9mIGludGVyZXN0XG5cdCAqICBAcmV0dXJucyB7bm9kZX0gd2lkZXN0IHRhYmxlIG5vZGVcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuR2V0V2lkZXN0Tm9kZSggc2V0dGluZ3MsIGNvbElkeCApXG5cdHtcblx0XHR2YXIgaWR4ID0gX2ZuR2V0TWF4TGVuU3RyaW5nKCBzZXR0aW5ncywgY29sSWR4ICk7XG5cdFx0aWYgKCBpZHggPCAwICkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHRcblx0XHR2YXIgZGF0YSA9IHNldHRpbmdzLmFvRGF0YVsgaWR4IF07XG5cdFx0cmV0dXJuICEgZGF0YS5uVHIgPyAvLyBNaWdodCBub3QgaGF2ZSBiZWVuIGNyZWF0ZWQgd2hlbiBkZWZlcnJlZCByZW5kZXJpbmdcblx0XHRcdCQoJzx0ZC8+JykuaHRtbCggX2ZuR2V0Q2VsbERhdGEoIHNldHRpbmdzLCBpZHgsIGNvbElkeCwgJ2Rpc3BsYXknICkgKVswXSA6XG5cdFx0XHRkYXRhLmFuQ2VsbHNbIGNvbElkeCBdO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIEdldCB0aGUgbWF4aW11bSBzdHJsZW4gZm9yIGVhY2ggZGF0YSBjb2x1bW5cblx0ICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHtpbnR9IGNvbElkeCBjb2x1bW4gb2YgaW50ZXJlc3Rcblx0ICogIEByZXR1cm5zIHtzdHJpbmd9IG1heCBzdHJpbmcgbGVuZ3RoIGZvciBlYWNoIGNvbHVtblxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5HZXRNYXhMZW5TdHJpbmcoIHNldHRpbmdzLCBjb2xJZHggKVxuXHR7XG5cdFx0dmFyIHMsIG1heD0tMSwgbWF4SWR4ID0gLTE7XG5cdFxuXHRcdGZvciAoIHZhciBpPTAsIGllbj1zZXR0aW5ncy5hb0RhdGEubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRzID0gX2ZuR2V0Q2VsbERhdGEoIHNldHRpbmdzLCBpLCBjb2xJZHgsICdkaXNwbGF5JyApKycnO1xuXHRcdFx0cyA9IHMucmVwbGFjZSggX19yZV9odG1sX3JlbW92ZSwgJycgKTtcblx0XHRcdHMgPSBzLnJlcGxhY2UoIC8mbmJzcDsvZywgJyAnICk7XG5cdFxuXHRcdFx0aWYgKCBzLmxlbmd0aCA+IG1heCApIHtcblx0XHRcdFx0bWF4ID0gcy5sZW5ndGg7XG5cdFx0XHRcdG1heElkeCA9IGk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcblx0XHRyZXR1cm4gbWF4SWR4O1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIEFwcGVuZCBhIENTUyB1bml0IChvbmx5IGlmIHJlcXVpcmVkKSB0byBhIHN0cmluZ1xuXHQgKiAgQHBhcmFtIHtzdHJpbmd9IHZhbHVlIHRvIGNzcy1pZnlcblx0ICogIEByZXR1cm5zIHtzdHJpbmd9IHZhbHVlIHdpdGggY3NzIHVuaXRcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuU3RyaW5nVG9Dc3MoIHMgKVxuXHR7XG5cdFx0aWYgKCBzID09PSBudWxsICkge1xuXHRcdFx0cmV0dXJuICcwcHgnO1xuXHRcdH1cblx0XG5cdFx0aWYgKCB0eXBlb2YgcyA9PSAnbnVtYmVyJyApIHtcblx0XHRcdHJldHVybiBzIDwgMCA/XG5cdFx0XHRcdCcwcHgnIDpcblx0XHRcdFx0cysncHgnO1xuXHRcdH1cblx0XG5cdFx0Ly8gQ2hlY2sgaXQgaGFzIGEgdW5pdCBjaGFyYWN0ZXIgYWxyZWFkeVxuXHRcdHJldHVybiBzLm1hdGNoKC9cXGQkLykgP1xuXHRcdFx0cysncHgnIDpcblx0XHRcdHM7XG5cdH1cblx0XG5cdFxuXHRcblx0ZnVuY3Rpb24gX2ZuU29ydEZsYXR0ZW4gKCBzZXR0aW5ncyApXG5cdHtcblx0XHR2YXJcblx0XHRcdGksIGlMZW4sIGssIGtMZW4sXG5cdFx0XHRhU29ydCA9IFtdLFxuXHRcdFx0YWlPcmlnID0gW10sXG5cdFx0XHRhb0NvbHVtbnMgPSBzZXR0aW5ncy5hb0NvbHVtbnMsXG5cdFx0XHRhRGF0YVNvcnQsIGlDb2wsIHNUeXBlLCBzcmNDb2wsXG5cdFx0XHRmaXhlZCA9IHNldHRpbmdzLmFhU29ydGluZ0ZpeGVkLFxuXHRcdFx0Zml4ZWRPYmogPSAkLmlzUGxhaW5PYmplY3QoIGZpeGVkICksXG5cdFx0XHRuZXN0ZWRTb3J0ID0gW10sXG5cdFx0XHRhZGQgPSBmdW5jdGlvbiAoIGEgKSB7XG5cdFx0XHRcdGlmICggYS5sZW5ndGggJiYgISAkLmlzQXJyYXkoIGFbMF0gKSApIHtcblx0XHRcdFx0XHQvLyAxRCBhcnJheVxuXHRcdFx0XHRcdG5lc3RlZFNvcnQucHVzaCggYSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdC8vIDJEIGFycmF5XG5cdFx0XHRcdFx0JC5tZXJnZSggbmVzdGVkU29ydCwgYSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcblx0XHQvLyBCdWlsZCB0aGUgc29ydCBhcnJheSwgd2l0aCBwcmUtZml4IGFuZCBwb3N0LWZpeCBvcHRpb25zIGlmIHRoZXkgaGF2ZSBiZWVuXG5cdFx0Ly8gc3BlY2lmaWVkXG5cdFx0aWYgKCAkLmlzQXJyYXkoIGZpeGVkICkgKSB7XG5cdFx0XHRhZGQoIGZpeGVkICk7XG5cdFx0fVxuXHRcblx0XHRpZiAoIGZpeGVkT2JqICYmIGZpeGVkLnByZSApIHtcblx0XHRcdGFkZCggZml4ZWQucHJlICk7XG5cdFx0fVxuXHRcblx0XHRhZGQoIHNldHRpbmdzLmFhU29ydGluZyApO1xuXHRcblx0XHRpZiAoZml4ZWRPYmogJiYgZml4ZWQucG9zdCApIHtcblx0XHRcdGFkZCggZml4ZWQucG9zdCApO1xuXHRcdH1cblx0XG5cdFx0Zm9yICggaT0wIDsgaTxuZXN0ZWRTb3J0Lmxlbmd0aCA7IGkrKyApXG5cdFx0e1xuXHRcdFx0c3JjQ29sID0gbmVzdGVkU29ydFtpXVswXTtcblx0XHRcdGFEYXRhU29ydCA9IGFvQ29sdW1uc1sgc3JjQ29sIF0uYURhdGFTb3J0O1xuXHRcblx0XHRcdGZvciAoIGs9MCwga0xlbj1hRGF0YVNvcnQubGVuZ3RoIDsgazxrTGVuIDsgaysrIClcblx0XHRcdHtcblx0XHRcdFx0aUNvbCA9IGFEYXRhU29ydFtrXTtcblx0XHRcdFx0c1R5cGUgPSBhb0NvbHVtbnNbIGlDb2wgXS5zVHlwZSB8fCAnc3RyaW5nJztcblx0XG5cdFx0XHRcdGlmICggbmVzdGVkU29ydFtpXS5faWR4ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0bmVzdGVkU29ydFtpXS5faWR4ID0gJC5pbkFycmF5KCBuZXN0ZWRTb3J0W2ldWzFdLCBhb0NvbHVtbnNbaUNvbF0uYXNTb3J0aW5nICk7XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdGFTb3J0LnB1c2goIHtcblx0XHRcdFx0XHRzcmM6ICAgICAgIHNyY0NvbCxcblx0XHRcdFx0XHRjb2w6ICAgICAgIGlDb2wsXG5cdFx0XHRcdFx0ZGlyOiAgICAgICBuZXN0ZWRTb3J0W2ldWzFdLFxuXHRcdFx0XHRcdGluZGV4OiAgICAgbmVzdGVkU29ydFtpXS5faWR4LFxuXHRcdFx0XHRcdHR5cGU6ICAgICAgc1R5cGUsXG5cdFx0XHRcdFx0Zm9ybWF0dGVyOiBEYXRhVGFibGUuZXh0LnR5cGUub3JkZXJbIHNUeXBlK1wiLXByZVwiIF1cblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0cmV0dXJuIGFTb3J0O1xuXHR9XG5cdFxuXHQvKipcblx0ICogQ2hhbmdlIHRoZSBvcmRlciBvZiB0aGUgdGFibGVcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKiAgQHRvZG8gVGhpcyByZWFsbHkgbmVlZHMgc3BsaXQgdXAhXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5Tb3J0ICggb1NldHRpbmdzIClcblx0e1xuXHRcdHZhclxuXHRcdFx0aSwgaWVuLCBpTGVuLCBqLCBqTGVuLCBrLCBrTGVuLFxuXHRcdFx0c0RhdGFUeXBlLCBuVGgsXG5cdFx0XHRhaU9yaWcgPSBbXSxcblx0XHRcdG9FeHRTb3J0ID0gRGF0YVRhYmxlLmV4dC50eXBlLm9yZGVyLFxuXHRcdFx0YW9EYXRhID0gb1NldHRpbmdzLmFvRGF0YSxcblx0XHRcdGFvQ29sdW1ucyA9IG9TZXR0aW5ncy5hb0NvbHVtbnMsXG5cdFx0XHRhRGF0YVNvcnQsIGRhdGEsIGlDb2wsIHNUeXBlLCBvU29ydCxcblx0XHRcdGZvcm1hdHRlcnMgPSAwLFxuXHRcdFx0c29ydENvbCxcblx0XHRcdGRpc3BsYXlNYXN0ZXIgPSBvU2V0dGluZ3MuYWlEaXNwbGF5TWFzdGVyLFxuXHRcdFx0YVNvcnQ7XG5cdFxuXHRcdC8vIFJlc29sdmUgYW55IGNvbHVtbiB0eXBlcyB0aGF0IGFyZSB1bmtub3duIGR1ZSB0byBhZGRpdGlvbiBvciBpbnZhbGlkYXRpb25cblx0XHQvLyBAdG9kbyBDYW4gdGhpcyBiZSBtb3ZlZCBpbnRvIGEgJ2RhdGEtcmVhZHknIGhhbmRsZXIgd2hpY2ggaXMgY2FsbGVkIHdoZW5cblx0XHQvLyAgIGRhdGEgaXMgZ29pbmcgdG8gYmUgdXNlZCBpbiB0aGUgdGFibGU/XG5cdFx0X2ZuQ29sdW1uVHlwZXMoIG9TZXR0aW5ncyApO1xuXHRcblx0XHRhU29ydCA9IF9mblNvcnRGbGF0dGVuKCBvU2V0dGluZ3MgKTtcblx0XG5cdFx0Zm9yICggaT0wLCBpZW49YVNvcnQubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRzb3J0Q29sID0gYVNvcnRbaV07XG5cdFxuXHRcdFx0Ly8gVHJhY2sgaWYgd2UgY2FuIHVzZSB0aGUgZmFzdCBzb3J0IGFsZ29yaXRobVxuXHRcdFx0aWYgKCBzb3J0Q29sLmZvcm1hdHRlciApIHtcblx0XHRcdFx0Zm9ybWF0dGVycysrO1xuXHRcdFx0fVxuXHRcblx0XHRcdC8vIExvYWQgdGhlIGRhdGEgbmVlZGVkIGZvciB0aGUgc29ydCwgZm9yIGVhY2ggY2VsbFxuXHRcdFx0X2ZuU29ydERhdGEoIG9TZXR0aW5ncywgc29ydENvbC5jb2wgKTtcblx0XHR9XG5cdFxuXHRcdC8qIE5vIHNvcnRpbmcgcmVxdWlyZWQgaWYgc2VydmVyLXNpZGUgb3Igbm8gc29ydGluZyBhcnJheSAqL1xuXHRcdGlmICggX2ZuRGF0YVNvdXJjZSggb1NldHRpbmdzICkgIT0gJ3NzcCcgJiYgYVNvcnQubGVuZ3RoICE9PSAwIClcblx0XHR7XG5cdFx0XHQvLyBDcmVhdGUgYSB2YWx1ZSAtIGtleSBhcnJheSBvZiB0aGUgY3VycmVudCByb3cgcG9zaXRpb25zIHN1Y2ggdGhhdCB3ZSBjYW4gdXNlIHRoZWlyXG5cdFx0XHQvLyBjdXJyZW50IHBvc2l0aW9uIGR1cmluZyB0aGUgc29ydCwgaWYgdmFsdWVzIG1hdGNoLCBpbiBvcmRlciB0byBwZXJmb3JtIHN0YWJsZSBzb3J0aW5nXG5cdFx0XHRmb3IgKCBpPTAsIGlMZW49ZGlzcGxheU1hc3Rlci5sZW5ndGggOyBpPGlMZW4gOyBpKysgKSB7XG5cdFx0XHRcdGFpT3JpZ1sgZGlzcGxheU1hc3RlcltpXSBdID0gaTtcblx0XHRcdH1cblx0XG5cdFx0XHQvKiBEbyB0aGUgc29ydCAtIGhlcmUgd2Ugd2FudCBtdWx0aS1jb2x1bW4gc29ydGluZyBiYXNlZCBvbiBhIGdpdmVuIGRhdGEgc291cmNlIChjb2x1bW4pXG5cdFx0XHQgKiBhbmQgc29ydGluZyBmdW5jdGlvbiAoZnJvbSBvU29ydCkgaW4gYSBjZXJ0YWluIGRpcmVjdGlvbi4gSXQncyByZWFzb25hYmx5IGNvbXBsZXggdG9cblx0XHRcdCAqIGZvbGxvdyBvbiBpdCdzIG93biwgYnV0IHRoaXMgaXMgd2hhdCB3ZSB3YW50IChleGFtcGxlIHR3byBjb2x1bW4gc29ydGluZyk6XG5cdFx0XHQgKiAgZm5Mb2NhbFNvcnRpbmcgPSBmdW5jdGlvbihhLGIpe1xuXHRcdFx0ICogICAgdmFyIGlUZXN0O1xuXHRcdFx0ICogICAgaVRlc3QgPSBvU29ydFsnc3RyaW5nLWFzYyddKCdkYXRhMTEnLCAnZGF0YTEyJyk7XG5cdFx0XHQgKiAgICAgIGlmIChpVGVzdCAhPT0gMClcblx0XHRcdCAqICAgICAgICByZXR1cm4gaVRlc3Q7XG5cdFx0XHQgKiAgICBpVGVzdCA9IG9Tb3J0WydudW1lcmljLWRlc2MnXSgnZGF0YTIxJywgJ2RhdGEyMicpO1xuXHRcdFx0ICogICAgaWYgKGlUZXN0ICE9PSAwKVxuXHRcdFx0ICogICAgICByZXR1cm4gaVRlc3Q7XG5cdFx0XHQgKiAgICByZXR1cm4gb1NvcnRbJ251bWVyaWMtYXNjJ10oIGFpT3JpZ1thXSwgYWlPcmlnW2JdICk7XG5cdFx0XHQgKiAgfVxuXHRcdFx0ICogQmFzaWNhbGx5IHdlIGhhdmUgYSB0ZXN0IGZvciBlYWNoIHNvcnRpbmcgY29sdW1uLCBpZiB0aGUgZGF0YSBpbiB0aGF0IGNvbHVtbiBpcyBlcXVhbCxcblx0XHRcdCAqIHRlc3QgdGhlIG5leHQgY29sdW1uLiBJZiBhbGwgY29sdW1ucyBtYXRjaCwgdGhlbiB3ZSB1c2UgYSBudW1lcmljIHNvcnQgb24gdGhlIHJvd1xuXHRcdFx0ICogcG9zaXRpb25zIGluIHRoZSBvcmlnaW5hbCBkYXRhIGFycmF5IHRvIHByb3ZpZGUgYSBzdGFibGUgc29ydC5cblx0XHRcdCAqXG5cdFx0XHQgKiBOb3RlIC0gSSBrbm93IGl0IHNlZW1zIGV4Y2Vzc2l2ZSB0byBoYXZlIHR3byBzb3J0aW5nIG1ldGhvZHMsIGJ1dCB0aGUgZmlyc3QgaXMgYXJvdW5kXG5cdFx0XHQgKiAxNSUgZmFzdGVyLCBzbyB0aGUgc2Vjb25kIGlzIG9ubHkgbWFpbnRhaW5lZCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2l0aCBzb3J0aW5nXG5cdFx0XHQgKiBtZXRob2RzIHdoaWNoIGRvIG5vdCBoYXZlIGEgcHJlLXNvcnQgZm9ybWF0dGluZyBmdW5jdGlvbi5cblx0XHRcdCAqL1xuXHRcdFx0aWYgKCBmb3JtYXR0ZXJzID09PSBhU29ydC5sZW5ndGggKSB7XG5cdFx0XHRcdC8vIEFsbCBzb3J0IHR5cGVzIGhhdmUgZm9ybWF0dGluZyBmdW5jdGlvbnNcblx0XHRcdFx0ZGlzcGxheU1hc3Rlci5zb3J0KCBmdW5jdGlvbiAoIGEsIGIgKSB7XG5cdFx0XHRcdFx0dmFyXG5cdFx0XHRcdFx0XHR4LCB5LCBrLCB0ZXN0LCBzb3J0LFxuXHRcdFx0XHRcdFx0bGVuPWFTb3J0Lmxlbmd0aCxcblx0XHRcdFx0XHRcdGRhdGFBID0gYW9EYXRhW2FdLl9hU29ydERhdGEsXG5cdFx0XHRcdFx0XHRkYXRhQiA9IGFvRGF0YVtiXS5fYVNvcnREYXRhO1xuXHRcblx0XHRcdFx0XHRmb3IgKCBrPTAgOyBrPGxlbiA7IGsrKyApIHtcblx0XHRcdFx0XHRcdHNvcnQgPSBhU29ydFtrXTtcblx0XG5cdFx0XHRcdFx0XHR4ID0gZGF0YUFbIHNvcnQuY29sIF07XG5cdFx0XHRcdFx0XHR5ID0gZGF0YUJbIHNvcnQuY29sIF07XG5cdFxuXHRcdFx0XHRcdFx0dGVzdCA9IHg8eSA/IC0xIDogeD55ID8gMSA6IDA7XG5cdFx0XHRcdFx0XHRpZiAoIHRlc3QgIT09IDAgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBzb3J0LmRpciA9PT0gJ2FzYycgPyB0ZXN0IDogLXRlc3Q7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHR4ID0gYWlPcmlnW2FdO1xuXHRcdFx0XHRcdHkgPSBhaU9yaWdbYl07XG5cdFx0XHRcdFx0cmV0dXJuIHg8eSA/IC0xIDogeD55ID8gMSA6IDA7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHQvLyBEZXByZWNpYXRlZCAtIHJlbW92ZSBpbiAxLjExIChwcm92aWRpbmcgYSBwbHVnLWluIG9wdGlvbilcblx0XHRcdFx0Ly8gTm90IGFsbCBzb3J0IHR5cGVzIGhhdmUgZm9ybWF0dGluZyBtZXRob2RzLCBzbyB3ZSBoYXZlIHRvIGNhbGwgdGhlaXIgc29ydGluZ1xuXHRcdFx0XHQvLyBtZXRob2RzLlxuXHRcdFx0XHRkaXNwbGF5TWFzdGVyLnNvcnQoIGZ1bmN0aW9uICggYSwgYiApIHtcblx0XHRcdFx0XHR2YXJcblx0XHRcdFx0XHRcdHgsIHksIGssIGwsIHRlc3QsIHNvcnQsIGZuLFxuXHRcdFx0XHRcdFx0bGVuPWFTb3J0Lmxlbmd0aCxcblx0XHRcdFx0XHRcdGRhdGFBID0gYW9EYXRhW2FdLl9hU29ydERhdGEsXG5cdFx0XHRcdFx0XHRkYXRhQiA9IGFvRGF0YVtiXS5fYVNvcnREYXRhO1xuXHRcblx0XHRcdFx0XHRmb3IgKCBrPTAgOyBrPGxlbiA7IGsrKyApIHtcblx0XHRcdFx0XHRcdHNvcnQgPSBhU29ydFtrXTtcblx0XG5cdFx0XHRcdFx0XHR4ID0gZGF0YUFbIHNvcnQuY29sIF07XG5cdFx0XHRcdFx0XHR5ID0gZGF0YUJbIHNvcnQuY29sIF07XG5cdFxuXHRcdFx0XHRcdFx0Zm4gPSBvRXh0U29ydFsgc29ydC50eXBlK1wiLVwiK3NvcnQuZGlyIF0gfHwgb0V4dFNvcnRbIFwic3RyaW5nLVwiK3NvcnQuZGlyIF07XG5cdFx0XHRcdFx0XHR0ZXN0ID0gZm4oIHgsIHkgKTtcblx0XHRcdFx0XHRcdGlmICggdGVzdCAhPT0gMCApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRlc3Q7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHR4ID0gYWlPcmlnW2FdO1xuXHRcdFx0XHRcdHkgPSBhaU9yaWdbYl07XG5cdFx0XHRcdFx0cmV0dXJuIHg8eSA/IC0xIDogeD55ID8gMSA6IDA7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHR9XG5cdFxuXHRcdC8qIFRlbGwgdGhlIGRyYXcgZnVuY3Rpb24gdGhhdCB3ZSBoYXZlIHNvcnRlZCB0aGUgZGF0YSAqL1xuXHRcdG9TZXR0aW5ncy5iU29ydGVkID0gdHJ1ZTtcblx0fVxuXHRcblx0XG5cdGZ1bmN0aW9uIF9mblNvcnRBcmlhICggc2V0dGluZ3MgKVxuXHR7XG5cdFx0dmFyIGxhYmVsO1xuXHRcdHZhciBuZXh0U29ydDtcblx0XHR2YXIgY29sdW1ucyA9IHNldHRpbmdzLmFvQ29sdW1ucztcblx0XHR2YXIgYVNvcnQgPSBfZm5Tb3J0RmxhdHRlbiggc2V0dGluZ3MgKTtcblx0XHR2YXIgb0FyaWEgPSBzZXR0aW5ncy5vTGFuZ3VhZ2Uub0FyaWE7XG5cdFxuXHRcdC8vIEFSSUEgYXR0cmlidXRlcyAtIG5lZWQgdG8gbG9vcCBhbGwgY29sdW1ucywgdG8gdXBkYXRlIGFsbCAocmVtb3Zpbmcgb2xkXG5cdFx0Ly8gYXR0cmlidXRlcyBhcyBuZWVkZWQpXG5cdFx0Zm9yICggdmFyIGk9MCwgaUxlbj1jb2x1bW5zLmxlbmd0aCA7IGk8aUxlbiA7IGkrKyApXG5cdFx0e1xuXHRcdFx0dmFyIGNvbCA9IGNvbHVtbnNbaV07XG5cdFx0XHR2YXIgYXNTb3J0aW5nID0gY29sLmFzU29ydGluZztcblx0XHRcdHZhciBzVGl0bGUgPSBjb2wuc1RpdGxlLnJlcGxhY2UoIC88Lio/Pi9nLCBcIlwiICk7XG5cdFx0XHR2YXIgdGggPSBjb2wublRoO1xuXHRcblx0XHRcdC8vIElFNyBpcyB0aHJvd2luZyBhbiBlcnJvciB3aGVuIHNldHRpbmcgdGhlc2UgcHJvcGVydGllcyB3aXRoIGpRdWVyeSdzXG5cdFx0XHQvLyBhdHRyKCkgYW5kIHJlbW92ZUF0dHIoKSBtZXRob2RzLi4uXG5cdFx0XHR0aC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtc29ydCcpO1xuXHRcblx0XHRcdC8qIEluIEFSSUEgb25seSB0aGUgZmlyc3Qgc29ydGluZyBjb2x1bW4gY2FuIGJlIG1hcmtlZCBhcyBzb3J0aW5nIC0gbm8gbXVsdGktc29ydCBvcHRpb24gKi9cblx0XHRcdGlmICggY29sLmJTb3J0YWJsZSApIHtcblx0XHRcdFx0aWYgKCBhU29ydC5sZW5ndGggPiAwICYmIGFTb3J0WzBdLmNvbCA9PSBpICkge1xuXHRcdFx0XHRcdHRoLnNldEF0dHJpYnV0ZSgnYXJpYS1zb3J0JywgYVNvcnRbMF0uZGlyPT1cImFzY1wiID8gXCJhc2NlbmRpbmdcIiA6IFwiZGVzY2VuZGluZ1wiICk7XG5cdFx0XHRcdFx0bmV4dFNvcnQgPSBhc1NvcnRpbmdbIGFTb3J0WzBdLmluZGV4KzEgXSB8fCBhc1NvcnRpbmdbMF07XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0bmV4dFNvcnQgPSBhc1NvcnRpbmdbMF07XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdGxhYmVsID0gc1RpdGxlICsgKCBuZXh0U29ydCA9PT0gXCJhc2NcIiA/XG5cdFx0XHRcdFx0b0FyaWEuc1NvcnRBc2NlbmRpbmcgOlxuXHRcdFx0XHRcdG9BcmlhLnNTb3J0RGVzY2VuZGluZ1xuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGxhYmVsID0gc1RpdGxlO1xuXHRcdFx0fVxuXHRcblx0XHRcdHRoLnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsIGxhYmVsKTtcblx0XHR9XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogRnVuY3Rpb24gdG8gcnVuIG9uIHVzZXIgc29ydCByZXF1ZXN0XG5cdCAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBwYXJhbSB7bm9kZX0gYXR0YWNoVG8gbm9kZSB0byBhdHRhY2ggdGhlIGhhbmRsZXIgdG9cblx0ICogIEBwYXJhbSB7aW50fSBjb2xJZHggY29sdW1uIHNvcnRpbmcgaW5kZXhcblx0ICogIEBwYXJhbSB7Ym9vbGVhbn0gW2FwcGVuZD1mYWxzZV0gQXBwZW5kIHRoZSByZXF1ZXN0ZWQgc29ydCB0byB0aGUgZXhpc3Rpbmdcblx0ICogICAgc29ydCBpZiB0cnVlIChpLmUuIG11bHRpLWNvbHVtbiBzb3J0KVxuXHQgKiAgQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSBjYWxsYmFjayBmdW5jdGlvblxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5Tb3J0TGlzdGVuZXIgKCBzZXR0aW5ncywgY29sSWR4LCBhcHBlbmQsIGNhbGxiYWNrIClcblx0e1xuXHRcdHZhciBjb2wgPSBzZXR0aW5ncy5hb0NvbHVtbnNbIGNvbElkeCBdO1xuXHRcdHZhciBzb3J0aW5nID0gc2V0dGluZ3MuYWFTb3J0aW5nO1xuXHRcdHZhciBhc1NvcnRpbmcgPSBjb2wuYXNTb3J0aW5nO1xuXHRcdHZhciBuZXh0U29ydElkeDtcblx0XHR2YXIgbmV4dCA9IGZ1bmN0aW9uICggYSwgb3ZlcmZsb3cgKSB7XG5cdFx0XHR2YXIgaWR4ID0gYS5faWR4O1xuXHRcdFx0aWYgKCBpZHggPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0aWR4ID0gJC5pbkFycmF5KCBhWzFdLCBhc1NvcnRpbmcgKTtcblx0XHRcdH1cblx0XG5cdFx0XHRyZXR1cm4gaWR4KzEgPCBhc1NvcnRpbmcubGVuZ3RoID9cblx0XHRcdFx0aWR4KzEgOlxuXHRcdFx0XHRvdmVyZmxvdyA/XG5cdFx0XHRcdFx0bnVsbCA6XG5cdFx0XHRcdFx0MDtcblx0XHR9O1xuXHRcblx0XHQvLyBDb252ZXJ0IHRvIDJEIGFycmF5IGlmIG5lZWRlZFxuXHRcdGlmICggdHlwZW9mIHNvcnRpbmdbMF0gPT09ICdudW1iZXInICkge1xuXHRcdFx0c29ydGluZyA9IHNldHRpbmdzLmFhU29ydGluZyA9IFsgc29ydGluZyBdO1xuXHRcdH1cblx0XG5cdFx0Ly8gSWYgYXBwZW5kaW5nIHRoZSBzb3J0IHRoZW4gd2UgYXJlIG11bHRpLWNvbHVtbiBzb3J0aW5nXG5cdFx0aWYgKCBhcHBlbmQgJiYgc2V0dGluZ3Mub0ZlYXR1cmVzLmJTb3J0TXVsdGkgKSB7XG5cdFx0XHQvLyBBcmUgd2UgYWxyZWFkeSBkb2luZyBzb21lIGtpbmQgb2Ygc29ydCBvbiB0aGlzIGNvbHVtbj9cblx0XHRcdHZhciBzb3J0SWR4ID0gJC5pbkFycmF5KCBjb2xJZHgsIF9wbHVjayhzb3J0aW5nLCAnMCcpICk7XG5cdFxuXHRcdFx0aWYgKCBzb3J0SWR4ICE9PSAtMSApIHtcblx0XHRcdFx0Ly8gWWVzLCBtb2RpZnkgdGhlIHNvcnRcblx0XHRcdFx0bmV4dFNvcnRJZHggPSBuZXh0KCBzb3J0aW5nW3NvcnRJZHhdLCB0cnVlICk7XG5cdFxuXHRcdFx0XHRpZiAoIG5leHRTb3J0SWR4ID09PSBudWxsICYmIHNvcnRpbmcubGVuZ3RoID09PSAxICkge1xuXHRcdFx0XHRcdG5leHRTb3J0SWR4ID0gMDsgLy8gY2FuJ3QgcmVtb3ZlIHNvcnRpbmcgY29tcGxldGVseVxuXHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRpZiAoIG5leHRTb3J0SWR4ID09PSBudWxsICkge1xuXHRcdFx0XHRcdHNvcnRpbmcuc3BsaWNlKCBzb3J0SWR4LCAxICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0c29ydGluZ1tzb3J0SWR4XVsxXSA9IGFzU29ydGluZ1sgbmV4dFNvcnRJZHggXTtcblx0XHRcdFx0XHRzb3J0aW5nW3NvcnRJZHhdLl9pZHggPSBuZXh0U29ydElkeDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdC8vIE5vIHNvcnQgb24gdGhpcyBjb2x1bW4geWV0XG5cdFx0XHRcdHNvcnRpbmcucHVzaCggWyBjb2xJZHgsIGFzU29ydGluZ1swXSwgMCBdICk7XG5cdFx0XHRcdHNvcnRpbmdbc29ydGluZy5sZW5ndGgtMV0uX2lkeCA9IDA7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCBzb3J0aW5nLmxlbmd0aCAmJiBzb3J0aW5nWzBdWzBdID09IGNvbElkeCApIHtcblx0XHRcdC8vIFNpbmdsZSBjb2x1bW4gLSBhbHJlYWR5IHNvcnRpbmcgb24gdGhpcyBjb2x1bW4sIG1vZGlmeSB0aGUgc29ydFxuXHRcdFx0bmV4dFNvcnRJZHggPSBuZXh0KCBzb3J0aW5nWzBdICk7XG5cdFxuXHRcdFx0c29ydGluZy5sZW5ndGggPSAxO1xuXHRcdFx0c29ydGluZ1swXVsxXSA9IGFzU29ydGluZ1sgbmV4dFNvcnRJZHggXTtcblx0XHRcdHNvcnRpbmdbMF0uX2lkeCA9IG5leHRTb3J0SWR4O1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdC8vIFNpbmdsZSBjb2x1bW4gLSBzb3J0IG9ubHkgb24gdGhpcyBjb2x1bW5cblx0XHRcdHNvcnRpbmcubGVuZ3RoID0gMDtcblx0XHRcdHNvcnRpbmcucHVzaCggWyBjb2xJZHgsIGFzU29ydGluZ1swXSBdICk7XG5cdFx0XHRzb3J0aW5nWzBdLl9pZHggPSAwO1xuXHRcdH1cblx0XG5cdFx0Ly8gUnVuIHRoZSBzb3J0IGJ5IGNhbGxpbmcgYSBmdWxsIHJlZHJhd1xuXHRcdF9mblJlRHJhdyggc2V0dGluZ3MgKTtcblx0XG5cdFx0Ly8gY2FsbGJhY2sgdXNlZCBmb3IgYXN5bmMgdXNlciBpbnRlcmFjdGlvblxuXHRcdGlmICggdHlwZW9mIGNhbGxiYWNrID09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRjYWxsYmFjayggc2V0dGluZ3MgKTtcblx0XHR9XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogQXR0YWNoIGEgc29ydCBoYW5kbGVyIChjbGljaykgdG8gYSBub2RlXG5cdCAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBwYXJhbSB7bm9kZX0gYXR0YWNoVG8gbm9kZSB0byBhdHRhY2ggdGhlIGhhbmRsZXIgdG9cblx0ICogIEBwYXJhbSB7aW50fSBjb2xJZHggY29sdW1uIHNvcnRpbmcgaW5kZXhcblx0ICogIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gY2FsbGJhY2sgZnVuY3Rpb25cblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuU29ydEF0dGFjaExpc3RlbmVyICggc2V0dGluZ3MsIGF0dGFjaFRvLCBjb2xJZHgsIGNhbGxiYWNrIClcblx0e1xuXHRcdHZhciBjb2wgPSBzZXR0aW5ncy5hb0NvbHVtbnNbIGNvbElkeCBdO1xuXHRcblx0XHRfZm5CaW5kQWN0aW9uKCBhdHRhY2hUbywge30sIGZ1bmN0aW9uIChlKSB7XG5cdFx0XHQvKiBJZiB0aGUgY29sdW1uIGlzIG5vdCBzb3J0YWJsZSAtIGRvbid0IHRvIGFueXRoaW5nICovXG5cdFx0XHRpZiAoIGNvbC5iU29ydGFibGUgPT09IGZhbHNlICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gSWYgcHJvY2Vzc2luZyBpcyBlbmFibGVkIHVzZSBhIHRpbWVvdXQgdG8gYWxsb3cgdGhlIHByb2Nlc3Npbmdcblx0XHRcdC8vIGRpc3BsYXkgdG8gYmUgc2hvd24gLSBvdGhlcndpc2UgdG8gaXQgc3luY2hyb25vdXNseVxuXHRcdFx0aWYgKCBzZXR0aW5ncy5vRmVhdHVyZXMuYlByb2Nlc3NpbmcgKSB7XG5cdFx0XHRcdF9mblByb2Nlc3NpbmdEaXNwbGF5KCBzZXR0aW5ncywgdHJ1ZSApO1xuXHRcblx0XHRcdFx0c2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0X2ZuU29ydExpc3RlbmVyKCBzZXR0aW5ncywgY29sSWR4LCBlLnNoaWZ0S2V5LCBjYWxsYmFjayApO1xuXHRcblx0XHRcdFx0XHQvLyBJbiBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nLCB0aGUgZHJhdyBjYWxsYmFjayB3aWxsIHJlbW92ZSB0aGVcblx0XHRcdFx0XHQvLyBwcm9jZXNzaW5nIGRpc3BsYXlcblx0XHRcdFx0XHRpZiAoIF9mbkRhdGFTb3VyY2UoIHNldHRpbmdzICkgIT09ICdzc3AnICkge1xuXHRcdFx0XHRcdFx0X2ZuUHJvY2Vzc2luZ0Rpc3BsYXkoIHNldHRpbmdzLCBmYWxzZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSwgMCApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdF9mblNvcnRMaXN0ZW5lciggc2V0dGluZ3MsIGNvbElkeCwgZS5zaGlmdEtleSwgY2FsbGJhY2sgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogU2V0IHRoZSBzb3J0aW5nIGNsYXNzZXMgb24gdGFibGUncyBib2R5LCBOb3RlOiBpdCBpcyBzYWZlIHRvIGNhbGwgdGhpcyBmdW5jdGlvblxuXHQgKiB3aGVuIGJTb3J0IGFuZCBiU29ydENsYXNzZXMgYXJlIGZhbHNlXG5cdCAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mblNvcnRpbmdDbGFzc2VzKCBzZXR0aW5ncyApXG5cdHtcblx0XHR2YXIgb2xkU29ydCA9IHNldHRpbmdzLmFMYXN0U29ydDtcblx0XHR2YXIgc29ydENsYXNzID0gc2V0dGluZ3Mub0NsYXNzZXMuc1NvcnRDb2x1bW47XG5cdFx0dmFyIHNvcnQgPSBfZm5Tb3J0RmxhdHRlbiggc2V0dGluZ3MgKTtcblx0XHR2YXIgZmVhdHVyZXMgPSBzZXR0aW5ncy5vRmVhdHVyZXM7XG5cdFx0dmFyIGksIGllbiwgY29sSWR4O1xuXHRcblx0XHRpZiAoIGZlYXR1cmVzLmJTb3J0ICYmIGZlYXR1cmVzLmJTb3J0Q2xhc3NlcyApIHtcblx0XHRcdC8vIFJlbW92ZSBvbGQgc29ydGluZyBjbGFzc2VzXG5cdFx0XHRmb3IgKCBpPTAsIGllbj1vbGRTb3J0Lmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRjb2xJZHggPSBvbGRTb3J0W2ldLnNyYztcblx0XG5cdFx0XHRcdC8vIFJlbW92ZSBjb2x1bW4gc29ydGluZ1xuXHRcdFx0XHQkKCBfcGx1Y2soIHNldHRpbmdzLmFvRGF0YSwgJ2FuQ2VsbHMnLCBjb2xJZHggKSApXG5cdFx0XHRcdFx0LnJlbW92ZUNsYXNzKCBzb3J0Q2xhc3MgKyAoaTwyID8gaSsxIDogMykgKTtcblx0XHRcdH1cblx0XG5cdFx0XHQvLyBBZGQgbmV3IGNvbHVtbiBzb3J0aW5nXG5cdFx0XHRmb3IgKCBpPTAsIGllbj1zb3J0Lmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRjb2xJZHggPSBzb3J0W2ldLnNyYztcblx0XG5cdFx0XHRcdCQoIF9wbHVjayggc2V0dGluZ3MuYW9EYXRhLCAnYW5DZWxscycsIGNvbElkeCApIClcblx0XHRcdFx0XHQuYWRkQ2xhc3MoIHNvcnRDbGFzcyArIChpPDIgPyBpKzEgOiAzKSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0c2V0dGluZ3MuYUxhc3RTb3J0ID0gc29ydDtcblx0fVxuXHRcblx0XG5cdC8vIEdldCB0aGUgZGF0YSB0byBzb3J0IGEgY29sdW1uLCBiZSBpdCBmcm9tIGNhY2hlLCBmcmVzaCAocG9wdWxhdGluZyB0aGVcblx0Ly8gY2FjaGUpLCBvciBmcm9tIGEgc29ydCBmb3JtYXR0ZXJcblx0ZnVuY3Rpb24gX2ZuU29ydERhdGEoIHNldHRpbmdzLCBpZHggKVxuXHR7XG5cdFx0Ly8gQ3VzdG9tIHNvcnRpbmcgZnVuY3Rpb24gLSBwcm92aWRlZCBieSB0aGUgc29ydCBkYXRhIHR5cGVcblx0XHR2YXIgY29sdW1uID0gc2V0dGluZ3MuYW9Db2x1bW5zWyBpZHggXTtcblx0XHR2YXIgY3VzdG9tU29ydCA9IERhdGFUYWJsZS5leHQub3JkZXJbIGNvbHVtbi5zU29ydERhdGFUeXBlIF07XG5cdFx0dmFyIGN1c3RvbURhdGE7XG5cdFxuXHRcdGlmICggY3VzdG9tU29ydCApIHtcblx0XHRcdGN1c3RvbURhdGEgPSBjdXN0b21Tb3J0LmNhbGwoIHNldHRpbmdzLm9JbnN0YW5jZSwgc2V0dGluZ3MsIGlkeCxcblx0XHRcdFx0X2ZuQ29sdW1uSW5kZXhUb1Zpc2libGUoIHNldHRpbmdzLCBpZHggKVxuXHRcdFx0KTtcblx0XHR9XG5cdFxuXHRcdC8vIFVzZSAvIHBvcHVsYXRlIGNhY2hlXG5cdFx0dmFyIHJvdywgY2VsbERhdGE7XG5cdFx0dmFyIGZvcm1hdHRlciA9IERhdGFUYWJsZS5leHQudHlwZS5vcmRlclsgY29sdW1uLnNUeXBlK1wiLXByZVwiIF07XG5cdFxuXHRcdGZvciAoIHZhciBpPTAsIGllbj1zZXR0aW5ncy5hb0RhdGEubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRyb3cgPSBzZXR0aW5ncy5hb0RhdGFbaV07XG5cdFxuXHRcdFx0aWYgKCAhIHJvdy5fYVNvcnREYXRhICkge1xuXHRcdFx0XHRyb3cuX2FTb3J0RGF0YSA9IFtdO1xuXHRcdFx0fVxuXHRcblx0XHRcdGlmICggISByb3cuX2FTb3J0RGF0YVtpZHhdIHx8IGN1c3RvbVNvcnQgKSB7XG5cdFx0XHRcdGNlbGxEYXRhID0gY3VzdG9tU29ydCA/XG5cdFx0XHRcdFx0Y3VzdG9tRGF0YVtpXSA6IC8vIElmIHRoZXJlIHdhcyBhIGN1c3RvbSBzb3J0IGZ1bmN0aW9uLCB1c2UgZGF0YSBmcm9tIHRoZXJlXG5cdFx0XHRcdFx0X2ZuR2V0Q2VsbERhdGEoIHNldHRpbmdzLCBpLCBpZHgsICdzb3J0JyApO1xuXHRcblx0XHRcdFx0cm93Ll9hU29ydERhdGFbIGlkeCBdID0gZm9ybWF0dGVyID9cblx0XHRcdFx0XHRmb3JtYXR0ZXIoIGNlbGxEYXRhICkgOlxuXHRcdFx0XHRcdGNlbGxEYXRhO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRcblx0XG5cdFxuXHQvKipcblx0ICogU2F2ZSB0aGUgc3RhdGUgb2YgYSB0YWJsZVxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5TYXZlU3RhdGUgKCBzZXR0aW5ncyApXG5cdHtcblx0XHRpZiAoICFzZXR0aW5ncy5vRmVhdHVyZXMuYlN0YXRlU2F2ZSB8fCBzZXR0aW5ncy5iRGVzdHJveWluZyApXG5cdFx0e1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XG5cdFx0LyogU3RvcmUgdGhlIGludGVyZXN0aW5nIHZhcmlhYmxlcyAqL1xuXHRcdHZhciBzdGF0ZSA9IHtcblx0XHRcdHRpbWU6ICAgICtuZXcgRGF0ZSgpLFxuXHRcdFx0c3RhcnQ6ICAgc2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQsXG5cdFx0XHRsZW5ndGg6ICBzZXR0aW5ncy5faURpc3BsYXlMZW5ndGgsXG5cdFx0XHRvcmRlcjogICAkLmV4dGVuZCggdHJ1ZSwgW10sIHNldHRpbmdzLmFhU29ydGluZyApLFxuXHRcdFx0c2VhcmNoOiAgX2ZuU2VhcmNoVG9DYW1lbCggc2V0dGluZ3Mub1ByZXZpb3VzU2VhcmNoICksXG5cdFx0XHRjb2x1bW5zOiAkLm1hcCggc2V0dGluZ3MuYW9Db2x1bW5zLCBmdW5jdGlvbiAoIGNvbCwgaSApIHtcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHR2aXNpYmxlOiBjb2wuYlZpc2libGUsXG5cdFx0XHRcdFx0c2VhcmNoOiBfZm5TZWFyY2hUb0NhbWVsKCBzZXR0aW5ncy5hb1ByZVNlYXJjaENvbHNbaV0gKVxuXHRcdFx0XHR9O1xuXHRcdFx0fSApXG5cdFx0fTtcblx0XG5cdFx0X2ZuQ2FsbGJhY2tGaXJlKCBzZXR0aW5ncywgXCJhb1N0YXRlU2F2ZVBhcmFtc1wiLCAnc3RhdGVTYXZlUGFyYW1zJywgW3NldHRpbmdzLCBzdGF0ZV0gKTtcblx0XG5cdFx0c2V0dGluZ3Mub1NhdmVkU3RhdGUgPSBzdGF0ZTtcblx0XHRzZXR0aW5ncy5mblN0YXRlU2F2ZUNhbGxiYWNrLmNhbGwoIHNldHRpbmdzLm9JbnN0YW5jZSwgc2V0dGluZ3MsIHN0YXRlICk7XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogQXR0ZW1wdCB0byBsb2FkIGEgc2F2ZWQgdGFibGUgc3RhdGVcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvSW5pdCBEYXRhVGFibGVzIGluaXQgb2JqZWN0IHNvIHdlIGNhbiBvdmVycmlkZSBzZXR0aW5nc1xuXHQgKiAgQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gZXhlY3V0ZSB3aGVuIHRoZSBzdGF0ZSBoYXMgYmVlbiBsb2FkZWRcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuTG9hZFN0YXRlICggc2V0dGluZ3MsIG9Jbml0LCBjYWxsYmFjayApXG5cdHtcblx0XHR2YXIgaSwgaWVuO1xuXHRcdHZhciBjb2x1bW5zID0gc2V0dGluZ3MuYW9Db2x1bW5zO1xuXHRcdHZhciBsb2FkZWQgPSBmdW5jdGlvbiAoIHMgKSB7XG5cdFx0XHRpZiAoICEgcyB8fCAhIHMudGltZSApIHtcblx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcblx0XHRcdC8vIEFsbG93IGN1c3RvbSBhbmQgcGx1Zy1pbiBtYW5pcHVsYXRpb24gZnVuY3Rpb25zIHRvIGFsdGVyIHRoZSBzYXZlZCBkYXRhIHNldCBhbmRcblx0XHRcdC8vIGNhbmNlbGxpbmcgb2YgbG9hZGluZyBieSByZXR1cm5pbmcgZmFsc2Vcblx0XHRcdHZhciBhYlN0YXRlTG9hZCA9IF9mbkNhbGxiYWNrRmlyZSggc2V0dGluZ3MsICdhb1N0YXRlTG9hZFBhcmFtcycsICdzdGF0ZUxvYWRQYXJhbXMnLCBbc2V0dGluZ3MsIHNdICk7XG5cdFx0XHRpZiAoICQuaW5BcnJheSggZmFsc2UsIGFiU3RhdGVMb2FkICkgIT09IC0xICkge1xuXHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gUmVqZWN0IG9sZCBkYXRhXG5cdFx0XHR2YXIgZHVyYXRpb24gPSBzZXR0aW5ncy5pU3RhdGVEdXJhdGlvbjtcblx0XHRcdGlmICggZHVyYXRpb24gPiAwICYmIHMudGltZSA8ICtuZXcgRGF0ZSgpIC0gKGR1cmF0aW9uKjEwMDApICkge1xuXHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gTnVtYmVyIG9mIGNvbHVtbnMgaGF2ZSBjaGFuZ2VkIC0gYWxsIGJldHMgYXJlIG9mZiwgbm8gcmVzdG9yZSBvZiBzZXR0aW5nc1xuXHRcdFx0aWYgKCBzLmNvbHVtbnMgJiYgY29sdW1ucy5sZW5ndGggIT09IHMuY29sdW1ucy5sZW5ndGggKSB7XG5cdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XG5cdFx0XHQvLyBTdG9yZSB0aGUgc2F2ZWQgc3RhdGUgc28gaXQgbWlnaHQgYmUgYWNjZXNzZWQgYXQgYW55IHRpbWVcblx0XHRcdHNldHRpbmdzLm9Mb2FkZWRTdGF0ZSA9ICQuZXh0ZW5kKCB0cnVlLCB7fSwgcyApO1xuXHRcblx0XHRcdC8vIFJlc3RvcmUga2V5IGZlYXR1cmVzIC0gdG9kbyAtIGZvciAxLjExIHRoaXMgbmVlZHMgdG8gYmUgZG9uZSBieVxuXHRcdFx0Ly8gc3Vic2NyaWJlZCBldmVudHNcblx0XHRcdGlmICggcy5zdGFydCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRzZXR0aW5ncy5faURpc3BsYXlTdGFydCAgICA9IHMuc3RhcnQ7XG5cdFx0XHRcdHNldHRpbmdzLmlJbml0RGlzcGxheVN0YXJ0ID0gcy5zdGFydDtcblx0XHRcdH1cblx0XHRcdGlmICggcy5sZW5ndGggIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0c2V0dGluZ3MuX2lEaXNwbGF5TGVuZ3RoICAgPSBzLmxlbmd0aDtcblx0XHRcdH1cblx0XG5cdFx0XHQvLyBPcmRlclxuXHRcdFx0aWYgKCBzLm9yZGVyICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHNldHRpbmdzLmFhU29ydGluZyA9IFtdO1xuXHRcdFx0XHQkLmVhY2goIHMub3JkZXIsIGZ1bmN0aW9uICggaSwgY29sICkge1xuXHRcdFx0XHRcdHNldHRpbmdzLmFhU29ydGluZy5wdXNoKCBjb2xbMF0gPj0gY29sdW1ucy5sZW5ndGggP1xuXHRcdFx0XHRcdFx0WyAwLCBjb2xbMV0gXSA6XG5cdFx0XHRcdFx0XHRjb2xcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gU2VhcmNoXG5cdFx0XHRpZiAoIHMuc2VhcmNoICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdCQuZXh0ZW5kKCBzZXR0aW5ncy5vUHJldmlvdXNTZWFyY2gsIF9mblNlYXJjaFRvSHVuZyggcy5zZWFyY2ggKSApO1xuXHRcdFx0fVxuXHRcblx0XHRcdC8vIENvbHVtbnNcblx0XHRcdC8vXG5cdFx0XHRpZiAoIHMuY29sdW1ucyApIHtcblx0XHRcdFx0Zm9yICggaT0wLCBpZW49cy5jb2x1bW5zLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRcdHZhciBjb2wgPSBzLmNvbHVtbnNbaV07XG5cdFxuXHRcdFx0XHRcdC8vIFZpc2liaWxpdHlcblx0XHRcdFx0XHRpZiAoIGNvbC52aXNpYmxlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRjb2x1bW5zW2ldLmJWaXNpYmxlID0gY29sLnZpc2libGU7XG5cdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHQvLyBTZWFyY2hcblx0XHRcdFx0XHRpZiAoIGNvbC5zZWFyY2ggIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdCQuZXh0ZW5kKCBzZXR0aW5ncy5hb1ByZVNlYXJjaENvbHNbaV0sIF9mblNlYXJjaFRvSHVuZyggY29sLnNlYXJjaCApICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFxuXHRcdFx0X2ZuQ2FsbGJhY2tGaXJlKCBzZXR0aW5ncywgJ2FvU3RhdGVMb2FkZWQnLCAnc3RhdGVMb2FkZWQnLCBbc2V0dGluZ3MsIHNdICk7XG5cdFx0XHRjYWxsYmFjaygpO1xuXHRcdH07XG5cdFxuXHRcdGlmICggISBzZXR0aW5ncy5vRmVhdHVyZXMuYlN0YXRlU2F2ZSApIHtcblx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcblx0XHR2YXIgc3RhdGUgPSBzZXR0aW5ncy5mblN0YXRlTG9hZENhbGxiYWNrLmNhbGwoIHNldHRpbmdzLm9JbnN0YW5jZSwgc2V0dGluZ3MsIGxvYWRlZCApO1xuXHRcblx0XHRpZiAoIHN0YXRlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRsb2FkZWQoIHN0YXRlICk7XG5cdFx0fVxuXHRcdC8vIG90aGVyd2lzZSwgd2FpdCBmb3IgdGhlIGxvYWRlZCBjYWxsYmFjayB0byBiZSBleGVjdXRlZFxuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIFJldHVybiB0aGUgc2V0dGluZ3Mgb2JqZWN0IGZvciBhIHBhcnRpY3VsYXIgdGFibGVcblx0ICogIEBwYXJhbSB7bm9kZX0gdGFibGUgdGFibGUgd2UgYXJlIHVzaW5nIGFzIGEgZGF0YVRhYmxlXG5cdCAqICBAcmV0dXJucyB7b2JqZWN0fSBTZXR0aW5ncyBvYmplY3QgLSBvciBudWxsIGlmIG5vdCBmb3VuZFxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5TZXR0aW5nc0Zyb21Ob2RlICggdGFibGUgKVxuXHR7XG5cdFx0dmFyIHNldHRpbmdzID0gRGF0YVRhYmxlLnNldHRpbmdzO1xuXHRcdHZhciBpZHggPSAkLmluQXJyYXkoIHRhYmxlLCBfcGx1Y2soIHNldHRpbmdzLCAnblRhYmxlJyApICk7XG5cdFxuXHRcdHJldHVybiBpZHggIT09IC0xID9cblx0XHRcdHNldHRpbmdzWyBpZHggXSA6XG5cdFx0XHRudWxsO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIExvZyBhbiBlcnJvciBtZXNzYWdlXG5cdCAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBwYXJhbSB7aW50fSBsZXZlbCBsb2cgZXJyb3IgbWVzc2FnZXMsIG9yIGRpc3BsYXkgdGhlbSB0byB0aGUgdXNlclxuXHQgKiAgQHBhcmFtIHtzdHJpbmd9IG1zZyBlcnJvciBtZXNzYWdlXG5cdCAqICBAcGFyYW0ge2ludH0gdG4gVGVjaG5pY2FsIG5vdGUgaWQgdG8gZ2V0IG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGVycm9yLlxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5Mb2coIHNldHRpbmdzLCBsZXZlbCwgbXNnLCB0biApXG5cdHtcblx0XHRtc2cgPSAnRGF0YVRhYmxlcyB3YXJuaW5nOiAnK1xuXHRcdFx0KHNldHRpbmdzID8gJ3RhYmxlIGlkPScrc2V0dGluZ3Muc1RhYmxlSWQrJyAtICcgOiAnJykrbXNnO1xuXHRcblx0XHRpZiAoIHRuICkge1xuXHRcdFx0bXNnICs9ICcuIEZvciBtb3JlIGluZm9ybWF0aW9uIGFib3V0IHRoaXMgZXJyb3IsIHBsZWFzZSBzZWUgJytcblx0XHRcdCdodHRwOi8vZGF0YXRhYmxlcy5uZXQvdG4vJyt0bjtcblx0XHR9XG5cdFxuXHRcdGlmICggISBsZXZlbCAgKSB7XG5cdFx0XHQvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBwcmUgMS4xMFxuXHRcdFx0dmFyIGV4dCA9IERhdGFUYWJsZS5leHQ7XG5cdFx0XHR2YXIgdHlwZSA9IGV4dC5zRXJyTW9kZSB8fCBleHQuZXJyTW9kZTtcblx0XG5cdFx0XHRpZiAoIHNldHRpbmdzICkge1xuXHRcdFx0XHRfZm5DYWxsYmFja0ZpcmUoIHNldHRpbmdzLCBudWxsLCAnZXJyb3InLCBbIHNldHRpbmdzLCB0biwgbXNnIF0gKTtcblx0XHRcdH1cblx0XG5cdFx0XHRpZiAoIHR5cGUgPT0gJ2FsZXJ0JyApIHtcblx0XHRcdFx0YWxlcnQoIG1zZyApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIHR5cGUgPT0gJ3Rocm93JyApIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKG1zZyk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggdHlwZW9mIHR5cGUgPT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0dHlwZSggc2V0dGluZ3MsIHRuLCBtc2cgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSBpZiAoIHdpbmRvdy5jb25zb2xlICYmIGNvbnNvbGUubG9nICkge1xuXHRcdFx0Y29uc29sZS5sb2coIG1zZyApO1xuXHRcdH1cblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBTZWUgaWYgYSBwcm9wZXJ0eSBpcyBkZWZpbmVkIG9uIG9uZSBvYmplY3QsIGlmIHNvIGFzc2lnbiBpdCB0byB0aGUgb3RoZXIgb2JqZWN0XG5cdCAqICBAcGFyYW0ge29iamVjdH0gcmV0IHRhcmdldCBvYmplY3Rcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBzcmMgc291cmNlIG9iamVjdFxuXHQgKiAgQHBhcmFtIHtzdHJpbmd9IG5hbWUgcHJvcGVydHlcblx0ICogIEBwYXJhbSB7c3RyaW5nfSBbbWFwcGVkTmFtZV0gbmFtZSB0byBtYXAgdG9vIC0gb3B0aW9uYWwsIG5hbWUgdXNlZCBpZiBub3QgZ2l2ZW5cblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuTWFwKCByZXQsIHNyYywgbmFtZSwgbWFwcGVkTmFtZSApXG5cdHtcblx0XHRpZiAoICQuaXNBcnJheSggbmFtZSApICkge1xuXHRcdFx0JC5lYWNoKCBuYW1lLCBmdW5jdGlvbiAoaSwgdmFsKSB7XG5cdFx0XHRcdGlmICggJC5pc0FycmF5KCB2YWwgKSApIHtcblx0XHRcdFx0XHRfZm5NYXAoIHJldCwgc3JjLCB2YWxbMF0sIHZhbFsxXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdF9mbk1hcCggcmV0LCBzcmMsIHZhbCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XG5cdFx0aWYgKCBtYXBwZWROYW1lID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRtYXBwZWROYW1lID0gbmFtZTtcblx0XHR9XG5cdFxuXHRcdGlmICggc3JjW25hbWVdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRyZXRbbWFwcGVkTmFtZV0gPSBzcmNbbmFtZV07XG5cdFx0fVxuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIEV4dGVuZCBvYmplY3RzIC0gdmVyeSBzaW1pbGFyIHRvIGpRdWVyeS5leHRlbmQsIGJ1dCBkZWVwIGNvcHkgb2JqZWN0cywgYW5kXG5cdCAqIHNoYWxsb3cgY29weSBhcnJheXMuIFRoZSByZWFzb24gd2UgbmVlZCB0byBkbyB0aGlzLCBpcyB0aGF0IHdlIGRvbid0IHdhbnQgdG9cblx0ICogZGVlcCBjb3B5IGFycmF5IGluaXQgdmFsdWVzIChzdWNoIGFzIGFhU29ydGluZykgc2luY2UgdGhlIGRldiB3b3VsZG4ndCBiZVxuXHQgKiBhYmxlIHRvIG92ZXJyaWRlIHRoZW0sIGJ1dCB3ZSBkbyB3YW50IHRvIGRlZXAgY29weSBhcnJheXMuXG5cdCAqICBAcGFyYW0ge29iamVjdH0gb3V0IE9iamVjdCB0byBleHRlbmRcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBleHRlbmRlciBPYmplY3QgZnJvbSB3aGljaCB0aGUgcHJvcGVydGllcyB3aWxsIGJlIGFwcGxpZWQgdG9cblx0ICogICAgICBvdXRcblx0ICogIEBwYXJhbSB7Ym9vbGVhbn0gYnJlYWtSZWZzIElmIHRydWUsIHRoZW4gYXJyYXlzIHdpbGwgYmUgc2xpY2VkIHRvIHRha2UgYW5cblx0ICogICAgICBpbmRlcGVuZGVudCBjb3B5IHdpdGggdGhlIGV4Y2VwdGlvbiBvZiB0aGUgYGRhdGFgIG9yIGBhYURhdGFgIHBhcmFtZXRlcnNcblx0ICogICAgICBpZiB0aGV5IGFyZSBwcmVzZW50LiBUaGlzIGlzIHNvIHlvdSBjYW4gcGFzcyBpbiBhIGNvbGxlY3Rpb24gdG9cblx0ICogICAgICBEYXRhVGFibGVzIGFuZCBoYXZlIHRoYXQgdXNlZCBhcyB5b3VyIGRhdGEgc291cmNlIHdpdGhvdXQgYnJlYWtpbmcgdGhlXG5cdCAqICAgICAgcmVmZXJlbmNlc1xuXHQgKiAgQHJldHVybnMge29iamVjdH0gb3V0IFJlZmVyZW5jZSwganVzdCBmb3IgY29udmVuaWVuY2UgLSBvdXQgPT09IHRoZSByZXR1cm4uXG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICogIEB0b2RvIFRoaXMgZG9lc24ndCB0YWtlIGFjY291bnQgb2YgYXJyYXlzIGluc2lkZSB0aGUgZGVlcCBjb3BpZWQgb2JqZWN0cy5cblx0ICovXG5cdGZ1bmN0aW9uIF9mbkV4dGVuZCggb3V0LCBleHRlbmRlciwgYnJlYWtSZWZzIClcblx0e1xuXHRcdHZhciB2YWw7XG5cdFxuXHRcdGZvciAoIHZhciBwcm9wIGluIGV4dGVuZGVyICkge1xuXHRcdFx0aWYgKCBleHRlbmRlci5oYXNPd25Qcm9wZXJ0eShwcm9wKSApIHtcblx0XHRcdFx0dmFsID0gZXh0ZW5kZXJbcHJvcF07XG5cdFxuXHRcdFx0XHRpZiAoICQuaXNQbGFpbk9iamVjdCggdmFsICkgKSB7XG5cdFx0XHRcdFx0aWYgKCAhICQuaXNQbGFpbk9iamVjdCggb3V0W3Byb3BdICkgKSB7XG5cdFx0XHRcdFx0XHRvdXRbcHJvcF0gPSB7fTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0JC5leHRlbmQoIHRydWUsIG91dFtwcm9wXSwgdmFsICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAoIGJyZWFrUmVmcyAmJiBwcm9wICE9PSAnZGF0YScgJiYgcHJvcCAhPT0gJ2FhRGF0YScgJiYgJC5pc0FycmF5KHZhbCkgKSB7XG5cdFx0XHRcdFx0b3V0W3Byb3BdID0gdmFsLnNsaWNlKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0b3V0W3Byb3BdID0gdmFsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcblx0XHRyZXR1cm4gb3V0O1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIEJpbmQgYW4gZXZlbnQgaGFuZGVycyB0byBhbGxvdyBhIGNsaWNrIG9yIHJldHVybiBrZXkgdG8gYWN0aXZhdGUgdGhlIGNhbGxiYWNrLlxuXHQgKiBUaGlzIGlzIGdvb2QgZm9yIGFjY2Vzc2liaWxpdHkgc2luY2UgYSByZXR1cm4gb24gdGhlIGtleWJvYXJkIHdpbGwgaGF2ZSB0aGVcblx0ICogc2FtZSBlZmZlY3QgYXMgYSBjbGljaywgaWYgdGhlIGVsZW1lbnQgaGFzIGZvY3VzLlxuXHQgKiAgQHBhcmFtIHtlbGVtZW50fSBuIEVsZW1lbnQgdG8gYmluZCB0aGUgYWN0aW9uIHRvXG5cdCAqICBAcGFyYW0ge29iamVjdH0gb0RhdGEgRGF0YSBvYmplY3QgdG8gcGFzcyB0byB0aGUgdHJpZ2dlcmVkIGZ1bmN0aW9uXG5cdCAqICBAcGFyYW0ge2Z1bmN0aW9ufSBmbiBDYWxsYmFjayBmdW5jdGlvbiBmb3Igd2hlbiB0aGUgZXZlbnQgaXMgdHJpZ2dlcmVkXG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkJpbmRBY3Rpb24oIG4sIG9EYXRhLCBmbiApXG5cdHtcblx0XHQkKG4pXG5cdFx0XHQub24oICdjbGljay5EVCcsIG9EYXRhLCBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRcdCQobikudHJpZ2dlcignYmx1cicpOyAvLyBSZW1vdmUgZm9jdXMgb3V0bGluZSBmb3IgbW91c2UgdXNlcnNcblx0XHRcdFx0XHRmbihlKTtcblx0XHRcdFx0fSApXG5cdFx0XHQub24oICdrZXlwcmVzcy5EVCcsIG9EYXRhLCBmdW5jdGlvbiAoZSl7XG5cdFx0XHRcdFx0aWYgKCBlLndoaWNoID09PSAxMyApIHtcblx0XHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdGZuKGUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApXG5cdFx0XHQub24oICdzZWxlY3RzdGFydC5EVCcsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHQvKiBUYWtlIHRoZSBicnV0YWwgYXBwcm9hY2ggdG8gY2FuY2VsbGluZyB0ZXh0IHNlbGVjdGlvbiAqL1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fSApO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIFJlZ2lzdGVyIGEgY2FsbGJhY2sgZnVuY3Rpb24uIEVhc2lseSBhbGxvd3MgYSBjYWxsYmFjayBmdW5jdGlvbiB0byBiZSBhZGRlZCB0b1xuXHQgKiBhbiBhcnJheSBzdG9yZSBvZiBjYWxsYmFjayBmdW5jdGlvbnMgdGhhdCBjYW4gdGhlbiBhbGwgYmUgY2FsbGVkIHRvZ2V0aGVyLlxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHtzdHJpbmd9IHNTdG9yZSBOYW1lIG9mIHRoZSBhcnJheSBzdG9yYWdlIGZvciB0aGUgY2FsbGJhY2tzIGluIG9TZXR0aW5nc1xuXHQgKiAgQHBhcmFtIHtmdW5jdGlvbn0gZm4gRnVuY3Rpb24gdG8gYmUgY2FsbGVkIGJhY2tcblx0ICogIEBwYXJhbSB7c3RyaW5nfSBzTmFtZSBJZGVudGlmeWluZyBuYW1lIGZvciB0aGUgY2FsbGJhY2sgKGkuZS4gYSBsYWJlbClcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuQ2FsbGJhY2tSZWcoIG9TZXR0aW5ncywgc1N0b3JlLCBmbiwgc05hbWUgKVxuXHR7XG5cdFx0aWYgKCBmbiApXG5cdFx0e1xuXHRcdFx0b1NldHRpbmdzW3NTdG9yZV0ucHVzaCgge1xuXHRcdFx0XHRcImZuXCI6IGZuLFxuXHRcdFx0XHRcInNOYW1lXCI6IHNOYW1lXG5cdFx0XHR9ICk7XG5cdFx0fVxuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIEZpcmUgY2FsbGJhY2sgZnVuY3Rpb25zIGFuZCB0cmlnZ2VyIGV2ZW50cy4gTm90ZSB0aGF0IHRoZSBsb29wIG92ZXIgdGhlXG5cdCAqIGNhbGxiYWNrIGFycmF5IHN0b3JlIGlzIGRvbmUgYmFja3dhcmRzISBGdXJ0aGVyIG5vdGUgdGhhdCB5b3UgZG8gbm90IHdhbnQgdG9cblx0ICogZmlyZSBvZmYgdHJpZ2dlcnMgaW4gdGltZSBzZW5zaXRpdmUgYXBwbGljYXRpb25zIChmb3IgZXhhbXBsZSBjZWxsIGNyZWF0aW9uKVxuXHQgKiBhcyBpdHMgc2xvdy5cblx0ICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHtzdHJpbmd9IGNhbGxiYWNrQXJyIE5hbWUgb2YgdGhlIGFycmF5IHN0b3JhZ2UgZm9yIHRoZSBjYWxsYmFja3MgaW5cblx0ICogICAgICBvU2V0dGluZ3Ncblx0ICogIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgTmFtZSBvZiB0aGUgalF1ZXJ5IGN1c3RvbSBldmVudCB0byB0cmlnZ2VyLiBJZlxuXHQgKiAgICAgIG51bGwgbm8gdHJpZ2dlciBpcyBmaXJlZFxuXHQgKiAgQHBhcmFtIHthcnJheX0gYXJncyBBcnJheSBvZiBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gL1xuXHQgKiAgICAgIHRyaWdnZXJcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuQ2FsbGJhY2tGaXJlKCBzZXR0aW5ncywgY2FsbGJhY2tBcnIsIGV2ZW50TmFtZSwgYXJncyApXG5cdHtcblx0XHR2YXIgcmV0ID0gW107XG5cdFxuXHRcdGlmICggY2FsbGJhY2tBcnIgKSB7XG5cdFx0XHRyZXQgPSAkLm1hcCggc2V0dGluZ3NbY2FsbGJhY2tBcnJdLnNsaWNlKCkucmV2ZXJzZSgpLCBmdW5jdGlvbiAodmFsLCBpKSB7XG5cdFx0XHRcdHJldHVybiB2YWwuZm4uYXBwbHkoIHNldHRpbmdzLm9JbnN0YW5jZSwgYXJncyApO1xuXHRcdFx0fSApO1xuXHRcdH1cblx0XG5cdFx0aWYgKCBldmVudE5hbWUgIT09IG51bGwgKSB7XG5cdFx0XHR2YXIgZSA9ICQuRXZlbnQoIGV2ZW50TmFtZSsnLmR0JyApO1xuXHRcblx0XHRcdCQoc2V0dGluZ3MublRhYmxlKS50cmlnZ2VyKCBlLCBhcmdzICk7XG5cdFxuXHRcdFx0cmV0LnB1c2goIGUucmVzdWx0ICk7XG5cdFx0fVxuXHRcblx0XHRyZXR1cm4gcmV0O1xuXHR9XG5cdFxuXHRcblx0ZnVuY3Rpb24gX2ZuTGVuZ3RoT3ZlcmZsb3cgKCBzZXR0aW5ncyApXG5cdHtcblx0XHR2YXJcblx0XHRcdHN0YXJ0ID0gc2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQsXG5cdFx0XHRlbmQgPSBzZXR0aW5ncy5mbkRpc3BsYXlFbmQoKSxcblx0XHRcdGxlbiA9IHNldHRpbmdzLl9pRGlzcGxheUxlbmd0aDtcblx0XG5cdFx0LyogSWYgd2UgaGF2ZSBzcGFjZSB0byBzaG93IGV4dHJhIHJvd3MgKGJhY2tpbmcgdXAgZnJvbSB0aGUgZW5kIHBvaW50IC0gdGhlbiBkbyBzbyAqL1xuXHRcdGlmICggc3RhcnQgPj0gZW5kIClcblx0XHR7XG5cdFx0XHRzdGFydCA9IGVuZCAtIGxlbjtcblx0XHR9XG5cdFxuXHRcdC8vIEtlZXAgdGhlIHN0YXJ0IHJlY29yZCBvbiB0aGUgY3VycmVudCBwYWdlXG5cdFx0c3RhcnQgLT0gKHN0YXJ0ICUgbGVuKTtcblx0XG5cdFx0aWYgKCBsZW4gPT09IC0xIHx8IHN0YXJ0IDwgMCApXG5cdFx0e1xuXHRcdFx0c3RhcnQgPSAwO1xuXHRcdH1cblx0XG5cdFx0c2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQgPSBzdGFydDtcblx0fVxuXHRcblx0XG5cdGZ1bmN0aW9uIF9mblJlbmRlcmVyKCBzZXR0aW5ncywgdHlwZSApXG5cdHtcblx0XHR2YXIgcmVuZGVyZXIgPSBzZXR0aW5ncy5yZW5kZXJlcjtcblx0XHR2YXIgaG9zdCA9IERhdGFUYWJsZS5leHQucmVuZGVyZXJbdHlwZV07XG5cdFxuXHRcdGlmICggJC5pc1BsYWluT2JqZWN0KCByZW5kZXJlciApICYmIHJlbmRlcmVyW3R5cGVdICkge1xuXHRcdFx0Ly8gU3BlY2lmaWMgcmVuZGVyZXIgZm9yIHRoaXMgdHlwZS4gSWYgYXZhaWxhYmxlIHVzZSBpdCwgb3RoZXJ3aXNlIHVzZVxuXHRcdFx0Ly8gdGhlIGRlZmF1bHQuXG5cdFx0XHRyZXR1cm4gaG9zdFtyZW5kZXJlclt0eXBlXV0gfHwgaG9zdC5fO1xuXHRcdH1cblx0XHRlbHNlIGlmICggdHlwZW9mIHJlbmRlcmVyID09PSAnc3RyaW5nJyApIHtcblx0XHRcdC8vIENvbW1vbiByZW5kZXJlciAtIGlmIHRoZXJlIGlzIG9uZSBhdmFpbGFibGUgZm9yIHRoaXMgdHlwZSB1c2UgaXQsXG5cdFx0XHQvLyBvdGhlcndpc2UgdXNlIHRoZSBkZWZhdWx0XG5cdFx0XHRyZXR1cm4gaG9zdFtyZW5kZXJlcl0gfHwgaG9zdC5fO1xuXHRcdH1cblx0XG5cdFx0Ly8gVXNlIHRoZSBkZWZhdWx0XG5cdFx0cmV0dXJuIGhvc3QuXztcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBEZXRlY3QgdGhlIGRhdGEgc291cmNlIGJlaW5nIHVzZWQgZm9yIHRoZSB0YWJsZS4gVXNlZCB0byBzaW1wbGlmeSB0aGUgY29kZVxuXHQgKiBhIGxpdHRsZSAoYWpheCkgYW5kIHRvIG1ha2UgaXQgY29tcHJlc3MgYSBsaXR0bGUgc21hbGxlci5cblx0ICpcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHJldHVybnMge3N0cmluZ30gRGF0YSBzb3VyY2Vcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuRGF0YVNvdXJjZSAoIHNldHRpbmdzIClcblx0e1xuXHRcdGlmICggc2V0dGluZ3Mub0ZlYXR1cmVzLmJTZXJ2ZXJTaWRlICkge1xuXHRcdFx0cmV0dXJuICdzc3AnO1xuXHRcdH1cblx0XHRlbHNlIGlmICggc2V0dGluZ3MuYWpheCB8fCBzZXR0aW5ncy5zQWpheFNvdXJjZSApIHtcblx0XHRcdHJldHVybiAnYWpheCc7XG5cdFx0fVxuXHRcdHJldHVybiAnZG9tJztcblx0fVxuXHRcblxuXHRcblx0XG5cdC8qKlxuXHQgKiBDb21wdXRlZCBzdHJ1Y3R1cmUgb2YgdGhlIERhdGFUYWJsZXMgQVBJLCBkZWZpbmVkIGJ5IHRoZSBvcHRpb25zIHBhc3NlZCB0b1xuXHQgKiBgRGF0YVRhYmxlLkFwaS5yZWdpc3RlcigpYCB3aGVuIGJ1aWxkaW5nIHRoZSBBUEkuXG5cdCAqXG5cdCAqIFRoZSBzdHJ1Y3R1cmUgaXMgYnVpbHQgaW4gb3JkZXIgdG8gc3BlZWQgY3JlYXRpb24gYW5kIGV4dGVuc2lvbiBvZiB0aGUgQXBpXG5cdCAqIG9iamVjdHMgc2luY2UgdGhlIGV4dGVuc2lvbnMgYXJlIGVmZmVjdGl2ZWx5IHByZS1wYXJzZWQuXG5cdCAqXG5cdCAqIFRoZSBhcnJheSBpcyBhbiBhcnJheSBvZiBvYmplY3RzIHdpdGggdGhlIGZvbGxvd2luZyBzdHJ1Y3R1cmUsIHdoZXJlIHRoaXNcblx0ICogYmFzZSBhcnJheSByZXByZXNlbnRzIHRoZSBBcGkgcHJvdG90eXBlIGJhc2U6XG5cdCAqXG5cdCAqICAgICBbXG5cdCAqICAgICAgIHtcblx0ICogICAgICAgICBuYW1lOiAgICAgICdkYXRhJyAgICAgICAgICAgICAgICAtLSBzdHJpbmcgICAtIFByb3BlcnR5IG5hbWVcblx0ICogICAgICAgICB2YWw6ICAgICAgIGZ1bmN0aW9uICgpIHt9LCAgICAgICAtLSBmdW5jdGlvbiAtIEFwaSBtZXRob2QgKG9yIHVuZGVmaW5lZCBpZiBqdXN0IGFuIG9iamVjdFxuXHQgKiAgICAgICAgIG1ldGhvZEV4dDogWyAuLi4gXSwgICAgICAgICAgICAgIC0tIGFycmF5ICAgIC0gQXJyYXkgb2YgQXBpIG9iamVjdCBkZWZpbml0aW9ucyB0byBleHRlbmQgdGhlIG1ldGhvZCByZXN1bHRcblx0ICogICAgICAgICBwcm9wRXh0OiAgIFsgLi4uIF0gICAgICAgICAgICAgICAtLSBhcnJheSAgICAtIEFycmF5IG9mIEFwaSBvYmplY3QgZGVmaW5pdGlvbnMgdG8gZXh0ZW5kIHRoZSBwcm9wZXJ0eVxuXHQgKiAgICAgICB9LFxuXHQgKiAgICAgICB7XG5cdCAqICAgICAgICAgbmFtZTogICAgICdyb3cnXG5cdCAqICAgICAgICAgdmFsOiAgICAgICB7fSxcblx0ICogICAgICAgICBtZXRob2RFeHQ6IFsgLi4uIF0sXG5cdCAqICAgICAgICAgcHJvcEV4dDogICBbXG5cdCAqICAgICAgICAgICB7XG5cdCAqICAgICAgICAgICAgIG5hbWU6ICAgICAgJ2RhdGEnXG5cdCAqICAgICAgICAgICAgIHZhbDogICAgICAgZnVuY3Rpb24gKCkge30sXG5cdCAqICAgICAgICAgICAgIG1ldGhvZEV4dDogWyAuLi4gXSxcblx0ICogICAgICAgICAgICAgcHJvcEV4dDogICBbIC4uLiBdXG5cdCAqICAgICAgICAgICB9LFxuXHQgKiAgICAgICAgICAgLi4uXG5cdCAqICAgICAgICAgXVxuXHQgKiAgICAgICB9XG5cdCAqICAgICBdXG5cdCAqXG5cdCAqIEB0eXBlIHtBcnJheX1cblx0ICogQGlnbm9yZVxuXHQgKi9cblx0dmFyIF9fYXBpU3RydWN0ID0gW107XG5cdFxuXHRcblx0LyoqXG5cdCAqIGBBcnJheS5wcm90b3R5cGVgIHJlZmVyZW5jZS5cblx0ICpcblx0ICogQHR5cGUgb2JqZWN0XG5cdCAqIEBpZ25vcmVcblx0ICovXG5cdHZhciBfX2FycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cdFxuXHRcblx0LyoqXG5cdCAqIEFic3RyYWN0aW9uIGZvciBgY29udGV4dGAgcGFyYW1ldGVyIG9mIHRoZSBgQXBpYCBjb25zdHJ1Y3RvciB0byBhbGxvdyBpdCB0b1xuXHQgKiB0YWtlIHNldmVyYWwgZGlmZmVyZW50IGZvcm1zIGZvciBlYXNlIG9mIHVzZS5cblx0ICpcblx0ICogRWFjaCBvZiB0aGUgaW5wdXQgcGFyYW1ldGVyIHR5cGVzIHdpbGwgYmUgY29udmVydGVkIHRvIGEgRGF0YVRhYmxlcyBzZXR0aW5nc1xuXHQgKiBvYmplY3Qgd2hlcmUgcG9zc2libGUuXG5cdCAqXG5cdCAqIEBwYXJhbSAge3N0cmluZ3xub2RlfGpRdWVyeXxvYmplY3R9IG1peGVkIERhdGFUYWJsZSBpZGVudGlmaWVyLiBDYW4gYmUgb25lXG5cdCAqICAgb2Y6XG5cdCAqXG5cdCAqICAgKiBgc3RyaW5nYCAtIGpRdWVyeSBzZWxlY3Rvci4gQW55IERhdGFUYWJsZXMnIG1hdGNoaW5nIHRoZSBnaXZlbiBzZWxlY3RvclxuXHQgKiAgICAgd2l0aCBiZSBmb3VuZCBhbmQgdXNlZC5cblx0ICogICAqIGBub2RlYCAtIGBUQUJMRWAgbm9kZSB3aGljaCBoYXMgYWxyZWFkeSBiZWVuIGZvcm1lZCBpbnRvIGEgRGF0YVRhYmxlLlxuXHQgKiAgICogYGpRdWVyeWAgLSBBIGpRdWVyeSBvYmplY3Qgb2YgYFRBQkxFYCBub2Rlcy5cblx0ICogICAqIGBvYmplY3RgIC0gRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogICAqIGBEYXRhVGFibGVzLkFwaWAgLSBBUEkgaW5zdGFuY2Vcblx0ICogQHJldHVybiB7YXJyYXl8bnVsbH0gTWF0Y2hpbmcgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RzLiBgbnVsbGAgb3Jcblx0ICogICBgdW5kZWZpbmVkYCBpcyByZXR1cm5lZCBpZiBubyBtYXRjaGluZyBEYXRhVGFibGUgaXMgZm91bmQuXG5cdCAqIEBpZ25vcmVcblx0ICovXG5cdHZhciBfdG9TZXR0aW5ncyA9IGZ1bmN0aW9uICggbWl4ZWQgKVxuXHR7XG5cdFx0dmFyIGlkeCwganE7XG5cdFx0dmFyIHNldHRpbmdzID0gRGF0YVRhYmxlLnNldHRpbmdzO1xuXHRcdHZhciB0YWJsZXMgPSAkLm1hcCggc2V0dGluZ3MsIGZ1bmN0aW9uIChlbCwgaSkge1xuXHRcdFx0cmV0dXJuIGVsLm5UYWJsZTtcblx0XHR9ICk7XG5cdFxuXHRcdGlmICggISBtaXhlZCApIHtcblx0XHRcdHJldHVybiBbXTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIG1peGVkLm5UYWJsZSAmJiBtaXhlZC5vQXBpICkge1xuXHRcdFx0Ly8gRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0XHRcdHJldHVybiBbIG1peGVkIF07XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCBtaXhlZC5ub2RlTmFtZSAmJiBtaXhlZC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAndGFibGUnICkge1xuXHRcdFx0Ly8gVGFibGUgbm9kZVxuXHRcdFx0aWR4ID0gJC5pbkFycmF5KCBtaXhlZCwgdGFibGVzICk7XG5cdFx0XHRyZXR1cm4gaWR4ICE9PSAtMSA/IFsgc2V0dGluZ3NbaWR4XSBdIDogbnVsbDtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIG1peGVkICYmIHR5cGVvZiBtaXhlZC5zZXR0aW5ncyA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdHJldHVybiBtaXhlZC5zZXR0aW5ncygpLnRvQXJyYXkoKTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIHR5cGVvZiBtaXhlZCA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHQvLyBqUXVlcnkgc2VsZWN0b3Jcblx0XHRcdGpxID0gJChtaXhlZCk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCBtaXhlZCBpbnN0YW5jZW9mICQgKSB7XG5cdFx0XHQvLyBqUXVlcnkgb2JqZWN0IChhbHNvIERhdGFUYWJsZXMgaW5zdGFuY2UpXG5cdFx0XHRqcSA9IG1peGVkO1xuXHRcdH1cblx0XG5cdFx0aWYgKCBqcSApIHtcblx0XHRcdHJldHVybiBqcS5tYXAoIGZ1bmN0aW9uKGkpIHtcblx0XHRcdFx0aWR4ID0gJC5pbkFycmF5KCB0aGlzLCB0YWJsZXMgKTtcblx0XHRcdFx0cmV0dXJuIGlkeCAhPT0gLTEgPyBzZXR0aW5nc1tpZHhdIDogbnVsbDtcblx0XHRcdH0gKS50b0FycmF5KCk7XG5cdFx0fVxuXHR9O1xuXHRcblx0XG5cdC8qKlxuXHQgKiBEYXRhVGFibGVzIEFQSSBjbGFzcyAtIHVzZWQgdG8gY29udHJvbCBhbmQgaW50ZXJmYWNlIHdpdGggIG9uZSBvciBtb3JlXG5cdCAqIERhdGFUYWJsZXMgZW5oYW5jZWQgdGFibGVzLlxuXHQgKlxuXHQgKiBUaGUgQVBJIGNsYXNzIGlzIGhlYXZpbHkgYmFzZWQgb24galF1ZXJ5LCBwcmVzZW50aW5nIGEgY2hhaW5hYmxlIGludGVyZmFjZVxuXHQgKiB0aGF0IHlvdSBjYW4gdXNlIHRvIGludGVyYWN0IHdpdGggdGFibGVzLiBFYWNoIGluc3RhbmNlIG9mIHRoZSBBUEkgY2xhc3MgaGFzXG5cdCAqIGEgXCJjb250ZXh0XCIgLSBpLmUuIHRoZSB0YWJsZXMgdGhhdCBpdCB3aWxsIG9wZXJhdGUgb24uIFRoaXMgY291bGQgYmUgYSBzaW5nbGVcblx0ICogdGFibGUsIGFsbCB0YWJsZXMgb24gYSBwYWdlIG9yIGEgc3ViLXNldCB0aGVyZW9mLlxuXHQgKlxuXHQgKiBBZGRpdGlvbmFsbHkgdGhlIEFQSSBpcyBkZXNpZ25lZCB0byBhbGxvdyB5b3UgdG8gZWFzaWx5IHdvcmsgd2l0aCB0aGUgZGF0YSBpblxuXHQgKiB0aGUgdGFibGVzLCByZXRyaWV2aW5nIGFuZCBtYW5pcHVsYXRpbmcgaXQgYXMgcmVxdWlyZWQuIFRoaXMgaXMgZG9uZSBieVxuXHQgKiBwcmVzZW50aW5nIHRoZSBBUEkgY2xhc3MgYXMgYW4gYXJyYXkgbGlrZSBpbnRlcmZhY2UuIFRoZSBjb250ZW50cyBvZiB0aGVcblx0ICogYXJyYXkgZGVwZW5kIHVwb24gdGhlIGFjdGlvbnMgcmVxdWVzdGVkIGJ5IGVhY2ggbWV0aG9kIChmb3IgZXhhbXBsZVxuXHQgKiBgcm93cygpLm5vZGVzKClgIHdpbGwgcmV0dXJuIGFuIGFycmF5IG9mIG5vZGVzLCB3aGlsZSBgcm93cygpLmRhdGEoKWAgd2lsbFxuXHQgKiByZXR1cm4gYW4gYXJyYXkgb2Ygb2JqZWN0cyBvciBhcnJheXMgZGVwZW5kaW5nIHVwb24geW91ciB0YWJsZSdzXG5cdCAqIGNvbmZpZ3VyYXRpb24pLiBUaGUgQVBJIG9iamVjdCBoYXMgYSBudW1iZXIgb2YgYXJyYXkgbGlrZSBtZXRob2RzIChgcHVzaGAsXG5cdCAqIGBwb3BgLCBgcmV2ZXJzZWAgZXRjKSBhcyB3ZWxsIGFzIGFkZGl0aW9uYWwgaGVscGVyIG1ldGhvZHMgKGBlYWNoYCwgYHBsdWNrYCxcblx0ICogYHVuaXF1ZWAgZXRjKSB0byBhc3Npc3QgeW91ciB3b3JraW5nIHdpdGggdGhlIGRhdGEgaGVsZCBpbiBhIHRhYmxlLlxuXHQgKlxuXHQgKiBNb3N0IG1ldGhvZHMgKHRob3NlIHdoaWNoIHJldHVybiBhbiBBcGkgaW5zdGFuY2UpIGFyZSBjaGFpbmFibGUsIHdoaWNoIG1lYW5zXG5cdCAqIHRoZSByZXR1cm4gZnJvbSBhIG1ldGhvZCBjYWxsIGFsc28gaGFzIGFsbCBvZiB0aGUgbWV0aG9kcyBhdmFpbGFibGUgdGhhdCB0aGVcblx0ICogdG9wIGxldmVsIG9iamVjdCBoYWQuIEZvciBleGFtcGxlLCB0aGVzZSB0d28gY2FsbHMgYXJlIGVxdWl2YWxlbnQ6XG5cdCAqXG5cdCAqICAgICAvLyBOb3QgY2hhaW5lZFxuXHQgKiAgICAgYXBpLnJvdy5hZGQoIHsuLi59ICk7XG5cdCAqICAgICBhcGkuZHJhdygpO1xuXHQgKlxuXHQgKiAgICAgLy8gQ2hhaW5lZFxuXHQgKiAgICAgYXBpLnJvdy5hZGQoIHsuLi59ICkuZHJhdygpO1xuXHQgKlxuXHQgKiBAY2xhc3MgRGF0YVRhYmxlLkFwaVxuXHQgKiBAcGFyYW0ge2FycmF5fG9iamVjdHxzdHJpbmd8alF1ZXJ5fSBjb250ZXh0IERhdGFUYWJsZSBpZGVudGlmaWVyLiBUaGlzIGlzXG5cdCAqICAgdXNlZCB0byBkZWZpbmUgd2hpY2ggRGF0YVRhYmxlcyBlbmhhbmNlZCB0YWJsZXMgdGhpcyBBUEkgd2lsbCBvcGVyYXRlIG9uLlxuXHQgKiAgIENhbiBiZSBvbmUgb2Y6XG5cdCAqXG5cdCAqICAgKiBgc3RyaW5nYCAtIGpRdWVyeSBzZWxlY3Rvci4gQW55IERhdGFUYWJsZXMnIG1hdGNoaW5nIHRoZSBnaXZlbiBzZWxlY3RvclxuXHQgKiAgICAgd2l0aCBiZSBmb3VuZCBhbmQgdXNlZC5cblx0ICogICAqIGBub2RlYCAtIGBUQUJMRWAgbm9kZSB3aGljaCBoYXMgYWxyZWFkeSBiZWVuIGZvcm1lZCBpbnRvIGEgRGF0YVRhYmxlLlxuXHQgKiAgICogYGpRdWVyeWAgLSBBIGpRdWVyeSBvYmplY3Qgb2YgYFRBQkxFYCBub2Rlcy5cblx0ICogICAqIGBvYmplY3RgIC0gRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogQHBhcmFtIHthcnJheX0gW2RhdGFdIERhdGEgdG8gaW5pdGlhbGlzZSB0aGUgQXBpIGluc3RhbmNlIHdpdGguXG5cdCAqXG5cdCAqIEBleGFtcGxlXG5cdCAqICAgLy8gRGlyZWN0IGluaXRpYWxpc2F0aW9uIGR1cmluZyBEYXRhVGFibGVzIGNvbnN0cnVjdGlvblxuXHQgKiAgIHZhciBhcGkgPSAkKCcjZXhhbXBsZScpLkRhdGFUYWJsZSgpO1xuXHQgKlxuXHQgKiBAZXhhbXBsZVxuXHQgKiAgIC8vIEluaXRpYWxpc2F0aW9uIHVzaW5nIGEgRGF0YVRhYmxlcyBqUXVlcnkgb2JqZWN0XG5cdCAqICAgdmFyIGFwaSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCkuYXBpKCk7XG5cdCAqXG5cdCAqIEBleGFtcGxlXG5cdCAqICAgLy8gSW5pdGlhbGlzYXRpb24gYXMgYSBjb25zdHJ1Y3RvclxuXHQgKiAgIHZhciBhcGkgPSBuZXcgJC5mbi5EYXRhVGFibGUuQXBpKCAndGFibGUuZGF0YVRhYmxlJyApO1xuXHQgKi9cblx0X0FwaSA9IGZ1bmN0aW9uICggY29udGV4dCwgZGF0YSApXG5cdHtcblx0XHRpZiAoICEgKHRoaXMgaW5zdGFuY2VvZiBfQXBpKSApIHtcblx0XHRcdHJldHVybiBuZXcgX0FwaSggY29udGV4dCwgZGF0YSApO1xuXHRcdH1cblx0XG5cdFx0dmFyIHNldHRpbmdzID0gW107XG5cdFx0dmFyIGN0eFNldHRpbmdzID0gZnVuY3Rpb24gKCBvICkge1xuXHRcdFx0dmFyIGEgPSBfdG9TZXR0aW5ncyggbyApO1xuXHRcdFx0aWYgKCBhICkge1xuXHRcdFx0XHRzZXR0aW5ncy5wdXNoLmFwcGx5KCBzZXR0aW5ncywgYSApO1xuXHRcdFx0fVxuXHRcdH07XG5cdFxuXHRcdGlmICggJC5pc0FycmF5KCBjb250ZXh0ICkgKSB7XG5cdFx0XHRmb3IgKCB2YXIgaT0wLCBpZW49Y29udGV4dC5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0Y3R4U2V0dGluZ3MoIGNvbnRleHRbaV0gKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRjdHhTZXR0aW5ncyggY29udGV4dCApO1xuXHRcdH1cblx0XG5cdFx0Ly8gUmVtb3ZlIGR1cGxpY2F0ZXNcblx0XHR0aGlzLmNvbnRleHQgPSBfdW5pcXVlKCBzZXR0aW5ncyApO1xuXHRcblx0XHQvLyBJbml0aWFsIGRhdGFcblx0XHRpZiAoIGRhdGEgKSB7XG5cdFx0XHQkLm1lcmdlKCB0aGlzLCBkYXRhICk7XG5cdFx0fVxuXHRcblx0XHQvLyBzZWxlY3RvclxuXHRcdHRoaXMuc2VsZWN0b3IgPSB7XG5cdFx0XHRyb3dzOiBudWxsLFxuXHRcdFx0Y29sczogbnVsbCxcblx0XHRcdG9wdHM6IG51bGxcblx0XHR9O1xuXHRcblx0XHRfQXBpLmV4dGVuZCggdGhpcywgdGhpcywgX19hcGlTdHJ1Y3QgKTtcblx0fTtcblx0XG5cdERhdGFUYWJsZS5BcGkgPSBfQXBpO1xuXHRcblx0Ly8gRG9uJ3QgZGVzdHJveSB0aGUgZXhpc3RpbmcgcHJvdG90eXBlLCBqdXN0IGV4dGVuZCBpdC4gUmVxdWlyZWQgZm9yIGpRdWVyeSAyJ3Ncblx0Ly8gaXNQbGFpbk9iamVjdC5cblx0JC5leHRlbmQoIF9BcGkucHJvdG90eXBlLCB7XG5cdFx0YW55OiBmdW5jdGlvbiAoKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLmNvdW50KCkgIT09IDA7XG5cdFx0fSxcblx0XG5cdFxuXHRcdGNvbmNhdDogIF9fYXJyYXlQcm90by5jb25jYXQsXG5cdFxuXHRcblx0XHRjb250ZXh0OiBbXSwgLy8gYXJyYXkgb2YgdGFibGUgc2V0dGluZ3Mgb2JqZWN0c1xuXHRcblx0XG5cdFx0Y291bnQ6IGZ1bmN0aW9uICgpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMuZmxhdHRlbigpLmxlbmd0aDtcblx0XHR9LFxuXHRcblx0XG5cdFx0ZWFjaDogZnVuY3Rpb24gKCBmbiApXG5cdFx0e1xuXHRcdFx0Zm9yICggdmFyIGk9MCwgaWVuPXRoaXMubGVuZ3RoIDsgaTxpZW47IGkrKyApIHtcblx0XHRcdFx0Zm4uY2FsbCggdGhpcywgdGhpc1tpXSwgaSwgdGhpcyApO1xuXHRcdFx0fVxuXHRcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH0sXG5cdFxuXHRcblx0XHRlcTogZnVuY3Rpb24gKCBpZHggKVxuXHRcdHtcblx0XHRcdHZhciBjdHggPSB0aGlzLmNvbnRleHQ7XG5cdFxuXHRcdFx0cmV0dXJuIGN0eC5sZW5ndGggPiBpZHggP1xuXHRcdFx0XHRuZXcgX0FwaSggY3R4W2lkeF0sIHRoaXNbaWR4XSApIDpcblx0XHRcdFx0bnVsbDtcblx0XHR9LFxuXHRcblx0XG5cdFx0ZmlsdGVyOiBmdW5jdGlvbiAoIGZuIClcblx0XHR7XG5cdFx0XHR2YXIgYSA9IFtdO1xuXHRcblx0XHRcdGlmICggX19hcnJheVByb3RvLmZpbHRlciApIHtcblx0XHRcdFx0YSA9IF9fYXJyYXlQcm90by5maWx0ZXIuY2FsbCggdGhpcywgZm4sIHRoaXMgKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHQvLyBDb21wYXRpYmlsaXR5IGZvciBicm93c2VycyB3aXRob3V0IEVNQ0EtMjUyLTUgKEpTIDEuNilcblx0XHRcdFx0Zm9yICggdmFyIGk9MCwgaWVuPXRoaXMubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdFx0aWYgKCBmbi5jYWxsKCB0aGlzLCB0aGlzW2ldLCBpLCB0aGlzICkgKSB7XG5cdFx0XHRcdFx0XHRhLnB1c2goIHRoaXNbaV0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XG5cdFx0XHRyZXR1cm4gbmV3IF9BcGkoIHRoaXMuY29udGV4dCwgYSApO1xuXHRcdH0sXG5cdFxuXHRcblx0XHRmbGF0dGVuOiBmdW5jdGlvbiAoKVxuXHRcdHtcblx0XHRcdHZhciBhID0gW107XG5cdFx0XHRyZXR1cm4gbmV3IF9BcGkoIHRoaXMuY29udGV4dCwgYS5jb25jYXQuYXBwbHkoIGEsIHRoaXMudG9BcnJheSgpICkgKTtcblx0XHR9LFxuXHRcblx0XG5cdFx0am9pbjogICAgX19hcnJheVByb3RvLmpvaW4sXG5cdFxuXHRcblx0XHRpbmRleE9mOiBfX2FycmF5UHJvdG8uaW5kZXhPZiB8fCBmdW5jdGlvbiAob2JqLCBzdGFydClcblx0XHR7XG5cdFx0XHRmb3IgKCB2YXIgaT0oc3RhcnQgfHwgMCksIGllbj10aGlzLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIHRoaXNbaV0gPT09IG9iaiApIHtcblx0XHRcdFx0XHRyZXR1cm4gaTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIC0xO1xuXHRcdH0sXG5cdFxuXHRcdGl0ZXJhdG9yOiBmdW5jdGlvbiAoIGZsYXR0ZW4sIHR5cGUsIGZuLCBhbHdheXNOZXcgKSB7XG5cdFx0XHR2YXJcblx0XHRcdFx0YSA9IFtdLCByZXQsXG5cdFx0XHRcdGksIGllbiwgaiwgamVuLFxuXHRcdFx0XHRjb250ZXh0ID0gdGhpcy5jb250ZXh0LFxuXHRcdFx0XHRyb3dzLCBpdGVtcywgaXRlbSxcblx0XHRcdFx0c2VsZWN0b3IgPSB0aGlzLnNlbGVjdG9yO1xuXHRcblx0XHRcdC8vIEFyZ3VtZW50IHNoaWZ0aW5nXG5cdFx0XHRpZiAoIHR5cGVvZiBmbGF0dGVuID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0YWx3YXlzTmV3ID0gZm47XG5cdFx0XHRcdGZuID0gdHlwZTtcblx0XHRcdFx0dHlwZSA9IGZsYXR0ZW47XG5cdFx0XHRcdGZsYXR0ZW4gPSBmYWxzZTtcblx0XHRcdH1cblx0XG5cdFx0XHRmb3IgKCBpPTAsIGllbj1jb250ZXh0Lmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHR2YXIgYXBpSW5zdCA9IG5ldyBfQXBpKCBjb250ZXh0W2ldICk7XG5cdFxuXHRcdFx0XHRpZiAoIHR5cGUgPT09ICd0YWJsZScgKSB7XG5cdFx0XHRcdFx0cmV0ID0gZm4uY2FsbCggYXBpSW5zdCwgY29udGV4dFtpXSwgaSApO1xuXHRcblx0XHRcdFx0XHRpZiAoIHJldCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0YS5wdXNoKCByZXQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAoIHR5cGUgPT09ICdjb2x1bW5zJyB8fCB0eXBlID09PSAncm93cycgKSB7XG5cdFx0XHRcdFx0Ly8gdGhpcyBoYXMgc2FtZSBsZW5ndGggYXMgY29udGV4dCAtIG9uZSBlbnRyeSBmb3IgZWFjaCB0YWJsZVxuXHRcdFx0XHRcdHJldCA9IGZuLmNhbGwoIGFwaUluc3QsIGNvbnRleHRbaV0sIHRoaXNbaV0sIGkgKTtcblx0XG5cdFx0XHRcdFx0aWYgKCByZXQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdGEucHVzaCggcmV0ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKCB0eXBlID09PSAnY29sdW1uJyB8fCB0eXBlID09PSAnY29sdW1uLXJvd3MnIHx8IHR5cGUgPT09ICdyb3cnIHx8IHR5cGUgPT09ICdjZWxsJyApIHtcblx0XHRcdFx0XHQvLyBjb2x1bW5zIGFuZCByb3dzIHNoYXJlIHRoZSBzYW1lIHN0cnVjdHVyZS5cblx0XHRcdFx0XHQvLyAndGhpcycgaXMgYW4gYXJyYXkgb2YgY29sdW1uIGluZGV4ZXMgZm9yIGVhY2ggY29udGV4dFxuXHRcdFx0XHRcdGl0ZW1zID0gdGhpc1tpXTtcblx0XG5cdFx0XHRcdFx0aWYgKCB0eXBlID09PSAnY29sdW1uLXJvd3MnICkge1xuXHRcdFx0XHRcdFx0cm93cyA9IF9zZWxlY3Rvcl9yb3dfaW5kZXhlcyggY29udGV4dFtpXSwgc2VsZWN0b3Iub3B0cyApO1xuXHRcdFx0XHRcdH1cblx0XG5cdFx0XHRcdFx0Zm9yICggaj0wLCBqZW49aXRlbXMubGVuZ3RoIDsgajxqZW4gOyBqKysgKSB7XG5cdFx0XHRcdFx0XHRpdGVtID0gaXRlbXNbal07XG5cdFxuXHRcdFx0XHRcdFx0aWYgKCB0eXBlID09PSAnY2VsbCcgKSB7XG5cdFx0XHRcdFx0XHRcdHJldCA9IGZuLmNhbGwoIGFwaUluc3QsIGNvbnRleHRbaV0sIGl0ZW0ucm93LCBpdGVtLmNvbHVtbiwgaSwgaiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHJldCA9IGZuLmNhbGwoIGFwaUluc3QsIGNvbnRleHRbaV0sIGl0ZW0sIGksIGosIHJvd3MgKTtcblx0XHRcdFx0XHRcdH1cblx0XG5cdFx0XHRcdFx0XHRpZiAoIHJldCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0XHRhLnB1c2goIHJldCApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcblx0XHRcdGlmICggYS5sZW5ndGggfHwgYWx3YXlzTmV3ICkge1xuXHRcdFx0XHR2YXIgYXBpID0gbmV3IF9BcGkoIGNvbnRleHQsIGZsYXR0ZW4gPyBhLmNvbmNhdC5hcHBseSggW10sIGEgKSA6IGEgKTtcblx0XHRcdFx0dmFyIGFwaVNlbGVjdG9yID0gYXBpLnNlbGVjdG9yO1xuXHRcdFx0XHRhcGlTZWxlY3Rvci5yb3dzID0gc2VsZWN0b3Iucm93cztcblx0XHRcdFx0YXBpU2VsZWN0b3IuY29scyA9IHNlbGVjdG9yLmNvbHM7XG5cdFx0XHRcdGFwaVNlbGVjdG9yLm9wdHMgPSBzZWxlY3Rvci5vcHRzO1xuXHRcdFx0XHRyZXR1cm4gYXBpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSxcblx0XG5cdFxuXHRcdGxhc3RJbmRleE9mOiBfX2FycmF5UHJvdG8ubGFzdEluZGV4T2YgfHwgZnVuY3Rpb24gKG9iaiwgc3RhcnQpXG5cdFx0e1xuXHRcdFx0Ly8gQml0IGNoZWVreS4uLlxuXHRcdFx0cmV0dXJuIHRoaXMuaW5kZXhPZi5hcHBseSggdGhpcy50b0FycmF5LnJldmVyc2UoKSwgYXJndW1lbnRzICk7XG5cdFx0fSxcblx0XG5cdFxuXHRcdGxlbmd0aDogIDAsXG5cdFxuXHRcblx0XHRtYXA6IGZ1bmN0aW9uICggZm4gKVxuXHRcdHtcblx0XHRcdHZhciBhID0gW107XG5cdFxuXHRcdFx0aWYgKCBfX2FycmF5UHJvdG8ubWFwICkge1xuXHRcdFx0XHRhID0gX19hcnJheVByb3RvLm1hcC5jYWxsKCB0aGlzLCBmbiwgdGhpcyApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdC8vIENvbXBhdGliaWxpdHkgZm9yIGJyb3dzZXJzIHdpdGhvdXQgRU1DQS0yNTItNSAoSlMgMS42KVxuXHRcdFx0XHRmb3IgKCB2YXIgaT0wLCBpZW49dGhpcy5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0XHRhLnB1c2goIGZuLmNhbGwoIHRoaXMsIHRoaXNbaV0sIGkgKSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFxuXHRcdFx0cmV0dXJuIG5ldyBfQXBpKCB0aGlzLmNvbnRleHQsIGEgKTtcblx0XHR9LFxuXHRcblx0XG5cdFx0cGx1Y2s6IGZ1bmN0aW9uICggcHJvcCApXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbiAoIGVsICkge1xuXHRcdFx0XHRyZXR1cm4gZWxbIHByb3AgXTtcblx0XHRcdH0gKTtcblx0XHR9LFxuXHRcblx0XHRwb3A6ICAgICBfX2FycmF5UHJvdG8ucG9wLFxuXHRcblx0XG5cdFx0cHVzaDogICAgX19hcnJheVByb3RvLnB1c2gsXG5cdFxuXHRcblx0XHQvLyBEb2VzIG5vdCByZXR1cm4gYW4gQVBJIGluc3RhbmNlXG5cdFx0cmVkdWNlOiBfX2FycmF5UHJvdG8ucmVkdWNlIHx8IGZ1bmN0aW9uICggZm4sIGluaXQgKVxuXHRcdHtcblx0XHRcdHJldHVybiBfZm5SZWR1Y2UoIHRoaXMsIGZuLCBpbml0LCAwLCB0aGlzLmxlbmd0aCwgMSApO1xuXHRcdH0sXG5cdFxuXHRcblx0XHRyZWR1Y2VSaWdodDogX19hcnJheVByb3RvLnJlZHVjZVJpZ2h0IHx8IGZ1bmN0aW9uICggZm4sIGluaXQgKVxuXHRcdHtcblx0XHRcdHJldHVybiBfZm5SZWR1Y2UoIHRoaXMsIGZuLCBpbml0LCB0aGlzLmxlbmd0aC0xLCAtMSwgLTEgKTtcblx0XHR9LFxuXHRcblx0XG5cdFx0cmV2ZXJzZTogX19hcnJheVByb3RvLnJldmVyc2UsXG5cdFxuXHRcblx0XHQvLyBPYmplY3Qgd2l0aCByb3dzLCBjb2x1bW5zIGFuZCBvcHRzXG5cdFx0c2VsZWN0b3I6IG51bGwsXG5cdFxuXHRcblx0XHRzaGlmdDogICBfX2FycmF5UHJvdG8uc2hpZnQsXG5cdFxuXHRcblx0XHRzbGljZTogZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIG5ldyBfQXBpKCB0aGlzLmNvbnRleHQsIHRoaXMgKTtcblx0XHR9LFxuXHRcblx0XG5cdFx0c29ydDogICAgX19hcnJheVByb3RvLnNvcnQsIC8vID8gbmFtZSAtIG9yZGVyP1xuXHRcblx0XG5cdFx0c3BsaWNlOiAgX19hcnJheVByb3RvLnNwbGljZSxcblx0XG5cdFxuXHRcdHRvQXJyYXk6IGZ1bmN0aW9uICgpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIF9fYXJyYXlQcm90by5zbGljZS5jYWxsKCB0aGlzICk7XG5cdFx0fSxcblx0XG5cdFxuXHRcdHRvJDogZnVuY3Rpb24gKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gJCggdGhpcyApO1xuXHRcdH0sXG5cdFxuXHRcblx0XHR0b0pRdWVyeTogZnVuY3Rpb24gKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gJCggdGhpcyApO1xuXHRcdH0sXG5cdFxuXHRcblx0XHR1bmlxdWU6IGZ1bmN0aW9uICgpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIG5ldyBfQXBpKCB0aGlzLmNvbnRleHQsIF91bmlxdWUodGhpcykgKTtcblx0XHR9LFxuXHRcblx0XG5cdFx0dW5zaGlmdDogX19hcnJheVByb3RvLnVuc2hpZnRcblx0fSApO1xuXHRcblx0XG5cdF9BcGkuZXh0ZW5kID0gZnVuY3Rpb24gKCBzY29wZSwgb2JqLCBleHQgKVxuXHR7XG5cdFx0Ly8gT25seSBleHRlbmQgQVBJIGluc3RhbmNlcyBhbmQgc3RhdGljIHByb3BlcnRpZXMgb2YgdGhlIEFQSVxuXHRcdGlmICggISBleHQubGVuZ3RoIHx8ICEgb2JqIHx8ICggISAob2JqIGluc3RhbmNlb2YgX0FwaSkgJiYgISBvYmouX19kdF93cmFwcGVyICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcblx0XHR2YXJcblx0XHRcdGksIGllbixcblx0XHRcdHN0cnVjdCxcblx0XHRcdG1ldGhvZFNjb3BpbmcgPSBmdW5jdGlvbiAoIHNjb3BlLCBmbiwgc3RydWMgKSB7XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0dmFyIHJldCA9IGZuLmFwcGx5KCBzY29wZSwgYXJndW1lbnRzICk7XG5cdFxuXHRcdFx0XHRcdC8vIE1ldGhvZCBleHRlbnNpb25cblx0XHRcdFx0XHRfQXBpLmV4dGVuZCggcmV0LCByZXQsIHN0cnVjLm1ldGhvZEV4dCApO1xuXHRcdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcblx0XHRmb3IgKCBpPTAsIGllbj1leHQubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRzdHJ1Y3QgPSBleHRbaV07XG5cdFxuXHRcdFx0Ly8gVmFsdWVcblx0XHRcdG9ialsgc3RydWN0Lm5hbWUgXSA9IHN0cnVjdC50eXBlID09PSAnZnVuY3Rpb24nID9cblx0XHRcdFx0bWV0aG9kU2NvcGluZyggc2NvcGUsIHN0cnVjdC52YWwsIHN0cnVjdCApIDpcblx0XHRcdFx0c3RydWN0LnR5cGUgPT09ICdvYmplY3QnID9cblx0XHRcdFx0XHR7fSA6XG5cdFx0XHRcdFx0c3RydWN0LnZhbDtcblx0XG5cdFx0XHRvYmpbIHN0cnVjdC5uYW1lIF0uX19kdF93cmFwcGVyID0gdHJ1ZTtcblx0XG5cdFx0XHQvLyBQcm9wZXJ0eSBleHRlbnNpb25cblx0XHRcdF9BcGkuZXh0ZW5kKCBzY29wZSwgb2JqWyBzdHJ1Y3QubmFtZSBdLCBzdHJ1Y3QucHJvcEV4dCApO1xuXHRcdH1cblx0fTtcblx0XG5cdFxuXHQvLyBAdG9kbyAtIElzIHRoZXJlIG5lZWQgZm9yIGFuIGF1Z21lbnQgZnVuY3Rpb24/XG5cdC8vIF9BcGkuYXVnbWVudCA9IGZ1bmN0aW9uICggaW5zdCwgbmFtZSApXG5cdC8vIHtcblx0Ly8gXHQvLyBGaW5kIHNyYyBvYmplY3QgaW4gdGhlIHN0cnVjdHVyZSBmcm9tIHRoZSBuYW1lXG5cdC8vIFx0dmFyIHBhcnRzID0gbmFtZS5zcGxpdCgnLicpO1xuXHRcblx0Ly8gXHRfQXBpLmV4dGVuZCggaW5zdCwgb2JqICk7XG5cdC8vIH07XG5cdFxuXHRcblx0Ly8gICAgIFtcblx0Ly8gICAgICAge1xuXHQvLyAgICAgICAgIG5hbWU6ICAgICAgJ2RhdGEnICAgICAgICAgICAgICAgIC0tIHN0cmluZyAgIC0gUHJvcGVydHkgbmFtZVxuXHQvLyAgICAgICAgIHZhbDogICAgICAgZnVuY3Rpb24gKCkge30sICAgICAgIC0tIGZ1bmN0aW9uIC0gQXBpIG1ldGhvZCAob3IgdW5kZWZpbmVkIGlmIGp1c3QgYW4gb2JqZWN0XG5cdC8vICAgICAgICAgbWV0aG9kRXh0OiBbIC4uLiBdLCAgICAgICAgICAgICAgLS0gYXJyYXkgICAgLSBBcnJheSBvZiBBcGkgb2JqZWN0IGRlZmluaXRpb25zIHRvIGV4dGVuZCB0aGUgbWV0aG9kIHJlc3VsdFxuXHQvLyAgICAgICAgIHByb3BFeHQ6ICAgWyAuLi4gXSAgICAgICAgICAgICAgIC0tIGFycmF5ICAgIC0gQXJyYXkgb2YgQXBpIG9iamVjdCBkZWZpbml0aW9ucyB0byBleHRlbmQgdGhlIHByb3BlcnR5XG5cdC8vICAgICAgIH0sXG5cdC8vICAgICAgIHtcblx0Ly8gICAgICAgICBuYW1lOiAgICAgJ3Jvdydcblx0Ly8gICAgICAgICB2YWw6ICAgICAgIHt9LFxuXHQvLyAgICAgICAgIG1ldGhvZEV4dDogWyAuLi4gXSxcblx0Ly8gICAgICAgICBwcm9wRXh0OiAgIFtcblx0Ly8gICAgICAgICAgIHtcblx0Ly8gICAgICAgICAgICAgbmFtZTogICAgICAnZGF0YSdcblx0Ly8gICAgICAgICAgICAgdmFsOiAgICAgICBmdW5jdGlvbiAoKSB7fSxcblx0Ly8gICAgICAgICAgICAgbWV0aG9kRXh0OiBbIC4uLiBdLFxuXHQvLyAgICAgICAgICAgICBwcm9wRXh0OiAgIFsgLi4uIF1cblx0Ly8gICAgICAgICAgIH0sXG5cdC8vICAgICAgICAgICAuLi5cblx0Ly8gICAgICAgICBdXG5cdC8vICAgICAgIH1cblx0Ly8gICAgIF1cblx0XG5cdF9BcGkucmVnaXN0ZXIgPSBfYXBpX3JlZ2lzdGVyID0gZnVuY3Rpb24gKCBuYW1lLCB2YWwgKVxuXHR7XG5cdFx0aWYgKCAkLmlzQXJyYXkoIG5hbWUgKSApIHtcblx0XHRcdGZvciAoIHZhciBqPTAsIGplbj1uYW1lLmxlbmd0aCA7IGo8amVuIDsgaisrICkge1xuXHRcdFx0XHRfQXBpLnJlZ2lzdGVyKCBuYW1lW2pdLCB2YWwgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFxuXHRcdHZhclxuXHRcdFx0aSwgaWVuLFxuXHRcdFx0aGVpciA9IG5hbWUuc3BsaXQoJy4nKSxcblx0XHRcdHN0cnVjdCA9IF9fYXBpU3RydWN0LFxuXHRcdFx0a2V5LCBtZXRob2Q7XG5cdFxuXHRcdHZhciBmaW5kID0gZnVuY3Rpb24gKCBzcmMsIG5hbWUgKSB7XG5cdFx0XHRmb3IgKCB2YXIgaT0wLCBpZW49c3JjLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIHNyY1tpXS5uYW1lID09PSBuYW1lICkge1xuXHRcdFx0XHRcdHJldHVybiBzcmNbaV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH07XG5cdFxuXHRcdGZvciAoIGk9MCwgaWVuPWhlaXIubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRtZXRob2QgPSBoZWlyW2ldLmluZGV4T2YoJygpJykgIT09IC0xO1xuXHRcdFx0a2V5ID0gbWV0aG9kID9cblx0XHRcdFx0aGVpcltpXS5yZXBsYWNlKCcoKScsICcnKSA6XG5cdFx0XHRcdGhlaXJbaV07XG5cdFxuXHRcdFx0dmFyIHNyYyA9IGZpbmQoIHN0cnVjdCwga2V5ICk7XG5cdFx0XHRpZiAoICEgc3JjICkge1xuXHRcdFx0XHRzcmMgPSB7XG5cdFx0XHRcdFx0bmFtZTogICAgICBrZXksXG5cdFx0XHRcdFx0dmFsOiAgICAgICB7fSxcblx0XHRcdFx0XHRtZXRob2RFeHQ6IFtdLFxuXHRcdFx0XHRcdHByb3BFeHQ6ICAgW10sXG5cdFx0XHRcdFx0dHlwZTogICAgICAnb2JqZWN0J1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRzdHJ1Y3QucHVzaCggc3JjICk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0aWYgKCBpID09PSBpZW4tMSApIHtcblx0XHRcdFx0c3JjLnZhbCA9IHZhbDtcblx0XHRcdFx0c3JjLnR5cGUgPSB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nID9cblx0XHRcdFx0XHQnZnVuY3Rpb24nIDpcblx0XHRcdFx0XHQkLmlzUGxhaW5PYmplY3QoIHZhbCApID9cblx0XHRcdFx0XHRcdCdvYmplY3QnIDpcblx0XHRcdFx0XHRcdCdvdGhlcic7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0c3RydWN0ID0gbWV0aG9kID9cblx0XHRcdFx0XHRzcmMubWV0aG9kRXh0IDpcblx0XHRcdFx0XHRzcmMucHJvcEV4dDtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdFxuXHRfQXBpLnJlZ2lzdGVyUGx1cmFsID0gX2FwaV9yZWdpc3RlclBsdXJhbCA9IGZ1bmN0aW9uICggcGx1cmFsTmFtZSwgc2luZ3VsYXJOYW1lLCB2YWwgKSB7XG5cdFx0X0FwaS5yZWdpc3RlciggcGx1cmFsTmFtZSwgdmFsICk7XG5cdFxuXHRcdF9BcGkucmVnaXN0ZXIoIHNpbmd1bGFyTmFtZSwgZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIHJldCA9IHZhbC5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFxuXHRcdFx0aWYgKCByZXQgPT09IHRoaXMgKSB7XG5cdFx0XHRcdC8vIFJldHVybmVkIGl0ZW0gaXMgdGhlIEFQSSBpbnN0YW5jZSB0aGF0IHdhcyBwYXNzZWQgaW4sIHJldHVybiBpdFxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCByZXQgaW5zdGFuY2VvZiBfQXBpICkge1xuXHRcdFx0XHQvLyBOZXcgQVBJIGluc3RhbmNlIHJldHVybmVkLCB3YW50IHRoZSB2YWx1ZSBmcm9tIHRoZSBmaXJzdCBpdGVtXG5cdFx0XHRcdC8vIGluIHRoZSByZXR1cm5lZCBhcnJheSBmb3IgdGhlIHNpbmd1bGFyIHJlc3VsdC5cblx0XHRcdFx0cmV0dXJuIHJldC5sZW5ndGggP1xuXHRcdFx0XHRcdCQuaXNBcnJheSggcmV0WzBdICkgP1xuXHRcdFx0XHRcdFx0bmV3IF9BcGkoIHJldC5jb250ZXh0LCByZXRbMF0gKSA6IC8vIEFycmF5IHJlc3VsdHMgYXJlICdlbmhhbmNlZCdcblx0XHRcdFx0XHRcdHJldFswXSA6XG5cdFx0XHRcdFx0dW5kZWZpbmVkO1xuXHRcdFx0fVxuXHRcblx0XHRcdC8vIE5vbi1BUEkgcmV0dXJuIC0ganVzdCBmaXJlIGl0IGJhY2tcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fSApO1xuXHR9O1xuXHRcblx0XG5cdC8qKlxuXHQgKiBTZWxlY3RvciBmb3IgSFRNTCB0YWJsZXMuIEFwcGx5IHRoZSBnaXZlbiBzZWxlY3RvciB0byB0aGUgZ2l2ZSBhcnJheSBvZlxuXHQgKiBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdHMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfGludGVnZXJ9IFtzZWxlY3Rvcl0galF1ZXJ5IHNlbGVjdG9yIHN0cmluZyBvciBpbnRlZ2VyXG5cdCAqIEBwYXJhbSAge2FycmF5fSBBcnJheSBvZiBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdHMgdG8gYmUgZmlsdGVyZWRcblx0ICogQHJldHVybiB7YXJyYXl9XG5cdCAqIEBpZ25vcmVcblx0ICovXG5cdHZhciBfX3RhYmxlX3NlbGVjdG9yID0gZnVuY3Rpb24gKCBzZWxlY3RvciwgYSApXG5cdHtcblx0XHRpZiAoICQuaXNBcnJheShzZWxlY3RvcikgKSB7XG5cdFx0XHRyZXR1cm4gJC5tYXAoIHNlbGVjdG9yLCBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdFx0XHRyZXR1cm4gX190YWJsZV9zZWxlY3RvcihpdGVtLCBhKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cdFxuXHRcdC8vIEludGVnZXIgaXMgdXNlZCB0byBwaWNrIG91dCBhIHRhYmxlIGJ5IGluZGV4XG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09ICdudW1iZXInICkge1xuXHRcdFx0cmV0dXJuIFsgYVsgc2VsZWN0b3IgXSBdO1xuXHRcdH1cblx0XG5cdFx0Ly8gUGVyZm9ybSBhIGpRdWVyeSBzZWxlY3RvciBvbiB0aGUgdGFibGUgbm9kZXNcblx0XHR2YXIgbm9kZXMgPSAkLm1hcCggYSwgZnVuY3Rpb24gKGVsLCBpKSB7XG5cdFx0XHRyZXR1cm4gZWwublRhYmxlO1xuXHRcdH0gKTtcblx0XG5cdFx0cmV0dXJuICQobm9kZXMpXG5cdFx0XHQuZmlsdGVyKCBzZWxlY3RvciApXG5cdFx0XHQubWFwKCBmdW5jdGlvbiAoaSkge1xuXHRcdFx0XHQvLyBOZWVkIHRvIHRyYW5zbGF0ZSBiYWNrIGZyb20gdGhlIHRhYmxlIG5vZGUgdG8gdGhlIHNldHRpbmdzXG5cdFx0XHRcdHZhciBpZHggPSAkLmluQXJyYXkoIHRoaXMsIG5vZGVzICk7XG5cdFx0XHRcdHJldHVybiBhWyBpZHggXTtcblx0XHRcdH0gKVxuXHRcdFx0LnRvQXJyYXkoKTtcblx0fTtcblx0XG5cdFxuXHRcblx0LyoqXG5cdCAqIENvbnRleHQgc2VsZWN0b3IgZm9yIHRoZSBBUEkncyBjb250ZXh0IChpLmUuIHRoZSB0YWJsZXMgdGhlIEFQSSBpbnN0YW5jZVxuXHQgKiByZWZlcnMgdG8uXG5cdCAqXG5cdCAqIEBuYW1lICAgIERhdGFUYWJsZS5BcGkjdGFibGVzXG5cdCAqIEBwYXJhbSB7c3RyaW5nfGludGVnZXJ9IFtzZWxlY3Rvcl0gU2VsZWN0b3IgdG8gcGljayB3aGljaCB0YWJsZXMgdGhlIGl0ZXJhdG9yXG5cdCAqICAgc2hvdWxkIG9wZXJhdGUgb24uIElmIG5vdCBnaXZlbiwgYWxsIHRhYmxlcyBpbiB0aGUgY3VycmVudCBjb250ZXh0IGFyZVxuXHQgKiAgIHVzZWQuIFRoaXMgY2FuIGJlIGdpdmVuIGFzIGEgalF1ZXJ5IHNlbGVjdG9yIChmb3IgZXhhbXBsZSBgJzpndCgwKSdgKSB0b1xuXHQgKiAgIHNlbGVjdCBtdWx0aXBsZSB0YWJsZXMgb3IgYXMgYW4gaW50ZWdlciB0byBzZWxlY3QgYSBzaW5nbGUgdGFibGUuXG5cdCAqIEByZXR1cm5zIHtEYXRhVGFibGUuQXBpfSBSZXR1cm5zIGEgbmV3IEFQSSBpbnN0YW5jZSBpZiBhIHNlbGVjdG9yIGlzIGdpdmVuLlxuXHQgKi9cblx0X2FwaV9yZWdpc3RlciggJ3RhYmxlcygpJywgZnVuY3Rpb24gKCBzZWxlY3RvciApIHtcblx0XHQvLyBBIG5ldyBpbnN0YW5jZSBpcyBjcmVhdGVkIGlmIHRoZXJlIHdhcyBhIHNlbGVjdG9yIHNwZWNpZmllZFxuXHRcdHJldHVybiBzZWxlY3RvciAhPT0gdW5kZWZpbmVkICYmIHNlbGVjdG9yICE9PSBudWxsID9cblx0XHRcdG5ldyBfQXBpKCBfX3RhYmxlX3NlbGVjdG9yKCBzZWxlY3RvciwgdGhpcy5jb250ZXh0ICkgKSA6XG5cdFx0XHR0aGlzO1xuXHR9ICk7XG5cdFxuXHRcblx0X2FwaV9yZWdpc3RlciggJ3RhYmxlKCknLCBmdW5jdGlvbiAoIHNlbGVjdG9yICkge1xuXHRcdHZhciB0YWJsZXMgPSB0aGlzLnRhYmxlcyggc2VsZWN0b3IgKTtcblx0XHR2YXIgY3R4ID0gdGFibGVzLmNvbnRleHQ7XG5cdFxuXHRcdC8vIFRydW5jYXRlIHRvIHRoZSBmaXJzdCBtYXRjaGVkIHRhYmxlXG5cdFx0cmV0dXJuIGN0eC5sZW5ndGggP1xuXHRcdFx0bmV3IF9BcGkoIGN0eFswXSApIDpcblx0XHRcdHRhYmxlcztcblx0fSApO1xuXHRcblx0XG5cdF9hcGlfcmVnaXN0ZXJQbHVyYWwoICd0YWJsZXMoKS5ub2RlcygpJywgJ3RhYmxlKCkubm9kZSgpJyAsIGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBjdHggKSB7XG5cdFx0XHRyZXR1cm4gY3R4Lm5UYWJsZTtcblx0XHR9LCAxICk7XG5cdH0gKTtcblx0XG5cdFxuXHRfYXBpX3JlZ2lzdGVyUGx1cmFsKCAndGFibGVzKCkuYm9keSgpJywgJ3RhYmxlKCkuYm9keSgpJyAsIGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBjdHggKSB7XG5cdFx0XHRyZXR1cm4gY3R4Lm5UQm9keTtcblx0XHR9LCAxICk7XG5cdH0gKTtcblx0XG5cdFxuXHRfYXBpX3JlZ2lzdGVyUGx1cmFsKCAndGFibGVzKCkuaGVhZGVyKCknLCAndGFibGUoKS5oZWFkZXIoKScgLCBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggY3R4ICkge1xuXHRcdFx0cmV0dXJuIGN0eC5uVEhlYWQ7XG5cdFx0fSwgMSApO1xuXHR9ICk7XG5cdFxuXHRcblx0X2FwaV9yZWdpc3RlclBsdXJhbCggJ3RhYmxlcygpLmZvb3RlcigpJywgJ3RhYmxlKCkuZm9vdGVyKCknICwgZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIGN0eCApIHtcblx0XHRcdHJldHVybiBjdHgublRGb290O1xuXHRcdH0sIDEgKTtcblx0fSApO1xuXHRcblx0XG5cdF9hcGlfcmVnaXN0ZXJQbHVyYWwoICd0YWJsZXMoKS5jb250YWluZXJzKCknLCAndGFibGUoKS5jb250YWluZXIoKScgLCBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggY3R4ICkge1xuXHRcdFx0cmV0dXJuIGN0eC5uVGFibGVXcmFwcGVyO1xuXHRcdH0sIDEgKTtcblx0fSApO1xuXHRcblx0XG5cdFxuXHQvKipcblx0ICogUmVkcmF3IHRoZSB0YWJsZXMgaW4gdGhlIGN1cnJlbnQgY29udGV4dC5cblx0ICovXG5cdF9hcGlfcmVnaXN0ZXIoICdkcmF3KCknLCBmdW5jdGlvbiAoIHBhZ2luZyApIHtcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBzZXR0aW5ncyApIHtcblx0XHRcdGlmICggcGFnaW5nID09PSAncGFnZScgKSB7XG5cdFx0XHRcdF9mbkRyYXcoIHNldHRpbmdzICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0aWYgKCB0eXBlb2YgcGFnaW5nID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0XHRwYWdpbmcgPSBwYWdpbmcgPT09ICdmdWxsLWhvbGQnID9cblx0XHRcdFx0XHRcdGZhbHNlIDpcblx0XHRcdFx0XHRcdHRydWU7XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdF9mblJlRHJhdyggc2V0dGluZ3MsIHBhZ2luZz09PWZhbHNlICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9ICk7XG5cdFxuXHRcblx0XG5cdC8qKlxuXHQgKiBHZXQgdGhlIGN1cnJlbnQgcGFnZSBpbmRleC5cblx0ICpcblx0ICogQHJldHVybiB7aW50ZWdlcn0gQ3VycmVudCBwYWdlIGluZGV4ICh6ZXJvIGJhc2VkKVxuXHQgKi8vKipcblx0ICogU2V0IHRoZSBjdXJyZW50IHBhZ2UuXG5cdCAqXG5cdCAqIE5vdGUgdGhhdCBpZiB5b3UgYXR0ZW1wdCB0byBzaG93IGEgcGFnZSB3aGljaCBkb2VzIG5vdCBleGlzdCwgRGF0YVRhYmxlcyB3aWxsXG5cdCAqIG5vdCB0aHJvdyBhbiBlcnJvciwgYnV0IHJhdGhlciByZXNldCB0aGUgcGFnaW5nLlxuXHQgKlxuXHQgKiBAcGFyYW0ge2ludGVnZXJ8c3RyaW5nfSBhY3Rpb24gVGhlIHBhZ2luZyBhY3Rpb24gdG8gdGFrZS4gVGhpcyBjYW4gYmUgb25lIG9mOlxuXHQgKiAgKiBgaW50ZWdlcmAgLSBUaGUgcGFnZSBpbmRleCB0byBqdW1wIHRvXG5cdCAqICAqIGBzdHJpbmdgIC0gQW4gYWN0aW9uIHRvIHRha2U6XG5cdCAqICAgICogYGZpcnN0YCAtIEp1bXAgdG8gZmlyc3QgcGFnZS5cblx0ICogICAgKiBgbmV4dGAgLSBKdW1wIHRvIHRoZSBuZXh0IHBhZ2Vcblx0ICogICAgKiBgcHJldmlvdXNgIC0gSnVtcCB0byBwcmV2aW91cyBwYWdlXG5cdCAqICAgICogYGxhc3RgIC0gSnVtcCB0byB0aGUgbGFzdCBwYWdlLlxuXHQgKiBAcmV0dXJucyB7RGF0YVRhYmxlcy5BcGl9IHRoaXNcblx0ICovXG5cdF9hcGlfcmVnaXN0ZXIoICdwYWdlKCknLCBmdW5jdGlvbiAoIGFjdGlvbiApIHtcblx0XHRpZiAoIGFjdGlvbiA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0cmV0dXJuIHRoaXMucGFnZS5pbmZvKCkucGFnZTsgLy8gbm90IGFuIGV4cGVuc2l2ZSBjYWxsXG5cdFx0fVxuXHRcblx0XHQvLyBlbHNlLCBoYXZlIGFuIGFjdGlvbiB0byB0YWtlIG9uIGFsbCB0YWJsZXNcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBzZXR0aW5ncyApIHtcblx0XHRcdF9mblBhZ2VDaGFuZ2UoIHNldHRpbmdzLCBhY3Rpb24gKTtcblx0XHR9ICk7XG5cdH0gKTtcblx0XG5cdFxuXHQvKipcblx0ICogUGFnaW5nIGluZm9ybWF0aW9uIGZvciB0aGUgZmlyc3QgdGFibGUgaW4gdGhlIGN1cnJlbnQgY29udGV4dC5cblx0ICpcblx0ICogSWYgeW91IHJlcXVpcmUgcGFnaW5nIGluZm9ybWF0aW9uIGZvciBhbm90aGVyIHRhYmxlLCB1c2UgdGhlIGB0YWJsZSgpYCBtZXRob2Rcblx0ICogd2l0aCBhIHN1aXRhYmxlIHNlbGVjdG9yLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtvYmplY3R9IE9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllcyBzZXQ6XG5cdCAqICAqIGBwYWdlYCAtIEN1cnJlbnQgcGFnZSBpbmRleCAoemVybyBiYXNlZCAtIGkuZS4gdGhlIGZpcnN0IHBhZ2UgaXMgYDBgKVxuXHQgKiAgKiBgcGFnZXNgIC0gVG90YWwgbnVtYmVyIG9mIHBhZ2VzXG5cdCAqICAqIGBzdGFydGAgLSBEaXNwbGF5IGluZGV4IGZvciB0aGUgZmlyc3QgcmVjb3JkIHNob3duIG9uIHRoZSBjdXJyZW50IHBhZ2Vcblx0ICogICogYGVuZGAgLSBEaXNwbGF5IGluZGV4IGZvciB0aGUgbGFzdCByZWNvcmQgc2hvd24gb24gdGhlIGN1cnJlbnQgcGFnZVxuXHQgKiAgKiBgbGVuZ3RoYCAtIERpc3BsYXkgbGVuZ3RoIChudW1iZXIgb2YgcmVjb3JkcykuIE5vdGUgdGhhdCBnZW5lcmFsbHkgYHN0YXJ0XG5cdCAqICAgICsgbGVuZ3RoID0gZW5kYCwgYnV0IHRoaXMgaXMgbm90IGFsd2F5cyB0cnVlLCBmb3IgZXhhbXBsZSBpZiB0aGVyZSBhcmVcblx0ICogICAgb25seSAyIHJlY29yZHMgdG8gc2hvdyBvbiB0aGUgZmluYWwgcGFnZSwgd2l0aCBhIGxlbmd0aCBvZiAxMC5cblx0ICogICogYHJlY29yZHNUb3RhbGAgLSBGdWxsIGRhdGEgc2V0IGxlbmd0aFxuXHQgKiAgKiBgcmVjb3Jkc0Rpc3BsYXlgIC0gRGF0YSBzZXQgbGVuZ3RoIG9uY2UgdGhlIGN1cnJlbnQgZmlsdGVyaW5nIGNyaXRlcmlvblxuXHQgKiAgICBhcmUgYXBwbGllZC5cblx0ICovXG5cdF9hcGlfcmVnaXN0ZXIoICdwYWdlLmluZm8oKScsIGZ1bmN0aW9uICggYWN0aW9uICkge1xuXHRcdGlmICggdGhpcy5jb250ZXh0Lmxlbmd0aCA9PT0gMCApIHtcblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcblx0XHR2YXJcblx0XHRcdHNldHRpbmdzICAgPSB0aGlzLmNvbnRleHRbMF0sXG5cdFx0XHRzdGFydCAgICAgID0gc2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQsXG5cdFx0XHRsZW4gICAgICAgID0gc2V0dGluZ3Mub0ZlYXR1cmVzLmJQYWdpbmF0ZSA/IHNldHRpbmdzLl9pRGlzcGxheUxlbmd0aCA6IC0xLFxuXHRcdFx0dmlzUmVjb3JkcyA9IHNldHRpbmdzLmZuUmVjb3Jkc0Rpc3BsYXkoKSxcblx0XHRcdGFsbCAgICAgICAgPSBsZW4gPT09IC0xO1xuXHRcblx0XHRyZXR1cm4ge1xuXHRcdFx0XCJwYWdlXCI6ICAgICAgICAgICBhbGwgPyAwIDogTWF0aC5mbG9vciggc3RhcnQgLyBsZW4gKSxcblx0XHRcdFwicGFnZXNcIjogICAgICAgICAgYWxsID8gMSA6IE1hdGguY2VpbCggdmlzUmVjb3JkcyAvIGxlbiApLFxuXHRcdFx0XCJzdGFydFwiOiAgICAgICAgICBzdGFydCxcblx0XHRcdFwiZW5kXCI6ICAgICAgICAgICAgc2V0dGluZ3MuZm5EaXNwbGF5RW5kKCksXG5cdFx0XHRcImxlbmd0aFwiOiAgICAgICAgIGxlbixcblx0XHRcdFwicmVjb3Jkc1RvdGFsXCI6ICAgc2V0dGluZ3MuZm5SZWNvcmRzVG90YWwoKSxcblx0XHRcdFwicmVjb3Jkc0Rpc3BsYXlcIjogdmlzUmVjb3Jkcyxcblx0XHRcdFwic2VydmVyU2lkZVwiOiAgICAgX2ZuRGF0YVNvdXJjZSggc2V0dGluZ3MgKSA9PT0gJ3NzcCdcblx0XHR9O1xuXHR9ICk7XG5cdFxuXHRcblx0LyoqXG5cdCAqIEdldCB0aGUgY3VycmVudCBwYWdlIGxlbmd0aC5cblx0ICpcblx0ICogQHJldHVybiB7aW50ZWdlcn0gQ3VycmVudCBwYWdlIGxlbmd0aC4gTm90ZSBgLTFgIGluZGljYXRlcyB0aGF0IGFsbCByZWNvcmRzXG5cdCAqICAgYXJlIHRvIGJlIHNob3duLlxuXHQgKi8vKipcblx0ICogU2V0IHRoZSBjdXJyZW50IHBhZ2UgbGVuZ3RoLlxuXHQgKlxuXHQgKiBAcGFyYW0ge2ludGVnZXJ9IFBhZ2UgbGVuZ3RoIHRvIHNldC4gVXNlIGAtMWAgdG8gc2hvdyBhbGwgcmVjb3Jkcy5cblx0ICogQHJldHVybnMge0RhdGFUYWJsZXMuQXBpfSB0aGlzXG5cdCAqL1xuXHRfYXBpX3JlZ2lzdGVyKCAncGFnZS5sZW4oKScsIGZ1bmN0aW9uICggbGVuICkge1xuXHRcdC8vIE5vdGUgdGhhdCB3ZSBjYW4ndCBjYWxsIHRoaXMgZnVuY3Rpb24gJ2xlbmd0aCgpJyBiZWNhdXNlIGBsZW5ndGhgXG5cdFx0Ly8gaXMgYSBKYXZhc2NyaXB0IHByb3BlcnR5IG9mIGZ1bmN0aW9ucyB3aGljaCBkZWZpbmVzIGhvdyBtYW55IGFyZ3VtZW50c1xuXHRcdC8vIHRoZSBmdW5jdGlvbiBleHBlY3RzLlxuXHRcdGlmICggbGVuID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5jb250ZXh0Lmxlbmd0aCAhPT0gMCA/XG5cdFx0XHRcdHRoaXMuY29udGV4dFswXS5faURpc3BsYXlMZW5ndGggOlxuXHRcdFx0XHR1bmRlZmluZWQ7XG5cdFx0fVxuXHRcblx0XHQvLyBlbHNlLCBzZXQgdGhlIHBhZ2UgbGVuZ3RoXG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0XHRfZm5MZW5ndGhDaGFuZ2UoIHNldHRpbmdzLCBsZW4gKTtcblx0XHR9ICk7XG5cdH0gKTtcblx0XG5cdFxuXHRcblx0dmFyIF9fcmVsb2FkID0gZnVuY3Rpb24gKCBzZXR0aW5ncywgaG9sZFBvc2l0aW9uLCBjYWxsYmFjayApIHtcblx0XHQvLyBVc2UgdGhlIGRyYXcgZXZlbnQgdG8gdHJpZ2dlciBhIGNhbGxiYWNrXG5cdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdHZhciBhcGkgPSBuZXcgX0FwaSggc2V0dGluZ3MgKTtcblx0XG5cdFx0XHRhcGkub25lKCAnZHJhdycsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0Y2FsbGJhY2soIGFwaS5hamF4Lmpzb24oKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblx0XG5cdFx0aWYgKCBfZm5EYXRhU291cmNlKCBzZXR0aW5ncyApID09ICdzc3AnICkge1xuXHRcdFx0X2ZuUmVEcmF3KCBzZXR0aW5ncywgaG9sZFBvc2l0aW9uICk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0X2ZuUHJvY2Vzc2luZ0Rpc3BsYXkoIHNldHRpbmdzLCB0cnVlICk7XG5cdFxuXHRcdFx0Ly8gQ2FuY2VsIGFuIGV4aXN0aW5nIHJlcXVlc3Rcblx0XHRcdHZhciB4aHIgPSBzZXR0aW5ncy5qcVhIUjtcblx0XHRcdGlmICggeGhyICYmIHhoci5yZWFkeVN0YXRlICE9PSA0ICkge1xuXHRcdFx0XHR4aHIuYWJvcnQoKTtcblx0XHRcdH1cblx0XG5cdFx0XHQvLyBUcmlnZ2VyIHhoclxuXHRcdFx0X2ZuQnVpbGRBamF4KCBzZXR0aW5ncywgW10sIGZ1bmN0aW9uKCBqc29uICkge1xuXHRcdFx0XHRfZm5DbGVhclRhYmxlKCBzZXR0aW5ncyApO1xuXHRcblx0XHRcdFx0dmFyIGRhdGEgPSBfZm5BamF4RGF0YVNyYyggc2V0dGluZ3MsIGpzb24gKTtcblx0XHRcdFx0Zm9yICggdmFyIGk9MCwgaWVuPWRhdGEubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdFx0X2ZuQWRkRGF0YSggc2V0dGluZ3MsIGRhdGFbaV0gKTtcblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0X2ZuUmVEcmF3KCBzZXR0aW5ncywgaG9sZFBvc2l0aW9uICk7XG5cdFx0XHRcdF9mblByb2Nlc3NpbmdEaXNwbGF5KCBzZXR0aW5ncywgZmFsc2UgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cdH07XG5cdFxuXHRcblx0LyoqXG5cdCAqIEdldCB0aGUgSlNPTiByZXNwb25zZSBmcm9tIHRoZSBsYXN0IEFqYXggcmVxdWVzdCB0aGF0IERhdGFUYWJsZXMgbWFkZSB0byB0aGVcblx0ICogc2VydmVyLiBOb3RlIHRoYXQgdGhpcyByZXR1cm5zIHRoZSBKU09OIGZyb20gdGhlIGZpcnN0IHRhYmxlIGluIHRoZSBjdXJyZW50XG5cdCAqIGNvbnRleHQuXG5cdCAqXG5cdCAqIEByZXR1cm4ge29iamVjdH0gSlNPTiByZWNlaXZlZCBmcm9tIHRoZSBzZXJ2ZXIuXG5cdCAqL1xuXHRfYXBpX3JlZ2lzdGVyKCAnYWpheC5qc29uKCknLCBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGN0eCA9IHRoaXMuY29udGV4dDtcblx0XG5cdFx0aWYgKCBjdHgubGVuZ3RoID4gMCApIHtcblx0XHRcdHJldHVybiBjdHhbMF0uanNvbjtcblx0XHR9XG5cdFxuXHRcdC8vIGVsc2UgcmV0dXJuIHVuZGVmaW5lZDtcblx0fSApO1xuXHRcblx0XG5cdC8qKlxuXHQgKiBHZXQgdGhlIGRhdGEgc3VibWl0dGVkIGluIHRoZSBsYXN0IEFqYXggcmVxdWVzdFxuXHQgKi9cblx0X2FwaV9yZWdpc3RlciggJ2FqYXgucGFyYW1zKCknLCBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGN0eCA9IHRoaXMuY29udGV4dDtcblx0XG5cdFx0aWYgKCBjdHgubGVuZ3RoID4gMCApIHtcblx0XHRcdHJldHVybiBjdHhbMF0ub0FqYXhEYXRhO1xuXHRcdH1cblx0XG5cdFx0Ly8gZWxzZSByZXR1cm4gdW5kZWZpbmVkO1xuXHR9ICk7XG5cdFxuXHRcblx0LyoqXG5cdCAqIFJlbG9hZCB0YWJsZXMgZnJvbSB0aGUgQWpheCBkYXRhIHNvdXJjZS4gTm90ZSB0aGF0IHRoaXMgZnVuY3Rpb24gd2lsbFxuXHQgKiBhdXRvbWF0aWNhbGx5IHJlLWRyYXcgdGhlIHRhYmxlIHdoZW4gdGhlIHJlbW90ZSBkYXRhIGhhcyBiZWVuIGxvYWRlZC5cblx0ICpcblx0ICogQHBhcmFtIHtib29sZWFufSBbcmVzZXQ9dHJ1ZV0gUmVzZXQgKGRlZmF1bHQpIG9yIGhvbGQgdGhlIGN1cnJlbnQgcGFnaW5nXG5cdCAqICAgcG9zaXRpb24uIEEgZnVsbCByZS1zb3J0IGFuZCByZS1maWx0ZXIgaXMgcGVyZm9ybWVkIHdoZW4gdGhpcyBtZXRob2QgaXNcblx0ICogICBjYWxsZWQsIHdoaWNoIGlzIHdoeSB0aGUgcGFnaW5hdGlvbiByZXNldCBpcyB0aGUgZGVmYXVsdCBhY3Rpb24uXG5cdCAqIEByZXR1cm5zIHtEYXRhVGFibGVzLkFwaX0gdGhpc1xuXHQgKi9cblx0X2FwaV9yZWdpc3RlciggJ2FqYXgucmVsb2FkKCknLCBmdW5jdGlvbiAoIGNhbGxiYWNrLCByZXNldFBhZ2luZyApIHtcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKHNldHRpbmdzKSB7XG5cdFx0XHRfX3JlbG9hZCggc2V0dGluZ3MsIHJlc2V0UGFnaW5nPT09ZmFsc2UsIGNhbGxiYWNrICk7XG5cdFx0fSApO1xuXHR9ICk7XG5cdFxuXHRcblx0LyoqXG5cdCAqIEdldCB0aGUgY3VycmVudCBBamF4IFVSTC4gTm90ZSB0aGF0IHRoaXMgcmV0dXJucyB0aGUgVVJMIGZyb20gdGhlIGZpcnN0XG5cdCAqIHRhYmxlIGluIHRoZSBjdXJyZW50IGNvbnRleHQuXG5cdCAqXG5cdCAqIEByZXR1cm4ge3N0cmluZ30gQ3VycmVudCBBamF4IHNvdXJjZSBVUkxcblx0ICovLyoqXG5cdCAqIFNldCB0aGUgQWpheCBVUkwuIE5vdGUgdGhhdCB0aGlzIHdpbGwgc2V0IHRoZSBVUkwgZm9yIGFsbCB0YWJsZXMgaW4gdGhlXG5cdCAqIGN1cnJlbnQgY29udGV4dC5cblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IHVybCBVUkwgdG8gc2V0LlxuXHQgKiBAcmV0dXJucyB7RGF0YVRhYmxlcy5BcGl9IHRoaXNcblx0ICovXG5cdF9hcGlfcmVnaXN0ZXIoICdhamF4LnVybCgpJywgZnVuY3Rpb24gKCB1cmwgKSB7XG5cdFx0dmFyIGN0eCA9IHRoaXMuY29udGV4dDtcblx0XG5cdFx0aWYgKCB1cmwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdC8vIGdldFxuXHRcdFx0aWYgKCBjdHgubGVuZ3RoID09PSAwICkge1xuXHRcdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHRcdFx0fVxuXHRcdFx0Y3R4ID0gY3R4WzBdO1xuXHRcblx0XHRcdHJldHVybiBjdHguYWpheCA/XG5cdFx0XHRcdCQuaXNQbGFpbk9iamVjdCggY3R4LmFqYXggKSA/XG5cdFx0XHRcdFx0Y3R4LmFqYXgudXJsIDpcblx0XHRcdFx0XHRjdHguYWpheCA6XG5cdFx0XHRcdGN0eC5zQWpheFNvdXJjZTtcblx0XHR9XG5cdFxuXHRcdC8vIHNldFxuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIHNldHRpbmdzICkge1xuXHRcdFx0aWYgKCAkLmlzUGxhaW5PYmplY3QoIHNldHRpbmdzLmFqYXggKSApIHtcblx0XHRcdFx0c2V0dGluZ3MuYWpheC51cmwgPSB1cmw7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0c2V0dGluZ3MuYWpheCA9IHVybDtcblx0XHRcdH1cblx0XHRcdC8vIE5vIG5lZWQgdG8gY29uc2lkZXIgc0FqYXhTb3VyY2UgaGVyZSBzaW5jZSBEYXRhVGFibGVzIGdpdmVzIHByaW9yaXR5XG5cdFx0XHQvLyB0byBgYWpheGAgb3ZlciBgc0FqYXhTb3VyY2VgLiBTbyBzZXR0aW5nIGBhamF4YCBoZXJlLCByZW5kZXJzIGFueVxuXHRcdFx0Ly8gdmFsdWUgb2YgYHNBamF4U291cmNlYCByZWR1bmRhbnQuXG5cdFx0fSApO1xuXHR9ICk7XG5cdFxuXHRcblx0LyoqXG5cdCAqIExvYWQgZGF0YSBmcm9tIHRoZSBuZXdseSBzZXQgQWpheCBVUkwuIE5vdGUgdGhhdCB0aGlzIG1ldGhvZCBpcyBvbmx5XG5cdCAqIGF2YWlsYWJsZSB3aGVuIGBhamF4LnVybCgpYCBpcyB1c2VkIHRvIHNldCBhIFVSTC4gQWRkaXRpb25hbGx5LCB0aGlzIG1ldGhvZFxuXHQgKiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzIGNhbGxpbmcgYGFqYXgucmVsb2FkKClgIGJ1dCBpcyBwcm92aWRlZCBmb3Jcblx0ICogY29udmVuaWVuY2Ugd2hlbiBzZXR0aW5nIGEgbmV3IFVSTC4gTGlrZSBgYWpheC5yZWxvYWQoKWAgaXQgd2lsbFxuXHQgKiBhdXRvbWF0aWNhbGx5IHJlZHJhdyB0aGUgdGFibGUgb25jZSB0aGUgcmVtb3RlIGRhdGEgaGFzIGJlZW4gbG9hZGVkLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7RGF0YVRhYmxlcy5BcGl9IHRoaXNcblx0ICovXG5cdF9hcGlfcmVnaXN0ZXIoICdhamF4LnVybCgpLmxvYWQoKScsIGZ1bmN0aW9uICggY2FsbGJhY2ssIHJlc2V0UGFnaW5nICkge1xuXHRcdC8vIFNhbWUgYXMgYSByZWxvYWQsIGJ1dCBtYWtlcyBzZW5zZSB0byBwcmVzZW50IGl0IGZvciBlYXN5IGFjY2VzcyBhZnRlciBhXG5cdFx0Ly8gdXJsIGNoYW5nZVxuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIGN0eCApIHtcblx0XHRcdF9fcmVsb2FkKCBjdHgsIHJlc2V0UGFnaW5nPT09ZmFsc2UsIGNhbGxiYWNrICk7XG5cdFx0fSApO1xuXHR9ICk7XG5cdFxuXHRcblx0XG5cdFxuXHR2YXIgX3NlbGVjdG9yX3J1biA9IGZ1bmN0aW9uICggdHlwZSwgc2VsZWN0b3IsIHNlbGVjdEZuLCBzZXR0aW5ncywgb3B0cyApXG5cdHtcblx0XHR2YXJcblx0XHRcdG91dCA9IFtdLCByZXMsXG5cdFx0XHRhLCBpLCBpZW4sIGosIGplbixcblx0XHRcdHNlbGVjdG9yVHlwZSA9IHR5cGVvZiBzZWxlY3Rvcjtcblx0XG5cdFx0Ly8gQ2FuJ3QganVzdCBjaGVjayBmb3IgaXNBcnJheSBoZXJlLCBhcyBhbiBBUEkgb3IgalF1ZXJ5IGluc3RhbmNlIG1pZ2h0IGJlXG5cdFx0Ly8gZ2l2ZW4gd2l0aCB0aGVpciBhcnJheSBsaWtlIGxvb2tcblx0XHRpZiAoICEgc2VsZWN0b3IgfHwgc2VsZWN0b3JUeXBlID09PSAnc3RyaW5nJyB8fCBzZWxlY3RvclR5cGUgPT09ICdmdW5jdGlvbicgfHwgc2VsZWN0b3IubGVuZ3RoID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRzZWxlY3RvciA9IFsgc2VsZWN0b3IgXTtcblx0XHR9XG5cdFxuXHRcdGZvciAoIGk9MCwgaWVuPXNlbGVjdG9yLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0Ly8gT25seSBzcGxpdCBvbiBzaW1wbGUgc3RyaW5ncyAtIGNvbXBsZXggZXhwcmVzc2lvbnMgd2lsbCBiZSBqUXVlcnkgc2VsZWN0b3JzXG5cdFx0XHRhID0gc2VsZWN0b3JbaV0gJiYgc2VsZWN0b3JbaV0uc3BsaXQgJiYgISBzZWxlY3RvcltpXS5tYXRjaCgvW1xcW1xcKDpdLykgP1xuXHRcdFx0XHRzZWxlY3RvcltpXS5zcGxpdCgnLCcpIDpcblx0XHRcdFx0WyBzZWxlY3RvcltpXSBdO1xuXHRcblx0XHRcdGZvciAoIGo9MCwgamVuPWEubGVuZ3RoIDsgajxqZW4gOyBqKysgKSB7XG5cdFx0XHRcdHJlcyA9IHNlbGVjdEZuKCB0eXBlb2YgYVtqXSA9PT0gJ3N0cmluZycgPyAkLnRyaW0oYVtqXSkgOiBhW2pdICk7XG5cdFxuXHRcdFx0XHRpZiAoIHJlcyAmJiByZXMubGVuZ3RoICkge1xuXHRcdFx0XHRcdG91dCA9IG91dC5jb25jYXQoIHJlcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcblx0XHQvLyBzZWxlY3RvciBleHRlbnNpb25zXG5cdFx0dmFyIGV4dCA9IF9leHQuc2VsZWN0b3JbIHR5cGUgXTtcblx0XHRpZiAoIGV4dC5sZW5ndGggKSB7XG5cdFx0XHRmb3IgKCBpPTAsIGllbj1leHQubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdG91dCA9IGV4dFtpXSggc2V0dGluZ3MsIG9wdHMsIG91dCApO1xuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0cmV0dXJuIF91bmlxdWUoIG91dCApO1xuXHR9O1xuXHRcblx0XG5cdHZhciBfc2VsZWN0b3Jfb3B0cyA9IGZ1bmN0aW9uICggb3B0cyApXG5cdHtcblx0XHRpZiAoICEgb3B0cyApIHtcblx0XHRcdG9wdHMgPSB7fTtcblx0XHR9XG5cdFxuXHRcdC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IGZvciAxLjktIHdoaWNoIHVzZWQgdGhlIHRlcm1pbm9sb2d5IGZpbHRlciByYXRoZXJcblx0XHQvLyB0aGFuIHNlYXJjaFxuXHRcdGlmICggb3B0cy5maWx0ZXIgJiYgb3B0cy5zZWFyY2ggPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdG9wdHMuc2VhcmNoID0gb3B0cy5maWx0ZXI7XG5cdFx0fVxuXHRcblx0XHRyZXR1cm4gJC5leHRlbmQoIHtcblx0XHRcdHNlYXJjaDogJ25vbmUnLFxuXHRcdFx0b3JkZXI6ICdjdXJyZW50Jyxcblx0XHRcdHBhZ2U6ICdhbGwnXG5cdFx0fSwgb3B0cyApO1xuXHR9O1xuXHRcblx0XG5cdHZhciBfc2VsZWN0b3JfZmlyc3QgPSBmdW5jdGlvbiAoIGluc3QgKVxuXHR7XG5cdFx0Ly8gUmVkdWNlIHRoZSBBUEkgaW5zdGFuY2UgdG8gdGhlIGZpcnN0IGl0ZW0gZm91bmRcblx0XHRmb3IgKCB2YXIgaT0wLCBpZW49aW5zdC5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdGlmICggaW5zdFtpXS5sZW5ndGggPiAwICkge1xuXHRcdFx0XHQvLyBBc3NpZ24gdGhlIGZpcnN0IGVsZW1lbnQgdG8gdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIGluc3RhbmNlXG5cdFx0XHRcdC8vIGFuZCB0cnVuY2F0ZSB0aGUgaW5zdGFuY2UgYW5kIGNvbnRleHRcblx0XHRcdFx0aW5zdFswXSA9IGluc3RbaV07XG5cdFx0XHRcdGluc3RbMF0ubGVuZ3RoID0gMTtcblx0XHRcdFx0aW5zdC5sZW5ndGggPSAxO1xuXHRcdFx0XHRpbnN0LmNvbnRleHQgPSBbIGluc3QuY29udGV4dFtpXSBdO1xuXHRcblx0XHRcdFx0cmV0dXJuIGluc3Q7XG5cdFx0XHR9XG5cdFx0fVxuXHRcblx0XHQvLyBOb3QgZm91bmQgLSByZXR1cm4gYW4gZW1wdHkgaW5zdGFuY2Vcblx0XHRpbnN0Lmxlbmd0aCA9IDA7XG5cdFx0cmV0dXJuIGluc3Q7XG5cdH07XG5cdFxuXHRcblx0dmFyIF9zZWxlY3Rvcl9yb3dfaW5kZXhlcyA9IGZ1bmN0aW9uICggc2V0dGluZ3MsIG9wdHMgKVxuXHR7XG5cdFx0dmFyXG5cdFx0XHRpLCBpZW4sIHRtcCwgYT1bXSxcblx0XHRcdGRpc3BsYXlGaWx0ZXJlZCA9IHNldHRpbmdzLmFpRGlzcGxheSxcblx0XHRcdGRpc3BsYXlNYXN0ZXIgPSBzZXR0aW5ncy5haURpc3BsYXlNYXN0ZXI7XG5cdFxuXHRcdHZhclxuXHRcdFx0c2VhcmNoID0gb3B0cy5zZWFyY2gsICAvLyBub25lLCBhcHBsaWVkLCByZW1vdmVkXG5cdFx0XHRvcmRlciAgPSBvcHRzLm9yZGVyLCAgIC8vIGFwcGxpZWQsIGN1cnJlbnQsIGluZGV4IChvcmlnaW5hbCAtIGNvbXBhdGliaWxpdHkgd2l0aCAxLjkpXG5cdFx0XHRwYWdlICAgPSBvcHRzLnBhZ2U7ICAgIC8vIGFsbCwgY3VycmVudFxuXHRcblx0XHRpZiAoIF9mbkRhdGFTb3VyY2UoIHNldHRpbmdzICkgPT0gJ3NzcCcgKSB7XG5cdFx0XHQvLyBJbiBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nIG1vZGUsIG1vc3Qgb3B0aW9ucyBhcmUgaXJyZWxldmFudCBzaW5jZVxuXHRcdFx0Ly8gcm93cyBub3Qgc2hvd24gZG9uJ3QgZXhpc3QgYW5kIHRoZSBpbmRleCBvcmRlciBpcyB0aGUgYXBwbGllZCBvcmRlclxuXHRcdFx0Ly8gUmVtb3ZlZCBpcyBhIHNwZWNpYWwgY2FzZSAtIGZvciBjb25zaXN0ZW5jeSBqdXN0IHJldHVybiBhbiBlbXB0eVxuXHRcdFx0Ly8gYXJyYXlcblx0XHRcdHJldHVybiBzZWFyY2ggPT09ICdyZW1vdmVkJyA/XG5cdFx0XHRcdFtdIDpcblx0XHRcdFx0X3JhbmdlKCAwLCBkaXNwbGF5TWFzdGVyLmxlbmd0aCApO1xuXHRcdH1cblx0XHRlbHNlIGlmICggcGFnZSA9PSAnY3VycmVudCcgKSB7XG5cdFx0XHQvLyBDdXJyZW50IHBhZ2UgaW1wbGllcyB0aGF0IG9yZGVyPWN1cnJlbnQgYW5kIGZpdGxlcj1hcHBsaWVkLCBzaW5jZSBpdCBpc1xuXHRcdFx0Ly8gZmFpcmx5IHNlbnNlbGVzcyBvdGhlcndpc2UsIHJlZ2FyZGxlc3Mgb2Ygd2hhdCBvcmRlciBhbmQgc2VhcmNoIGFjdHVhbGx5XG5cdFx0XHQvLyBhcmVcblx0XHRcdGZvciAoIGk9c2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQsIGllbj1zZXR0aW5ncy5mbkRpc3BsYXlFbmQoKSA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRhLnB1c2goIGRpc3BsYXlGaWx0ZXJlZFtpXSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIGlmICggb3JkZXIgPT0gJ2N1cnJlbnQnIHx8IG9yZGVyID09ICdhcHBsaWVkJyApIHtcblx0XHRcdGlmICggc2VhcmNoID09ICdub25lJykge1xuXHRcdFx0XHRhID0gZGlzcGxheU1hc3Rlci5zbGljZSgpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIHNlYXJjaCA9PSAnYXBwbGllZCcgKSB7XG5cdFx0XHRcdGEgPSBkaXNwbGF5RmlsdGVyZWQuc2xpY2UoKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCBzZWFyY2ggPT0gJ3JlbW92ZWQnICkge1xuXHRcdFx0XHQvLyBPKG4rbSkgc29sdXRpb24gYnkgY3JlYXRpbmcgYSBoYXNoIG1hcFxuXHRcdFx0XHR2YXIgZGlzcGxheUZpbHRlcmVkTWFwID0ge307XG5cdFxuXHRcdFx0XHRmb3IgKCB2YXIgaT0wLCBpZW49ZGlzcGxheUZpbHRlcmVkLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRcdGRpc3BsYXlGaWx0ZXJlZE1hcFtkaXNwbGF5RmlsdGVyZWRbaV1dID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0YSA9ICQubWFwKCBkaXNwbGF5TWFzdGVyLCBmdW5jdGlvbiAoZWwpIHtcblx0XHRcdFx0XHRyZXR1cm4gISBkaXNwbGF5RmlsdGVyZWRNYXAuaGFzT3duUHJvcGVydHkoZWwpID9cblx0XHRcdFx0XHRcdGVsIDpcblx0XHRcdFx0XHRcdG51bGw7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSBpZiAoIG9yZGVyID09ICdpbmRleCcgfHwgb3JkZXIgPT0gJ29yaWdpbmFsJyApIHtcblx0XHRcdGZvciAoIGk9MCwgaWVuPXNldHRpbmdzLmFvRGF0YS5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBzZWFyY2ggPT0gJ25vbmUnICkge1xuXHRcdFx0XHRcdGEucHVzaCggaSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgeyAvLyBhcHBsaWVkIHwgcmVtb3ZlZFxuXHRcdFx0XHRcdHRtcCA9ICQuaW5BcnJheSggaSwgZGlzcGxheUZpbHRlcmVkICk7XG5cdFxuXHRcdFx0XHRcdGlmICgodG1wID09PSAtMSAmJiBzZWFyY2ggPT0gJ3JlbW92ZWQnKSB8fFxuXHRcdFx0XHRcdFx0KHRtcCA+PSAwICAgJiYgc2VhcmNoID09ICdhcHBsaWVkJykgKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGEucHVzaCggaSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0cmV0dXJuIGE7XG5cdH07XG5cdFxuXHRcblx0LyogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqXG5cdCAqIFJvd3Ncblx0ICpcblx0ICoge30gICAgICAgICAgLSBubyBzZWxlY3RvciAtIHVzZSBhbGwgYXZhaWxhYmxlIHJvd3Ncblx0ICoge2ludGVnZXJ9ICAgLSByb3cgYW9EYXRhIGluZGV4XG5cdCAqIHtub2RlfSAgICAgIC0gVFIgbm9kZVxuXHQgKiB7c3RyaW5nfSAgICAtIGpRdWVyeSBzZWxlY3RvciB0byBhcHBseSB0byB0aGUgVFIgZWxlbWVudHNcblx0ICoge2FycmF5fSAgICAgLSBqUXVlcnkgYXJyYXkgb2Ygbm9kZXMsIG9yIHNpbXBseSBhbiBhcnJheSBvZiBUUiBub2Rlc1xuXHQgKlxuXHQgKi9cblx0dmFyIF9fcm93X3NlbGVjdG9yID0gZnVuY3Rpb24gKCBzZXR0aW5ncywgc2VsZWN0b3IsIG9wdHMgKVxuXHR7XG5cdFx0dmFyIHJvd3M7XG5cdFx0dmFyIHJ1biA9IGZ1bmN0aW9uICggc2VsICkge1xuXHRcdFx0dmFyIHNlbEludCA9IF9pbnRWYWwoIHNlbCApO1xuXHRcdFx0dmFyIGksIGllbjtcblx0XHRcdHZhciBhb0RhdGEgPSBzZXR0aW5ncy5hb0RhdGE7XG5cdFxuXHRcdFx0Ly8gU2hvcnQgY3V0IC0gc2VsZWN0b3IgaXMgYSBudW1iZXIgYW5kIG5vIG9wdGlvbnMgcHJvdmlkZWQgKGRlZmF1bHQgaXNcblx0XHRcdC8vIGFsbCByZWNvcmRzLCBzbyBubyBuZWVkIHRvIGNoZWNrIGlmIHRoZSBpbmRleCBpcyBpbiB0aGVyZSwgc2luY2UgaXRcblx0XHRcdC8vIG11c3QgYmUgLSBkZXYgZXJyb3IgaWYgdGhlIGluZGV4IGRvZXNuJ3QgZXhpc3QpLlxuXHRcdFx0aWYgKCBzZWxJbnQgIT09IG51bGwgJiYgISBvcHRzICkge1xuXHRcdFx0XHRyZXR1cm4gWyBzZWxJbnQgXTtcblx0XHRcdH1cblx0XG5cdFx0XHRpZiAoICEgcm93cyApIHtcblx0XHRcdFx0cm93cyA9IF9zZWxlY3Rvcl9yb3dfaW5kZXhlcyggc2V0dGluZ3MsIG9wdHMgKTtcblx0XHRcdH1cblx0XG5cdFx0XHRpZiAoIHNlbEludCAhPT0gbnVsbCAmJiAkLmluQXJyYXkoIHNlbEludCwgcm93cyApICE9PSAtMSApIHtcblx0XHRcdFx0Ly8gU2VsZWN0b3IgLSBpbnRlZ2VyXG5cdFx0XHRcdHJldHVybiBbIHNlbEludCBdO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIHNlbCA9PT0gbnVsbCB8fCBzZWwgPT09IHVuZGVmaW5lZCB8fCBzZWwgPT09ICcnICkge1xuXHRcdFx0XHQvLyBTZWxlY3RvciAtIG5vbmVcblx0XHRcdFx0cmV0dXJuIHJvd3M7XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gU2VsZWN0b3IgLSBmdW5jdGlvblxuXHRcdFx0aWYgKCB0eXBlb2Ygc2VsID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHRyZXR1cm4gJC5tYXAoIHJvd3MsIGZ1bmN0aW9uIChpZHgpIHtcblx0XHRcdFx0XHR2YXIgcm93ID0gYW9EYXRhWyBpZHggXTtcblx0XHRcdFx0XHRyZXR1cm4gc2VsKCBpZHgsIHJvdy5fYURhdGEsIHJvdy5uVHIgKSA/IGlkeCA6IG51bGw7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XG5cdFx0XHQvLyBTZWxlY3RvciAtIG5vZGVcblx0XHRcdGlmICggc2VsLm5vZGVOYW1lICkge1xuXHRcdFx0XHR2YXIgcm93SWR4ID0gc2VsLl9EVF9Sb3dJbmRleDsgIC8vIFByb3BlcnR5IGFkZGVkIGJ5IERUIGZvciBmYXN0IGxvb2t1cFxuXHRcdFx0XHR2YXIgY2VsbElkeCA9IHNlbC5fRFRfQ2VsbEluZGV4O1xuXHRcblx0XHRcdFx0aWYgKCByb3dJZHggIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCB0aGUgcm93IGlzIGFjdHVhbGx5IHN0aWxsIHByZXNlbnQgaW4gdGhlIHRhYmxlXG5cdFx0XHRcdFx0cmV0dXJuIGFvRGF0YVsgcm93SWR4IF0gJiYgYW9EYXRhWyByb3dJZHggXS5uVHIgPT09IHNlbCA/XG5cdFx0XHRcdFx0XHRbIHJvd0lkeCBdIDpcblx0XHRcdFx0XHRcdFtdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKCBjZWxsSWR4ICkge1xuXHRcdFx0XHRcdHJldHVybiBhb0RhdGFbIGNlbGxJZHgucm93IF0gJiYgYW9EYXRhWyBjZWxsSWR4LnJvdyBdLm5UciA9PT0gc2VsLnBhcmVudE5vZGUgP1xuXHRcdFx0XHRcdFx0WyBjZWxsSWR4LnJvdyBdIDpcblx0XHRcdFx0XHRcdFtdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHZhciBob3N0ID0gJChzZWwpLmNsb3Nlc3QoJypbZGF0YS1kdC1yb3ddJyk7XG5cdFx0XHRcdFx0cmV0dXJuIGhvc3QubGVuZ3RoID9cblx0XHRcdFx0XHRcdFsgaG9zdC5kYXRhKCdkdC1yb3cnKSBdIDpcblx0XHRcdFx0XHRcdFtdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gSUQgc2VsZWN0b3IuIFdhbnQgdG8gYWx3YXlzIGJlIGFibGUgdG8gc2VsZWN0IHJvd3MgYnkgaWQsIHJlZ2FyZGxlc3Ncblx0XHRcdC8vIG9mIGlmIHRoZSB0ciBlbGVtZW50IGhhcyBiZWVuIGNyZWF0ZWQgb3Igbm90LCBzbyBjYW4ndCByZWx5IHVwb25cblx0XHRcdC8vIGpRdWVyeSBoZXJlIC0gaGVuY2UgYSBjdXN0b20gaW1wbGVtZW50YXRpb24uIFRoaXMgZG9lcyBub3QgbWF0Y2hcblx0XHRcdC8vIFNpenpsZSdzIGZhc3Qgc2VsZWN0b3Igb3IgSFRNTDQgLSBpbiBIVE1MNSB0aGUgSUQgY2FuIGJlIGFueXRoaW5nLFxuXHRcdFx0Ly8gYnV0IHRvIHNlbGVjdCBpdCB1c2luZyBhIENTUyBzZWxlY3RvciBlbmdpbmUgKGxpa2UgU2l6emxlIG9yXG5cdFx0XHQvLyBxdWVyeVNlbGVjdCkgaXQgd291bGQgbmVlZCB0byBuZWVkIHRvIGJlIGVzY2FwZWQgZm9yIHNvbWUgY2hhcmFjdGVycy5cblx0XHRcdC8vIERhdGFUYWJsZXMgc2ltcGxpZmllcyB0aGlzIGZvciByb3cgc2VsZWN0b3JzIHNpbmNlIHlvdSBjYW4gc2VsZWN0XG5cdFx0XHQvLyBvbmx5IGEgcm93LiBBICMgaW5kaWNhdGVzIGFuIGlkIGFueSBhbnl0aGluZyB0aGF0IGZvbGxvd3MgaXMgdGhlIGlkIC1cblx0XHRcdC8vIHVuZXNjYXBlZC5cblx0XHRcdGlmICggdHlwZW9mIHNlbCA9PT0gJ3N0cmluZycgJiYgc2VsLmNoYXJBdCgwKSA9PT0gJyMnICkge1xuXHRcdFx0XHQvLyBnZXQgcm93IGluZGV4IGZyb20gaWRcblx0XHRcdFx0dmFyIHJvd09iaiA9IHNldHRpbmdzLmFJZHNbIHNlbC5yZXBsYWNlKCAvXiMvLCAnJyApIF07XG5cdFx0XHRcdGlmICggcm93T2JqICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIFsgcm93T2JqLmlkeCBdO1xuXHRcdFx0XHR9XG5cdFxuXHRcdFx0XHQvLyBuZWVkIHRvIGZhbGwgdGhyb3VnaCB0byBqUXVlcnkgaW4gY2FzZSB0aGVyZSBpcyBET00gaWQgdGhhdFxuXHRcdFx0XHQvLyBtYXRjaGVzXG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8vIEdldCBub2RlcyBpbiB0aGUgb3JkZXIgZnJvbSB0aGUgYHJvd3NgIGFycmF5IHdpdGggbnVsbCB2YWx1ZXMgcmVtb3ZlZFxuXHRcdFx0dmFyIG5vZGVzID0gX3JlbW92ZUVtcHR5KFxuXHRcdFx0XHRfcGx1Y2tfb3JkZXIoIHNldHRpbmdzLmFvRGF0YSwgcm93cywgJ25UcicgKVxuXHRcdFx0KTtcblx0XG5cdFx0XHQvLyBTZWxlY3RvciAtIGpRdWVyeSBzZWxlY3RvciBzdHJpbmcsIGFycmF5IG9mIG5vZGVzIG9yIGpRdWVyeSBvYmplY3QvXG5cdFx0XHQvLyBBcyBqUXVlcnkncyAuZmlsdGVyKCkgYWxsb3dzIGpRdWVyeSBvYmplY3RzIHRvIGJlIHBhc3NlZCBpbiBmaWx0ZXIsXG5cdFx0XHQvLyBpdCBhbHNvIGFsbG93cyBhcnJheXMsIHNvIHRoaXMgd2lsbCBjb3BlIHdpdGggYWxsIHRocmVlIG9wdGlvbnNcblx0XHRcdHJldHVybiAkKG5vZGVzKVxuXHRcdFx0XHQuZmlsdGVyKCBzZWwgKVxuXHRcdFx0XHQubWFwKCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuX0RUX1Jvd0luZGV4O1xuXHRcdFx0XHR9IClcblx0XHRcdFx0LnRvQXJyYXkoKTtcblx0XHR9O1xuXHRcblx0XHRyZXR1cm4gX3NlbGVjdG9yX3J1biggJ3JvdycsIHNlbGVjdG9yLCBydW4sIHNldHRpbmdzLCBvcHRzICk7XG5cdH07XG5cdFxuXHRcblx0X2FwaV9yZWdpc3RlciggJ3Jvd3MoKScsIGZ1bmN0aW9uICggc2VsZWN0b3IsIG9wdHMgKSB7XG5cdFx0Ly8gYXJndW1lbnQgc2hpZnRpbmdcblx0XHRpZiAoIHNlbGVjdG9yID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRzZWxlY3RvciA9ICcnO1xuXHRcdH1cblx0XHRlbHNlIGlmICggJC5pc1BsYWluT2JqZWN0KCBzZWxlY3RvciApICkge1xuXHRcdFx0b3B0cyA9IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSAnJztcblx0XHR9XG5cdFxuXHRcdG9wdHMgPSBfc2VsZWN0b3Jfb3B0cyggb3B0cyApO1xuXHRcblx0XHR2YXIgaW5zdCA9IHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0XHRyZXR1cm4gX19yb3dfc2VsZWN0b3IoIHNldHRpbmdzLCBzZWxlY3Rvciwgb3B0cyApO1xuXHRcdH0sIDEgKTtcblx0XG5cdFx0Ly8gV2FudCBhcmd1bWVudCBzaGlmdGluZyBoZXJlIGFuZCBpbiBfX3Jvd19zZWxlY3Rvcj9cblx0XHRpbnN0LnNlbGVjdG9yLnJvd3MgPSBzZWxlY3Rvcjtcblx0XHRpbnN0LnNlbGVjdG9yLm9wdHMgPSBvcHRzO1xuXHRcblx0XHRyZXR1cm4gaW5zdDtcblx0fSApO1xuXHRcblx0X2FwaV9yZWdpc3RlciggJ3Jvd3MoKS5ub2RlcygpJywgZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAncm93JywgZnVuY3Rpb24gKCBzZXR0aW5ncywgcm93ICkge1xuXHRcdFx0cmV0dXJuIHNldHRpbmdzLmFvRGF0YVsgcm93IF0ublRyIHx8IHVuZGVmaW5lZDtcblx0XHR9LCAxICk7XG5cdH0gKTtcblx0XG5cdF9hcGlfcmVnaXN0ZXIoICdyb3dzKCkuZGF0YSgpJywgZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCB0cnVlLCAncm93cycsIGZ1bmN0aW9uICggc2V0dGluZ3MsIHJvd3MgKSB7XG5cdFx0XHRyZXR1cm4gX3BsdWNrX29yZGVyKCBzZXR0aW5ncy5hb0RhdGEsIHJvd3MsICdfYURhdGEnICk7XG5cdFx0fSwgMSApO1xuXHR9ICk7XG5cdFxuXHRfYXBpX3JlZ2lzdGVyUGx1cmFsKCAncm93cygpLmNhY2hlKCknLCAncm93KCkuY2FjaGUoKScsIGZ1bmN0aW9uICggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3JvdycsIGZ1bmN0aW9uICggc2V0dGluZ3MsIHJvdyApIHtcblx0XHRcdHZhciByID0gc2V0dGluZ3MuYW9EYXRhWyByb3cgXTtcblx0XHRcdHJldHVybiB0eXBlID09PSAnc2VhcmNoJyA/IHIuX2FGaWx0ZXJEYXRhIDogci5fYVNvcnREYXRhO1xuXHRcdH0sIDEgKTtcblx0fSApO1xuXHRcblx0X2FwaV9yZWdpc3RlclBsdXJhbCggJ3Jvd3MoKS5pbnZhbGlkYXRlKCknLCAncm93KCkuaW52YWxpZGF0ZSgpJywgZnVuY3Rpb24gKCBzcmMgKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICdyb3cnLCBmdW5jdGlvbiAoIHNldHRpbmdzLCByb3cgKSB7XG5cdFx0XHRfZm5JbnZhbGlkYXRlKCBzZXR0aW5ncywgcm93LCBzcmMgKTtcblx0XHR9ICk7XG5cdH0gKTtcblx0XG5cdF9hcGlfcmVnaXN0ZXJQbHVyYWwoICdyb3dzKCkuaW5kZXhlcygpJywgJ3JvdygpLmluZGV4KCknLCBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICdyb3cnLCBmdW5jdGlvbiAoIHNldHRpbmdzLCByb3cgKSB7XG5cdFx0XHRyZXR1cm4gcm93O1xuXHRcdH0sIDEgKTtcblx0fSApO1xuXHRcblx0X2FwaV9yZWdpc3RlclBsdXJhbCggJ3Jvd3MoKS5pZHMoKScsICdyb3coKS5pZCgpJywgZnVuY3Rpb24gKCBoYXNoICkge1xuXHRcdHZhciBhID0gW107XG5cdFx0dmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG5cdFxuXHRcdC8vIGBpdGVyYXRvcmAgd2lsbCBkcm9wIHVuZGVmaW5lZCB2YWx1ZXMsIGJ1dCBpbiB0aGlzIGNhc2Ugd2Ugd2FudCB0aGVtXG5cdFx0Zm9yICggdmFyIGk9MCwgaWVuPWNvbnRleHQubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRmb3IgKCB2YXIgaj0wLCBqZW49dGhpc1tpXS5sZW5ndGggOyBqPGplbiA7IGorKyApIHtcblx0XHRcdFx0dmFyIGlkID0gY29udGV4dFtpXS5yb3dJZEZuKCBjb250ZXh0W2ldLmFvRGF0YVsgdGhpc1tpXVtqXSBdLl9hRGF0YSApO1xuXHRcdFx0XHRhLnB1c2goIChoYXNoID09PSB0cnVlID8gJyMnIDogJycgKSsgaWQgKTtcblx0XHRcdH1cblx0XHR9XG5cdFxuXHRcdHJldHVybiBuZXcgX0FwaSggY29udGV4dCwgYSApO1xuXHR9ICk7XG5cdFxuXHRfYXBpX3JlZ2lzdGVyUGx1cmFsKCAncm93cygpLnJlbW92ZSgpJywgJ3JvdygpLnJlbW92ZSgpJywgZnVuY3Rpb24gKCkge1xuXHRcdHZhciB0aGF0ID0gdGhpcztcblx0XG5cdFx0dGhpcy5pdGVyYXRvciggJ3JvdycsIGZ1bmN0aW9uICggc2V0dGluZ3MsIHJvdywgdGhhdElkeCApIHtcblx0XHRcdHZhciBkYXRhID0gc2V0dGluZ3MuYW9EYXRhO1xuXHRcdFx0dmFyIHJvd0RhdGEgPSBkYXRhWyByb3cgXTtcblx0XHRcdHZhciBpLCBpZW4sIGosIGplbjtcblx0XHRcdHZhciBsb29wUm93LCBsb29wQ2VsbHM7XG5cdFxuXHRcdFx0ZGF0YS5zcGxpY2UoIHJvdywgMSApO1xuXHRcblx0XHRcdC8vIFVwZGF0ZSB0aGUgY2FjaGVkIGluZGV4ZXNcblx0XHRcdGZvciAoIGk9MCwgaWVuPWRhdGEubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdGxvb3BSb3cgPSBkYXRhW2ldO1xuXHRcdFx0XHRsb29wQ2VsbHMgPSBsb29wUm93LmFuQ2VsbHM7XG5cdFxuXHRcdFx0XHQvLyBSb3dzXG5cdFx0XHRcdGlmICggbG9vcFJvdy5uVHIgIT09IG51bGwgKSB7XG5cdFx0XHRcdFx0bG9vcFJvdy5uVHIuX0RUX1Jvd0luZGV4ID0gaTtcblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0Ly8gQ2VsbHNcblx0XHRcdFx0aWYgKCBsb29wQ2VsbHMgIT09IG51bGwgKSB7XG5cdFx0XHRcdFx0Zm9yICggaj0wLCBqZW49bG9vcENlbGxzLmxlbmd0aCA7IGo8amVuIDsgaisrICkge1xuXHRcdFx0XHRcdFx0bG9vcENlbGxzW2pdLl9EVF9DZWxsSW5kZXgucm93ID0gaTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XG5cdFx0XHQvLyBEZWxldGUgZnJvbSB0aGUgZGlzcGxheSBhcnJheXNcblx0XHRcdF9mbkRlbGV0ZUluZGV4KCBzZXR0aW5ncy5haURpc3BsYXlNYXN0ZXIsIHJvdyApO1xuXHRcdFx0X2ZuRGVsZXRlSW5kZXgoIHNldHRpbmdzLmFpRGlzcGxheSwgcm93ICk7XG5cdFx0XHRfZm5EZWxldGVJbmRleCggdGhhdFsgdGhhdElkeCBdLCByb3csIGZhbHNlICk7IC8vIG1haW50YWluIGxvY2FsIGluZGV4ZXNcblx0XG5cdFx0XHQvLyBGb3Igc2VydmVyLXNpZGUgcHJvY2Vzc2luZyB0YWJsZXMgLSBzdWJ0cmFjdCB0aGUgZGVsZXRlZCByb3cgZnJvbSB0aGUgY291bnRcblx0XHRcdGlmICggc2V0dGluZ3MuX2lSZWNvcmRzRGlzcGxheSA+IDAgKSB7XG5cdFx0XHRcdHNldHRpbmdzLl9pUmVjb3Jkc0Rpc3BsYXktLTtcblx0XHRcdH1cblx0XG5cdFx0XHQvLyBDaGVjayBmb3IgYW4gJ292ZXJmbG93JyB0aGV5IGNhc2UgZm9yIGRpc3BsYXlpbmcgdGhlIHRhYmxlXG5cdFx0XHRfZm5MZW5ndGhPdmVyZmxvdyggc2V0dGluZ3MgKTtcblx0XG5cdFx0XHQvLyBSZW1vdmUgdGhlIHJvdydzIElEIHJlZmVyZW5jZSBpZiB0aGVyZSBpcyBvbmVcblx0XHRcdHZhciBpZCA9IHNldHRpbmdzLnJvd0lkRm4oIHJvd0RhdGEuX2FEYXRhICk7XG5cdFx0XHRpZiAoIGlkICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdGRlbGV0ZSBzZXR0aW5ncy5hSWRzWyBpZCBdO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XG5cdFx0dGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBzZXR0aW5ncyApIHtcblx0XHRcdGZvciAoIHZhciBpPTAsIGllbj1zZXR0aW5ncy5hb0RhdGEubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdHNldHRpbmdzLmFvRGF0YVtpXS5pZHggPSBpO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0gKTtcblx0XG5cdFxuXHRfYXBpX3JlZ2lzdGVyKCAncm93cy5hZGQoKScsIGZ1bmN0aW9uICggcm93cyApIHtcblx0XHR2YXIgbmV3Um93cyA9IHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0XHRcdHZhciByb3csIGksIGllbjtcblx0XHRcdFx0dmFyIG91dCA9IFtdO1xuXHRcblx0XHRcdFx0Zm9yICggaT0wLCBpZW49cm93cy5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0XHRyb3cgPSByb3dzW2ldO1xuXHRcblx0XHRcdFx0XHRpZiAoIHJvdy5ub2RlTmFtZSAmJiByb3cubm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PT0gJ1RSJyApIHtcblx0XHRcdFx0XHRcdG91dC5wdXNoKCBfZm5BZGRUciggc2V0dGluZ3MsIHJvdyApWzBdICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0b3V0LnB1c2goIF9mbkFkZERhdGEoIHNldHRpbmdzLCByb3cgKSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0cmV0dXJuIG91dDtcblx0XHRcdH0sIDEgKTtcblx0XG5cdFx0Ly8gUmV0dXJuIGFuIEFwaS5yb3dzKCkgZXh0ZW5kZWQgaW5zdGFuY2UsIHNvIHJvd3MoKS5ub2RlcygpIGV0YyBjYW4gYmUgdXNlZFxuXHRcdHZhciBtb2RSb3dzID0gdGhpcy5yb3dzKCAtMSApO1xuXHRcdG1vZFJvd3MucG9wKCk7XG5cdFx0JC5tZXJnZSggbW9kUm93cywgbmV3Um93cyApO1xuXHRcblx0XHRyZXR1cm4gbW9kUm93cztcblx0fSApO1xuXHRcblx0XG5cdFxuXHRcblx0XG5cdC8qKlxuXHQgKlxuXHQgKi9cblx0X2FwaV9yZWdpc3RlciggJ3JvdygpJywgZnVuY3Rpb24gKCBzZWxlY3Rvciwgb3B0cyApIHtcblx0XHRyZXR1cm4gX3NlbGVjdG9yX2ZpcnN0KCB0aGlzLnJvd3MoIHNlbGVjdG9yLCBvcHRzICkgKTtcblx0fSApO1xuXHRcblx0XG5cdF9hcGlfcmVnaXN0ZXIoICdyb3coKS5kYXRhKCknLCBmdW5jdGlvbiAoIGRhdGEgKSB7XG5cdFx0dmFyIGN0eCA9IHRoaXMuY29udGV4dDtcblx0XG5cdFx0aWYgKCBkYXRhID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHQvLyBHZXRcblx0XHRcdHJldHVybiBjdHgubGVuZ3RoICYmIHRoaXMubGVuZ3RoID9cblx0XHRcdFx0Y3R4WzBdLmFvRGF0YVsgdGhpc1swXSBdLl9hRGF0YSA6XG5cdFx0XHRcdHVuZGVmaW5lZDtcblx0XHR9XG5cdFxuXHRcdC8vIFNldFxuXHRcdHZhciByb3cgPSBjdHhbMF0uYW9EYXRhWyB0aGlzWzBdIF07XG5cdFx0cm93Ll9hRGF0YSA9IGRhdGE7XG5cdFxuXHRcdC8vIElmIHRoZSBET00gaGFzIGFuIGlkLCBhbmQgdGhlIGRhdGEgc291cmNlIGlzIGFuIGFycmF5XG5cdFx0aWYgKCAkLmlzQXJyYXkoIGRhdGEgKSAmJiByb3cublRyICYmIHJvdy5uVHIuaWQgKSB7XG5cdFx0XHRfZm5TZXRPYmplY3REYXRhRm4oIGN0eFswXS5yb3dJZCApKCBkYXRhLCByb3cublRyLmlkICk7XG5cdFx0fVxuXHRcblx0XHQvLyBBdXRvbWF0aWNhbGx5IGludmFsaWRhdGVcblx0XHRfZm5JbnZhbGlkYXRlKCBjdHhbMF0sIHRoaXNbMF0sICdkYXRhJyApO1xuXHRcblx0XHRyZXR1cm4gdGhpcztcblx0fSApO1xuXHRcblx0XG5cdF9hcGlfcmVnaXN0ZXIoICdyb3coKS5ub2RlKCknLCBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGN0eCA9IHRoaXMuY29udGV4dDtcblx0XG5cdFx0cmV0dXJuIGN0eC5sZW5ndGggJiYgdGhpcy5sZW5ndGggP1xuXHRcdFx0Y3R4WzBdLmFvRGF0YVsgdGhpc1swXSBdLm5UciB8fCBudWxsIDpcblx0XHRcdG51bGw7XG5cdH0gKTtcblx0XG5cdFxuXHRfYXBpX3JlZ2lzdGVyKCAncm93LmFkZCgpJywgZnVuY3Rpb24gKCByb3cgKSB7XG5cdFx0Ly8gQWxsb3cgYSBqUXVlcnkgb2JqZWN0IHRvIGJlIHBhc3NlZCBpbiAtIG9ubHkgYSBzaW5nbGUgcm93IGlzIGFkZGVkIGZyb21cblx0XHQvLyBpdCB0aG91Z2ggLSB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgc2V0XG5cdFx0aWYgKCByb3cgaW5zdGFuY2VvZiAkICYmIHJvdy5sZW5ndGggKSB7XG5cdFx0XHRyb3cgPSByb3dbMF07XG5cdFx0fVxuXHRcblx0XHR2YXIgcm93cyA9IHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0XHRpZiAoIHJvdy5ub2RlTmFtZSAmJiByb3cubm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PT0gJ1RSJyApIHtcblx0XHRcdFx0cmV0dXJuIF9mbkFkZFRyKCBzZXR0aW5ncywgcm93IClbMF07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gX2ZuQWRkRGF0YSggc2V0dGluZ3MsIHJvdyApO1xuXHRcdH0gKTtcblx0XG5cdFx0Ly8gUmV0dXJuIGFuIEFwaS5yb3dzKCkgZXh0ZW5kZWQgaW5zdGFuY2UsIHdpdGggdGhlIG5ld2x5IGFkZGVkIHJvdyBzZWxlY3RlZFxuXHRcdHJldHVybiB0aGlzLnJvdyggcm93c1swXSApO1xuXHR9ICk7XG5cdFxuXHRcblx0XG5cdHZhciBfX2RldGFpbHNfYWRkID0gZnVuY3Rpb24gKCBjdHgsIHJvdywgZGF0YSwga2xhc3MgKVxuXHR7XG5cdFx0Ly8gQ29udmVydCB0byBhcnJheSBvZiBUUiBlbGVtZW50c1xuXHRcdHZhciByb3dzID0gW107XG5cdFx0dmFyIGFkZFJvdyA9IGZ1bmN0aW9uICggciwgayApIHtcblx0XHRcdC8vIFJlY3Vyc2lvbiB0byBhbGxvdyBmb3IgYXJyYXlzIG9mIGpRdWVyeSBvYmplY3RzXG5cdFx0XHRpZiAoICQuaXNBcnJheSggciApIHx8IHIgaW5zdGFuY2VvZiAkICkge1xuXHRcdFx0XHRmb3IgKCB2YXIgaT0wLCBpZW49ci5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0XHRhZGRSb3coIHJbaV0sIGsgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gSWYgd2UgZ2V0IGEgVFIgZWxlbWVudCwgdGhlbiBqdXN0IGFkZCBpdCBkaXJlY3RseSAtIHVwIHRvIHRoZSBkZXZcblx0XHRcdC8vIHRvIGFkZCB0aGUgY29ycmVjdCBudW1iZXIgb2YgY29sdW1ucyBldGNcblx0XHRcdGlmICggci5ub2RlTmFtZSAmJiByLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICd0cicgKSB7XG5cdFx0XHRcdHJvd3MucHVzaCggciApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdC8vIE90aGVyd2lzZSBjcmVhdGUgYSByb3cgd2l0aCBhIHdyYXBwZXJcblx0XHRcdFx0dmFyIGNyZWF0ZWQgPSAkKCc8dHI+PHRkLz48L3RyPicpLmFkZENsYXNzKCBrICk7XG5cdFx0XHRcdCQoJ3RkJywgY3JlYXRlZClcblx0XHRcdFx0XHQuYWRkQ2xhc3MoIGsgKVxuXHRcdFx0XHRcdC5odG1sKCByIClcblx0XHRcdFx0XHRbMF0uY29sU3BhbiA9IF9mblZpc2JsZUNvbHVtbnMoIGN0eCApO1xuXHRcblx0XHRcdFx0cm93cy5wdXNoKCBjcmVhdGVkWzBdICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XG5cdFx0YWRkUm93KCBkYXRhLCBrbGFzcyApO1xuXHRcblx0XHRpZiAoIHJvdy5fZGV0YWlscyApIHtcblx0XHRcdHJvdy5fZGV0YWlscy5kZXRhY2goKTtcblx0XHR9XG5cdFxuXHRcdHJvdy5fZGV0YWlscyA9ICQocm93cyk7XG5cdFxuXHRcdC8vIElmIHRoZSBjaGlsZHJlbiB3ZXJlIGFscmVhZHkgc2hvd24sIHRoYXQgc3RhdGUgc2hvdWxkIGJlIHJldGFpbmVkXG5cdFx0aWYgKCByb3cuX2RldGFpbHNTaG93ICkge1xuXHRcdFx0cm93Ll9kZXRhaWxzLmluc2VydEFmdGVyKCByb3cublRyICk7XG5cdFx0fVxuXHR9O1xuXHRcblx0XG5cdHZhciBfX2RldGFpbHNfcmVtb3ZlID0gZnVuY3Rpb24gKCBhcGksIGlkeCApXG5cdHtcblx0XHR2YXIgY3R4ID0gYXBpLmNvbnRleHQ7XG5cdFxuXHRcdGlmICggY3R4Lmxlbmd0aCApIHtcblx0XHRcdHZhciByb3cgPSBjdHhbMF0uYW9EYXRhWyBpZHggIT09IHVuZGVmaW5lZCA/IGlkeCA6IGFwaVswXSBdO1xuXHRcblx0XHRcdGlmICggcm93ICYmIHJvdy5fZGV0YWlscyApIHtcblx0XHRcdFx0cm93Ll9kZXRhaWxzLnJlbW92ZSgpO1xuXHRcblx0XHRcdFx0cm93Ll9kZXRhaWxzU2hvdyA9IHVuZGVmaW5lZDtcblx0XHRcdFx0cm93Ll9kZXRhaWxzID0gdW5kZWZpbmVkO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0XG5cdFxuXHR2YXIgX19kZXRhaWxzX2Rpc3BsYXkgPSBmdW5jdGlvbiAoIGFwaSwgc2hvdyApIHtcblx0XHR2YXIgY3R4ID0gYXBpLmNvbnRleHQ7XG5cdFxuXHRcdGlmICggY3R4Lmxlbmd0aCAmJiBhcGkubGVuZ3RoICkge1xuXHRcdFx0dmFyIHJvdyA9IGN0eFswXS5hb0RhdGFbIGFwaVswXSBdO1xuXHRcblx0XHRcdGlmICggcm93Ll9kZXRhaWxzICkge1xuXHRcdFx0XHRyb3cuX2RldGFpbHNTaG93ID0gc2hvdztcblx0XG5cdFx0XHRcdGlmICggc2hvdyApIHtcblx0XHRcdFx0XHRyb3cuX2RldGFpbHMuaW5zZXJ0QWZ0ZXIoIHJvdy5uVHIgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRyb3cuX2RldGFpbHMuZGV0YWNoKCk7XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdF9fZGV0YWlsc19ldmVudHMoIGN0eFswXSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0XG5cdFxuXHR2YXIgX19kZXRhaWxzX2V2ZW50cyA9IGZ1bmN0aW9uICggc2V0dGluZ3MgKVxuXHR7XG5cdFx0dmFyIGFwaSA9IG5ldyBfQXBpKCBzZXR0aW5ncyApO1xuXHRcdHZhciBuYW1lc3BhY2UgPSAnLmR0LkRUX2RldGFpbHMnO1xuXHRcdHZhciBkcmF3RXZlbnQgPSAnZHJhdycrbmFtZXNwYWNlO1xuXHRcdHZhciBjb2x2aXNFdmVudCA9ICdjb2x1bW4tdmlzaWJpbGl0eScrbmFtZXNwYWNlO1xuXHRcdHZhciBkZXN0cm95RXZlbnQgPSAnZGVzdHJveScrbmFtZXNwYWNlO1xuXHRcdHZhciBkYXRhID0gc2V0dGluZ3MuYW9EYXRhO1xuXHRcblx0XHRhcGkub2ZmKCBkcmF3RXZlbnQgKycgJysgY29sdmlzRXZlbnQgKycgJysgZGVzdHJveUV2ZW50ICk7XG5cdFxuXHRcdGlmICggX3BsdWNrKCBkYXRhLCAnX2RldGFpbHMnICkubGVuZ3RoID4gMCApIHtcblx0XHRcdC8vIE9uIGVhY2ggZHJhdywgaW5zZXJ0IHRoZSByZXF1aXJlZCBlbGVtZW50cyBpbnRvIHRoZSBkb2N1bWVudFxuXHRcdFx0YXBpLm9uKCBkcmF3RXZlbnQsIGZ1bmN0aW9uICggZSwgY3R4ICkge1xuXHRcdFx0XHRpZiAoIHNldHRpbmdzICE9PSBjdHggKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRhcGkucm93cygge3BhZ2U6J2N1cnJlbnQnfSApLmVxKDApLmVhY2goIGZ1bmN0aW9uIChpZHgpIHtcblx0XHRcdFx0XHQvLyBJbnRlcm5hbCBkYXRhIGdyYWJcblx0XHRcdFx0XHR2YXIgcm93ID0gZGF0YVsgaWR4IF07XG5cdFxuXHRcdFx0XHRcdGlmICggcm93Ll9kZXRhaWxzU2hvdyApIHtcblx0XHRcdFx0XHRcdHJvdy5fZGV0YWlscy5pbnNlcnRBZnRlciggcm93Lm5UciApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0fSApO1xuXHRcblx0XHRcdC8vIENvbHVtbiB2aXNpYmlsaXR5IGNoYW5nZSAtIHVwZGF0ZSB0aGUgY29sc3BhblxuXHRcdFx0YXBpLm9uKCBjb2x2aXNFdmVudCwgZnVuY3Rpb24gKCBlLCBjdHgsIGlkeCwgdmlzICkge1xuXHRcdFx0XHRpZiAoIHNldHRpbmdzICE9PSBjdHggKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFxuXHRcdFx0XHQvLyBVcGRhdGUgdGhlIGNvbHNwYW4gZm9yIHRoZSBkZXRhaWxzIHJvd3MgKG5vdGUsIG9ubHkgaWYgaXQgYWxyZWFkeSBoYXNcblx0XHRcdFx0Ly8gYSBjb2xzcGFuKVxuXHRcdFx0XHR2YXIgcm93LCB2aXNpYmxlID0gX2ZuVmlzYmxlQ29sdW1ucyggY3R4ICk7XG5cdFxuXHRcdFx0XHRmb3IgKCB2YXIgaT0wLCBpZW49ZGF0YS5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0XHRyb3cgPSBkYXRhW2ldO1xuXHRcblx0XHRcdFx0XHRpZiAoIHJvdy5fZGV0YWlscyApIHtcblx0XHRcdFx0XHRcdHJvdy5fZGV0YWlscy5jaGlsZHJlbigndGRbY29sc3Bhbl0nKS5hdHRyKCdjb2xzcGFuJywgdmlzaWJsZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcblx0XHRcdC8vIFRhYmxlIGRlc3Ryb3llZCAtIG51a2UgYW55IGNoaWxkIHJvd3Ncblx0XHRcdGFwaS5vbiggZGVzdHJveUV2ZW50LCBmdW5jdGlvbiAoIGUsIGN0eCApIHtcblx0XHRcdFx0aWYgKCBzZXR0aW5ncyAhPT0gY3R4ICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0Zm9yICggdmFyIGk9MCwgaWVuPWRhdGEubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdFx0aWYgKCBkYXRhW2ldLl9kZXRhaWxzICkge1xuXHRcdFx0XHRcdFx0X19kZXRhaWxzX3JlbW92ZSggYXBpLCBpICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fVxuXHR9O1xuXHRcblx0Ly8gU3RyaW5ncyBmb3IgdGhlIG1ldGhvZCBuYW1lcyB0byBoZWxwIG1pbmlmaWNhdGlvblxuXHR2YXIgX2VtcCA9ICcnO1xuXHR2YXIgX2NoaWxkX29iaiA9IF9lbXArJ3JvdygpLmNoaWxkJztcblx0dmFyIF9jaGlsZF9tdGggPSBfY2hpbGRfb2JqKycoKSc7XG5cdFxuXHQvLyBkYXRhIGNhbiBiZTpcblx0Ly8gIHRyXG5cdC8vICBzdHJpbmdcblx0Ly8gIGpRdWVyeSBvciBhcnJheSBvZiBhbnkgb2YgdGhlIGFib3ZlXG5cdF9hcGlfcmVnaXN0ZXIoIF9jaGlsZF9tdGgsIGZ1bmN0aW9uICggZGF0YSwga2xhc3MgKSB7XG5cdFx0dmFyIGN0eCA9IHRoaXMuY29udGV4dDtcblx0XG5cdFx0aWYgKCBkYXRhID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHQvLyBnZXRcblx0XHRcdHJldHVybiBjdHgubGVuZ3RoICYmIHRoaXMubGVuZ3RoID9cblx0XHRcdFx0Y3R4WzBdLmFvRGF0YVsgdGhpc1swXSBdLl9kZXRhaWxzIDpcblx0XHRcdFx0dW5kZWZpbmVkO1xuXHRcdH1cblx0XHRlbHNlIGlmICggZGF0YSA9PT0gdHJ1ZSApIHtcblx0XHRcdC8vIHNob3dcblx0XHRcdHRoaXMuY2hpbGQuc2hvdygpO1xuXHRcdH1cblx0XHRlbHNlIGlmICggZGF0YSA9PT0gZmFsc2UgKSB7XG5cdFx0XHQvLyByZW1vdmVcblx0XHRcdF9fZGV0YWlsc19yZW1vdmUoIHRoaXMgKTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIGN0eC5sZW5ndGggJiYgdGhpcy5sZW5ndGggKSB7XG5cdFx0XHQvLyBzZXRcblx0XHRcdF9fZGV0YWlsc19hZGQoIGN0eFswXSwgY3R4WzBdLmFvRGF0YVsgdGhpc1swXSBdLCBkYXRhLCBrbGFzcyApO1xuXHRcdH1cblx0XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0gKTtcblx0XG5cdFxuXHRfYXBpX3JlZ2lzdGVyKCBbXG5cdFx0X2NoaWxkX29iaisnLnNob3coKScsXG5cdFx0X2NoaWxkX210aCsnLnNob3coKScgLy8gb25seSB3aGVuIGBjaGlsZCgpYCB3YXMgY2FsbGVkIHdpdGggcGFyYW1ldGVycyAod2l0aG91dFxuXHRdLCBmdW5jdGlvbiAoIHNob3cgKSB7ICAgLy8gaXQgcmV0dXJucyBhbiBvYmplY3QgYW5kIHRoaXMgbWV0aG9kIGlzIG5vdCBleGVjdXRlZClcblx0XHRfX2RldGFpbHNfZGlzcGxheSggdGhpcywgdHJ1ZSApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9ICk7XG5cdFxuXHRcblx0X2FwaV9yZWdpc3RlciggW1xuXHRcdF9jaGlsZF9vYmorJy5oaWRlKCknLFxuXHRcdF9jaGlsZF9tdGgrJy5oaWRlKCknIC8vIG9ubHkgd2hlbiBgY2hpbGQoKWAgd2FzIGNhbGxlZCB3aXRoIHBhcmFtZXRlcnMgKHdpdGhvdXRcblx0XSwgZnVuY3Rpb24gKCkgeyAgICAgICAgIC8vIGl0IHJldHVybnMgYW4gb2JqZWN0IGFuZCB0aGlzIG1ldGhvZCBpcyBub3QgZXhlY3V0ZWQpXG5cdFx0X19kZXRhaWxzX2Rpc3BsYXkoIHRoaXMsIGZhbHNlICk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0gKTtcblx0XG5cdFxuXHRfYXBpX3JlZ2lzdGVyKCBbXG5cdFx0X2NoaWxkX29iaisnLnJlbW92ZSgpJyxcblx0XHRfY2hpbGRfbXRoKycucmVtb3ZlKCknIC8vIG9ubHkgd2hlbiBgY2hpbGQoKWAgd2FzIGNhbGxlZCB3aXRoIHBhcmFtZXRlcnMgKHdpdGhvdXRcblx0XSwgZnVuY3Rpb24gKCkgeyAgICAgICAgICAgLy8gaXQgcmV0dXJucyBhbiBvYmplY3QgYW5kIHRoaXMgbWV0aG9kIGlzIG5vdCBleGVjdXRlZClcblx0XHRfX2RldGFpbHNfcmVtb3ZlKCB0aGlzICk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0gKTtcblx0XG5cdFxuXHRfYXBpX3JlZ2lzdGVyKCBfY2hpbGRfb2JqKycuaXNTaG93bigpJywgZnVuY3Rpb24gKCkge1xuXHRcdHZhciBjdHggPSB0aGlzLmNvbnRleHQ7XG5cdFxuXHRcdGlmICggY3R4Lmxlbmd0aCAmJiB0aGlzLmxlbmd0aCApIHtcblx0XHRcdC8vIF9kZXRhaWxzU2hvd24gYXMgZmFsc2Ugb3IgdW5kZWZpbmVkIHdpbGwgZmFsbCB0aHJvdWdoIHRvIHJldHVybiBmYWxzZVxuXHRcdFx0cmV0dXJuIGN0eFswXS5hb0RhdGFbIHRoaXNbMF0gXS5fZGV0YWlsc1Nob3cgfHwgZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSApO1xuXHRcblx0XG5cdFxuXHQvKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICpcblx0ICogQ29sdW1uc1xuXHQgKlxuXHQgKiB7aW50ZWdlcn0gICAgICAgICAgIC0gY29sdW1uIGluZGV4ICg+PTAgY291bnQgZnJvbSBsZWZ0LCA8MCBjb3VudCBmcm9tIHJpZ2h0KVxuXHQgKiBcIntpbnRlZ2VyfTp2aXNJZHhcIiAgLSB2aXNpYmxlIGNvbHVtbiBpbmRleCAoaS5lLiB0cmFuc2xhdGUgdG8gY29sdW1uIGluZGV4KSAgKD49MCBjb3VudCBmcm9tIGxlZnQsIDwwIGNvdW50IGZyb20gcmlnaHQpXG5cdCAqIFwie2ludGVnZXJ9OnZpc2libGVcIiAtIGFsaWFzIGZvciB7aW50ZWdlcn06dmlzSWR4ICAoPj0wIGNvdW50IGZyb20gbGVmdCwgPDAgY291bnQgZnJvbSByaWdodClcblx0ICogXCJ7c3RyaW5nfTpuYW1lXCIgICAgIC0gY29sdW1uIG5hbWVcblx0ICogXCJ7c3RyaW5nfVwiICAgICAgICAgIC0galF1ZXJ5IHNlbGVjdG9yIG9uIGNvbHVtbiBoZWFkZXIgbm9kZXNcblx0ICpcblx0ICovXG5cdFxuXHQvLyBjYW4gYmUgYW4gYXJyYXkgb2YgdGhlc2UgaXRlbXMsIGNvbW1hIHNlcGFyYXRlZCBsaXN0LCBvciBhbiBhcnJheSBvZiBjb21tYVxuXHQvLyBzZXBhcmF0ZWQgbGlzdHNcblx0XG5cdHZhciBfX3JlX2NvbHVtbl9zZWxlY3RvciA9IC9eKFteOl0rKToobmFtZXx2aXNJZHh8dmlzaWJsZSkkLztcblx0XG5cdFxuXHQvLyByMSBhbmQgcjIgYXJlIHJlZHVuZGFudCAtIGJ1dCBpdCBtZWFucyB0aGF0IHRoZSBwYXJhbWV0ZXJzIG1hdGNoIGZvciB0aGVcblx0Ly8gaXRlcmF0b3IgY2FsbGJhY2sgaW4gY29sdW1ucygpLmRhdGEoKVxuXHR2YXIgX19jb2x1bW5EYXRhID0gZnVuY3Rpb24gKCBzZXR0aW5ncywgY29sdW1uLCByMSwgcjIsIHJvd3MgKSB7XG5cdFx0dmFyIGEgPSBbXTtcblx0XHRmb3IgKCB2YXIgcm93PTAsIGllbj1yb3dzLmxlbmd0aCA7IHJvdzxpZW4gOyByb3crKyApIHtcblx0XHRcdGEucHVzaCggX2ZuR2V0Q2VsbERhdGEoIHNldHRpbmdzLCByb3dzW3Jvd10sIGNvbHVtbiApICk7XG5cdFx0fVxuXHRcdHJldHVybiBhO1xuXHR9O1xuXHRcblx0XG5cdHZhciBfX2NvbHVtbl9zZWxlY3RvciA9IGZ1bmN0aW9uICggc2V0dGluZ3MsIHNlbGVjdG9yLCBvcHRzIClcblx0e1xuXHRcdHZhclxuXHRcdFx0Y29sdW1ucyA9IHNldHRpbmdzLmFvQ29sdW1ucyxcblx0XHRcdG5hbWVzID0gX3BsdWNrKCBjb2x1bW5zLCAnc05hbWUnICksXG5cdFx0XHRub2RlcyA9IF9wbHVjayggY29sdW1ucywgJ25UaCcgKTtcblx0XG5cdFx0dmFyIHJ1biA9IGZ1bmN0aW9uICggcyApIHtcblx0XHRcdHZhciBzZWxJbnQgPSBfaW50VmFsKCBzICk7XG5cdFxuXHRcdFx0Ly8gU2VsZWN0b3IgLSBhbGxcblx0XHRcdGlmICggcyA9PT0gJycgKSB7XG5cdFx0XHRcdHJldHVybiBfcmFuZ2UoIGNvbHVtbnMubGVuZ3RoICk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gU2VsZWN0b3IgLSBpbmRleFxuXHRcdFx0aWYgKCBzZWxJbnQgIT09IG51bGwgKSB7XG5cdFx0XHRcdHJldHVybiBbIHNlbEludCA+PSAwID9cblx0XHRcdFx0XHRzZWxJbnQgOiAvLyBDb3VudCBmcm9tIGxlZnRcblx0XHRcdFx0XHRjb2x1bW5zLmxlbmd0aCArIHNlbEludCAvLyBDb3VudCBmcm9tIHJpZ2h0ICgrIGJlY2F1c2UgaXRzIGEgbmVnYXRpdmUgdmFsdWUpXG5cdFx0XHRcdF07XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gU2VsZWN0b3IgPSBmdW5jdGlvblxuXHRcdFx0aWYgKCB0eXBlb2YgcyA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0dmFyIHJvd3MgPSBfc2VsZWN0b3Jfcm93X2luZGV4ZXMoIHNldHRpbmdzLCBvcHRzICk7XG5cdFxuXHRcdFx0XHRyZXR1cm4gJC5tYXAoIGNvbHVtbnMsIGZ1bmN0aW9uIChjb2wsIGlkeCkge1xuXHRcdFx0XHRcdHJldHVybiBzKFxuXHRcdFx0XHRcdFx0XHRpZHgsXG5cdFx0XHRcdFx0XHRcdF9fY29sdW1uRGF0YSggc2V0dGluZ3MsIGlkeCwgMCwgMCwgcm93cyApLFxuXHRcdFx0XHRcdFx0XHRub2Rlc1sgaWR4IF1cblx0XHRcdFx0XHRcdCkgPyBpZHggOiBudWxsO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8galF1ZXJ5IG9yIHN0cmluZyBzZWxlY3RvclxuXHRcdFx0dmFyIG1hdGNoID0gdHlwZW9mIHMgPT09ICdzdHJpbmcnID9cblx0XHRcdFx0cy5tYXRjaCggX19yZV9jb2x1bW5fc2VsZWN0b3IgKSA6XG5cdFx0XHRcdCcnO1xuXHRcblx0XHRcdGlmICggbWF0Y2ggKSB7XG5cdFx0XHRcdHN3aXRjaCggbWF0Y2hbMl0gKSB7XG5cdFx0XHRcdFx0Y2FzZSAndmlzSWR4Jzpcblx0XHRcdFx0XHRjYXNlICd2aXNpYmxlJzpcblx0XHRcdFx0XHRcdHZhciBpZHggPSBwYXJzZUludCggbWF0Y2hbMV0sIDEwICk7XG5cdFx0XHRcdFx0XHQvLyBWaXNpYmxlIGluZGV4IGdpdmVuLCBjb252ZXJ0IHRvIGNvbHVtbiBpbmRleFxuXHRcdFx0XHRcdFx0aWYgKCBpZHggPCAwICkge1xuXHRcdFx0XHRcdFx0XHQvLyBDb3VudGluZyBmcm9tIHRoZSByaWdodFxuXHRcdFx0XHRcdFx0XHR2YXIgdmlzQ29sdW1ucyA9ICQubWFwKCBjb2x1bW5zLCBmdW5jdGlvbiAoY29sLGkpIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gY29sLmJWaXNpYmxlID8gaSA6IG51bGw7XG5cdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIFsgdmlzQ29sdW1uc1sgdmlzQ29sdW1ucy5sZW5ndGggKyBpZHggXSBdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Ly8gQ291bnRpbmcgZnJvbSB0aGUgbGVmdFxuXHRcdFx0XHRcdFx0cmV0dXJuIFsgX2ZuVmlzaWJsZVRvQ29sdW1uSW5kZXgoIHNldHRpbmdzLCBpZHggKSBdO1xuXHRcblx0XHRcdFx0XHRjYXNlICduYW1lJzpcblx0XHRcdFx0XHRcdC8vIG1hdGNoIGJ5IG5hbWUuIGBuYW1lc2AgaXMgY29sdW1uIGluZGV4IGNvbXBsZXRlIGFuZCBpbiBvcmRlclxuXHRcdFx0XHRcdFx0cmV0dXJuICQubWFwKCBuYW1lcywgZnVuY3Rpb24gKG5hbWUsIGkpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIG5hbWUgPT09IG1hdGNoWzFdID8gaSA6IG51bGw7XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFxuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRyZXR1cm4gW107XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XG5cdFx0XHQvLyBDZWxsIGluIHRoZSB0YWJsZSBib2R5XG5cdFx0XHRpZiAoIHMubm9kZU5hbWUgJiYgcy5fRFRfQ2VsbEluZGV4ICkge1xuXHRcdFx0XHRyZXR1cm4gWyBzLl9EVF9DZWxsSW5kZXguY29sdW1uIF07XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8galF1ZXJ5IHNlbGVjdG9yIG9uIHRoZSBUSCBlbGVtZW50cyBmb3IgdGhlIGNvbHVtbnNcblx0XHRcdHZhciBqcVJlc3VsdCA9ICQoIG5vZGVzIClcblx0XHRcdFx0LmZpbHRlciggcyApXG5cdFx0XHRcdC5tYXAoIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRyZXR1cm4gJC5pbkFycmF5KCB0aGlzLCBub2RlcyApOyAvLyBgbm9kZXNgIGlzIGNvbHVtbiBpbmRleCBjb21wbGV0ZSBhbmQgaW4gb3JkZXJcblx0XHRcdFx0fSApXG5cdFx0XHRcdC50b0FycmF5KCk7XG5cdFxuXHRcdFx0aWYgKCBqcVJlc3VsdC5sZW5ndGggfHwgISBzLm5vZGVOYW1lICkge1xuXHRcdFx0XHRyZXR1cm4ganFSZXN1bHQ7XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gT3RoZXJ3aXNlIGEgbm9kZSB3aGljaCBtaWdodCBoYXZlIGEgYGR0LWNvbHVtbmAgZGF0YSBhdHRyaWJ1dGUsIG9yIGJlXG5cdFx0XHQvLyBhIGNoaWxkIG9yIHN1Y2ggYW4gZWxlbWVudFxuXHRcdFx0dmFyIGhvc3QgPSAkKHMpLmNsb3Nlc3QoJypbZGF0YS1kdC1jb2x1bW5dJyk7XG5cdFx0XHRyZXR1cm4gaG9zdC5sZW5ndGggP1xuXHRcdFx0XHRbIGhvc3QuZGF0YSgnZHQtY29sdW1uJykgXSA6XG5cdFx0XHRcdFtdO1xuXHRcdH07XG5cdFxuXHRcdHJldHVybiBfc2VsZWN0b3JfcnVuKCAnY29sdW1uJywgc2VsZWN0b3IsIHJ1biwgc2V0dGluZ3MsIG9wdHMgKTtcblx0fTtcblx0XG5cdFxuXHR2YXIgX19zZXRDb2x1bW5WaXMgPSBmdW5jdGlvbiAoIHNldHRpbmdzLCBjb2x1bW4sIHZpcyApIHtcblx0XHR2YXJcblx0XHRcdGNvbHMgPSBzZXR0aW5ncy5hb0NvbHVtbnMsXG5cdFx0XHRjb2wgID0gY29sc1sgY29sdW1uIF0sXG5cdFx0XHRkYXRhID0gc2V0dGluZ3MuYW9EYXRhLFxuXHRcdFx0cm93LCBjZWxscywgaSwgaWVuLCB0cjtcblx0XG5cdFx0Ly8gR2V0XG5cdFx0aWYgKCB2aXMgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHJldHVybiBjb2wuYlZpc2libGU7XG5cdFx0fVxuXHRcblx0XHQvLyBTZXRcblx0XHQvLyBObyBjaGFuZ2Vcblx0XHRpZiAoIGNvbC5iVmlzaWJsZSA9PT0gdmlzICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XG5cdFx0aWYgKCB2aXMgKSB7XG5cdFx0XHQvLyBJbnNlcnQgY29sdW1uXG5cdFx0XHQvLyBOZWVkIHRvIGRlY2lkZSBpZiB3ZSBzaG91bGQgdXNlIGFwcGVuZENoaWxkIG9yIGluc2VydEJlZm9yZVxuXHRcdFx0dmFyIGluc2VydEJlZm9yZSA9ICQuaW5BcnJheSggdHJ1ZSwgX3BsdWNrKGNvbHMsICdiVmlzaWJsZScpLCBjb2x1bW4rMSApO1xuXHRcblx0XHRcdGZvciAoIGk9MCwgaWVuPWRhdGEubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdHRyID0gZGF0YVtpXS5uVHI7XG5cdFx0XHRcdGNlbGxzID0gZGF0YVtpXS5hbkNlbGxzO1xuXHRcblx0XHRcdFx0aWYgKCB0ciApIHtcblx0XHRcdFx0XHQvLyBpbnNlcnRCZWZvcmUgY2FuIGFjdCBsaWtlIGFwcGVuZENoaWxkIGlmIDJuZCBhcmcgaXMgbnVsbFxuXHRcdFx0XHRcdHRyLmluc2VydEJlZm9yZSggY2VsbHNbIGNvbHVtbiBdLCBjZWxsc1sgaW5zZXJ0QmVmb3JlIF0gfHwgbnVsbCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0Ly8gUmVtb3ZlIGNvbHVtblxuXHRcdFx0JCggX3BsdWNrKCBzZXR0aW5ncy5hb0RhdGEsICdhbkNlbGxzJywgY29sdW1uICkgKS5kZXRhY2goKTtcblx0XHR9XG5cdFxuXHRcdC8vIENvbW1vbiBhY3Rpb25zXG5cdFx0Y29sLmJWaXNpYmxlID0gdmlzO1xuXHR9O1xuXHRcblx0XG5cdF9hcGlfcmVnaXN0ZXIoICdjb2x1bW5zKCknLCBmdW5jdGlvbiAoIHNlbGVjdG9yLCBvcHRzICkge1xuXHRcdC8vIGFyZ3VtZW50IHNoaWZ0aW5nXG5cdFx0aWYgKCBzZWxlY3RvciA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0c2VsZWN0b3IgPSAnJztcblx0XHR9XG5cdFx0ZWxzZSBpZiAoICQuaXNQbGFpbk9iamVjdCggc2VsZWN0b3IgKSApIHtcblx0XHRcdG9wdHMgPSBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gJyc7XG5cdFx0fVxuXHRcblx0XHRvcHRzID0gX3NlbGVjdG9yX29wdHMoIG9wdHMgKTtcblx0XG5cdFx0dmFyIGluc3QgPSB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIHNldHRpbmdzICkge1xuXHRcdFx0cmV0dXJuIF9fY29sdW1uX3NlbGVjdG9yKCBzZXR0aW5ncywgc2VsZWN0b3IsIG9wdHMgKTtcblx0XHR9LCAxICk7XG5cdFxuXHRcdC8vIFdhbnQgYXJndW1lbnQgc2hpZnRpbmcgaGVyZSBhbmQgaW4gX3Jvd19zZWxlY3Rvcj9cblx0XHRpbnN0LnNlbGVjdG9yLmNvbHMgPSBzZWxlY3Rvcjtcblx0XHRpbnN0LnNlbGVjdG9yLm9wdHMgPSBvcHRzO1xuXHRcblx0XHRyZXR1cm4gaW5zdDtcblx0fSApO1xuXHRcblx0X2FwaV9yZWdpc3RlclBsdXJhbCggJ2NvbHVtbnMoKS5oZWFkZXIoKScsICdjb2x1bW4oKS5oZWFkZXIoKScsIGZ1bmN0aW9uICggc2VsZWN0b3IsIG9wdHMgKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICdjb2x1bW4nLCBmdW5jdGlvbiAoIHNldHRpbmdzLCBjb2x1bW4gKSB7XG5cdFx0XHRyZXR1cm4gc2V0dGluZ3MuYW9Db2x1bW5zW2NvbHVtbl0ublRoO1xuXHRcdH0sIDEgKTtcblx0fSApO1xuXHRcblx0X2FwaV9yZWdpc3RlclBsdXJhbCggJ2NvbHVtbnMoKS5mb290ZXIoKScsICdjb2x1bW4oKS5mb290ZXIoKScsIGZ1bmN0aW9uICggc2VsZWN0b3IsIG9wdHMgKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICdjb2x1bW4nLCBmdW5jdGlvbiAoIHNldHRpbmdzLCBjb2x1bW4gKSB7XG5cdFx0XHRyZXR1cm4gc2V0dGluZ3MuYW9Db2x1bW5zW2NvbHVtbl0ublRmO1xuXHRcdH0sIDEgKTtcblx0fSApO1xuXHRcblx0X2FwaV9yZWdpc3RlclBsdXJhbCggJ2NvbHVtbnMoKS5kYXRhKCknLCAnY29sdW1uKCkuZGF0YSgpJywgZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAnY29sdW1uLXJvd3MnLCBfX2NvbHVtbkRhdGEsIDEgKTtcblx0fSApO1xuXHRcblx0X2FwaV9yZWdpc3RlclBsdXJhbCggJ2NvbHVtbnMoKS5kYXRhU3JjKCknLCAnY29sdW1uKCkuZGF0YVNyYygpJywgZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAnY29sdW1uJywgZnVuY3Rpb24gKCBzZXR0aW5ncywgY29sdW1uICkge1xuXHRcdFx0cmV0dXJuIHNldHRpbmdzLmFvQ29sdW1uc1tjb2x1bW5dLm1EYXRhO1xuXHRcdH0sIDEgKTtcblx0fSApO1xuXHRcblx0X2FwaV9yZWdpc3RlclBsdXJhbCggJ2NvbHVtbnMoKS5jYWNoZSgpJywgJ2NvbHVtbigpLmNhY2hlKCknLCBmdW5jdGlvbiAoIHR5cGUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICdjb2x1bW4tcm93cycsIGZ1bmN0aW9uICggc2V0dGluZ3MsIGNvbHVtbiwgaSwgaiwgcm93cyApIHtcblx0XHRcdHJldHVybiBfcGx1Y2tfb3JkZXIoIHNldHRpbmdzLmFvRGF0YSwgcm93cyxcblx0XHRcdFx0dHlwZSA9PT0gJ3NlYXJjaCcgPyAnX2FGaWx0ZXJEYXRhJyA6ICdfYVNvcnREYXRhJywgY29sdW1uXG5cdFx0XHQpO1xuXHRcdH0sIDEgKTtcblx0fSApO1xuXHRcblx0X2FwaV9yZWdpc3RlclBsdXJhbCggJ2NvbHVtbnMoKS5ub2RlcygpJywgJ2NvbHVtbigpLm5vZGVzKCknLCBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICdjb2x1bW4tcm93cycsIGZ1bmN0aW9uICggc2V0dGluZ3MsIGNvbHVtbiwgaSwgaiwgcm93cyApIHtcblx0XHRcdHJldHVybiBfcGx1Y2tfb3JkZXIoIHNldHRpbmdzLmFvRGF0YSwgcm93cywgJ2FuQ2VsbHMnLCBjb2x1bW4gKSA7XG5cdFx0fSwgMSApO1xuXHR9ICk7XG5cdFxuXHRfYXBpX3JlZ2lzdGVyUGx1cmFsKCAnY29sdW1ucygpLnZpc2libGUoKScsICdjb2x1bW4oKS52aXNpYmxlKCknLCBmdW5jdGlvbiAoIHZpcywgY2FsYyApIHtcblx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cdFx0dmFyIHJldCA9IHRoaXMuaXRlcmF0b3IoICdjb2x1bW4nLCBmdW5jdGlvbiAoIHNldHRpbmdzLCBjb2x1bW4gKSB7XG5cdFx0XHRpZiAoIHZpcyA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gc2V0dGluZ3MuYW9Db2x1bW5zWyBjb2x1bW4gXS5iVmlzaWJsZTtcblx0XHRcdH0gLy8gZWxzZVxuXHRcdFx0X19zZXRDb2x1bW5WaXMoIHNldHRpbmdzLCBjb2x1bW4sIHZpcyApO1xuXHRcdH0gKTtcblx0XG5cdFx0Ly8gR3JvdXAgdGhlIGNvbHVtbiB2aXNpYmlsaXR5IGNoYW5nZXNcblx0XHRpZiAoIHZpcyAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBzZXR0aW5ncyApIHtcblx0XHRcdFx0Ly8gUmVkcmF3IHRoZSBoZWFkZXIgYWZ0ZXIgY2hhbmdlc1xuXHRcdFx0XHRfZm5EcmF3SGVhZCggc2V0dGluZ3MsIHNldHRpbmdzLmFvSGVhZGVyICk7XG5cdFx0XHRcdF9mbkRyYXdIZWFkKCBzZXR0aW5ncywgc2V0dGluZ3MuYW9Gb290ZXIgKTtcblx0XHRcblx0XHRcdFx0Ly8gVXBkYXRlIGNvbHNwYW4gZm9yIG5vIHJlY29yZHMgZGlzcGxheS4gQ2hpbGQgcm93cyBhbmQgZXh0ZW5zaW9ucyB3aWxsIHVzZSB0aGVpciBvd25cblx0XHRcdFx0Ly8gbGlzdGVuZXJzIHRvIGRvIHRoaXMgLSBvbmx5IG5lZWQgdG8gdXBkYXRlIHRoZSBlbXB0eSB0YWJsZSBpdGVtIGhlcmVcblx0XHRcdFx0aWYgKCAhIHNldHRpbmdzLmFpRGlzcGxheS5sZW5ndGggKSB7XG5cdFx0XHRcdFx0JChzZXR0aW5ncy5uVEJvZHkpLmZpbmQoJ3RkW2NvbHNwYW5dJykuYXR0cignY29sc3BhbicsIF9mblZpc2JsZUNvbHVtbnMoc2V0dGluZ3MpKTtcblx0XHRcdFx0fVxuXHRcdFxuXHRcdFx0XHRfZm5TYXZlU3RhdGUoIHNldHRpbmdzICk7XG5cdFxuXHRcdFx0XHQvLyBTZWNvbmQgbG9vcCBvbmNlIHRoZSBmaXJzdCBpcyBkb25lIGZvciBldmVudHNcblx0XHRcdFx0dGhhdC5pdGVyYXRvciggJ2NvbHVtbicsIGZ1bmN0aW9uICggc2V0dGluZ3MsIGNvbHVtbiApIHtcblx0XHRcdFx0XHRfZm5DYWxsYmFja0ZpcmUoIHNldHRpbmdzLCBudWxsLCAnY29sdW1uLXZpc2liaWxpdHknLCBbc2V0dGluZ3MsIGNvbHVtbiwgdmlzLCBjYWxjXSApO1xuXHRcdFx0XHR9ICk7XG5cdFxuXHRcdFx0XHRpZiAoIGNhbGMgPT09IHVuZGVmaW5lZCB8fCBjYWxjICkge1xuXHRcdFx0XHRcdHRoYXQuY29sdW1ucy5hZGp1c3QoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHRcblx0XHRyZXR1cm4gcmV0O1xuXHR9ICk7XG5cdFxuXHRfYXBpX3JlZ2lzdGVyUGx1cmFsKCAnY29sdW1ucygpLmluZGV4ZXMoKScsICdjb2x1bW4oKS5pbmRleCgpJywgZnVuY3Rpb24gKCB0eXBlICkge1xuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAnY29sdW1uJywgZnVuY3Rpb24gKCBzZXR0aW5ncywgY29sdW1uICkge1xuXHRcdFx0cmV0dXJuIHR5cGUgPT09ICd2aXNpYmxlJyA/XG5cdFx0XHRcdF9mbkNvbHVtbkluZGV4VG9WaXNpYmxlKCBzZXR0aW5ncywgY29sdW1uICkgOlxuXHRcdFx0XHRjb2x1bW47XG5cdFx0fSwgMSApO1xuXHR9ICk7XG5cdFxuXHRfYXBpX3JlZ2lzdGVyKCAnY29sdW1ucy5hZGp1c3QoKScsIGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBzZXR0aW5ncyApIHtcblx0XHRcdF9mbkFkanVzdENvbHVtblNpemluZyggc2V0dGluZ3MgKTtcblx0XHR9LCAxICk7XG5cdH0gKTtcblx0XG5cdF9hcGlfcmVnaXN0ZXIoICdjb2x1bW4uaW5kZXgoKScsIGZ1bmN0aW9uICggdHlwZSwgaWR4ICkge1xuXHRcdGlmICggdGhpcy5jb250ZXh0Lmxlbmd0aCAhPT0gMCApIHtcblx0XHRcdHZhciBjdHggPSB0aGlzLmNvbnRleHRbMF07XG5cdFxuXHRcdFx0aWYgKCB0eXBlID09PSAnZnJvbVZpc2libGUnIHx8IHR5cGUgPT09ICd0b0RhdGEnICkge1xuXHRcdFx0XHRyZXR1cm4gX2ZuVmlzaWJsZVRvQ29sdW1uSW5kZXgoIGN0eCwgaWR4ICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggdHlwZSA9PT0gJ2Zyb21EYXRhJyB8fCB0eXBlID09PSAndG9WaXNpYmxlJyApIHtcblx0XHRcdFx0cmV0dXJuIF9mbkNvbHVtbkluZGV4VG9WaXNpYmxlKCBjdHgsIGlkeCApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSApO1xuXHRcblx0X2FwaV9yZWdpc3RlciggJ2NvbHVtbigpJywgZnVuY3Rpb24gKCBzZWxlY3Rvciwgb3B0cyApIHtcblx0XHRyZXR1cm4gX3NlbGVjdG9yX2ZpcnN0KCB0aGlzLmNvbHVtbnMoIHNlbGVjdG9yLCBvcHRzICkgKTtcblx0fSApO1xuXHRcblx0XG5cdFxuXHR2YXIgX19jZWxsX3NlbGVjdG9yID0gZnVuY3Rpb24gKCBzZXR0aW5ncywgc2VsZWN0b3IsIG9wdHMgKVxuXHR7XG5cdFx0dmFyIGRhdGEgPSBzZXR0aW5ncy5hb0RhdGE7XG5cdFx0dmFyIHJvd3MgPSBfc2VsZWN0b3Jfcm93X2luZGV4ZXMoIHNldHRpbmdzLCBvcHRzICk7XG5cdFx0dmFyIGNlbGxzID0gX3JlbW92ZUVtcHR5KCBfcGx1Y2tfb3JkZXIoIGRhdGEsIHJvd3MsICdhbkNlbGxzJyApICk7XG5cdFx0dmFyIGFsbENlbGxzID0gJCggW10uY29uY2F0LmFwcGx5KFtdLCBjZWxscykgKTtcblx0XHR2YXIgcm93O1xuXHRcdHZhciBjb2x1bW5zID0gc2V0dGluZ3MuYW9Db2x1bW5zLmxlbmd0aDtcblx0XHR2YXIgYSwgaSwgaWVuLCBqLCBvLCBob3N0O1xuXHRcblx0XHR2YXIgcnVuID0gZnVuY3Rpb24gKCBzICkge1xuXHRcdFx0dmFyIGZuU2VsZWN0b3IgPSB0eXBlb2YgcyA9PT0gJ2Z1bmN0aW9uJztcblx0XG5cdFx0XHRpZiAoIHMgPT09IG51bGwgfHwgcyA9PT0gdW5kZWZpbmVkIHx8IGZuU2VsZWN0b3IgKSB7XG5cdFx0XHRcdC8vIEFsbCBjZWxscyBhbmQgZnVuY3Rpb24gc2VsZWN0b3JzXG5cdFx0XHRcdGEgPSBbXTtcblx0XG5cdFx0XHRcdGZvciAoIGk9MCwgaWVuPXJvd3MubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdFx0cm93ID0gcm93c1tpXTtcblx0XG5cdFx0XHRcdFx0Zm9yICggaj0wIDsgajxjb2x1bW5zIDsgaisrICkge1xuXHRcdFx0XHRcdFx0byA9IHtcblx0XHRcdFx0XHRcdFx0cm93OiByb3csXG5cdFx0XHRcdFx0XHRcdGNvbHVtbjogalxuXHRcdFx0XHRcdFx0fTtcblx0XG5cdFx0XHRcdFx0XHRpZiAoIGZuU2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0XHRcdC8vIFNlbGVjdG9yIC0gZnVuY3Rpb25cblx0XHRcdFx0XHRcdFx0aG9zdCA9IGRhdGFbIHJvdyBdO1xuXHRcblx0XHRcdFx0XHRcdFx0aWYgKCBzKCBvLCBfZm5HZXRDZWxsRGF0YShzZXR0aW5ncywgcm93LCBqKSwgaG9zdC5hbkNlbGxzID8gaG9zdC5hbkNlbGxzW2pdIDogbnVsbCApICkge1xuXHRcdFx0XHRcdFx0XHRcdGEucHVzaCggbyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gU2VsZWN0b3IgLSBhbGxcblx0XHRcdFx0XHRcdFx0YS5wdXNoKCBvICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRyZXR1cm4gYTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Ly8gU2VsZWN0b3IgLSBpbmRleFxuXHRcdFx0aWYgKCAkLmlzUGxhaW5PYmplY3QoIHMgKSApIHtcblx0XHRcdFx0Ly8gVmFsaWQgY2VsbCBpbmRleCBhbmQgaXRzIGluIHRoZSBhcnJheSBvZiBzZWxlY3RhYmxlIHJvd3Ncblx0XHRcdFx0cmV0dXJuIHMuY29sdW1uICE9PSB1bmRlZmluZWQgJiYgcy5yb3cgIT09IHVuZGVmaW5lZCAmJiAkLmluQXJyYXkoIHMucm93LCByb3dzICkgIT09IC0xID9cblx0XHRcdFx0XHRbc10gOlxuXHRcdFx0XHRcdFtdO1xuXHRcdFx0fVxuXHRcblx0XHRcdC8vIFNlbGVjdG9yIC0galF1ZXJ5IGZpbHRlcmVkIGNlbGxzXG5cdFx0XHR2YXIganFSZXN1bHQgPSBhbGxDZWxsc1xuXHRcdFx0XHQuZmlsdGVyKCBzIClcblx0XHRcdFx0Lm1hcCggZnVuY3Rpb24gKGksIGVsKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHsgLy8gdXNlIGEgbmV3IG9iamVjdCwgaW4gY2FzZSBzb21lb25lIGNoYW5nZXMgdGhlIHZhbHVlc1xuXHRcdFx0XHRcdFx0cm93OiAgICBlbC5fRFRfQ2VsbEluZGV4LnJvdyxcblx0XHRcdFx0XHRcdGNvbHVtbjogZWwuX0RUX0NlbGxJbmRleC5jb2x1bW5cblx0IFx0XHRcdFx0fTtcblx0XHRcdFx0fSApXG5cdFx0XHRcdC50b0FycmF5KCk7XG5cdFxuXHRcdFx0aWYgKCBqcVJlc3VsdC5sZW5ndGggfHwgISBzLm5vZGVOYW1lICkge1xuXHRcdFx0XHRyZXR1cm4ganFSZXN1bHQ7XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gT3RoZXJ3aXNlIHRoZSBzZWxlY3RvciBpcyBhIG5vZGUsIGFuZCB0aGVyZSBpcyBvbmUgbGFzdCBvcHRpb24gLSB0aGVcblx0XHRcdC8vIGVsZW1lbnQgbWlnaHQgYmUgYSBjaGlsZCBvZiBhbiBlbGVtZW50IHdoaWNoIGhhcyBkdC1yb3cgYW5kIGR0LWNvbHVtblxuXHRcdFx0Ly8gZGF0YSBhdHRyaWJ1dGVzXG5cdFx0XHRob3N0ID0gJChzKS5jbG9zZXN0KCcqW2RhdGEtZHQtcm93XScpO1xuXHRcdFx0cmV0dXJuIGhvc3QubGVuZ3RoID9cblx0XHRcdFx0WyB7XG5cdFx0XHRcdFx0cm93OiBob3N0LmRhdGEoJ2R0LXJvdycpLFxuXHRcdFx0XHRcdGNvbHVtbjogaG9zdC5kYXRhKCdkdC1jb2x1bW4nKVxuXHRcdFx0XHR9IF0gOlxuXHRcdFx0XHRbXTtcblx0XHR9O1xuXHRcblx0XHRyZXR1cm4gX3NlbGVjdG9yX3J1biggJ2NlbGwnLCBzZWxlY3RvciwgcnVuLCBzZXR0aW5ncywgb3B0cyApO1xuXHR9O1xuXHRcblx0XG5cdFxuXHRcblx0X2FwaV9yZWdpc3RlciggJ2NlbGxzKCknLCBmdW5jdGlvbiAoIHJvd1NlbGVjdG9yLCBjb2x1bW5TZWxlY3Rvciwgb3B0cyApIHtcblx0XHQvLyBBcmd1bWVudCBzaGlmdGluZ1xuXHRcdGlmICggJC5pc1BsYWluT2JqZWN0KCByb3dTZWxlY3RvciApICkge1xuXHRcdFx0Ly8gSW5kZXhlc1xuXHRcdFx0aWYgKCByb3dTZWxlY3Rvci5yb3cgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0Ly8gU2VsZWN0b3Igb3B0aW9ucyBpbiBmaXJzdCBwYXJhbWV0ZXJcblx0XHRcdFx0b3B0cyA9IHJvd1NlbGVjdG9yO1xuXHRcdFx0XHRyb3dTZWxlY3RvciA9IG51bGw7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0Ly8gQ2VsbCBpbmRleCBvYmplY3RzIGluIGZpcnN0IHBhcmFtZXRlclxuXHRcdFx0XHRvcHRzID0gY29sdW1uU2VsZWN0b3I7XG5cdFx0XHRcdGNvbHVtblNlbGVjdG9yID0gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKCAkLmlzUGxhaW5PYmplY3QoIGNvbHVtblNlbGVjdG9yICkgKSB7XG5cdFx0XHRvcHRzID0gY29sdW1uU2VsZWN0b3I7XG5cdFx0XHRjb2x1bW5TZWxlY3RvciA9IG51bGw7XG5cdFx0fVxuXHRcblx0XHQvLyBDZWxsIHNlbGVjdG9yXG5cdFx0aWYgKCBjb2x1bW5TZWxlY3RvciA9PT0gbnVsbCB8fCBjb2x1bW5TZWxlY3RvciA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0XHRcdHJldHVybiBfX2NlbGxfc2VsZWN0b3IoIHNldHRpbmdzLCByb3dTZWxlY3RvciwgX3NlbGVjdG9yX29wdHMoIG9wdHMgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblx0XG5cdFx0Ly8gVGhlIGRlZmF1bHQgYnVpbHQgaW4gb3B0aW9ucyBuZWVkIHRvIGFwcGx5IHRvIHJvdyBhbmQgY29sdW1uc1xuXHRcdHZhciBpbnRlcm5hbE9wdHMgPSBvcHRzID8ge1xuXHRcdFx0cGFnZTogb3B0cy5wYWdlLFxuXHRcdFx0b3JkZXI6IG9wdHMub3JkZXIsXG5cdFx0XHRzZWFyY2g6IG9wdHMuc2VhcmNoXG5cdFx0fSA6IHt9O1xuXHRcblx0XHQvLyBSb3cgKyBjb2x1bW4gc2VsZWN0b3Jcblx0XHR2YXIgY29sdW1ucyA9IHRoaXMuY29sdW1ucyggY29sdW1uU2VsZWN0b3IsIGludGVybmFsT3B0cyApO1xuXHRcdHZhciByb3dzID0gdGhpcy5yb3dzKCByb3dTZWxlY3RvciwgaW50ZXJuYWxPcHRzICk7XG5cdFx0dmFyIGksIGllbiwgaiwgamVuO1xuXHRcblx0XHR2YXIgY2VsbHNOb09wdHMgPSB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIHNldHRpbmdzLCBpZHggKSB7XG5cdFx0XHR2YXIgYSA9IFtdO1xuXHRcblx0XHRcdGZvciAoIGk9MCwgaWVuPXJvd3NbaWR4XS5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0Zm9yICggaj0wLCBqZW49Y29sdW1uc1tpZHhdLmxlbmd0aCA7IGo8amVuIDsgaisrICkge1xuXHRcdFx0XHRcdGEucHVzaCgge1xuXHRcdFx0XHRcdFx0cm93OiAgICByb3dzW2lkeF1baV0sXG5cdFx0XHRcdFx0XHRjb2x1bW46IGNvbHVtbnNbaWR4XVtqXVxuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcblx0XHRcdHJldHVybiBhO1xuXHRcdH0sIDEgKTtcblx0XG5cdFx0Ly8gVGhlcmUgaXMgY3VycmVudGx5IG9ubHkgb25lIGV4dGVuc2lvbiB3aGljaCB1c2VzIGEgY2VsbCBzZWxlY3RvciBleHRlbnNpb25cblx0XHQvLyBJdCBpcyBhIF9tYWpvcl8gcGVyZm9ybWFuY2UgZHJhZyB0byBydW4gdGhpcyBpZiBpdCBpc24ndCBuZWVkZWQsIHNvIHRoaXMgaXNcblx0XHQvLyBhbiBleHRlbnNpb24gc3BlY2lmaWMgY2hlY2sgYXQgdGhlIG1vbWVudFxuXHRcdHZhciBjZWxscyA9IG9wdHMgJiYgb3B0cy5zZWxlY3RlZCA/XG5cdFx0XHR0aGlzLmNlbGxzKCBjZWxsc05vT3B0cywgb3B0cyApIDpcblx0XHRcdGNlbGxzTm9PcHRzO1xuXHRcblx0XHQkLmV4dGVuZCggY2VsbHMuc2VsZWN0b3IsIHtcblx0XHRcdGNvbHM6IGNvbHVtblNlbGVjdG9yLFxuXHRcdFx0cm93czogcm93U2VsZWN0b3IsXG5cdFx0XHRvcHRzOiBvcHRzXG5cdFx0fSApO1xuXHRcblx0XHRyZXR1cm4gY2VsbHM7XG5cdH0gKTtcblx0XG5cdFxuXHRfYXBpX3JlZ2lzdGVyUGx1cmFsKCAnY2VsbHMoKS5ub2RlcygpJywgJ2NlbGwoKS5ub2RlKCknLCBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICdjZWxsJywgZnVuY3Rpb24gKCBzZXR0aW5ncywgcm93LCBjb2x1bW4gKSB7XG5cdFx0XHR2YXIgZGF0YSA9IHNldHRpbmdzLmFvRGF0YVsgcm93IF07XG5cdFxuXHRcdFx0cmV0dXJuIGRhdGEgJiYgZGF0YS5hbkNlbGxzID9cblx0XHRcdFx0ZGF0YS5hbkNlbGxzWyBjb2x1bW4gXSA6XG5cdFx0XHRcdHVuZGVmaW5lZDtcblx0XHR9LCAxICk7XG5cdH0gKTtcblx0XG5cdFxuXHRfYXBpX3JlZ2lzdGVyKCAnY2VsbHMoKS5kYXRhKCknLCBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICdjZWxsJywgZnVuY3Rpb24gKCBzZXR0aW5ncywgcm93LCBjb2x1bW4gKSB7XG5cdFx0XHRyZXR1cm4gX2ZuR2V0Q2VsbERhdGEoIHNldHRpbmdzLCByb3csIGNvbHVtbiApO1xuXHRcdH0sIDEgKTtcblx0fSApO1xuXHRcblx0XG5cdF9hcGlfcmVnaXN0ZXJQbHVyYWwoICdjZWxscygpLmNhY2hlKCknLCAnY2VsbCgpLmNhY2hlKCknLCBmdW5jdGlvbiAoIHR5cGUgKSB7XG5cdFx0dHlwZSA9IHR5cGUgPT09ICdzZWFyY2gnID8gJ19hRmlsdGVyRGF0YScgOiAnX2FTb3J0RGF0YSc7XG5cdFxuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAnY2VsbCcsIGZ1bmN0aW9uICggc2V0dGluZ3MsIHJvdywgY29sdW1uICkge1xuXHRcdFx0cmV0dXJuIHNldHRpbmdzLmFvRGF0YVsgcm93IF1bIHR5cGUgXVsgY29sdW1uIF07XG5cdFx0fSwgMSApO1xuXHR9ICk7XG5cdFxuXHRcblx0X2FwaV9yZWdpc3RlclBsdXJhbCggJ2NlbGxzKCkucmVuZGVyKCknLCAnY2VsbCgpLnJlbmRlcigpJywgZnVuY3Rpb24gKCB0eXBlICkge1xuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAnY2VsbCcsIGZ1bmN0aW9uICggc2V0dGluZ3MsIHJvdywgY29sdW1uICkge1xuXHRcdFx0cmV0dXJuIF9mbkdldENlbGxEYXRhKCBzZXR0aW5ncywgcm93LCBjb2x1bW4sIHR5cGUgKTtcblx0XHR9LCAxICk7XG5cdH0gKTtcblx0XG5cdFxuXHRfYXBpX3JlZ2lzdGVyUGx1cmFsKCAnY2VsbHMoKS5pbmRleGVzKCknLCAnY2VsbCgpLmluZGV4KCknLCBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICdjZWxsJywgZnVuY3Rpb24gKCBzZXR0aW5ncywgcm93LCBjb2x1bW4gKSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRyb3c6IHJvdyxcblx0XHRcdFx0Y29sdW1uOiBjb2x1bW4sXG5cdFx0XHRcdGNvbHVtblZpc2libGU6IF9mbkNvbHVtbkluZGV4VG9WaXNpYmxlKCBzZXR0aW5ncywgY29sdW1uIClcblx0XHRcdH07XG5cdFx0fSwgMSApO1xuXHR9ICk7XG5cdFxuXHRcblx0X2FwaV9yZWdpc3RlclBsdXJhbCggJ2NlbGxzKCkuaW52YWxpZGF0ZSgpJywgJ2NlbGwoKS5pbnZhbGlkYXRlKCknLCBmdW5jdGlvbiAoIHNyYyApIHtcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ2NlbGwnLCBmdW5jdGlvbiAoIHNldHRpbmdzLCByb3csIGNvbHVtbiApIHtcblx0XHRcdF9mbkludmFsaWRhdGUoIHNldHRpbmdzLCByb3csIHNyYywgY29sdW1uICk7XG5cdFx0fSApO1xuXHR9ICk7XG5cdFxuXHRcblx0XG5cdF9hcGlfcmVnaXN0ZXIoICdjZWxsKCknLCBmdW5jdGlvbiAoIHJvd1NlbGVjdG9yLCBjb2x1bW5TZWxlY3Rvciwgb3B0cyApIHtcblx0XHRyZXR1cm4gX3NlbGVjdG9yX2ZpcnN0KCB0aGlzLmNlbGxzKCByb3dTZWxlY3RvciwgY29sdW1uU2VsZWN0b3IsIG9wdHMgKSApO1xuXHR9ICk7XG5cdFxuXHRcblx0X2FwaV9yZWdpc3RlciggJ2NlbGwoKS5kYXRhKCknLCBmdW5jdGlvbiAoIGRhdGEgKSB7XG5cdFx0dmFyIGN0eCA9IHRoaXMuY29udGV4dDtcblx0XHR2YXIgY2VsbCA9IHRoaXNbMF07XG5cdFxuXHRcdGlmICggZGF0YSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0Ly8gR2V0XG5cdFx0XHRyZXR1cm4gY3R4Lmxlbmd0aCAmJiBjZWxsLmxlbmd0aCA/XG5cdFx0XHRcdF9mbkdldENlbGxEYXRhKCBjdHhbMF0sIGNlbGxbMF0ucm93LCBjZWxsWzBdLmNvbHVtbiApIDpcblx0XHRcdFx0dW5kZWZpbmVkO1xuXHRcdH1cblx0XG5cdFx0Ly8gU2V0XG5cdFx0X2ZuU2V0Q2VsbERhdGEoIGN0eFswXSwgY2VsbFswXS5yb3csIGNlbGxbMF0uY29sdW1uLCBkYXRhICk7XG5cdFx0X2ZuSW52YWxpZGF0ZSggY3R4WzBdLCBjZWxsWzBdLnJvdywgJ2RhdGEnLCBjZWxsWzBdLmNvbHVtbiApO1xuXHRcblx0XHRyZXR1cm4gdGhpcztcblx0fSApO1xuXHRcblx0XG5cdFxuXHQvKipcblx0ICogR2V0IGN1cnJlbnQgb3JkZXJpbmcgKHNvcnRpbmcpIHRoYXQgaGFzIGJlZW4gYXBwbGllZCB0byB0aGUgdGFibGUuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHthcnJheX0gMkQgYXJyYXkgY29udGFpbmluZyB0aGUgc29ydGluZyBpbmZvcm1hdGlvbiBmb3IgdGhlIGZpcnN0XG5cdCAqICAgdGFibGUgaW4gdGhlIGN1cnJlbnQgY29udGV4dC4gRWFjaCBlbGVtZW50IGluIHRoZSBwYXJlbnQgYXJyYXkgcmVwcmVzZW50c1xuXHQgKiAgIGEgY29sdW1uIGJlaW5nIHNvcnRlZCB1cG9uIChpLmUuIG11bHRpLXNvcnRpbmcgd2l0aCB0d28gY29sdW1ucyB3b3VsZCBoYXZlXG5cdCAqICAgMiBpbm5lciBhcnJheXMpLiBUaGUgaW5uZXIgYXJyYXlzIG1heSBoYXZlIDIgb3IgMyBlbGVtZW50cy4gVGhlIGZpcnN0IGlzXG5cdCAqICAgdGhlIGNvbHVtbiBpbmRleCB0aGF0IHRoZSBzb3J0aW5nIGNvbmRpdGlvbiBhcHBsaWVzIHRvLCB0aGUgc2Vjb25kIGlzIHRoZVxuXHQgKiAgIGRpcmVjdGlvbiBvZiB0aGUgc29ydCAoYGRlc2NgIG9yIGBhc2NgKSBhbmQsIG9wdGlvbmFsbHksIHRoZSB0aGlyZCBpcyB0aGVcblx0ICogICBpbmRleCBvZiB0aGUgc29ydGluZyBvcmRlciBmcm9tIHRoZSBgY29sdW1uLnNvcnRpbmdgIGluaXRpYWxpc2F0aW9uIGFycmF5LlxuXHQgKi8vKipcblx0ICogU2V0IHRoZSBvcmRlcmluZyBmb3IgdGhlIHRhYmxlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge2ludGVnZXJ9IG9yZGVyIENvbHVtbiBpbmRleCB0byBzb3J0IHVwb24uXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBkaXJlY3Rpb24gRGlyZWN0aW9uIG9mIHRoZSBzb3J0IHRvIGJlIGFwcGxpZWQgKGBhc2NgIG9yIGBkZXNjYClcblx0ICogQHJldHVybnMge0RhdGFUYWJsZXMuQXBpfSB0aGlzXG5cdCAqLy8qKlxuXHQgKiBTZXQgdGhlIG9yZGVyaW5nIGZvciB0aGUgdGFibGUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7YXJyYXl9IG9yZGVyIDFEIGFycmF5IG9mIHNvcnRpbmcgaW5mb3JtYXRpb24gdG8gYmUgYXBwbGllZC5cblx0ICogQHBhcmFtIHthcnJheX0gWy4uLl0gT3B0aW9uYWwgYWRkaXRpb25hbCBzb3J0aW5nIGNvbmRpdGlvbnNcblx0ICogQHJldHVybnMge0RhdGFUYWJsZXMuQXBpfSB0aGlzXG5cdCAqLy8qKlxuXHQgKiBTZXQgdGhlIG9yZGVyaW5nIGZvciB0aGUgdGFibGUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7YXJyYXl9IG9yZGVyIDJEIGFycmF5IG9mIHNvcnRpbmcgaW5mb3JtYXRpb24gdG8gYmUgYXBwbGllZC5cblx0ICogQHJldHVybnMge0RhdGFUYWJsZXMuQXBpfSB0aGlzXG5cdCAqL1xuXHRfYXBpX3JlZ2lzdGVyKCAnb3JkZXIoKScsIGZ1bmN0aW9uICggb3JkZXIsIGRpciApIHtcblx0XHR2YXIgY3R4ID0gdGhpcy5jb250ZXh0O1xuXHRcblx0XHRpZiAoIG9yZGVyID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHQvLyBnZXRcblx0XHRcdHJldHVybiBjdHgubGVuZ3RoICE9PSAwID9cblx0XHRcdFx0Y3R4WzBdLmFhU29ydGluZyA6XG5cdFx0XHRcdHVuZGVmaW5lZDtcblx0XHR9XG5cdFxuXHRcdC8vIHNldFxuXHRcdGlmICggdHlwZW9mIG9yZGVyID09PSAnbnVtYmVyJyApIHtcblx0XHRcdC8vIFNpbXBsZSBjb2x1bW4gLyBkaXJlY3Rpb24gcGFzc2VkIGluXG5cdFx0XHRvcmRlciA9IFsgWyBvcmRlciwgZGlyIF0gXTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIG9yZGVyLmxlbmd0aCAmJiAhICQuaXNBcnJheSggb3JkZXJbMF0gKSApIHtcblx0XHRcdC8vIEFyZ3VtZW50cyBwYXNzZWQgaW4gKGxpc3Qgb2YgMUQgYXJyYXlzKVxuXHRcdFx0b3JkZXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggYXJndW1lbnRzICk7XG5cdFx0fVxuXHRcdC8vIG90aGVyd2lzZSBhIDJEIGFycmF5IHdhcyBwYXNzZWQgaW5cblx0XG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0XHRzZXR0aW5ncy5hYVNvcnRpbmcgPSBvcmRlci5zbGljZSgpO1xuXHRcdH0gKTtcblx0fSApO1xuXHRcblx0XG5cdC8qKlxuXHQgKiBBdHRhY2ggYSBzb3J0IGxpc3RlbmVyIHRvIGFuIGVsZW1lbnQgZm9yIGEgZ2l2ZW4gY29sdW1uXG5cdCAqXG5cdCAqIEBwYXJhbSB7bm9kZXxqUXVlcnl8c3RyaW5nfSBub2RlIElkZW50aWZpZXIgZm9yIHRoZSBlbGVtZW50KHMpIHRvIGF0dGFjaCB0aGVcblx0ICogICBsaXN0ZW5lciB0by4gVGhpcyBjYW4gdGFrZSB0aGUgZm9ybSBvZiBhIHNpbmdsZSBET00gbm9kZSwgYSBqUXVlcnlcblx0ICogICBjb2xsZWN0aW9uIG9mIG5vZGVzIG9yIGEgalF1ZXJ5IHNlbGVjdG9yIHdoaWNoIHdpbGwgaWRlbnRpZnkgdGhlIG5vZGUocykuXG5cdCAqIEBwYXJhbSB7aW50ZWdlcn0gY29sdW1uIHRoZSBjb2x1bW4gdGhhdCBhIGNsaWNrIG9uIHRoaXMgbm9kZSB3aWxsIHNvcnQgb25cblx0ICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSBjYWxsYmFjayBmdW5jdGlvbiB3aGVuIHNvcnQgaXMgcnVuXG5cdCAqIEByZXR1cm5zIHtEYXRhVGFibGVzLkFwaX0gdGhpc1xuXHQgKi9cblx0X2FwaV9yZWdpc3RlciggJ29yZGVyLmxpc3RlbmVyKCknLCBmdW5jdGlvbiAoIG5vZGUsIGNvbHVtbiwgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0XHRfZm5Tb3J0QXR0YWNoTGlzdGVuZXIoIHNldHRpbmdzLCBub2RlLCBjb2x1bW4sIGNhbGxiYWNrICk7XG5cdFx0fSApO1xuXHR9ICk7XG5cdFxuXHRcblx0X2FwaV9yZWdpc3RlciggJ29yZGVyLmZpeGVkKCknLCBmdW5jdGlvbiAoIHNldCApIHtcblx0XHRpZiAoICEgc2V0ICkge1xuXHRcdFx0dmFyIGN0eCA9IHRoaXMuY29udGV4dDtcblx0XHRcdHZhciBmaXhlZCA9IGN0eC5sZW5ndGggP1xuXHRcdFx0XHRjdHhbMF0uYWFTb3J0aW5nRml4ZWQgOlxuXHRcdFx0XHR1bmRlZmluZWQ7XG5cdFxuXHRcdFx0cmV0dXJuICQuaXNBcnJheSggZml4ZWQgKSA/XG5cdFx0XHRcdHsgcHJlOiBmaXhlZCB9IDpcblx0XHRcdFx0Zml4ZWQ7XG5cdFx0fVxuXHRcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBzZXR0aW5ncyApIHtcblx0XHRcdHNldHRpbmdzLmFhU29ydGluZ0ZpeGVkID0gJC5leHRlbmQoIHRydWUsIHt9LCBzZXQgKTtcblx0XHR9ICk7XG5cdH0gKTtcblx0XG5cdFxuXHQvLyBPcmRlciBieSB0aGUgc2VsZWN0ZWQgY29sdW1uKHMpXG5cdF9hcGlfcmVnaXN0ZXIoIFtcblx0XHQnY29sdW1ucygpLm9yZGVyKCknLFxuXHRcdCdjb2x1bW4oKS5vcmRlcigpJ1xuXHRdLCBmdW5jdGlvbiAoIGRpciApIHtcblx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cdFxuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIHNldHRpbmdzLCBpICkge1xuXHRcdFx0dmFyIHNvcnQgPSBbXTtcblx0XG5cdFx0XHQkLmVhY2goIHRoYXRbaV0sIGZ1bmN0aW9uIChqLCBjb2wpIHtcblx0XHRcdFx0c29ydC5wdXNoKCBbIGNvbCwgZGlyIF0gKTtcblx0XHRcdH0gKTtcblx0XG5cdFx0XHRzZXR0aW5ncy5hYVNvcnRpbmcgPSBzb3J0O1xuXHRcdH0gKTtcblx0fSApO1xuXHRcblx0XG5cdFxuXHRfYXBpX3JlZ2lzdGVyKCAnc2VhcmNoKCknLCBmdW5jdGlvbiAoIGlucHV0LCByZWdleCwgc21hcnQsIGNhc2VJbnNlbiApIHtcblx0XHR2YXIgY3R4ID0gdGhpcy5jb250ZXh0O1xuXHRcblx0XHRpZiAoIGlucHV0ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHQvLyBnZXRcblx0XHRcdHJldHVybiBjdHgubGVuZ3RoICE9PSAwID9cblx0XHRcdFx0Y3R4WzBdLm9QcmV2aW91c1NlYXJjaC5zU2VhcmNoIDpcblx0XHRcdFx0dW5kZWZpbmVkO1xuXHRcdH1cblx0XG5cdFx0Ly8gc2V0XG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0XHRpZiAoICEgc2V0dGluZ3Mub0ZlYXR1cmVzLmJGaWx0ZXIgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XG5cdFx0XHRfZm5GaWx0ZXJDb21wbGV0ZSggc2V0dGluZ3MsICQuZXh0ZW5kKCB7fSwgc2V0dGluZ3Mub1ByZXZpb3VzU2VhcmNoLCB7XG5cdFx0XHRcdFwic1NlYXJjaFwiOiBpbnB1dCtcIlwiLFxuXHRcdFx0XHRcImJSZWdleFwiOiAgcmVnZXggPT09IG51bGwgPyBmYWxzZSA6IHJlZ2V4LFxuXHRcdFx0XHRcImJTbWFydFwiOiAgc21hcnQgPT09IG51bGwgPyB0cnVlICA6IHNtYXJ0LFxuXHRcdFx0XHRcImJDYXNlSW5zZW5zaXRpdmVcIjogY2FzZUluc2VuID09PSBudWxsID8gdHJ1ZSA6IGNhc2VJbnNlblxuXHRcdFx0fSApLCAxICk7XG5cdFx0fSApO1xuXHR9ICk7XG5cdFxuXHRcblx0X2FwaV9yZWdpc3RlclBsdXJhbChcblx0XHQnY29sdW1ucygpLnNlYXJjaCgpJyxcblx0XHQnY29sdW1uKCkuc2VhcmNoKCknLFxuXHRcdGZ1bmN0aW9uICggaW5wdXQsIHJlZ2V4LCBzbWFydCwgY2FzZUluc2VuICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICdjb2x1bW4nLCBmdW5jdGlvbiAoIHNldHRpbmdzLCBjb2x1bW4gKSB7XG5cdFx0XHRcdHZhciBwcmVTZWFyY2ggPSBzZXR0aW5ncy5hb1ByZVNlYXJjaENvbHM7XG5cdFxuXHRcdFx0XHRpZiAoIGlucHV0ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0Ly8gZ2V0XG5cdFx0XHRcdFx0cmV0dXJuIHByZVNlYXJjaFsgY29sdW1uIF0uc1NlYXJjaDtcblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0Ly8gc2V0XG5cdFx0XHRcdGlmICggISBzZXR0aW5ncy5vRmVhdHVyZXMuYkZpbHRlciApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdCQuZXh0ZW5kKCBwcmVTZWFyY2hbIGNvbHVtbiBdLCB7XG5cdFx0XHRcdFx0XCJzU2VhcmNoXCI6IGlucHV0K1wiXCIsXG5cdFx0XHRcdFx0XCJiUmVnZXhcIjogIHJlZ2V4ID09PSBudWxsID8gZmFsc2UgOiByZWdleCxcblx0XHRcdFx0XHRcImJTbWFydFwiOiAgc21hcnQgPT09IG51bGwgPyB0cnVlICA6IHNtYXJ0LFxuXHRcdFx0XHRcdFwiYkNhc2VJbnNlbnNpdGl2ZVwiOiBjYXNlSW5zZW4gPT09IG51bGwgPyB0cnVlIDogY2FzZUluc2VuXG5cdFx0XHRcdH0gKTtcblx0XG5cdFx0XHRcdF9mbkZpbHRlckNvbXBsZXRlKCBzZXR0aW5ncywgc2V0dGluZ3Mub1ByZXZpb3VzU2VhcmNoLCAxICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXHQpO1xuXHRcblx0Lypcblx0ICogU3RhdGUgQVBJIG1ldGhvZHNcblx0ICovXG5cdFxuXHRfYXBpX3JlZ2lzdGVyKCAnc3RhdGUoKScsIGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5jb250ZXh0Lmxlbmd0aCA/XG5cdFx0XHR0aGlzLmNvbnRleHRbMF0ub1NhdmVkU3RhdGUgOlxuXHRcdFx0bnVsbDtcblx0fSApO1xuXHRcblx0XG5cdF9hcGlfcmVnaXN0ZXIoICdzdGF0ZS5jbGVhcigpJywgZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIHNldHRpbmdzICkge1xuXHRcdFx0Ly8gU2F2ZSBhbiBlbXB0eSBvYmplY3Rcblx0XHRcdHNldHRpbmdzLmZuU3RhdGVTYXZlQ2FsbGJhY2suY2FsbCggc2V0dGluZ3Mub0luc3RhbmNlLCBzZXR0aW5ncywge30gKTtcblx0XHR9ICk7XG5cdH0gKTtcblx0XG5cdFxuXHRfYXBpX3JlZ2lzdGVyKCAnc3RhdGUubG9hZGVkKCknLCBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuY29udGV4dC5sZW5ndGggP1xuXHRcdFx0dGhpcy5jb250ZXh0WzBdLm9Mb2FkZWRTdGF0ZSA6XG5cdFx0XHRudWxsO1xuXHR9ICk7XG5cdFxuXHRcblx0X2FwaV9yZWdpc3RlciggJ3N0YXRlLnNhdmUoKScsIGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBzZXR0aW5ncyApIHtcblx0XHRcdF9mblNhdmVTdGF0ZSggc2V0dGluZ3MgKTtcblx0XHR9ICk7XG5cdH0gKTtcblx0XG5cdFxuXHRcblx0LyoqXG5cdCAqIFByb3ZpZGUgYSBjb21tb24gbWV0aG9kIGZvciBwbHVnLWlucyB0byBjaGVjayB0aGUgdmVyc2lvbiBvZiBEYXRhVGFibGVzIGJlaW5nXG5cdCAqIHVzZWQsIGluIG9yZGVyIHRvIGVuc3VyZSBjb21wYXRpYmlsaXR5LlxuXHQgKlxuXHQgKiAgQHBhcmFtIHtzdHJpbmd9IHZlcnNpb24gVmVyc2lvbiBzdHJpbmcgdG8gY2hlY2sgZm9yLCBpbiB0aGUgZm9ybWF0IFwiWC5ZLlpcIi5cblx0ICogICAgTm90ZSB0aGF0IHRoZSBmb3JtYXRzIFwiWFwiIGFuZCBcIlguWVwiIGFyZSBhbHNvIGFjY2VwdGFibGUuXG5cdCAqICBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGlzIHZlcnNpb24gb2YgRGF0YVRhYmxlcyBpcyBncmVhdGVyIG9yIGVxdWFsIHRvXG5cdCAqICAgIHRoZSByZXF1aXJlZCB2ZXJzaW9uLCBvciBmYWxzZSBpZiB0aGlzIHZlcnNpb24gb2YgRGF0YVRhbGVzIGlzIG5vdFxuXHQgKiAgICBzdWl0YWJsZVxuXHQgKiAgQHN0YXRpY1xuXHQgKiAgQGR0b3B0IEFQSS1TdGF0aWNcblx0ICpcblx0ICogIEBleGFtcGxlXG5cdCAqICAgIGFsZXJ0KCAkLmZuLmRhdGFUYWJsZS52ZXJzaW9uQ2hlY2soICcxLjkuMCcgKSApO1xuXHQgKi9cblx0RGF0YVRhYmxlLnZlcnNpb25DaGVjayA9IERhdGFUYWJsZS5mblZlcnNpb25DaGVjayA9IGZ1bmN0aW9uKCB2ZXJzaW9uIClcblx0e1xuXHRcdHZhciBhVGhpcyA9IERhdGFUYWJsZS52ZXJzaW9uLnNwbGl0KCcuJyk7XG5cdFx0dmFyIGFUaGF0ID0gdmVyc2lvbi5zcGxpdCgnLicpO1xuXHRcdHZhciBpVGhpcywgaVRoYXQ7XG5cdFxuXHRcdGZvciAoIHZhciBpPTAsIGlMZW49YVRoYXQubGVuZ3RoIDsgaTxpTGVuIDsgaSsrICkge1xuXHRcdFx0aVRoaXMgPSBwYXJzZUludCggYVRoaXNbaV0sIDEwICkgfHwgMDtcblx0XHRcdGlUaGF0ID0gcGFyc2VJbnQoIGFUaGF0W2ldLCAxMCApIHx8IDA7XG5cdFxuXHRcdFx0Ly8gUGFydHMgYXJlIHRoZSBzYW1lLCBrZWVwIGNvbXBhcmluZ1xuXHRcdFx0aWYgKGlUaGlzID09PSBpVGhhdCkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XG5cdFx0XHQvLyBQYXJ0cyBhcmUgZGlmZmVyZW50LCByZXR1cm4gaW1tZWRpYXRlbHlcblx0XHRcdHJldHVybiBpVGhpcyA+IGlUaGF0O1xuXHRcdH1cblx0XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cdFxuXHRcblx0LyoqXG5cdCAqIENoZWNrIGlmIGEgYDx0YWJsZT5gIG5vZGUgaXMgYSBEYXRhVGFibGUgdGFibGUgYWxyZWFkeSBvciBub3QuXG5cdCAqXG5cdCAqICBAcGFyYW0ge25vZGV8anF1ZXJ5fHN0cmluZ30gdGFibGUgVGFibGUgbm9kZSwgalF1ZXJ5IG9iamVjdCBvciBqUXVlcnlcblx0ICogICAgICBzZWxlY3RvciBmb3IgdGhlIHRhYmxlIHRvIHRlc3QuIE5vdGUgdGhhdCBpZiBtb3JlIHRoYW4gbW9yZSB0aGFuIG9uZVxuXHQgKiAgICAgIHRhYmxlIGlzIHBhc3NlZCBvbiwgb25seSB0aGUgZmlyc3Qgd2lsbCBiZSBjaGVja2VkXG5cdCAqICBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSB0aGUgdGFibGUgZ2l2ZW4gaXMgYSBEYXRhVGFibGUsIG9yIGZhbHNlIG90aGVyd2lzZVxuXHQgKiAgQHN0YXRpY1xuXHQgKiAgQGR0b3B0IEFQSS1TdGF0aWNcblx0ICpcblx0ICogIEBleGFtcGxlXG5cdCAqICAgIGlmICggISAkLmZuLkRhdGFUYWJsZS5pc0RhdGFUYWJsZSggJyNleGFtcGxlJyApICkge1xuXHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XG5cdCAqICAgIH1cblx0ICovXG5cdERhdGFUYWJsZS5pc0RhdGFUYWJsZSA9IERhdGFUYWJsZS5mbklzRGF0YVRhYmxlID0gZnVuY3Rpb24gKCB0YWJsZSApXG5cdHtcblx0XHR2YXIgdCA9ICQodGFibGUpLmdldCgwKTtcblx0XHR2YXIgaXMgPSBmYWxzZTtcblx0XG5cdFx0aWYgKCB0YWJsZSBpbnN0YW5jZW9mIERhdGFUYWJsZS5BcGkgKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFxuXHRcdCQuZWFjaCggRGF0YVRhYmxlLnNldHRpbmdzLCBmdW5jdGlvbiAoaSwgbykge1xuXHRcdFx0dmFyIGhlYWQgPSBvLm5TY3JvbGxIZWFkID8gJCgndGFibGUnLCBvLm5TY3JvbGxIZWFkKVswXSA6IG51bGw7XG5cdFx0XHR2YXIgZm9vdCA9IG8ublNjcm9sbEZvb3QgPyAkKCd0YWJsZScsIG8ublNjcm9sbEZvb3QpWzBdIDogbnVsbDtcblx0XG5cdFx0XHRpZiAoIG8ublRhYmxlID09PSB0IHx8IGhlYWQgPT09IHQgfHwgZm9vdCA9PT0gdCApIHtcblx0XHRcdFx0aXMgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XG5cdFx0cmV0dXJuIGlzO1xuXHR9O1xuXHRcblx0XG5cdC8qKlxuXHQgKiBHZXQgYWxsIERhdGFUYWJsZSB0YWJsZXMgdGhhdCBoYXZlIGJlZW4gaW5pdGlhbGlzZWQgLSBvcHRpb25hbGx5IHlvdSBjYW5cblx0ICogc2VsZWN0IHRvIGdldCBvbmx5IGN1cnJlbnRseSB2aXNpYmxlIHRhYmxlcy5cblx0ICpcblx0ICogIEBwYXJhbSB7Ym9vbGVhbn0gW3Zpc2libGU9ZmFsc2VdIEZsYWcgdG8gaW5kaWNhdGUgaWYgeW91IHdhbnQgYWxsIChkZWZhdWx0KVxuXHQgKiAgICBvciB2aXNpYmxlIHRhYmxlcyBvbmx5LlxuXHQgKiAgQHJldHVybnMge2FycmF5fSBBcnJheSBvZiBgdGFibGVgIG5vZGVzIChub3QgRGF0YVRhYmxlIGluc3RhbmNlcykgd2hpY2ggYXJlXG5cdCAqICAgIERhdGFUYWJsZXNcblx0ICogIEBzdGF0aWNcblx0ICogIEBkdG9wdCBBUEktU3RhdGljXG5cdCAqXG5cdCAqICBAZXhhbXBsZVxuXHQgKiAgICAkLmVhY2goICQuZm4uZGF0YVRhYmxlLnRhYmxlcyh0cnVlKSwgZnVuY3Rpb24gKCkge1xuXHQgKiAgICAgICQodGFibGUpLkRhdGFUYWJsZSgpLmNvbHVtbnMuYWRqdXN0KCk7XG5cdCAqICAgIH0gKTtcblx0ICovXG5cdERhdGFUYWJsZS50YWJsZXMgPSBEYXRhVGFibGUuZm5UYWJsZXMgPSBmdW5jdGlvbiAoIHZpc2libGUgKVxuXHR7XG5cdFx0dmFyIGFwaSA9IGZhbHNlO1xuXHRcblx0XHRpZiAoICQuaXNQbGFpbk9iamVjdCggdmlzaWJsZSApICkge1xuXHRcdFx0YXBpID0gdmlzaWJsZS5hcGk7XG5cdFx0XHR2aXNpYmxlID0gdmlzaWJsZS52aXNpYmxlO1xuXHRcdH1cblx0XG5cdFx0dmFyIGEgPSAkLm1hcCggRGF0YVRhYmxlLnNldHRpbmdzLCBmdW5jdGlvbiAobykge1xuXHRcdFx0aWYgKCAhdmlzaWJsZSB8fCAodmlzaWJsZSAmJiAkKG8ublRhYmxlKS5pcygnOnZpc2libGUnKSkgKSB7XG5cdFx0XHRcdHJldHVybiBvLm5UYWJsZTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdFxuXHRcdHJldHVybiBhcGkgP1xuXHRcdFx0bmV3IF9BcGkoIGEgKSA6XG5cdFx0XHRhO1xuXHR9O1xuXHRcblx0XG5cdC8qKlxuXHQgKiBDb252ZXJ0IGZyb20gY2FtZWwgY2FzZSBwYXJhbWV0ZXJzIHRvIEh1bmdhcmlhbiBub3RhdGlvbi4gVGhpcyBpcyBtYWRlIHB1YmxpY1xuXHQgKiBmb3IgdGhlIGV4dGVuc2lvbnMgdG8gcHJvdmlkZSB0aGUgc2FtZSBhYmlsaXR5IGFzIERhdGFUYWJsZXMgY29yZSB0byBhY2NlcHRcblx0ICogZWl0aGVyIHRoZSAxLjkgc3R5bGUgSHVuZ2FyaWFuIG5vdGF0aW9uLCBvciB0aGUgMS4xMCsgc3R5bGUgY2FtZWxDYXNlXG5cdCAqIHBhcmFtZXRlcnMuXG5cdCAqXG5cdCAqICBAcGFyYW0ge29iamVjdH0gc3JjIFRoZSBtb2RlbCBvYmplY3Qgd2hpY2ggaG9sZHMgYWxsIHBhcmFtZXRlcnMgdGhhdCBjYW4gYmVcblx0ICogICAgbWFwcGVkLlxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IHVzZXIgVGhlIG9iamVjdCB0byBjb252ZXJ0IGZyb20gY2FtZWwgY2FzZSB0byBIdW5nYXJpYW4uXG5cdCAqICBAcGFyYW0ge2Jvb2xlYW59IGZvcmNlIFdoZW4gc2V0IHRvIGB0cnVlYCwgcHJvcGVydGllcyB3aGljaCBhbHJlYWR5IGhhdmUgYVxuXHQgKiAgICBIdW5nYXJpYW4gdmFsdWUgaW4gdGhlIGB1c2VyYCBvYmplY3Qgd2lsbCBiZSBvdmVyd3JpdHRlbi4gT3RoZXJ3aXNlIHRoZXlcblx0ICogICAgd29uJ3QgYmUuXG5cdCAqL1xuXHREYXRhVGFibGUuY2FtZWxUb0h1bmdhcmlhbiA9IF9mbkNhbWVsVG9IdW5nYXJpYW47XG5cdFxuXHRcblx0XG5cdC8qKlxuXHQgKlxuXHQgKi9cblx0X2FwaV9yZWdpc3RlciggJyQoKScsIGZ1bmN0aW9uICggc2VsZWN0b3IsIG9wdHMgKSB7XG5cdFx0dmFyXG5cdFx0XHRyb3dzICAgPSB0aGlzLnJvd3MoIG9wdHMgKS5ub2RlcygpLCAvLyBHZXQgYWxsIHJvd3Ncblx0XHRcdGpxUm93cyA9ICQocm93cyk7XG5cdFxuXHRcdHJldHVybiAkKCBbXS5jb25jYXQoXG5cdFx0XHRqcVJvd3MuZmlsdGVyKCBzZWxlY3RvciApLnRvQXJyYXkoKSxcblx0XHRcdGpxUm93cy5maW5kKCBzZWxlY3RvciApLnRvQXJyYXkoKVxuXHRcdCkgKTtcblx0fSApO1xuXHRcblx0XG5cdC8vIGpRdWVyeSBmdW5jdGlvbnMgdG8gb3BlcmF0ZSBvbiB0aGUgdGFibGVzXG5cdCQuZWFjaCggWyAnb24nLCAnb25lJywgJ29mZicgXSwgZnVuY3Rpb24gKGksIGtleSkge1xuXHRcdF9hcGlfcmVnaXN0ZXIoIGtleSsnKCknLCBmdW5jdGlvbiAoIC8qIGV2ZW50LCBoYW5kbGVyICovICkge1xuXHRcdFx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXHRcblx0XHRcdC8vIEFkZCB0aGUgYGR0YCBuYW1lc3BhY2UgYXV0b21hdGljYWxseSBpZiBpdCBpc24ndCBhbHJlYWR5IHByZXNlbnRcblx0XHRcdGFyZ3NbMF0gPSAkLm1hcCggYXJnc1swXS5zcGxpdCggL1xccy8gKSwgZnVuY3Rpb24gKCBlICkge1xuXHRcdFx0XHRyZXR1cm4gISBlLm1hdGNoKC9cXC5kdFxcYi8pID9cblx0XHRcdFx0XHRlKycuZHQnIDpcblx0XHRcdFx0XHRlO1xuXHRcdFx0XHR9ICkuam9pbiggJyAnICk7XG5cdFxuXHRcdFx0dmFyIGluc3QgPSAkKCB0aGlzLnRhYmxlcygpLm5vZGVzKCkgKTtcblx0XHRcdGluc3Rba2V5XS5hcHBseSggaW5zdCwgYXJncyApO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSApO1xuXHR9ICk7XG5cdFxuXHRcblx0X2FwaV9yZWdpc3RlciggJ2NsZWFyKCknLCBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0XHRfZm5DbGVhclRhYmxlKCBzZXR0aW5ncyApO1xuXHRcdH0gKTtcblx0fSApO1xuXHRcblx0XG5cdF9hcGlfcmVnaXN0ZXIoICdzZXR0aW5ncygpJywgZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBuZXcgX0FwaSggdGhpcy5jb250ZXh0LCB0aGlzLmNvbnRleHQgKTtcblx0fSApO1xuXHRcblx0XG5cdF9hcGlfcmVnaXN0ZXIoICdpbml0KCknLCBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGN0eCA9IHRoaXMuY29udGV4dDtcblx0XHRyZXR1cm4gY3R4Lmxlbmd0aCA/IGN0eFswXS5vSW5pdCA6IG51bGw7XG5cdH0gKTtcblx0XG5cdFxuXHRfYXBpX3JlZ2lzdGVyKCAnZGF0YSgpJywgZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIHNldHRpbmdzICkge1xuXHRcdFx0cmV0dXJuIF9wbHVjayggc2V0dGluZ3MuYW9EYXRhLCAnX2FEYXRhJyApO1xuXHRcdH0gKS5mbGF0dGVuKCk7XG5cdH0gKTtcblx0XG5cdFxuXHRfYXBpX3JlZ2lzdGVyKCAnZGVzdHJveSgpJywgZnVuY3Rpb24gKCByZW1vdmUgKSB7XG5cdFx0cmVtb3ZlID0gcmVtb3ZlIHx8IGZhbHNlO1xuXHRcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBzZXR0aW5ncyApIHtcblx0XHRcdHZhciBvcmlnICAgICAgPSBzZXR0aW5ncy5uVGFibGVXcmFwcGVyLnBhcmVudE5vZGU7XG5cdFx0XHR2YXIgY2xhc3NlcyAgID0gc2V0dGluZ3Mub0NsYXNzZXM7XG5cdFx0XHR2YXIgdGFibGUgICAgID0gc2V0dGluZ3MublRhYmxlO1xuXHRcdFx0dmFyIHRib2R5ICAgICA9IHNldHRpbmdzLm5UQm9keTtcblx0XHRcdHZhciB0aGVhZCAgICAgPSBzZXR0aW5ncy5uVEhlYWQ7XG5cdFx0XHR2YXIgdGZvb3QgICAgID0gc2V0dGluZ3MublRGb290O1xuXHRcdFx0dmFyIGpxVGFibGUgICA9ICQodGFibGUpO1xuXHRcdFx0dmFyIGpxVGJvZHkgICA9ICQodGJvZHkpO1xuXHRcdFx0dmFyIGpxV3JhcHBlciA9ICQoc2V0dGluZ3MublRhYmxlV3JhcHBlcik7XG5cdFx0XHR2YXIgcm93cyAgICAgID0gJC5tYXAoIHNldHRpbmdzLmFvRGF0YSwgZnVuY3Rpb24gKHIpIHsgcmV0dXJuIHIublRyOyB9ICk7XG5cdFx0XHR2YXIgaSwgaWVuO1xuXHRcblx0XHRcdC8vIEZsYWcgdG8gbm90ZSB0aGF0IHRoZSB0YWJsZSBpcyBjdXJyZW50bHkgYmVpbmcgZGVzdHJveWVkIC0gbm8gYWN0aW9uXG5cdFx0XHQvLyBzaG91bGQgYmUgdGFrZW5cblx0XHRcdHNldHRpbmdzLmJEZXN0cm95aW5nID0gdHJ1ZTtcblx0XG5cdFx0XHQvLyBGaXJlIG9mZiB0aGUgZGVzdHJveSBjYWxsYmFja3MgZm9yIHBsdWctaW5zIGV0Y1xuXHRcdFx0X2ZuQ2FsbGJhY2tGaXJlKCBzZXR0aW5ncywgXCJhb0Rlc3Ryb3lDYWxsYmFja1wiLCBcImRlc3Ryb3lcIiwgW3NldHRpbmdzXSApO1xuXHRcblx0XHRcdC8vIElmIG5vdCBiZWluZyByZW1vdmVkIGZyb20gdGhlIGRvY3VtZW50LCBtYWtlIGFsbCBjb2x1bW5zIHZpc2libGVcblx0XHRcdGlmICggISByZW1vdmUgKSB7XG5cdFx0XHRcdG5ldyBfQXBpKCBzZXR0aW5ncyApLmNvbHVtbnMoKS52aXNpYmxlKCB0cnVlICk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gQmxpdHogYWxsIGBEVGAgbmFtZXNwYWNlZCBldmVudHMgKHRoZXNlIGFyZSBpbnRlcm5hbCBldmVudHMsIHRoZVxuXHRcdFx0Ly8gbG93ZXJjYXNlLCBgZHRgIGV2ZW50cyBhcmUgdXNlciBzdWJzY3JpYmVkIGFuZCB0aGV5IGFyZSByZXNwb25zaWJsZVxuXHRcdFx0Ly8gZm9yIHJlbW92aW5nIHRoZW1cblx0XHRcdGpxV3JhcHBlci5vZmYoJy5EVCcpLmZpbmQoJzpub3QodGJvZHkgKiknKS5vZmYoJy5EVCcpO1xuXHRcdFx0JCh3aW5kb3cpLm9mZignLkRULScrc2V0dGluZ3Muc0luc3RhbmNlKTtcblx0XG5cdFx0XHQvLyBXaGVuIHNjcm9sbGluZyB3ZSBoYWQgdG8gYnJlYWsgdGhlIHRhYmxlIHVwIC0gcmVzdG9yZSBpdFxuXHRcdFx0aWYgKCB0YWJsZSAhPSB0aGVhZC5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRqcVRhYmxlLmNoaWxkcmVuKCd0aGVhZCcpLmRldGFjaCgpO1xuXHRcdFx0XHRqcVRhYmxlLmFwcGVuZCggdGhlYWQgKTtcblx0XHRcdH1cblx0XG5cdFx0XHRpZiAoIHRmb290ICYmIHRhYmxlICE9IHRmb290LnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdGpxVGFibGUuY2hpbGRyZW4oJ3Rmb290JykuZGV0YWNoKCk7XG5cdFx0XHRcdGpxVGFibGUuYXBwZW5kKCB0Zm9vdCApO1xuXHRcdFx0fVxuXHRcblx0XHRcdHNldHRpbmdzLmFhU29ydGluZyA9IFtdO1xuXHRcdFx0c2V0dGluZ3MuYWFTb3J0aW5nRml4ZWQgPSBbXTtcblx0XHRcdF9mblNvcnRpbmdDbGFzc2VzKCBzZXR0aW5ncyApO1xuXHRcblx0XHRcdCQoIHJvd3MgKS5yZW1vdmVDbGFzcyggc2V0dGluZ3MuYXNTdHJpcGVDbGFzc2VzLmpvaW4oJyAnKSApO1xuXHRcblx0XHRcdCQoJ3RoLCB0ZCcsIHRoZWFkKS5yZW1vdmVDbGFzcyggY2xhc3Nlcy5zU29ydGFibGUrJyAnK1xuXHRcdFx0XHRjbGFzc2VzLnNTb3J0YWJsZUFzYysnICcrY2xhc3Nlcy5zU29ydGFibGVEZXNjKycgJytjbGFzc2VzLnNTb3J0YWJsZU5vbmVcblx0XHRcdCk7XG5cdFxuXHRcdFx0Ly8gQWRkIHRoZSBUUiBlbGVtZW50cyBiYWNrIGludG8gdGhlIHRhYmxlIGluIHRoZWlyIG9yaWdpbmFsIG9yZGVyXG5cdFx0XHRqcVRib2R5LmNoaWxkcmVuKCkuZGV0YWNoKCk7XG5cdFx0XHRqcVRib2R5LmFwcGVuZCggcm93cyApO1xuXHRcblx0XHRcdC8vIFJlbW92ZSB0aGUgRGF0YVRhYmxlcyBnZW5lcmF0ZWQgbm9kZXMsIGV2ZW50cyBhbmQgY2xhc3Nlc1xuXHRcdFx0dmFyIHJlbW92ZWRNZXRob2QgPSByZW1vdmUgPyAncmVtb3ZlJyA6ICdkZXRhY2gnO1xuXHRcdFx0anFUYWJsZVsgcmVtb3ZlZE1ldGhvZCBdKCk7XG5cdFx0XHRqcVdyYXBwZXJbIHJlbW92ZWRNZXRob2QgXSgpO1xuXHRcblx0XHRcdC8vIElmIHdlIG5lZWQgdG8gcmVhdHRhY2ggdGhlIHRhYmxlIHRvIHRoZSBkb2N1bWVudFxuXHRcdFx0aWYgKCAhIHJlbW92ZSAmJiBvcmlnICkge1xuXHRcdFx0XHQvLyBpbnNlcnRCZWZvcmUgYWN0cyBsaWtlIGFwcGVuZENoaWxkIGlmICFhcmdbMV1cblx0XHRcdFx0b3JpZy5pbnNlcnRCZWZvcmUoIHRhYmxlLCBzZXR0aW5ncy5uVGFibGVSZWluc2VydEJlZm9yZSApO1xuXHRcblx0XHRcdFx0Ly8gUmVzdG9yZSB0aGUgd2lkdGggb2YgdGhlIG9yaWdpbmFsIHRhYmxlIC0gd2FzIHJlYWQgZnJvbSB0aGUgc3R5bGUgcHJvcGVydHksXG5cdFx0XHRcdC8vIHNvIHdlIGNhbiByZXN0b3JlIGRpcmVjdGx5IHRvIHRoYXRcblx0XHRcdFx0anFUYWJsZVxuXHRcdFx0XHRcdC5jc3MoICd3aWR0aCcsIHNldHRpbmdzLnNEZXN0cm95V2lkdGggKVxuXHRcdFx0XHRcdC5yZW1vdmVDbGFzcyggY2xhc3Nlcy5zVGFibGUgKTtcblx0XG5cdFx0XHRcdC8vIElmIHRoZSB3ZXJlIG9yaWdpbmFsbHkgc3RyaXBlIGNsYXNzZXMgLSB0aGVuIHdlIGFkZCB0aGVtIGJhY2sgaGVyZS5cblx0XHRcdFx0Ly8gTm90ZSB0aGlzIGlzIG5vdCBmb29sIHByb29mIChmb3IgZXhhbXBsZSBpZiBub3QgYWxsIHJvd3MgaGFkIHN0cmlwZVxuXHRcdFx0XHQvLyBjbGFzc2VzIC0gYnV0IGl0J3MgYSBnb29kIGVmZm9ydCB3aXRob3V0IGdldHRpbmcgY2FycmllZCBhd2F5XG5cdFx0XHRcdGllbiA9IHNldHRpbmdzLmFzRGVzdHJveVN0cmlwZXMubGVuZ3RoO1xuXHRcblx0XHRcdFx0aWYgKCBpZW4gKSB7XG5cdFx0XHRcdFx0anFUYm9keS5jaGlsZHJlbigpLmVhY2goIGZ1bmN0aW9uIChpKSB7XG5cdFx0XHRcdFx0XHQkKHRoaXMpLmFkZENsYXNzKCBzZXR0aW5ncy5hc0Rlc3Ryb3lTdHJpcGVzW2kgJSBpZW5dICk7XG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFxuXHRcdFx0LyogUmVtb3ZlIHRoZSBzZXR0aW5ncyBvYmplY3QgZnJvbSB0aGUgc2V0dGluZ3MgYXJyYXkgKi9cblx0XHRcdHZhciBpZHggPSAkLmluQXJyYXkoIHNldHRpbmdzLCBEYXRhVGFibGUuc2V0dGluZ3MgKTtcblx0XHRcdGlmICggaWR4ICE9PSAtMSApIHtcblx0XHRcdFx0RGF0YVRhYmxlLnNldHRpbmdzLnNwbGljZSggaWR4LCAxICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9ICk7XG5cdFxuXHRcblx0Ly8gQWRkIHRoZSBgZXZlcnkoKWAgbWV0aG9kIGZvciByb3dzLCBjb2x1bW5zIGFuZCBjZWxscyBpbiBhIGNvbXBhY3QgZm9ybVxuXHQkLmVhY2goIFsgJ2NvbHVtbicsICdyb3cnLCAnY2VsbCcgXSwgZnVuY3Rpb24gKCBpLCB0eXBlICkge1xuXHRcdF9hcGlfcmVnaXN0ZXIoIHR5cGUrJ3MoKS5ldmVyeSgpJywgZnVuY3Rpb24gKCBmbiApIHtcblx0XHRcdHZhciBvcHRzID0gdGhpcy5zZWxlY3Rvci5vcHRzO1xuXHRcdFx0dmFyIGFwaSA9IHRoaXM7XG5cdFxuXHRcdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoIHR5cGUsIGZ1bmN0aW9uICggc2V0dGluZ3MsIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQgKSB7XG5cdFx0XHRcdC8vIFJvd3MgYW5kIGNvbHVtbnM6XG5cdFx0XHRcdC8vICBhcmcxIC0gaW5kZXhcblx0XHRcdFx0Ly8gIGFyZzIgLSB0YWJsZSBjb3VudGVyXG5cdFx0XHRcdC8vICBhcmczIC0gbG9vcCBjb3VudGVyXG5cdFx0XHRcdC8vICBhcmc0IC0gdW5kZWZpbmVkXG5cdFx0XHRcdC8vIENlbGxzOlxuXHRcdFx0XHQvLyAgYXJnMSAtIHJvdyBpbmRleFxuXHRcdFx0XHQvLyAgYXJnMiAtIGNvbHVtbiBpbmRleFxuXHRcdFx0XHQvLyAgYXJnMyAtIHRhYmxlIGNvdW50ZXJcblx0XHRcdFx0Ly8gIGFyZzQgLSBsb29wIGNvdW50ZXJcblx0XHRcdFx0Zm4uY2FsbChcblx0XHRcdFx0XHRhcGlbIHR5cGUgXShcblx0XHRcdFx0XHRcdGFyZzEsXG5cdFx0XHRcdFx0XHR0eXBlPT09J2NlbGwnID8gYXJnMiA6IG9wdHMsXG5cdFx0XHRcdFx0XHR0eXBlPT09J2NlbGwnID8gb3B0cyA6IHVuZGVmaW5lZFxuXHRcdFx0XHRcdCksXG5cdFx0XHRcdFx0YXJnMSwgYXJnMiwgYXJnMywgYXJnNFxuXHRcdFx0XHQpO1xuXHRcdFx0fSApO1xuXHRcdH0gKTtcblx0fSApO1xuXHRcblx0XG5cdC8vIGkxOG4gbWV0aG9kIGZvciBleHRlbnNpb25zIHRvIGJlIGFibGUgdG8gdXNlIHRoZSBsYW5ndWFnZSBvYmplY3QgZnJvbSB0aGVcblx0Ly8gRGF0YVRhYmxlXG5cdF9hcGlfcmVnaXN0ZXIoICdpMThuKCknLCBmdW5jdGlvbiAoIHRva2VuLCBkZWYsIHBsdXJhbCApIHtcblx0XHR2YXIgY3R4ID0gdGhpcy5jb250ZXh0WzBdO1xuXHRcdHZhciByZXNvbHZlZCA9IF9mbkdldE9iamVjdERhdGFGbiggdG9rZW4gKSggY3R4Lm9MYW5ndWFnZSApO1xuXHRcblx0XHRpZiAoIHJlc29sdmVkID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRyZXNvbHZlZCA9IGRlZjtcblx0XHR9XG5cdFxuXHRcdGlmICggcGx1cmFsICE9PSB1bmRlZmluZWQgJiYgJC5pc1BsYWluT2JqZWN0KCByZXNvbHZlZCApICkge1xuXHRcdFx0cmVzb2x2ZWQgPSByZXNvbHZlZFsgcGx1cmFsIF0gIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdHJlc29sdmVkWyBwbHVyYWwgXSA6XG5cdFx0XHRcdHJlc29sdmVkLl87XG5cdFx0fVxuXHRcblx0XHRyZXR1cm4gcmVzb2x2ZWQucmVwbGFjZSggJyVkJywgcGx1cmFsICk7IC8vIG5iOiBwbHVyYWwgbWlnaHQgYmUgdW5kZWZpbmVkLFxuXHR9ICk7XG5cdC8qKlxuXHQgKiBWZXJzaW9uIHN0cmluZyBmb3IgcGx1Zy1pbnMgdG8gY2hlY2sgY29tcGF0aWJpbGl0eS4gQWxsb3dlZCBmb3JtYXQgaXNcblx0ICogYGEuYi5jLWRgIHdoZXJlOiBhOmludCwgYjppbnQsIGM6aW50LCBkOnN0cmluZyhkZXZ8YmV0YXxhbHBoYSkuIGBkYCBpcyB1c2VkXG5cdCAqIG9ubHkgZm9yIG5vbi1yZWxlYXNlIGJ1aWxkcy4gU2VlIGh0dHA6Ly9zZW12ZXIub3JnLyBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0ICogIEBtZW1iZXJcblx0ICogIEB0eXBlIHN0cmluZ1xuXHQgKiAgQGRlZmF1bHQgVmVyc2lvbiBudW1iZXJcblx0ICovXG5cdERhdGFUYWJsZS52ZXJzaW9uID0gXCIxLjEwLjIxXCI7XG5cblx0LyoqXG5cdCAqIFByaXZhdGUgZGF0YSBzdG9yZSwgY29udGFpbmluZyBhbGwgb2YgdGhlIHNldHRpbmdzIG9iamVjdHMgdGhhdCBhcmVcblx0ICogY3JlYXRlZCBmb3IgdGhlIHRhYmxlcyBvbiBhIGdpdmVuIHBhZ2UuXG5cdCAqXG5cdCAqIE5vdGUgdGhhdCB0aGUgYERhdGFUYWJsZS5zZXR0aW5nc2Agb2JqZWN0IGlzIGFsaWFzZWQgdG9cblx0ICogYGpRdWVyeS5mbi5kYXRhVGFibGVFeHRgIHRocm91Z2ggd2hpY2ggaXQgbWF5IGJlIGFjY2Vzc2VkIGFuZFxuXHQgKiBtYW5pcHVsYXRlZCwgb3IgYGpRdWVyeS5mbi5kYXRhVGFibGUuc2V0dGluZ3NgLlxuXHQgKiAgQG1lbWJlclxuXHQgKiAgQHR5cGUgYXJyYXlcblx0ICogIEBkZWZhdWx0IFtdXG5cdCAqICBAcHJpdmF0ZVxuXHQgKi9cblx0RGF0YVRhYmxlLnNldHRpbmdzID0gW107XG5cblx0LyoqXG5cdCAqIE9iamVjdCBtb2RlbHMgY29udGFpbmVyLCBmb3IgdGhlIHZhcmlvdXMgbW9kZWxzIHRoYXQgRGF0YVRhYmxlcyBoYXNcblx0ICogYXZhaWxhYmxlIHRvIGl0LiBUaGVzZSBtb2RlbHMgZGVmaW5lIHRoZSBvYmplY3RzIHRoYXQgYXJlIHVzZWQgdG8gaG9sZFxuXHQgKiB0aGUgYWN0aXZlIHN0YXRlIGFuZCBjb25maWd1cmF0aW9uIG9mIHRoZSB0YWJsZS5cblx0ICogIEBuYW1lc3BhY2Vcblx0ICovXG5cdERhdGFUYWJsZS5tb2RlbHMgPSB7fTtcblx0XG5cdFxuXHRcblx0LyoqXG5cdCAqIFRlbXBsYXRlIG9iamVjdCBmb3IgdGhlIHdheSBpbiB3aGljaCBEYXRhVGFibGVzIGhvbGRzIGluZm9ybWF0aW9uIGFib3V0XG5cdCAqIHNlYXJjaCBpbmZvcm1hdGlvbiBmb3IgdGhlIGdsb2JhbCBmaWx0ZXIgYW5kIGluZGl2aWR1YWwgY29sdW1uIGZpbHRlcnMuXG5cdCAqICBAbmFtZXNwYWNlXG5cdCAqL1xuXHREYXRhVGFibGUubW9kZWxzLm9TZWFyY2ggPSB7XG5cdFx0LyoqXG5cdFx0ICogRmxhZyB0byBpbmRpY2F0ZSBpZiB0aGUgZmlsdGVyaW5nIHNob3VsZCBiZSBjYXNlIGluc2Vuc2l0aXZlIG9yIG5vdFxuXHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0ICogIEBkZWZhdWx0IHRydWVcblx0XHQgKi9cblx0XHRcImJDYXNlSW5zZW5zaXRpdmVcIjogdHJ1ZSxcblx0XG5cdFx0LyoqXG5cdFx0ICogQXBwbGllZCBzZWFyY2ggdGVybVxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgPGk+RW1wdHkgc3RyaW5nPC9pPlxuXHRcdCAqL1xuXHRcdFwic1NlYXJjaFwiOiBcIlwiLFxuXHRcblx0XHQvKipcblx0XHQgKiBGbGFnIHRvIGluZGljYXRlIGlmIHRoZSBzZWFyY2ggdGVybSBzaG91bGQgYmUgaW50ZXJwcmV0ZWQgYXMgYVxuXHRcdCAqIHJlZ3VsYXIgZXhwcmVzc2lvbiAodHJ1ZSkgb3Igbm90IChmYWxzZSkgYW5kIHRoZXJlZm9yZSBhbmQgc3BlY2lhbFxuXHRcdCAqIHJlZ2V4IGNoYXJhY3RlcnMgZXNjYXBlZC5cblx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdCAqICBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqL1xuXHRcdFwiYlJlZ2V4XCI6IGZhbHNlLFxuXHRcblx0XHQvKipcblx0XHQgKiBGbGFnIHRvIGluZGljYXRlIGlmIERhdGFUYWJsZXMgaXMgdG8gdXNlIGl0cyBzbWFydCBmaWx0ZXJpbmcgb3Igbm90LlxuXHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0ICogIEBkZWZhdWx0IHRydWVcblx0XHQgKi9cblx0XHRcImJTbWFydFwiOiB0cnVlXG5cdH07XG5cdFxuXHRcblx0XG5cdFxuXHQvKipcblx0ICogVGVtcGxhdGUgb2JqZWN0IGZvciB0aGUgd2F5IGluIHdoaWNoIERhdGFUYWJsZXMgaG9sZHMgaW5mb3JtYXRpb24gYWJvdXRcblx0ICogZWFjaCBpbmRpdmlkdWFsIHJvdy4gVGhpcyBpcyB0aGUgb2JqZWN0IGZvcm1hdCB1c2VkIGZvciB0aGUgc2V0dGluZ3Ncblx0ICogYW9EYXRhIGFycmF5LlxuXHQgKiAgQG5hbWVzcGFjZVxuXHQgKi9cblx0RGF0YVRhYmxlLm1vZGVscy5vUm93ID0ge1xuXHRcdC8qKlxuXHRcdCAqIFRSIGVsZW1lbnQgZm9yIHRoZSByb3dcblx0XHQgKiAgQHR5cGUgbm9kZVxuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0XCJuVHJcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogQXJyYXkgb2YgVEQgZWxlbWVudHMgZm9yIGVhY2ggcm93LiBUaGlzIGlzIG51bGwgdW50aWwgdGhlIHJvdyBoYXMgYmVlblxuXHRcdCAqIGNyZWF0ZWQuXG5cdFx0ICogIEB0eXBlIGFycmF5IG5vZGVzXG5cdFx0ICogIEBkZWZhdWx0IFtdXG5cdFx0ICovXG5cdFx0XCJhbkNlbGxzXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIERhdGEgb2JqZWN0IGZyb20gdGhlIG9yaWdpbmFsIGRhdGEgc291cmNlIGZvciB0aGUgcm93LiBUaGlzIGlzIGVpdGhlclxuXHRcdCAqIGFuIGFycmF5IGlmIHVzaW5nIHRoZSB0cmFkaXRpb25hbCBmb3JtIG9mIERhdGFUYWJsZXMsIG9yIGFuIG9iamVjdCBpZlxuXHRcdCAqIHVzaW5nIG1EYXRhIG9wdGlvbnMuIFRoZSBleGFjdCB0eXBlIHdpbGwgZGVwZW5kIG9uIHRoZSBwYXNzZWQgaW5cblx0XHQgKiBkYXRhIGZyb20gdGhlIGRhdGEgc291cmNlLCBvciB3aWxsIGJlIGFuIGFycmF5IGlmIHVzaW5nIERPTSBhIGRhdGFcblx0XHQgKiBzb3VyY2UuXG5cdFx0ICogIEB0eXBlIGFycmF5fG9iamVjdFxuXHRcdCAqICBAZGVmYXVsdCBbXVxuXHRcdCAqL1xuXHRcdFwiX2FEYXRhXCI6IFtdLFxuXHRcblx0XHQvKipcblx0XHQgKiBTb3J0aW5nIGRhdGEgY2FjaGUgLSB0aGlzIGFycmF5IGlzIG9zdGVuc2libHkgdGhlIHNhbWUgbGVuZ3RoIGFzIHRoZVxuXHRcdCAqIG51bWJlciBvZiBjb2x1bW5zIChhbHRob3VnaCBlYWNoIGluZGV4IGlzIGdlbmVyYXRlZCBvbmx5IGFzIGl0IGlzXG5cdFx0ICogbmVlZGVkKSwgYW5kIGhvbGRzIHRoZSBkYXRhIHRoYXQgaXMgdXNlZCBmb3Igc29ydGluZyBlYWNoIGNvbHVtbiBpbiB0aGVcblx0XHQgKiByb3cuIFdlIGRvIHRoaXMgY2FjaGUgZ2VuZXJhdGlvbiBhdCB0aGUgc3RhcnQgb2YgdGhlIHNvcnQgaW4gb3JkZXIgdGhhdFxuXHRcdCAqIHRoZSBmb3JtYXR0aW5nIG9mIHRoZSBzb3J0IGRhdGEgbmVlZCBiZSBkb25lIG9ubHkgb25jZSBmb3IgZWFjaCBjZWxsXG5cdFx0ICogcGVyIHNvcnQuIFRoaXMgYXJyYXkgc2hvdWxkIG5vdCBiZSByZWFkIGZyb20gb3Igd3JpdHRlbiB0byBieSBhbnl0aGluZ1xuXHRcdCAqIG90aGVyIHRoYW4gdGhlIG1hc3RlciBzb3J0aW5nIG1ldGhvZHMuXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0XHRcIl9hU29ydERhdGFcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogUGVyIGNlbGwgZmlsdGVyaW5nIGRhdGEgY2FjaGUuIEFzIHBlciB0aGUgc29ydCBkYXRhIGNhY2hlLCB1c2VkIHRvXG5cdFx0ICogaW5jcmVhc2UgdGhlIHBlcmZvcm1hbmNlIG9mIHRoZSBmaWx0ZXJpbmcgaW4gRGF0YVRhYmxlc1xuXHRcdCAqICBAdHlwZSBhcnJheVxuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0XCJfYUZpbHRlckRhdGFcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogRmlsdGVyaW5nIGRhdGEgY2FjaGUuIFRoaXMgaXMgdGhlIHNhbWUgYXMgdGhlIGNlbGwgZmlsdGVyaW5nIGNhY2hlLCBidXRcblx0XHQgKiBpbiB0aGlzIGNhc2UgYSBzdHJpbmcgcmF0aGVyIHRoYW4gYW4gYXJyYXkuIFRoaXMgaXMgZWFzaWx5IGNvbXB1dGVkIHdpdGhcblx0XHQgKiBhIGpvaW4gb24gYF9hRmlsdGVyRGF0YWAsIGJ1dCBpcyBwcm92aWRlZCBhcyBhIGNhY2hlIHNvIHRoZSBqb2luIGlzbid0XG5cdFx0ICogbmVlZGVkIG9uIGV2ZXJ5IHNlYXJjaCAobWVtb3J5IHRyYWRlZCBmb3IgcGVyZm9ybWFuY2UpXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0XHRcIl9zRmlsdGVyUm93XCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIENhY2hlIG9mIHRoZSBjbGFzcyBuYW1lIHRoYXQgRGF0YVRhYmxlcyBoYXMgYXBwbGllZCB0byB0aGUgcm93LCBzbyB3ZVxuXHRcdCAqIGNhbiBxdWlja2x5IGxvb2sgYXQgdGhpcyB2YXJpYWJsZSByYXRoZXIgdGhhbiBuZWVkaW5nIHRvIGRvIGEgRE9NIGNoZWNrXG5cdFx0ICogb24gY2xhc3NOYW1lIGZvciB0aGUgblRyIHByb3BlcnR5LlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgPGk+RW1wdHkgc3RyaW5nPC9pPlxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdFwiX3NSb3dTdHJpcGVcIjogXCJcIixcblx0XG5cdFx0LyoqXG5cdFx0ICogRGVub3RlIGlmIHRoZSBvcmlnaW5hbCBkYXRhIHNvdXJjZSB3YXMgZnJvbSB0aGUgRE9NLCBvciB0aGUgZGF0YSBzb3VyY2Vcblx0XHQgKiBvYmplY3QuIFRoaXMgaXMgdXNlZCBmb3IgaW52YWxpZGF0aW5nIGRhdGEsIHNvIERhdGFUYWJsZXMgY2FuXG5cdFx0ICogYXV0b21hdGljYWxseSByZWFkIGRhdGEgZnJvbSB0aGUgb3JpZ2luYWwgc291cmNlLCB1bmxlc3MgdW5pbnN0cnVjdGVkXG5cdFx0ICogb3RoZXJ3aXNlLlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdFwic3JjXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEluZGV4IGluIHRoZSBhb0RhdGEgYXJyYXkuIFRoaXMgc2F2ZXMgYW4gaW5kZXhPZiBsb29rdXAgd2hlbiB3ZSBoYXZlIHRoZVxuXHRcdCAqIG9iamVjdCwgYnV0IHdhbnQgdG8ga25vdyB0aGUgaW5kZXhcblx0XHQgKiAgQHR5cGUgaW50ZWdlclxuXHRcdCAqICBAZGVmYXVsdCAtMVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdFwiaWR4XCI6IC0xXG5cdH07XG5cdFxuXHRcblx0LyoqXG5cdCAqIFRlbXBsYXRlIG9iamVjdCBmb3IgdGhlIGNvbHVtbiBpbmZvcm1hdGlvbiBvYmplY3QgaW4gRGF0YVRhYmxlcy4gVGhpcyBvYmplY3Rcblx0ICogaXMgaGVsZCBpbiB0aGUgc2V0dGluZ3MgYW9Db2x1bW5zIGFycmF5IGFuZCBjb250YWlucyBhbGwgdGhlIGluZm9ybWF0aW9uIHRoYXRcblx0ICogRGF0YVRhYmxlcyBuZWVkcyBhYm91dCBlYWNoIGluZGl2aWR1YWwgY29sdW1uLlxuXHQgKlxuXHQgKiBOb3RlIHRoYXQgdGhpcyBvYmplY3QgaXMgcmVsYXRlZCB0byB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbn1cblx0ICogYnV0IHRoaXMgb25lIGlzIHRoZSBpbnRlcm5hbCBkYXRhIHN0b3JlIGZvciBEYXRhVGFibGVzJ3MgY2FjaGUgb2YgY29sdW1ucy5cblx0ICogSXQgc2hvdWxkIE5PVCBiZSBtYW5pcHVsYXRlZCBvdXRzaWRlIG9mIERhdGFUYWJsZXMuIEFueSBjb25maWd1cmF0aW9uIHNob3VsZFxuXHQgKiBiZSBkb25lIHRocm91Z2ggdGhlIGluaXRpYWxpc2F0aW9uIG9wdGlvbnMuXG5cdCAqICBAbmFtZXNwYWNlXG5cdCAqL1xuXHREYXRhVGFibGUubW9kZWxzLm9Db2x1bW4gPSB7XG5cdFx0LyoqXG5cdFx0ICogQ29sdW1uIGluZGV4LiBUaGlzIGNvdWxkIGJlIHdvcmtlZCBvdXQgb24tdGhlLWZseSB3aXRoICQuaW5BcnJheSwgYnV0IGl0XG5cdFx0ICogaXMgZmFzdGVyIHRvIGp1c3QgaG9sZCBpdCBhcyBhIHZhcmlhYmxlXG5cdFx0ICogIEB0eXBlIGludGVnZXJcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdFwiaWR4XCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEEgbGlzdCBvZiB0aGUgY29sdW1ucyB0aGF0IHNvcnRpbmcgc2hvdWxkIG9jY3VyIG9uIHdoZW4gdGhpcyBjb2x1bW5cblx0XHQgKiBpcyBzb3J0ZWQuIFRoYXQgdGhpcyBwcm9wZXJ0eSBpcyBhbiBhcnJheSBhbGxvd3MgbXVsdGktY29sdW1uIHNvcnRpbmdcblx0XHQgKiB0byBiZSBkZWZpbmVkIGZvciBhIGNvbHVtbiAoZm9yIGV4YW1wbGUgZmlyc3QgbmFtZSAvIGxhc3QgbmFtZSBjb2x1bW5zXG5cdFx0ICogd291bGQgYmVuZWZpdCBmcm9tIHRoaXMpLiBUaGUgdmFsdWVzIGFyZSBpbnRlZ2VycyBwb2ludGluZyB0byB0aGVcblx0XHQgKiBjb2x1bW5zIHRvIGJlIHNvcnRlZCBvbiAodHlwaWNhbGx5IGl0IHdpbGwgYmUgYSBzaW5nbGUgaW50ZWdlciBwb2ludGluZ1xuXHRcdCAqIGF0IGl0c2VsZiwgYnV0IHRoYXQgZG9lc24ndCBuZWVkIHRvIGJlIHRoZSBjYXNlKS5cblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKi9cblx0XHRcImFEYXRhU29ydFwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBEZWZpbmUgdGhlIHNvcnRpbmcgZGlyZWN0aW9ucyB0aGF0IGFyZSBhcHBsaWVkIHRvIHRoZSBjb2x1bW4sIGluIHNlcXVlbmNlXG5cdFx0ICogYXMgdGhlIGNvbHVtbiBpcyByZXBlYXRlZGx5IHNvcnRlZCB1cG9uIC0gaS5lLiB0aGUgZmlyc3QgdmFsdWUgaXMgdXNlZFxuXHRcdCAqIGFzIHRoZSBzb3J0aW5nIGRpcmVjdGlvbiB3aGVuIHRoZSBjb2x1bW4gaWYgZmlyc3Qgc29ydGVkIChjbGlja2VkIG9uKS5cblx0XHQgKiBTb3J0IGl0IGFnYWluIChjbGljayBhZ2FpbikgYW5kIGl0IHdpbGwgbW92ZSBvbiB0byB0aGUgbmV4dCBpbmRleC5cblx0XHQgKiBSZXBlYXQgdW50aWwgbG9vcC5cblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKi9cblx0XHRcImFzU29ydGluZ1wiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBGbGFnIHRvIGluZGljYXRlIGlmIHRoZSBjb2x1bW4gaXMgc2VhcmNoYWJsZSwgYW5kIHRodXMgc2hvdWxkIGJlIGluY2x1ZGVkXG5cdFx0ICogaW4gdGhlIGZpbHRlcmluZyBvciBub3QuXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKi9cblx0XHRcImJTZWFyY2hhYmxlXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEZsYWcgdG8gaW5kaWNhdGUgaWYgdGhlIGNvbHVtbiBpcyBzb3J0YWJsZSBvciBub3QuXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKi9cblx0XHRcImJTb3J0YWJsZVwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBGbGFnIHRvIGluZGljYXRlIGlmIHRoZSBjb2x1bW4gaXMgY3VycmVudGx5IHZpc2libGUgaW4gdGhlIHRhYmxlIG9yIG5vdFxuXHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0ICovXG5cdFx0XCJiVmlzaWJsZVwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBTdG9yZSBmb3IgbWFudWFsIHR5cGUgYXNzaWdubWVudCB1c2luZyB0aGUgYGNvbHVtbi50eXBlYCBvcHRpb24uIFRoaXNcblx0XHQgKiBpcyBoZWxkIGluIHN0b3JlIHNvIHdlIGNhbiBtYW5pcHVsYXRlIHRoZSBjb2x1bW4ncyBgc1R5cGVgIHByb3BlcnR5LlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdFwiX3NNYW51YWxUeXBlXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEZsYWcgdG8gaW5kaWNhdGUgaWYgSFRNTDUgZGF0YSBhdHRyaWJ1dGVzIHNob3VsZCBiZSB1c2VkIGFzIHRoZSBkYXRhXG5cdFx0ICogc291cmNlIGZvciBmaWx0ZXJpbmcgb3Igc29ydGluZy4gVHJ1ZSBpcyBlaXRoZXIgYXJlLlxuXHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0ICogIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0XCJfYkF0dHJTcmNcIjogZmFsc2UsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIERldmVsb3BlciBkZWZpbmFibGUgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2hlbmV2ZXIgYSBjZWxsIGlzIGNyZWF0ZWQgKEFqYXggc291cmNlLFxuXHRcdCAqIGV0Yykgb3IgcHJvY2Vzc2VkIGZvciBpbnB1dCAoRE9NIHNvdXJjZSkuIFRoaXMgY2FuIGJlIHVzZWQgYXMgYSBjb21wbGltZW50IHRvIG1SZW5kZXJcblx0XHQgKiBhbGxvd2luZyB5b3UgdG8gbW9kaWZ5IHRoZSBET00gZWxlbWVudCAoYWRkIGJhY2tncm91bmQgY29sb3VyIGZvciBleGFtcGxlKSB3aGVuIHRoZVxuXHRcdCAqIGVsZW1lbnQgaXMgYXZhaWxhYmxlLlxuXHRcdCAqICBAdHlwZSBmdW5jdGlvblxuXHRcdCAqICBAcGFyYW0ge2VsZW1lbnR9IG5UZCBUaGUgVEQgbm9kZSB0aGF0IGhhcyBiZWVuIGNyZWF0ZWRcblx0XHQgKiAgQHBhcmFtIHsqfSBzRGF0YSBUaGUgRGF0YSBmb3IgdGhlIGNlbGxcblx0XHQgKiAgQHBhcmFtIHthcnJheXxvYmplY3R9IG9EYXRhIFRoZSBkYXRhIGZvciB0aGUgd2hvbGUgcm93XG5cdFx0ICogIEBwYXJhbSB7aW50fSBpUm93IFRoZSByb3cgaW5kZXggZm9yIHRoZSBhb0RhdGEgZGF0YSBzdG9yZVxuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0XCJmbkNyZWF0ZWRDZWxsXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEZ1bmN0aW9uIHRvIGdldCBkYXRhIGZyb20gYSBjZWxsIGluIGEgY29sdW1uLiBZb3Ugc2hvdWxkIDxiPm5ldmVyPC9iPlxuXHRcdCAqIGFjY2VzcyBkYXRhIGRpcmVjdGx5IHRocm91Z2ggX2FEYXRhIGludGVybmFsbHkgaW4gRGF0YVRhYmxlcyAtIGFsd2F5cyB1c2Vcblx0XHQgKiB0aGUgbWV0aG9kIGF0dGFjaGVkIHRvIHRoaXMgcHJvcGVydHkuIEl0IGFsbG93cyBtRGF0YSB0byBmdW5jdGlvbiBhc1xuXHRcdCAqIHJlcXVpcmVkLiBUaGlzIGZ1bmN0aW9uIGlzIGF1dG9tYXRpY2FsbHkgYXNzaWduZWQgYnkgdGhlIGNvbHVtblxuXHRcdCAqIGluaXRpYWxpc2F0aW9uIG1ldGhvZFxuXHRcdCAqICBAdHlwZSBmdW5jdGlvblxuXHRcdCAqICBAcGFyYW0ge2FycmF5fG9iamVjdH0gb0RhdGEgVGhlIGRhdGEgYXJyYXkvb2JqZWN0IGZvciB0aGUgYXJyYXlcblx0XHQgKiAgICAoaS5lLiBhb0RhdGFbXS5fYURhdGEpXG5cdFx0ICogIEBwYXJhbSB7c3RyaW5nfSBzU3BlY2lmaWMgVGhlIHNwZWNpZmljIGRhdGEgdHlwZSB5b3Ugd2FudCB0byBnZXQgLVxuXHRcdCAqICAgICdkaXNwbGF5JywgJ3R5cGUnICdmaWx0ZXInICdzb3J0J1xuXHRcdCAqICBAcmV0dXJucyB7Kn0gVGhlIGRhdGEgZm9yIHRoZSBjZWxsIGZyb20gdGhlIGdpdmVuIHJvdydzIGRhdGFcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdFwiZm5HZXREYXRhXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEZ1bmN0aW9uIHRvIHNldCBkYXRhIGZvciBhIGNlbGwgaW4gdGhlIGNvbHVtbi4gWW91IHNob3VsZCA8Yj5uZXZlcjwvYj5cblx0XHQgKiBzZXQgdGhlIGRhdGEgZGlyZWN0bHkgdG8gX2FEYXRhIGludGVybmFsbHkgaW4gRGF0YVRhYmxlcyAtIGFsd2F5cyB1c2Vcblx0XHQgKiB0aGlzIG1ldGhvZC4gSXQgYWxsb3dzIG1EYXRhIHRvIGZ1bmN0aW9uIGFzIHJlcXVpcmVkLiBUaGlzIGZ1bmN0aW9uXG5cdFx0ICogaXMgYXV0b21hdGljYWxseSBhc3NpZ25lZCBieSB0aGUgY29sdW1uIGluaXRpYWxpc2F0aW9uIG1ldGhvZFxuXHRcdCAqICBAdHlwZSBmdW5jdGlvblxuXHRcdCAqICBAcGFyYW0ge2FycmF5fG9iamVjdH0gb0RhdGEgVGhlIGRhdGEgYXJyYXkvb2JqZWN0IGZvciB0aGUgYXJyYXlcblx0XHQgKiAgICAoaS5lLiBhb0RhdGFbXS5fYURhdGEpXG5cdFx0ICogIEBwYXJhbSB7Kn0gc1ZhbHVlIFZhbHVlIHRvIHNldFxuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0XCJmblNldERhdGFcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogUHJvcGVydHkgdG8gcmVhZCB0aGUgdmFsdWUgZm9yIHRoZSBjZWxscyBpbiB0aGUgY29sdW1uIGZyb20gdGhlIGRhdGFcblx0XHQgKiBzb3VyY2UgYXJyYXkgLyBvYmplY3QuIElmIG51bGwsIHRoZW4gdGhlIGRlZmF1bHQgY29udGVudCBpcyB1c2VkLCBpZiBhXG5cdFx0ICogZnVuY3Rpb24gaXMgZ2l2ZW4gdGhlbiB0aGUgcmV0dXJuIGZyb20gdGhlIGZ1bmN0aW9uIGlzIHVzZWQuXG5cdFx0ICogIEB0eXBlIGZ1bmN0aW9ufGludHxzdHJpbmd8bnVsbFxuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0XCJtRGF0YVwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBQYXJ0bmVyIHByb3BlcnR5IHRvIG1EYXRhIHdoaWNoIGlzIHVzZWQgKG9ubHkgd2hlbiBkZWZpbmVkKSB0byBnZXRcblx0XHQgKiB0aGUgZGF0YSAtIGkuZS4gaXQgaXMgYmFzaWNhbGx5IHRoZSBzYW1lIGFzIG1EYXRhLCBidXQgd2l0aG91dCB0aGVcblx0XHQgKiAnc2V0JyBvcHRpb24sIGFuZCBhbHNvIHRoZSBkYXRhIGZlZCB0byBpdCBpcyB0aGUgcmVzdWx0IGZyb20gbURhdGEuXG5cdFx0ICogVGhpcyBpcyB0aGUgcmVuZGVyaW5nIG1ldGhvZCB0byBtYXRjaCB0aGUgZGF0YSBtZXRob2Qgb2YgbURhdGEuXG5cdFx0ICogIEB0eXBlIGZ1bmN0aW9ufGludHxzdHJpbmd8bnVsbFxuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0XCJtUmVuZGVyXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFVuaXF1ZSBoZWFkZXIgVEgvVEQgZWxlbWVudCBmb3IgdGhpcyBjb2x1bW4gLSB0aGlzIGlzIHdoYXQgdGhlIHNvcnRpbmdcblx0XHQgKiBsaXN0ZW5lciBpcyBhdHRhY2hlZCB0byAoaWYgc29ydGluZyBpcyBlbmFibGVkLilcblx0XHQgKiAgQHR5cGUgbm9kZVxuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0XCJuVGhcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogVW5pcXVlIGZvb3RlciBUSC9URCBlbGVtZW50IGZvciB0aGlzIGNvbHVtbiAoaWYgdGhlcmUgaXMgb25lKS4gTm90IHVzZWRcblx0XHQgKiBpbiBEYXRhVGFibGVzIGFzIHN1Y2gsIGJ1dCBjYW4gYmUgdXNlZCBmb3IgcGx1Zy1pbnMgdG8gcmVmZXJlbmNlIHRoZVxuXHRcdCAqIGZvb3RlciBmb3IgZWFjaCBjb2x1bW4uXG5cdFx0ICogIEB0eXBlIG5vZGVcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdFwiblRmXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBjbGFzcyB0byBhcHBseSB0byBhbGwgVEQgZWxlbWVudHMgaW4gdGhlIHRhYmxlJ3MgVEJPRFkgZm9yIHRoZSBjb2x1bW5cblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHRcInNDbGFzc1wiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBXaGVuIERhdGFUYWJsZXMgY2FsY3VsYXRlcyB0aGUgY29sdW1uIHdpZHRocyB0byBhc3NpZ24gdG8gZWFjaCBjb2x1bW4sXG5cdFx0ICogaXQgZmluZHMgdGhlIGxvbmdlc3Qgc3RyaW5nIGluIGVhY2ggY29sdW1uIGFuZCB0aGVuIGNvbnN0cnVjdHMgYVxuXHRcdCAqIHRlbXBvcmFyeSB0YWJsZSBhbmQgcmVhZHMgdGhlIHdpZHRocyBmcm9tIHRoYXQuIFRoZSBwcm9ibGVtIHdpdGggdGhpc1xuXHRcdCAqIGlzIHRoYXQgXCJtbW1cIiBpcyBtdWNoIHdpZGVyIHRoZW4gXCJpaWlpXCIsIGJ1dCB0aGUgbGF0dGVyIGlzIGEgbG9uZ2VyXG5cdFx0ICogc3RyaW5nIC0gdGh1cyB0aGUgY2FsY3VsYXRpb24gY2FuIGdvIHdyb25nIChkb2luZyBpdCBwcm9wZXJseSBhbmQgcHV0dGluZ1xuXHRcdCAqIGl0IGludG8gYW4gRE9NIG9iamVjdCBhbmQgbWVhc3VyaW5nIHRoYXQgaXMgaG9ycmlibHkoISkgc2xvdykuIFRodXMgYXNcblx0XHQgKiBhIFwid29yayBhcm91bmRcIiB3ZSBwcm92aWRlIHRoaXMgb3B0aW9uLiBJdCB3aWxsIGFwcGVuZCBpdHMgdmFsdWUgdG8gdGhlXG5cdFx0ICogdGV4dCB0aGF0IGlzIGZvdW5kIHRvIGJlIHRoZSBsb25nZXN0IHN0cmluZyBmb3IgdGhlIGNvbHVtbiAtIGkuZS4gcGFkZGluZy5cblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICovXG5cdFx0XCJzQ29udGVudFBhZGRpbmdcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogQWxsb3dzIGEgZGVmYXVsdCB2YWx1ZSB0byBiZSBnaXZlbiBmb3IgYSBjb2x1bW4ncyBkYXRhLCBhbmQgd2lsbCBiZSB1c2VkXG5cdFx0ICogd2hlbmV2ZXIgYSBudWxsIGRhdGEgc291cmNlIGlzIGVuY291bnRlcmVkICh0aGlzIGNhbiBiZSBiZWNhdXNlIG1EYXRhXG5cdFx0ICogaXMgc2V0IHRvIG51bGwsIG9yIGJlY2F1c2UgdGhlIGRhdGEgc291cmNlIGl0c2VsZiBpcyBudWxsKS5cblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHRcInNEZWZhdWx0Q29udGVudFwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBOYW1lIGZvciB0aGUgY29sdW1uLCBhbGxvd2luZyByZWZlcmVuY2UgdG8gdGhlIGNvbHVtbiBieSBuYW1lIGFzIHdlbGwgYXNcblx0XHQgKiBieSBpbmRleCAobmVlZHMgYSBsb29rdXAgdG8gd29yayBieSBuYW1lKS5cblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICovXG5cdFx0XCJzTmFtZVwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBDdXN0b20gc29ydGluZyBkYXRhIHR5cGUgLSBkZWZpbmVzIHdoaWNoIG9mIHRoZSBhdmFpbGFibGUgcGx1Zy1pbnMgaW5cblx0XHQgKiBhZm5Tb3J0RGF0YSB0aGUgY3VzdG9tIHNvcnRpbmcgd2lsbCB1c2UgLSBpZiBhbnkgaXMgZGVmaW5lZC5cblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICogIEBkZWZhdWx0IHN0ZFxuXHRcdCAqL1xuXHRcdFwic1NvcnREYXRhVHlwZVwiOiAnc3RkJyxcblx0XG5cdFx0LyoqXG5cdFx0ICogQ2xhc3MgdG8gYmUgYXBwbGllZCB0byB0aGUgaGVhZGVyIGVsZW1lbnQgd2hlbiBzb3J0aW5nIG9uIHRoaXMgY29sdW1uXG5cdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0XCJzU29ydGluZ0NsYXNzXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIENsYXNzIHRvIGJlIGFwcGxpZWQgdG8gdGhlIGhlYWRlciBlbGVtZW50IHdoZW4gc29ydGluZyBvbiB0aGlzIGNvbHVtbiAtXG5cdFx0ICogd2hlbiBqUXVlcnkgVUkgdGhlbWluZyBpcyB1c2VkLlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdFwic1NvcnRpbmdDbGFzc0pVSVwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBUaXRsZSBvZiB0aGUgY29sdW1uIC0gd2hhdCBpcyBzZWVuIGluIHRoZSBUSCBlbGVtZW50IChuVGgpLlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKi9cblx0XHRcInNUaXRsZVwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBDb2x1bW4gc29ydGluZyBhbmQgZmlsdGVyaW5nIHR5cGVcblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHRcInNUeXBlXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFdpZHRoIG9mIHRoZSBjb2x1bW5cblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHRcInNXaWR0aFwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBXaWR0aCBvZiB0aGUgY29sdW1uIHdoZW4gaXQgd2FzIGZpcnN0IFwiZW5jb3VudGVyZWRcIlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdFwic1dpZHRoT3JpZ1wiOiBudWxsXG5cdH07XG5cdFxuXHRcblx0Lypcblx0ICogRGV2ZWxvcGVyIG5vdGU6IFRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBvYmplY3QgYmVsb3cgYXJlIGdpdmVuIGluIEh1bmdhcmlhblxuXHQgKiBub3RhdGlvbiwgdGhhdCB3YXMgdXNlZCBhcyB0aGUgaW50ZXJmYWNlIGZvciBEYXRhVGFibGVzIHByaW9yIHRvIHYxLjEwLCBob3dldmVyXG5cdCAqIGZyb20gdjEuMTAgb253YXJkcyB0aGUgcHJpbWFyeSBpbnRlcmZhY2UgaXMgY2FtZWwgY2FzZS4gSW4gb3JkZXIgdG8gYXZvaWRcblx0ICogYnJlYWtpbmcgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgdXR0ZXJseSB3aXRoIHRoaXMgY2hhbmdlLCB0aGUgSHVuZ2FyaWFuXG5cdCAqIHZlcnNpb24gaXMgc3RpbGwsIGludGVybmFsbHkgdGhlIHByaW1hcnkgaW50ZXJmYWNlLCBidXQgaXMgaXMgbm90IGRvY3VtZW50ZWRcblx0ICogLSBoZW5jZSB0aGUgQG5hbWUgdGFncyBpbiBlYWNoIGRvYyBjb21tZW50LiBUaGlzIGFsbG93cyBhIEphdmFzY3JpcHQgZnVuY3Rpb25cblx0ICogdG8gY3JlYXRlIGEgbWFwIGZyb20gSHVuZ2FyaWFuIG5vdGF0aW9uIHRvIGNhbWVsIGNhc2UgKGdvaW5nIHRoZSBvdGhlciBkaXJlY3Rpb25cblx0ICogd291bGQgcmVxdWlyZSBlYWNoIHByb3BlcnR5IHRvIGJlIGxpc3RlZCwgd2hpY2ggd291bGQgYXQgYXJvdW5kIDNLIHRvIHRoZSBzaXplXG5cdCAqIG9mIERhdGFUYWJsZXMsIHdoaWxlIHRoaXMgbWV0aG9kIGlzIGFib3V0IGEgMC41SyBoaXQuXG5cdCAqXG5cdCAqIFVsdGltYXRlbHkgdGhpcyBkb2VzIHBhdmUgdGhlIHdheSBmb3IgSHVuZ2FyaWFuIG5vdGF0aW9uIHRvIGJlIGRyb3BwZWRcblx0ICogY29tcGxldGVseSwgYnV0IHRoYXQgaXMgYSBtYXNzaXZlIGFtb3VudCBvZiB3b3JrIGFuZCB3aWxsIGJyZWFrIGN1cnJlbnRcblx0ICogaW5zdGFsbHMgKHRoZXJlZm9yZSBpcyBvbi1ob2xkIHVudGlsIHYyKS5cblx0ICovXG5cdFxuXHQvKipcblx0ICogSW5pdGlhbGlzYXRpb24gb3B0aW9ucyB0aGF0IGNhbiBiZSBnaXZlbiB0byBEYXRhVGFibGVzIGF0IGluaXRpYWxpc2F0aW9uXG5cdCAqIHRpbWUuXG5cdCAqICBAbmFtZXNwYWNlXG5cdCAqL1xuXHREYXRhVGFibGUuZGVmYXVsdHMgPSB7XG5cdFx0LyoqXG5cdFx0ICogQW4gYXJyYXkgb2YgZGF0YSB0byB1c2UgZm9yIHRoZSB0YWJsZSwgcGFzc2VkIGluIGF0IGluaXRpYWxpc2F0aW9uIHdoaWNoXG5cdFx0ICogd2lsbCBiZSB1c2VkIGluIHByZWZlcmVuY2UgdG8gYW55IGRhdGEgd2hpY2ggaXMgYWxyZWFkeSBpbiB0aGUgRE9NLiBUaGlzIGlzXG5cdFx0ICogcGFydGljdWxhcmx5IHVzZWZ1bCBmb3IgY29uc3RydWN0aW5nIHRhYmxlcyBwdXJlbHkgaW4gSmF2YXNjcmlwdCwgZm9yXG5cdFx0ICogZXhhbXBsZSB3aXRoIGEgY3VzdG9tIEFqYXggY2FsbC5cblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBPcHRpb25cblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmRhdGFcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIFVzaW5nIGEgMkQgYXJyYXkgZGF0YSBzb3VyY2Vcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24gKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJkYXRhXCI6IFtcblx0XHQgKiAgICAgICAgICBbJ1RyaWRlbnQnLCAnSW50ZXJuZXQgRXhwbG9yZXIgNC4wJywgJ1dpbiA5NSsnLCA0LCAnWCddLFxuXHRcdCAqICAgICAgICAgIFsnVHJpZGVudCcsICdJbnRlcm5ldCBFeHBsb3JlciA1LjAnLCAnV2luIDk1KycsIDUsICdDJ10sXG5cdFx0ICogICAgICAgIF0sXG5cdFx0ICogICAgICAgIFwiY29sdW1uc1wiOiBbXG5cdFx0ICogICAgICAgICAgeyBcInRpdGxlXCI6IFwiRW5naW5lXCIgfSxcblx0XHQgKiAgICAgICAgICB7IFwidGl0bGVcIjogXCJCcm93c2VyXCIgfSxcblx0XHQgKiAgICAgICAgICB7IFwidGl0bGVcIjogXCJQbGF0Zm9ybVwiIH0sXG5cdFx0ICogICAgICAgICAgeyBcInRpdGxlXCI6IFwiVmVyc2lvblwiIH0sXG5cdFx0ICogICAgICAgICAgeyBcInRpdGxlXCI6IFwiR3JhZGVcIiB9XG5cdFx0ICogICAgICAgIF1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBVc2luZyBhbiBhcnJheSBvZiBvYmplY3RzIGFzIGEgZGF0YSBzb3VyY2UgKGBkYXRhYClcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24gKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJkYXRhXCI6IFtcblx0XHQgKiAgICAgICAgICB7XG5cdFx0ICogICAgICAgICAgICBcImVuZ2luZVwiOiAgIFwiVHJpZGVudFwiLFxuXHRcdCAqICAgICAgICAgICAgXCJicm93c2VyXCI6ICBcIkludGVybmV0IEV4cGxvcmVyIDQuMFwiLFxuXHRcdCAqICAgICAgICAgICAgXCJwbGF0Zm9ybVwiOiBcIldpbiA5NStcIixcblx0XHQgKiAgICAgICAgICAgIFwidmVyc2lvblwiOiAgNCxcblx0XHQgKiAgICAgICAgICAgIFwiZ3JhZGVcIjogICAgXCJYXCJcblx0XHQgKiAgICAgICAgICB9LFxuXHRcdCAqICAgICAgICAgIHtcblx0XHQgKiAgICAgICAgICAgIFwiZW5naW5lXCI6ICAgXCJUcmlkZW50XCIsXG5cdFx0ICogICAgICAgICAgICBcImJyb3dzZXJcIjogIFwiSW50ZXJuZXQgRXhwbG9yZXIgNS4wXCIsXG5cdFx0ICogICAgICAgICAgICBcInBsYXRmb3JtXCI6IFwiV2luIDk1K1wiLFxuXHRcdCAqICAgICAgICAgICAgXCJ2ZXJzaW9uXCI6ICA1LFxuXHRcdCAqICAgICAgICAgICAgXCJncmFkZVwiOiAgICBcIkNcIlxuXHRcdCAqICAgICAgICAgIH1cblx0XHQgKiAgICAgICAgXSxcblx0XHQgKiAgICAgICAgXCJjb2x1bW5zXCI6IFtcblx0XHQgKiAgICAgICAgICB7IFwidGl0bGVcIjogXCJFbmdpbmVcIiwgICBcImRhdGFcIjogXCJlbmdpbmVcIiB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJ0aXRsZVwiOiBcIkJyb3dzZXJcIiwgIFwiZGF0YVwiOiBcImJyb3dzZXJcIiB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJ0aXRsZVwiOiBcIlBsYXRmb3JtXCIsIFwiZGF0YVwiOiBcInBsYXRmb3JtXCIgfSxcblx0XHQgKiAgICAgICAgICB7IFwidGl0bGVcIjogXCJWZXJzaW9uXCIsICBcImRhdGFcIjogXCJ2ZXJzaW9uXCIgfSxcblx0XHQgKiAgICAgICAgICB7IFwidGl0bGVcIjogXCJHcmFkZVwiLCAgICBcImRhdGFcIjogXCJncmFkZVwiIH1cblx0XHQgKiAgICAgICAgXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcImFhRGF0YVwiOiBudWxsLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogSWYgb3JkZXJpbmcgaXMgZW5hYmxlZCwgdGhlbiBEYXRhVGFibGVzIHdpbGwgcGVyZm9ybSBhIGZpcnN0IHBhc3Mgc29ydCBvblxuXHRcdCAqIGluaXRpYWxpc2F0aW9uLiBZb3UgY2FuIGRlZmluZSB3aGljaCBjb2x1bW4ocykgdGhlIHNvcnQgaXMgcGVyZm9ybWVkXG5cdFx0ICogdXBvbiwgYW5kIHRoZSBzb3J0aW5nIGRpcmVjdGlvbiwgd2l0aCB0aGlzIHZhcmlhYmxlLiBUaGUgYHNvcnRpbmdgIGFycmF5XG5cdFx0ICogc2hvdWxkIGNvbnRhaW4gYW4gYXJyYXkgZm9yIGVhY2ggY29sdW1uIHRvIGJlIHNvcnRlZCBpbml0aWFsbHkgY29udGFpbmluZ1xuXHRcdCAqIHRoZSBjb2x1bW4ncyBpbmRleCBhbmQgYSBkaXJlY3Rpb24gc3RyaW5nICgnYXNjJyBvciAnZGVzYycpLlxuXHRcdCAqICBAdHlwZSBhcnJheVxuXHRcdCAqICBAZGVmYXVsdCBbWzAsJ2FzYyddXVxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBPcHRpb25cblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLm9yZGVyXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBTb3J0IGJ5IDNyZCBjb2x1bW4gZmlyc3QsIGFuZCB0aGVuIDR0aCBjb2x1bW5cblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcIm9yZGVyXCI6IFtbMiwnYXNjJ10sIFszLCdkZXNjJ11dXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqXG5cdFx0ICogICAgLy8gTm8gaW5pdGlhbCBzb3J0aW5nXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJvcmRlclwiOiBbXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcImFhU29ydGluZ1wiOiBbWzAsJ2FzYyddXSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgcGFyYW1ldGVyIGlzIGJhc2ljYWxseSBpZGVudGljYWwgdG8gdGhlIGBzb3J0aW5nYCBwYXJhbWV0ZXIsIGJ1dFxuXHRcdCAqIGNhbm5vdCBiZSBvdmVycmlkZGVuIGJ5IHVzZXIgaW50ZXJhY3Rpb24gd2l0aCB0aGUgdGFibGUuIFdoYXQgdGhpcyBtZWFuc1xuXHRcdCAqIGlzIHRoYXQgeW91IGNvdWxkIGhhdmUgYSBjb2x1bW4gKHZpc2libGUgb3IgaGlkZGVuKSB3aGljaCB0aGUgc29ydGluZ1xuXHRcdCAqIHdpbGwgYWx3YXlzIGJlIGZvcmNlZCBvbiBmaXJzdCAtIGFueSBzb3J0aW5nIGFmdGVyIHRoYXQgKGZyb20gdGhlIHVzZXIpXG5cdFx0ICogd2lsbCB0aGVuIGJlIHBlcmZvcm1lZCBhcyByZXF1aXJlZC4gVGhpcyBjYW4gYmUgdXNlZnVsIGZvciBncm91cGluZyByb3dzXG5cdFx0ICogdG9nZXRoZXIuXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgT3B0aW9uXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5vcmRlckZpeGVkXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcIm9yZGVyRml4ZWRcIjogW1swLCdhc2MnXV1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9IClcblx0XHQgKi9cblx0XHRcImFhU29ydGluZ0ZpeGVkXCI6IFtdLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogRGF0YVRhYmxlcyBjYW4gYmUgaW5zdHJ1Y3RlZCB0byBsb2FkIGRhdGEgdG8gZGlzcGxheSBpbiB0aGUgdGFibGUgZnJvbSBhXG5cdFx0ICogQWpheCBzb3VyY2UuIFRoaXMgb3B0aW9uIGRlZmluZXMgaG93IHRoYXQgQWpheCBjYWxsIGlzIG1hZGUgYW5kIHdoZXJlIHRvLlxuXHRcdCAqXG5cdFx0ICogVGhlIGBhamF4YCBwcm9wZXJ0eSBoYXMgdGhyZWUgZGlmZmVyZW50IG1vZGVzIG9mIG9wZXJhdGlvbiwgZGVwZW5kaW5nIG9uXG5cdFx0ICogaG93IGl0IGlzIGRlZmluZWQuIFRoZXNlIGFyZTpcblx0XHQgKlxuXHRcdCAqICogYHN0cmluZ2AgLSBTZXQgdGhlIFVSTCBmcm9tIHdoZXJlIHRoZSBkYXRhIHNob3VsZCBiZSBsb2FkZWQgZnJvbS5cblx0XHQgKiAqIGBvYmplY3RgIC0gRGVmaW5lIHByb3BlcnRpZXMgZm9yIGBqUXVlcnkuYWpheGAuXG5cdFx0ICogKiBgZnVuY3Rpb25gIC0gQ3VzdG9tIGRhdGEgZ2V0IGZ1bmN0aW9uXG5cdFx0ICpcblx0XHQgKiBgc3RyaW5nYFxuXHRcdCAqIC0tLS0tLS0tXG5cdFx0ICpcblx0XHQgKiBBcyBhIHN0cmluZywgdGhlIGBhamF4YCBwcm9wZXJ0eSBzaW1wbHkgZGVmaW5lcyB0aGUgVVJMIGZyb20gd2hpY2hcblx0XHQgKiBEYXRhVGFibGVzIHdpbGwgbG9hZCBkYXRhLlxuXHRcdCAqXG5cdFx0ICogYG9iamVjdGBcblx0XHQgKiAtLS0tLS0tLVxuXHRcdCAqXG5cdFx0ICogQXMgYW4gb2JqZWN0LCB0aGUgcGFyYW1ldGVycyBpbiB0aGUgb2JqZWN0IGFyZSBwYXNzZWQgdG9cblx0XHQgKiBbalF1ZXJ5LmFqYXhdKGh0dHA6Ly9hcGkuanF1ZXJ5LmNvbS9qUXVlcnkuYWpheC8pIGFsbG93aW5nIGZpbmUgY29udHJvbFxuXHRcdCAqIG9mIHRoZSBBamF4IHJlcXVlc3QuIERhdGFUYWJsZXMgaGFzIGEgbnVtYmVyIG9mIGRlZmF1bHQgcGFyYW1ldGVycyB3aGljaFxuXHRcdCAqIHlvdSBjYW4gb3ZlcnJpZGUgdXNpbmcgdGhpcyBvcHRpb24uIFBsZWFzZSByZWZlciB0byB0aGUgalF1ZXJ5XG5cdFx0ICogZG9jdW1lbnRhdGlvbiBmb3IgYSBmdWxsIGRlc2NyaXB0aW9uIG9mIHRoZSBvcHRpb25zIGF2YWlsYWJsZSwgYWx0aG91Z2hcblx0XHQgKiB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnMgcHJvdmlkZSBhZGRpdGlvbmFsIG9wdGlvbnMgaW4gRGF0YVRhYmxlcyBvclxuXHRcdCAqIHJlcXVpcmUgc3BlY2lhbCBjb25zaWRlcmF0aW9uOlxuXHRcdCAqXG5cdFx0ICogKiBgZGF0YWAgLSBBcyB3aXRoIGpRdWVyeSwgYGRhdGFgIGNhbiBiZSBwcm92aWRlZCBhcyBhbiBvYmplY3QsIGJ1dCBpdFxuXHRcdCAqICAgY2FuIGFsc28gYmUgdXNlZCBhcyBhIGZ1bmN0aW9uIHRvIG1hbmlwdWxhdGUgdGhlIGRhdGEgRGF0YVRhYmxlcyBzZW5kc1xuXHRcdCAqICAgdG8gdGhlIHNlcnZlci4gVGhlIGZ1bmN0aW9uIHRha2VzIGEgc2luZ2xlIHBhcmFtZXRlciwgYW4gb2JqZWN0IG9mXG5cdFx0ICogICBwYXJhbWV0ZXJzIHdpdGggdGhlIHZhbHVlcyB0aGF0IERhdGFUYWJsZXMgaGFzIHJlYWRpZWQgZm9yIHNlbmRpbmcuIEFuXG5cdFx0ICogICBvYmplY3QgbWF5IGJlIHJldHVybmVkIHdoaWNoIHdpbGwgYmUgbWVyZ2VkIGludG8gdGhlIERhdGFUYWJsZXNcblx0XHQgKiAgIGRlZmF1bHRzLCBvciB5b3UgY2FuIGFkZCB0aGUgaXRlbXMgdG8gdGhlIG9iamVjdCB0aGF0IHdhcyBwYXNzZWQgaW4gYW5kXG5cdFx0ICogICBub3QgcmV0dXJuIGFueXRoaW5nIGZyb20gdGhlIGZ1bmN0aW9uLiBUaGlzIHN1cGVyc2VkZXMgYGZuU2VydmVyUGFyYW1zYFxuXHRcdCAqICAgZnJvbSBEYXRhVGFibGVzIDEuOS0uXG5cdFx0ICpcblx0XHQgKiAqIGBkYXRhU3JjYCAtIEJ5IGRlZmF1bHQgRGF0YVRhYmxlcyB3aWxsIGxvb2sgZm9yIHRoZSBwcm9wZXJ0eSBgZGF0YWAgKG9yXG5cdFx0ICogICBgYWFEYXRhYCBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIERhdGFUYWJsZXMgMS45LSkgd2hlbiBvYnRhaW5pbmcgZGF0YVxuXHRcdCAqICAgZnJvbSBhbiBBamF4IHNvdXJjZSBvciBmb3Igc2VydmVyLXNpZGUgcHJvY2Vzc2luZyAtIHRoaXMgcGFyYW1ldGVyXG5cdFx0ICogICBhbGxvd3MgdGhhdCBwcm9wZXJ0eSB0byBiZSBjaGFuZ2VkLiBZb3UgY2FuIHVzZSBKYXZhc2NyaXB0IGRvdHRlZFxuXHRcdCAqICAgb2JqZWN0IG5vdGF0aW9uIHRvIGdldCBhIGRhdGEgc291cmNlIGZvciBtdWx0aXBsZSBsZXZlbHMgb2YgbmVzdGluZywgb3Jcblx0XHQgKiAgIGl0IG15IGJlIHVzZWQgYXMgYSBmdW5jdGlvbi4gQXMgYSBmdW5jdGlvbiBpdCB0YWtlcyBhIHNpbmdsZSBwYXJhbWV0ZXIsXG5cdFx0ICogICB0aGUgSlNPTiByZXR1cm5lZCBmcm9tIHRoZSBzZXJ2ZXIsIHdoaWNoIGNhbiBiZSBtYW5pcHVsYXRlZCBhc1xuXHRcdCAqICAgcmVxdWlyZWQsIHdpdGggdGhlIHJldHVybmVkIHZhbHVlIGJlaW5nIHRoYXQgdXNlZCBieSBEYXRhVGFibGVzIGFzIHRoZVxuXHRcdCAqICAgZGF0YSBzb3VyY2UgZm9yIHRoZSB0YWJsZS4gVGhpcyBzdXBlcnNlZGVzIGBzQWpheERhdGFQcm9wYCBmcm9tXG5cdFx0ICogICBEYXRhVGFibGVzIDEuOS0uXG5cdFx0ICpcblx0XHQgKiAqIGBzdWNjZXNzYCAtIFNob3VsZCBub3QgYmUgb3ZlcnJpZGRlbiBpdCBpcyB1c2VkIGludGVybmFsbHkgaW5cblx0XHQgKiAgIERhdGFUYWJsZXMuIFRvIG1hbmlwdWxhdGUgLyB0cmFuc2Zvcm0gdGhlIGRhdGEgcmV0dXJuZWQgYnkgdGhlIHNlcnZlclxuXHRcdCAqICAgdXNlIGBhamF4LmRhdGFTcmNgLCBvciB1c2UgYGFqYXhgIGFzIGEgZnVuY3Rpb24gKHNlZSBiZWxvdykuXG5cdFx0ICpcblx0XHQgKiBgZnVuY3Rpb25gXG5cdFx0ICogLS0tLS0tLS0tLVxuXHRcdCAqXG5cdFx0ICogQXMgYSBmdW5jdGlvbiwgbWFraW5nIHRoZSBBamF4IGNhbGwgaXMgbGVmdCB1cCB0byB5b3Vyc2VsZiBhbGxvd2luZ1xuXHRcdCAqIGNvbXBsZXRlIGNvbnRyb2wgb2YgdGhlIEFqYXggcmVxdWVzdC4gSW5kZWVkLCBpZiBkZXNpcmVkLCBhIG1ldGhvZCBvdGhlclxuXHRcdCAqIHRoYW4gQWpheCBjb3VsZCBiZSB1c2VkIHRvIG9idGFpbiB0aGUgcmVxdWlyZWQgZGF0YSwgc3VjaCBhcyBXZWIgc3RvcmFnZVxuXHRcdCAqIG9yIGFuIEFJUiBkYXRhYmFzZS5cblx0XHQgKlxuXHRcdCAqIFRoZSBmdW5jdGlvbiBpcyBnaXZlbiBmb3VyIHBhcmFtZXRlcnMgYW5kIG5vIHJldHVybiBpcyByZXF1aXJlZC4gVGhlXG5cdFx0ICogcGFyYW1ldGVycyBhcmU6XG5cdFx0ICpcblx0XHQgKiAxLiBfb2JqZWN0XyAtIERhdGEgdG8gc2VuZCB0byB0aGUgc2VydmVyXG5cdFx0ICogMi4gX2Z1bmN0aW9uXyAtIENhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgbXVzdCBiZSBleGVjdXRlZCB3aGVuIHRoZSByZXF1aXJlZFxuXHRcdCAqICAgIGRhdGEgaGFzIGJlZW4gb2J0YWluZWQuIFRoYXQgZGF0YSBzaG91bGQgYmUgcGFzc2VkIGludG8gdGhlIGNhbGxiYWNrXG5cdFx0ICogICAgYXMgdGhlIG9ubHkgcGFyYW1ldGVyXG5cdFx0ICogMy4gX29iamVjdF8gLSBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdCBmb3IgdGhlIHRhYmxlXG5cdFx0ICpcblx0XHQgKiBOb3RlIHRoYXQgdGhpcyBzdXBlcnNlZGVzIGBmblNlcnZlckRhdGFgIGZyb20gRGF0YVRhYmxlcyAxLjktLlxuXHRcdCAqXG5cdFx0ICogIEB0eXBlIHN0cmluZ3xvYmplY3R8ZnVuY3Rpb25cblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBPcHRpb25cblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmFqYXhcblx0XHQgKiAgQHNpbmNlIDEuMTAuMFxuXHRcdCAqXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiAgIC8vIEdldCBKU09OIGRhdGEgZnJvbSBhIGZpbGUgdmlhIEFqYXguXG5cdFx0ICogICAvLyBOb3RlIERhdGFUYWJsZXMgZXhwZWN0cyBkYXRhIGluIHRoZSBmb3JtIGB7IGRhdGE6IFsgLi4uZGF0YS4uLiBdIH1gIGJ5IGRlZmF1bHQpLlxuXHRcdCAqICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgXCJhamF4XCI6IFwiZGF0YS5qc29uXCJcblx0XHQgKiAgIH0gKTtcblx0XHQgKlxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogICAvLyBHZXQgSlNPTiBkYXRhIGZyb20gYSBmaWxlIHZpYSBBamF4LCB1c2luZyBgZGF0YVNyY2AgdG8gY2hhbmdlXG5cdFx0ICogICAvLyBgZGF0YWAgdG8gYHRhYmxlRGF0YWAgKGkuZS4gYHsgdGFibGVEYXRhOiBbIC4uLmRhdGEuLi4gXSB9YClcblx0XHQgKiAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgIFwiYWpheFwiOiB7XG5cdFx0ICogICAgICAgXCJ1cmxcIjogXCJkYXRhLmpzb25cIixcblx0XHQgKiAgICAgICBcImRhdGFTcmNcIjogXCJ0YWJsZURhdGFcIlxuXHRcdCAqICAgICB9XG5cdFx0ICogICB9ICk7XG5cdFx0ICpcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqICAgLy8gR2V0IEpTT04gZGF0YSBmcm9tIGEgZmlsZSB2aWEgQWpheCwgdXNpbmcgYGRhdGFTcmNgIHRvIHJlYWQgZGF0YVxuXHRcdCAqICAgLy8gZnJvbSBhIHBsYWluIGFycmF5IHJhdGhlciB0aGFuIGFuIGFycmF5IGluIGFuIG9iamVjdFxuXHRcdCAqICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgXCJhamF4XCI6IHtcblx0XHQgKiAgICAgICBcInVybFwiOiBcImRhdGEuanNvblwiLFxuXHRcdCAqICAgICAgIFwiZGF0YVNyY1wiOiBcIlwiXG5cdFx0ICogICAgIH1cblx0XHQgKiAgIH0gKTtcblx0XHQgKlxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogICAvLyBNYW5pcHVsYXRlIHRoZSBkYXRhIHJldHVybmVkIGZyb20gdGhlIHNlcnZlciAtIGFkZCBhIGxpbmsgdG8gZGF0YVxuXHRcdCAqICAgLy8gKG5vdGUgdGhpcyBjYW4sIHNob3VsZCwgYmUgZG9uZSB1c2luZyBgcmVuZGVyYCBmb3IgdGhlIGNvbHVtbiAtIHRoaXNcblx0XHQgKiAgIC8vIGlzIGp1c3QgYSBzaW1wbGUgZXhhbXBsZSBvZiBob3cgdGhlIGRhdGEgY2FuIGJlIG1hbmlwdWxhdGVkKS5cblx0XHQgKiAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgIFwiYWpheFwiOiB7XG5cdFx0ICogICAgICAgXCJ1cmxcIjogXCJkYXRhLmpzb25cIixcblx0XHQgKiAgICAgICBcImRhdGFTcmNcIjogZnVuY3Rpb24gKCBqc29uICkge1xuXHRcdCAqICAgICAgICAgZm9yICggdmFyIGk9MCwgaWVuPWpzb24ubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0ICogICAgICAgICAgIGpzb25baV1bMF0gPSAnPGEgaHJlZj1cIi9tZXNzYWdlLycranNvbltpXVswXSsnPlZpZXcgbWVzc2FnZTwvYT4nO1xuXHRcdCAqICAgICAgICAgfVxuXHRcdCAqICAgICAgICAgcmV0dXJuIGpzb247XG5cdFx0ICogICAgICAgfVxuXHRcdCAqICAgICB9XG5cdFx0ICogICB9ICk7XG5cdFx0ICpcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqICAgLy8gQWRkIGRhdGEgdG8gdGhlIHJlcXVlc3Rcblx0XHQgKiAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgIFwiYWpheFwiOiB7XG5cdFx0ICogICAgICAgXCJ1cmxcIjogXCJkYXRhLmpzb25cIixcblx0XHQgKiAgICAgICBcImRhdGFcIjogZnVuY3Rpb24gKCBkICkge1xuXHRcdCAqICAgICAgICAgcmV0dXJuIHtcblx0XHQgKiAgICAgICAgICAgXCJleHRyYV9zZWFyY2hcIjogJCgnI2V4dHJhJykudmFsKClcblx0XHQgKiAgICAgICAgIH07XG5cdFx0ICogICAgICAgfVxuXHRcdCAqICAgICB9XG5cdFx0ICogICB9ICk7XG5cdFx0ICpcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqICAgLy8gU2VuZCByZXF1ZXN0IGFzIFBPU1Rcblx0XHQgKiAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgIFwiYWpheFwiOiB7XG5cdFx0ICogICAgICAgXCJ1cmxcIjogXCJkYXRhLmpzb25cIixcblx0XHQgKiAgICAgICBcInR5cGVcIjogXCJQT1NUXCJcblx0XHQgKiAgICAgfVxuXHRcdCAqICAgfSApO1xuXHRcdCAqXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiAgIC8vIEdldCB0aGUgZGF0YSBmcm9tIGxvY2FsU3RvcmFnZSAoY291bGQgaW50ZXJmYWNlIHdpdGggYSBmb3JtIGZvclxuXHRcdCAqICAgLy8gYWRkaW5nLCBlZGl0aW5nIGFuZCByZW1vdmluZyByb3dzKS5cblx0XHQgKiAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgIFwiYWpheFwiOiBmdW5jdGlvbiAoZGF0YSwgY2FsbGJhY2ssIHNldHRpbmdzKSB7XG5cdFx0ICogICAgICAgY2FsbGJhY2soXG5cdFx0ICogICAgICAgICBKU09OLnBhcnNlKCBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnZGF0YVRhYmxlc0RhdGEnKSApXG5cdFx0ICogICAgICAgKTtcblx0XHQgKiAgICAgfVxuXHRcdCAqICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiYWpheFwiOiBudWxsLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhpcyBwYXJhbWV0ZXIgYWxsb3dzIHlvdSB0byByZWFkaWx5IHNwZWNpZnkgdGhlIGVudHJpZXMgaW4gdGhlIGxlbmd0aCBkcm9wXG5cdFx0ICogZG93biBtZW51IHRoYXQgRGF0YVRhYmxlcyBzaG93cyB3aGVuIHBhZ2luYXRpb24gaXMgZW5hYmxlZC4gSXQgY2FuIGJlXG5cdFx0ICogZWl0aGVyIGEgMUQgYXJyYXkgb2Ygb3B0aW9ucyB3aGljaCB3aWxsIGJlIHVzZWQgZm9yIGJvdGggdGhlIGRpc3BsYXllZFxuXHRcdCAqIG9wdGlvbiBhbmQgdGhlIHZhbHVlLCBvciBhIDJEIGFycmF5IHdoaWNoIHdpbGwgdXNlIHRoZSBhcnJheSBpbiB0aGUgZmlyc3Rcblx0XHQgKiBwb3NpdGlvbiBhcyB0aGUgdmFsdWUsIGFuZCB0aGUgYXJyYXkgaW4gdGhlIHNlY29uZCBwb3NpdGlvbiBhcyB0aGVcblx0XHQgKiBkaXNwbGF5ZWQgb3B0aW9ucyAodXNlZnVsIGZvciBsYW5ndWFnZSBzdHJpbmdzIHN1Y2ggYXMgJ0FsbCcpLlxuXHRcdCAqXG5cdFx0ICogTm90ZSB0aGF0IHRoZSBgcGFnZUxlbmd0aGAgcHJvcGVydHkgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IHNldCB0byB0aGVcblx0XHQgKiBmaXJzdCB2YWx1ZSBnaXZlbiBpbiB0aGlzIGFycmF5LCB1bmxlc3MgYHBhZ2VMZW5ndGhgIGlzIGFsc28gcHJvdmlkZWQuXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IFsgMTAsIDI1LCA1MCwgMTAwIF1cblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgT3B0aW9uXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sZW5ndGhNZW51XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImxlbmd0aE1lbnVcIjogW1sxMCwgMjUsIDUwLCAtMV0sIFsxMCwgMjUsIDUwLCBcIkFsbFwiXV1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJhTGVuZ3RoTWVudVwiOiBbIDEwLCAyNSwgNTAsIDEwMCBdLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIGBjb2x1bW5zYCBvcHRpb24gaW4gdGhlIGluaXRpYWxpc2F0aW9uIHBhcmFtZXRlciBhbGxvd3MgeW91IHRvIGRlZmluZVxuXHRcdCAqIGRldGFpbHMgYWJvdXQgdGhlIHdheSBpbmRpdmlkdWFsIGNvbHVtbnMgYmVoYXZlLiBGb3IgYSBmdWxsIGxpc3Qgb2Zcblx0XHQgKiBjb2x1bW4gb3B0aW9ucyB0aGF0IGNhbiBiZSBzZXQsIHBsZWFzZSBzZWVcblx0XHQgKiB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbn0uIE5vdGUgdGhhdCBpZiB5b3UgdXNlIGBjb2x1bW5zYCB0b1xuXHRcdCAqIGRlZmluZSB5b3VyIGNvbHVtbnMsIHlvdSBtdXN0IGhhdmUgYW4gZW50cnkgaW4gdGhlIGFycmF5IGZvciBldmVyeSBzaW5nbGVcblx0XHQgKiBjb2x1bW4gdGhhdCB5b3UgaGF2ZSBpbiB5b3VyIHRhYmxlICh0aGVzZSBjYW4gYmUgbnVsbCBpZiB5b3UgZG9uJ3Qgd2hpY2hcblx0XHQgKiB0byBzcGVjaWZ5IGFueSBvcHRpb25zKS5cblx0XHQgKiAgQG1lbWJlclxuXHRcdCAqXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW5cblx0XHQgKi9cblx0XHRcImFvQ29sdW1uc1wiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBWZXJ5IHNpbWlsYXIgdG8gYGNvbHVtbnNgLCBgY29sdW1uRGVmc2AgYWxsb3dzIHlvdSB0byB0YXJnZXQgYSBzcGVjaWZpY1xuXHRcdCAqIGNvbHVtbiwgbXVsdGlwbGUgY29sdW1ucywgb3IgYWxsIGNvbHVtbnMsIHVzaW5nIHRoZSBgdGFyZ2V0c2AgcHJvcGVydHkgb2Zcblx0XHQgKiBlYWNoIG9iamVjdCBpbiB0aGUgYXJyYXkuIFRoaXMgYWxsb3dzIGdyZWF0IGZsZXhpYmlsaXR5IHdoZW4gY3JlYXRpbmdcblx0XHQgKiB0YWJsZXMsIGFzIHRoZSBgY29sdW1uRGVmc2AgYXJyYXlzIGNhbiBiZSBvZiBhbnkgbGVuZ3RoLCB0YXJnZXRpbmcgdGhlXG5cdFx0ICogY29sdW1ucyB5b3Ugc3BlY2lmaWNhbGx5IHdhbnQuIGBjb2x1bW5EZWZzYCBtYXkgdXNlIGFueSBvZiB0aGUgY29sdW1uXG5cdFx0ICogb3B0aW9ucyBhdmFpbGFibGU6IHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1ufSwgYnV0IGl0IF9tdXN0X1xuXHRcdCAqIGhhdmUgYHRhcmdldHNgIGRlZmluZWQgaW4gZWFjaCBvYmplY3QgaW4gdGhlIGFycmF5LiBWYWx1ZXMgaW4gdGhlIGB0YXJnZXRzYFxuXHRcdCAqIGFycmF5IG1heSBiZTpcblx0XHQgKiAgIDx1bD5cblx0XHQgKiAgICAgPGxpPmEgc3RyaW5nIC0gY2xhc3MgbmFtZSB3aWxsIGJlIG1hdGNoZWQgb24gdGhlIFRIIGZvciB0aGUgY29sdW1uPC9saT5cblx0XHQgKiAgICAgPGxpPjAgb3IgYSBwb3NpdGl2ZSBpbnRlZ2VyIC0gY29sdW1uIGluZGV4IGNvdW50aW5nIGZyb20gdGhlIGxlZnQ8L2xpPlxuXHRcdCAqICAgICA8bGk+YSBuZWdhdGl2ZSBpbnRlZ2VyIC0gY29sdW1uIGluZGV4IGNvdW50aW5nIGZyb20gdGhlIHJpZ2h0PC9saT5cblx0XHQgKiAgICAgPGxpPnRoZSBzdHJpbmcgXCJfYWxsXCIgLSBhbGwgY29sdW1ucyAoaS5lLiBhc3NpZ24gYSBkZWZhdWx0KTwvbGk+XG5cdFx0ICogICA8L3VsPlxuXHRcdCAqICBAbWVtYmVyXG5cdFx0ICpcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbkRlZnNcblx0XHQgKi9cblx0XHRcImFvQ29sdW1uRGVmc1wiOiBudWxsLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogQmFzaWNhbGx5IHRoZSBzYW1lIGFzIGBzZWFyY2hgLCB0aGlzIHBhcmFtZXRlciBkZWZpbmVzIHRoZSBpbmRpdmlkdWFsIGNvbHVtblxuXHRcdCAqIGZpbHRlcmluZyBzdGF0ZSBhdCBpbml0aWFsaXNhdGlvbiB0aW1lLiBUaGUgYXJyYXkgbXVzdCBiZSBvZiB0aGUgc2FtZSBzaXplXG5cdFx0ICogYXMgdGhlIG51bWJlciBvZiBjb2x1bW5zLCBhbmQgZWFjaCBlbGVtZW50IGJlIGFuIG9iamVjdCB3aXRoIHRoZSBwYXJhbWV0ZXJzXG5cdFx0ICogYHNlYXJjaGAgYW5kIGBlc2NhcGVSZWdleGAgKHRoZSBsYXR0ZXIgaXMgb3B0aW9uYWwpLiAnbnVsbCcgaXMgYWxzb1xuXHRcdCAqIGFjY2VwdGVkIGFuZCB0aGUgZGVmYXVsdCB3aWxsIGJlIHVzZWQuXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IFtdXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IE9wdGlvblxuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuc2VhcmNoQ29sc1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJzZWFyY2hDb2xzXCI6IFtcblx0XHQgKiAgICAgICAgICBudWxsLFxuXHRcdCAqICAgICAgICAgIHsgXCJzZWFyY2hcIjogXCJNeSBmaWx0ZXJcIiB9LFxuXHRcdCAqICAgICAgICAgIG51bGwsXG5cdFx0ICogICAgICAgICAgeyBcInNlYXJjaFwiOiBcIl5bMC05XVwiLCBcImVzY2FwZVJlZ2V4XCI6IGZhbHNlIH1cblx0XHQgKiAgICAgICAgXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKVxuXHRcdCAqL1xuXHRcdFwiYW9TZWFyY2hDb2xzXCI6IFtdLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogQW4gYXJyYXkgb2YgQ1NTIGNsYXNzZXMgdGhhdCBzaG91bGQgYmUgYXBwbGllZCB0byBkaXNwbGF5ZWQgcm93cy4gVGhpc1xuXHRcdCAqIGFycmF5IG1heSBiZSBvZiBhbnkgbGVuZ3RoLCBhbmQgRGF0YVRhYmxlcyB3aWxsIGFwcGx5IGVhY2ggY2xhc3Ncblx0XHQgKiBzZXF1ZW50aWFsbHksIGxvb3Bpbmcgd2hlbiByZXF1aXJlZC5cblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgbnVsbCA8aT5XaWxsIHRha2UgdGhlIHZhbHVlcyBkZXRlcm1pbmVkIGJ5IHRoZSBgb0NsYXNzZXMuc3RyaXBlKmBcblx0XHQgKiAgICBvcHRpb25zPC9pPlxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBPcHRpb25cblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnN0cmlwZUNsYXNzZXNcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwic3RyaXBlQ2xhc3Nlc1wiOiBbICdzdHJpcDEnLCAnc3RyaXAyJywgJ3N0cmlwMycgXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKVxuXHRcdCAqL1xuXHRcdFwiYXNTdHJpcGVDbGFzc2VzXCI6IG51bGwsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBFbmFibGUgb3IgZGlzYWJsZSBhdXRvbWF0aWMgY29sdW1uIHdpZHRoIGNhbGN1bGF0aW9uLiBUaGlzIGNhbiBiZSBkaXNhYmxlZFxuXHRcdCAqIGFzIGFuIG9wdGltaXNhdGlvbiAoaXQgdGFrZXMgc29tZSB0aW1lIHRvIGNhbGN1bGF0ZSB0aGUgd2lkdGhzKSBpZiB0aGVcblx0XHQgKiB0YWJsZXMgd2lkdGhzIGFyZSBwYXNzZWQgaW4gdXNpbmcgYGNvbHVtbnNgLlxuXHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0ICogIEBkZWZhdWx0IHRydWVcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgRmVhdHVyZXNcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmF1dG9XaWR0aFxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uICgpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwiYXV0b1dpZHRoXCI6IGZhbHNlXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiYkF1dG9XaWR0aFwiOiB0cnVlLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogRGVmZXJyZWQgcmVuZGVyaW5nIGNhbiBwcm92aWRlIERhdGFUYWJsZXMgd2l0aCBhIGh1Z2Ugc3BlZWQgYm9vc3Qgd2hlbiB5b3Vcblx0XHQgKiBhcmUgdXNpbmcgYW4gQWpheCBvciBKUyBkYXRhIHNvdXJjZSBmb3IgdGhlIHRhYmxlLiBUaGlzIG9wdGlvbiwgd2hlbiBzZXQgdG9cblx0XHQgKiB0cnVlLCB3aWxsIGNhdXNlIERhdGFUYWJsZXMgdG8gZGVmZXIgdGhlIGNyZWF0aW9uIG9mIHRoZSB0YWJsZSBlbGVtZW50cyBmb3Jcblx0XHQgKiBlYWNoIHJvdyB1bnRpbCB0aGV5IGFyZSBuZWVkZWQgZm9yIGEgZHJhdyAtIHNhdmluZyBhIHNpZ25pZmljYW50IGFtb3VudCBvZlxuXHRcdCAqIHRpbWUuXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKiAgQGRlZmF1bHQgZmFsc2Vcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgRmVhdHVyZXNcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmRlZmVyUmVuZGVyXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImFqYXhcIjogXCJzb3VyY2VzL2FycmF5cy50eHRcIixcblx0XHQgKiAgICAgICAgXCJkZWZlclJlbmRlclwiOiB0cnVlXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiYkRlZmVyUmVuZGVyXCI6IGZhbHNlLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogUmVwbGFjZSBhIERhdGFUYWJsZSB3aGljaCBtYXRjaGVzIHRoZSBnaXZlbiBzZWxlY3RvciBhbmQgcmVwbGFjZSBpdCB3aXRoXG5cdFx0ICogb25lIHdoaWNoIGhhcyB0aGUgcHJvcGVydGllcyBvZiB0aGUgbmV3IGluaXRpYWxpc2F0aW9uIG9iamVjdCBwYXNzZWQuIElmIG5vXG5cdFx0ICogdGFibGUgbWF0Y2hlcyB0aGUgc2VsZWN0b3IsIHRoZW4gdGhlIG5ldyBEYXRhVGFibGUgd2lsbCBiZSBjb25zdHJ1Y3RlZCBhc1xuXHRcdCAqIHBlciBub3JtYWwuXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKiAgQGRlZmF1bHQgZmFsc2Vcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgT3B0aW9uc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuZGVzdHJveVxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJzcm9sbFlcIjogXCIyMDBweFwiLFxuXHRcdCAqICAgICAgICBcInBhZ2luYXRlXCI6IGZhbHNlXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICpcblx0XHQgKiAgICAgIC8vIFNvbWUgdGltZSBsYXRlci4uLi5cblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwiZmlsdGVyXCI6IGZhbHNlLFxuXHRcdCAqICAgICAgICBcImRlc3Ryb3lcIjogdHJ1ZVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcImJEZXN0cm95XCI6IGZhbHNlLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogRW5hYmxlIG9yIGRpc2FibGUgZmlsdGVyaW5nIG9mIGRhdGEuIEZpbHRlcmluZyBpbiBEYXRhVGFibGVzIGlzIFwic21hcnRcIiBpblxuXHRcdCAqIHRoYXQgaXQgYWxsb3dzIHRoZSBlbmQgdXNlciB0byBpbnB1dCBtdWx0aXBsZSB3b3JkcyAoc3BhY2Ugc2VwYXJhdGVkKSBhbmRcblx0XHQgKiB3aWxsIG1hdGNoIGEgcm93IGNvbnRhaW5pbmcgdGhvc2Ugd29yZHMsIGV2ZW4gaWYgbm90IGluIHRoZSBvcmRlciB0aGF0IHdhc1xuXHRcdCAqIHNwZWNpZmllZCAodGhpcyBhbGxvdyBtYXRjaGluZyBhY3Jvc3MgbXVsdGlwbGUgY29sdW1ucykuIE5vdGUgdGhhdCBpZiB5b3Vcblx0XHQgKiB3aXNoIHRvIHVzZSBmaWx0ZXJpbmcgaW4gRGF0YVRhYmxlcyB0aGlzIG11c3QgcmVtYWluICd0cnVlJyAtIHRvIHJlbW92ZSB0aGVcblx0XHQgKiBkZWZhdWx0IGZpbHRlcmluZyBpbnB1dCBib3ggYW5kIHJldGFpbiBmaWx0ZXJpbmcgYWJpbGl0aWVzLCBwbGVhc2UgdXNlXG5cdFx0ICoge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0cy5kb219LlxuXHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0ICogIEBkZWZhdWx0IHRydWVcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgRmVhdHVyZXNcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnNlYXJjaGluZ1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uICgpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwic2VhcmNoaW5nXCI6IGZhbHNlXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiYkZpbHRlclwiOiB0cnVlLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogRW5hYmxlIG9yIGRpc2FibGUgdGhlIHRhYmxlIGluZm9ybWF0aW9uIGRpc3BsYXkuIFRoaXMgc2hvd3MgaW5mb3JtYXRpb25cblx0XHQgKiBhYm91dCB0aGUgZGF0YSB0aGF0IGlzIGN1cnJlbnRseSB2aXNpYmxlIG9uIHRoZSBwYWdlLCBpbmNsdWRpbmcgaW5mb3JtYXRpb25cblx0XHQgKiBhYm91dCBmaWx0ZXJlZCBkYXRhIGlmIHRoYXQgYWN0aW9uIGlzIGJlaW5nIHBlcmZvcm1lZC5cblx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdCAqICBAZGVmYXVsdCB0cnVlXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IEZlYXR1cmVzXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5pbmZvXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24gKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJpbmZvXCI6IGZhbHNlXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiYkluZm9cIjogdHJ1ZSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEFsbG93cyB0aGUgZW5kIHVzZXIgdG8gc2VsZWN0IHRoZSBzaXplIG9mIGEgZm9ybWF0dGVkIHBhZ2UgZnJvbSBhIHNlbGVjdFxuXHRcdCAqIG1lbnUgKHNpemVzIGFyZSAxMCwgMjUsIDUwIGFuZCAxMDApLiBSZXF1aXJlcyBwYWdpbmF0aW9uIChgcGFnaW5hdGVgKS5cblx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdCAqICBAZGVmYXVsdCB0cnVlXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IEZlYXR1cmVzXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sZW5ndGhDaGFuZ2Vcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbiAoKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImxlbmd0aENoYW5nZVwiOiBmYWxzZVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcImJMZW5ndGhDaGFuZ2VcIjogdHJ1ZSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEVuYWJsZSBvciBkaXNhYmxlIHBhZ2luYXRpb24uXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKiAgQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBGZWF0dXJlc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMucGFnaW5nXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24gKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJwYWdpbmdcIjogZmFsc2Vcblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJiUGFnaW5hdGVcIjogdHJ1ZSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEVuYWJsZSBvciBkaXNhYmxlIHRoZSBkaXNwbGF5IG9mIGEgJ3Byb2Nlc3NpbmcnIGluZGljYXRvciB3aGVuIHRoZSB0YWJsZSBpc1xuXHRcdCAqIGJlaW5nIHByb2Nlc3NlZCAoZS5nLiBhIHNvcnQpLiBUaGlzIGlzIHBhcnRpY3VsYXJseSB1c2VmdWwgZm9yIHRhYmxlcyB3aXRoXG5cdFx0ICogbGFyZ2UgYW1vdW50cyBvZiBkYXRhIHdoZXJlIGl0IGNhbiB0YWtlIGEgbm90aWNlYWJsZSBhbW91bnQgb2YgdGltZSB0byBzb3J0XG5cdFx0ICogdGhlIGVudHJpZXMuXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKiAgQGRlZmF1bHQgZmFsc2Vcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgRmVhdHVyZXNcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnByb2Nlc3Npbmdcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbiAoKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcInByb2Nlc3NpbmdcIjogdHJ1ZVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcImJQcm9jZXNzaW5nXCI6IGZhbHNlLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogUmV0cmlldmUgdGhlIERhdGFUYWJsZXMgb2JqZWN0IGZvciB0aGUgZ2l2ZW4gc2VsZWN0b3IuIE5vdGUgdGhhdCBpZiB0aGVcblx0XHQgKiB0YWJsZSBoYXMgYWxyZWFkeSBiZWVuIGluaXRpYWxpc2VkLCB0aGlzIHBhcmFtZXRlciB3aWxsIGNhdXNlIERhdGFUYWJsZXNcblx0XHQgKiB0byBzaW1wbHkgcmV0dXJuIHRoZSBvYmplY3QgdGhhdCBoYXMgYWxyZWFkeSBiZWVuIHNldCB1cCAtIGl0IHdpbGwgbm90IHRha2Vcblx0XHQgKiBhY2NvdW50IG9mIGFueSBjaGFuZ2VzIHlvdSBtaWdodCBoYXZlIG1hZGUgdG8gdGhlIGluaXRpYWxpc2F0aW9uIG9iamVjdFxuXHRcdCAqIHBhc3NlZCB0byBEYXRhVGFibGVzIChzZXR0aW5nIHRoaXMgcGFyYW1ldGVyIHRvIHRydWUgaXMgYW4gYWNrbm93bGVkZ2VtZW50XG5cdFx0ICogdGhhdCB5b3UgdW5kZXJzdGFuZCB0aGlzKS4gYGRlc3Ryb3lgIGNhbiBiZSB1c2VkIHRvIHJlaW5pdGlhbGlzZSBhIHRhYmxlIGlmXG5cdFx0ICogeW91IG5lZWQuXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKiAgQGRlZmF1bHQgZmFsc2Vcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgT3B0aW9uc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMucmV0cmlldmVcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgIGluaXRUYWJsZSgpO1xuXHRcdCAqICAgICAgdGFibGVBY3Rpb25zKCk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqXG5cdFx0ICogICAgZnVuY3Rpb24gaW5pdFRhYmxlICgpXG5cdFx0ICogICAge1xuXHRcdCAqICAgICAgcmV0dXJuICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwic2Nyb2xsWVwiOiBcIjIwMHB4XCIsXG5cdFx0ICogICAgICAgIFwicGFnaW5hdGVcIjogZmFsc2UsXG5cdFx0ICogICAgICAgIFwicmV0cmlldmVcIjogdHJ1ZVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH1cblx0XHQgKlxuXHRcdCAqICAgIGZ1bmN0aW9uIHRhYmxlQWN0aW9ucyAoKVxuXHRcdCAqICAgIHtcblx0XHQgKiAgICAgIHZhciB0YWJsZSA9IGluaXRUYWJsZSgpO1xuXHRcdCAqICAgICAgLy8gcGVyZm9ybSBBUEkgb3BlcmF0aW9ucyB3aXRoIG9UYWJsZVxuXHRcdCAqICAgIH1cblx0XHQgKi9cblx0XHRcImJSZXRyaWV2ZVwiOiBmYWxzZSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFdoZW4gdmVydGljYWwgKHkpIHNjcm9sbGluZyBpcyBlbmFibGVkLCBEYXRhVGFibGVzIHdpbGwgZm9yY2UgdGhlIGhlaWdodCBvZlxuXHRcdCAqIHRoZSB0YWJsZSdzIHZpZXdwb3J0IHRvIHRoZSBnaXZlbiBoZWlnaHQgYXQgYWxsIHRpbWVzICh1c2VmdWwgZm9yIGxheW91dCkuXG5cdFx0ICogSG93ZXZlciwgdGhpcyBjYW4gbG9vayBvZGQgd2hlbiBmaWx0ZXJpbmcgZGF0YSBkb3duIHRvIGEgc21hbGwgZGF0YSBzZXQsXG5cdFx0ICogYW5kIHRoZSBmb290ZXIgaXMgbGVmdCBcImZsb2F0aW5nXCIgZnVydGhlciBkb3duLiBUaGlzIHBhcmFtZXRlciAod2hlblxuXHRcdCAqIGVuYWJsZWQpIHdpbGwgY2F1c2UgRGF0YVRhYmxlcyB0byBjb2xsYXBzZSB0aGUgdGFibGUncyB2aWV3cG9ydCBkb3duIHdoZW5cblx0XHQgKiB0aGUgcmVzdWx0IHNldCB3aWxsIGZpdCB3aXRoaW4gdGhlIGdpdmVuIFkgaGVpZ2h0LlxuXHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0ICogIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IE9wdGlvbnNcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnNjcm9sbENvbGxhcHNlXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcInNjcm9sbFlcIjogXCIyMDBcIixcblx0XHQgKiAgICAgICAgXCJzY3JvbGxDb2xsYXBzZVwiOiB0cnVlXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiYlNjcm9sbENvbGxhcHNlXCI6IGZhbHNlLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogQ29uZmlndXJlIERhdGFUYWJsZXMgdG8gdXNlIHNlcnZlci1zaWRlIHByb2Nlc3NpbmcuIE5vdGUgdGhhdCB0aGVcblx0XHQgKiBgYWpheGAgcGFyYW1ldGVyIG11c3QgYWxzbyBiZSBnaXZlbiBpbiBvcmRlciB0byBnaXZlIERhdGFUYWJsZXMgYVxuXHRcdCAqIHNvdXJjZSB0byBvYnRhaW4gdGhlIHJlcXVpcmVkIGRhdGEgZm9yIGVhY2ggZHJhdy5cblx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdCAqICBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBGZWF0dXJlc1xuXHRcdCAqICBAZHRvcHQgU2VydmVyLXNpZGVcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnNlcnZlclNpZGVcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbiAoKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcInNlcnZlclNpZGVcIjogdHJ1ZSxcblx0XHQgKiAgICAgICAgXCJhamF4XCI6IFwieGhyLnBocFwiXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiYlNlcnZlclNpZGVcIjogZmFsc2UsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBFbmFibGUgb3IgZGlzYWJsZSBzb3J0aW5nIG9mIGNvbHVtbnMuIFNvcnRpbmcgb2YgaW5kaXZpZHVhbCBjb2x1bW5zIGNhbiBiZVxuXHRcdCAqIGRpc2FibGVkIGJ5IHRoZSBgc29ydGFibGVgIG9wdGlvbiBmb3IgZWFjaCBjb2x1bW4uXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKiAgQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBGZWF0dXJlc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMub3JkZXJpbmdcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbiAoKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcIm9yZGVyaW5nXCI6IGZhbHNlXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiYlNvcnRcIjogdHJ1ZSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEVuYWJsZSBvciBkaXNwbGF5IERhdGFUYWJsZXMnIGFiaWxpdHkgdG8gc29ydCBtdWx0aXBsZSBjb2x1bW5zIGF0IHRoZVxuXHRcdCAqIHNhbWUgdGltZSAoYWN0aXZhdGVkIGJ5IHNoaWZ0LWNsaWNrIGJ5IHRoZSB1c2VyKS5cblx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdCAqICBAZGVmYXVsdCB0cnVlXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IE9wdGlvbnNcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLm9yZGVyTXVsdGlcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIERpc2FibGUgbXVsdGlwbGUgY29sdW1uIHNvcnRpbmcgYWJpbGl0eVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbiAoKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcIm9yZGVyTXVsdGlcIjogZmFsc2Vcblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJiU29ydE11bHRpXCI6IHRydWUsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBBbGxvd3MgY29udHJvbCBvdmVyIHdoZXRoZXIgRGF0YVRhYmxlcyBzaG91bGQgdXNlIHRoZSB0b3AgKHRydWUpIHVuaXF1ZVxuXHRcdCAqIGNlbGwgdGhhdCBpcyBmb3VuZCBmb3IgYSBzaW5nbGUgY29sdW1uLCBvciB0aGUgYm90dG9tIChmYWxzZSAtIGRlZmF1bHQpLlxuXHRcdCAqIFRoaXMgaXMgdXNlZnVsIHdoZW4gdXNpbmcgY29tcGxleCBoZWFkZXJzLlxuXHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0ICogIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IE9wdGlvbnNcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLm9yZGVyQ2VsbHNUb3Bcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwib3JkZXJDZWxsc1RvcFwiOiB0cnVlXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiYlNvcnRDZWxsc1RvcFwiOiBmYWxzZSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEVuYWJsZSBvciBkaXNhYmxlIHRoZSBhZGRpdGlvbiBvZiB0aGUgY2xhc3NlcyBgc29ydGluZ1xcXzFgLCBgc29ydGluZ1xcXzJgIGFuZFxuXHRcdCAqIGBzb3J0aW5nXFxfM2AgdG8gdGhlIGNvbHVtbnMgd2hpY2ggYXJlIGN1cnJlbnRseSBiZWluZyBzb3J0ZWQgb24uIFRoaXMgaXNcblx0XHQgKiBwcmVzZW50ZWQgYXMgYSBmZWF0dXJlIHN3aXRjaCBhcyBpdCBjYW4gaW5jcmVhc2UgcHJvY2Vzc2luZyB0aW1lICh3aGlsZVxuXHRcdCAqIGNsYXNzZXMgYXJlIHJlbW92ZWQgYW5kIGFkZGVkKSBzbyBmb3IgbGFyZ2UgZGF0YSBzZXRzIHlvdSBtaWdodCB3YW50IHRvXG5cdFx0ICogdHVybiB0aGlzIG9mZi5cblx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdCAqICBAZGVmYXVsdCB0cnVlXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IEZlYXR1cmVzXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5vcmRlckNsYXNzZXNcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbiAoKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcIm9yZGVyQ2xhc3Nlc1wiOiBmYWxzZVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcImJTb3J0Q2xhc3Nlc1wiOiB0cnVlLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogRW5hYmxlIG9yIGRpc2FibGUgc3RhdGUgc2F2aW5nLiBXaGVuIGVuYWJsZWQgSFRNTDUgYGxvY2FsU3RvcmFnZWAgd2lsbCBiZVxuXHRcdCAqIHVzZWQgdG8gc2F2ZSB0YWJsZSBkaXNwbGF5IGluZm9ybWF0aW9uIHN1Y2ggYXMgcGFnaW5hdGlvbiBpbmZvcm1hdGlvbixcblx0XHQgKiBkaXNwbGF5IGxlbmd0aCwgZmlsdGVyaW5nIGFuZCBzb3J0aW5nLiBBcyBzdWNoIHdoZW4gdGhlIGVuZCB1c2VyIHJlbG9hZHNcblx0XHQgKiB0aGUgcGFnZSB0aGUgZGlzcGxheSBkaXNwbGF5IHdpbGwgbWF0Y2ggd2hhdCB0aHkgaGFkIHByZXZpb3VzbHkgc2V0IHVwLlxuXHRcdCAqXG5cdFx0ICogRHVlIHRvIHRoZSB1c2Ugb2YgYGxvY2FsU3RvcmFnZWAgdGhlIGRlZmF1bHQgc3RhdGUgc2F2aW5nIGlzIG5vdCBzdXBwb3J0ZWRcblx0XHQgKiBpbiBJRTYgb3IgNy4gSWYgc3RhdGUgc2F2aW5nIGlzIHJlcXVpcmVkIGluIHRob3NlIGJyb3dzZXJzLCB1c2Vcblx0XHQgKiBgc3RhdGVTYXZlQ2FsbGJhY2tgIHRvIHByb3ZpZGUgYSBzdG9yYWdlIHNvbHV0aW9uIHN1Y2ggYXMgY29va2llcy5cblx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdCAqICBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBGZWF0dXJlc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuc3RhdGVTYXZlXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24gKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJzdGF0ZVNhdmVcIjogdHJ1ZVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcImJTdGF0ZVNhdmVcIjogZmFsc2UsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aGVuIGEgVFIgZWxlbWVudCBpcyBjcmVhdGVkIChhbmQgYWxsIFREIGNoaWxkXG5cdFx0ICogZWxlbWVudHMgaGF2ZSBiZWVuIGluc2VydGVkKSwgb3IgcmVnaXN0ZXJlZCBpZiB1c2luZyBhIERPTSBzb3VyY2UsIGFsbG93aW5nXG5cdFx0ICogbWFuaXB1bGF0aW9uIG9mIHRoZSBUUiBlbGVtZW50IChhZGRpbmcgY2xhc3NlcyBldGMpLlxuXHRcdCAqICBAdHlwZSBmdW5jdGlvblxuXHRcdCAqICBAcGFyYW0ge25vZGV9IHJvdyBcIlRSXCIgZWxlbWVudCBmb3IgdGhlIGN1cnJlbnQgcm93XG5cdFx0ICogIEBwYXJhbSB7YXJyYXl9IGRhdGEgUmF3IGRhdGEgYXJyYXkgZm9yIHRoaXMgcm93XG5cdFx0ICogIEBwYXJhbSB7aW50fSBkYXRhSW5kZXggVGhlIGluZGV4IG9mIHRoaXMgcm93IGluIHRoZSBpbnRlcm5hbCBhb0RhdGEgYXJyYXlcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgQ2FsbGJhY2tzXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jcmVhdGVkUm93XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImNyZWF0ZWRSb3dcIjogZnVuY3Rpb24oIHJvdywgZGF0YSwgZGF0YUluZGV4ICkge1xuXHRcdCAqICAgICAgICAgIC8vIEJvbGQgdGhlIGdyYWRlIGZvciBhbGwgJ0EnIGdyYWRlIGJyb3dzZXJzXG5cdFx0ICogICAgICAgICAgaWYgKCBkYXRhWzRdID09IFwiQVwiIClcblx0XHQgKiAgICAgICAgICB7XG5cdFx0ICogICAgICAgICAgICAkKCd0ZDplcSg0KScsIHJvdykuaHRtbCggJzxiPkE8L2I+JyApO1xuXHRcdCAqICAgICAgICAgIH1cblx0XHQgKiAgICAgICAgfVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcImZuQ3JlYXRlZFJvd1wiOiBudWxsLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgb24gZXZlcnkgJ2RyYXcnIGV2ZW50LCBhbmQgYWxsb3dzIHlvdSB0b1xuXHRcdCAqIGR5bmFtaWNhbGx5IG1vZGlmeSBhbnkgYXNwZWN0IHlvdSB3YW50IGFib3V0IHRoZSBjcmVhdGVkIERPTS5cblx0XHQgKiAgQHR5cGUgZnVuY3Rpb25cblx0XHQgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IENhbGxiYWNrc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuZHJhd0NhbGxiYWNrXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImRyYXdDYWxsYmFja1wiOiBmdW5jdGlvbiggc2V0dGluZ3MgKSB7XG5cdFx0ICogICAgICAgICAgYWxlcnQoICdEYXRhVGFibGVzIGhhcyByZWRyYXduIHRoZSB0YWJsZScgKTtcblx0XHQgKiAgICAgICAgfVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcImZuRHJhd0NhbGxiYWNrXCI6IG51bGwsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBJZGVudGljYWwgdG8gZm5IZWFkZXJDYWxsYmFjaygpIGJ1dCBmb3IgdGhlIHRhYmxlIGZvb3RlciB0aGlzIGZ1bmN0aW9uXG5cdFx0ICogYWxsb3dzIHlvdSB0byBtb2RpZnkgdGhlIHRhYmxlIGZvb3RlciBvbiBldmVyeSAnZHJhdycgZXZlbnQuXG5cdFx0ICogIEB0eXBlIGZ1bmN0aW9uXG5cdFx0ICogIEBwYXJhbSB7bm9kZX0gZm9vdCBcIlRSXCIgZWxlbWVudCBmb3IgdGhlIGZvb3RlclxuXHRcdCAqICBAcGFyYW0ge2FycmF5fSBkYXRhIEZ1bGwgdGFibGUgZGF0YSAoYXMgZGVyaXZlZCBmcm9tIHRoZSBvcmlnaW5hbCBIVE1MKVxuXHRcdCAqICBAcGFyYW0ge2ludH0gc3RhcnQgSW5kZXggZm9yIHRoZSBjdXJyZW50IGRpc3BsYXkgc3RhcnRpbmcgcG9pbnQgaW4gdGhlXG5cdFx0ICogICAgZGlzcGxheSBhcnJheVxuXHRcdCAqICBAcGFyYW0ge2ludH0gZW5kIEluZGV4IGZvciB0aGUgY3VycmVudCBkaXNwbGF5IGVuZGluZyBwb2ludCBpbiB0aGVcblx0XHQgKiAgICBkaXNwbGF5IGFycmF5XG5cdFx0ICogIEBwYXJhbSB7YXJyYXkgaW50fSBkaXNwbGF5IEluZGV4IGFycmF5IHRvIHRyYW5zbGF0ZSB0aGUgdmlzdWFsIHBvc2l0aW9uXG5cdFx0ICogICAgdG8gdGhlIGZ1bGwgZGF0YSBhcnJheVxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBDYWxsYmFja3Ncblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmZvb3RlckNhbGxiYWNrXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImZvb3RlckNhbGxiYWNrXCI6IGZ1bmN0aW9uKCB0Zm9vdCwgZGF0YSwgc3RhcnQsIGVuZCwgZGlzcGxheSApIHtcblx0XHQgKiAgICAgICAgICB0Zm9vdC5nZXRFbGVtZW50c0J5VGFnTmFtZSgndGgnKVswXS5pbm5lckhUTUwgPSBcIlN0YXJ0aW5nIGluZGV4IGlzIFwiK3N0YXJ0O1xuXHRcdCAqICAgICAgICB9XG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApXG5cdFx0ICovXG5cdFx0XCJmbkZvb3RlckNhbGxiYWNrXCI6IG51bGwsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBXaGVuIHJlbmRlcmluZyBsYXJnZSBudW1iZXJzIGluIHRoZSBpbmZvcm1hdGlvbiBlbGVtZW50IGZvciB0aGUgdGFibGVcblx0XHQgKiAoaS5lLiBcIlNob3dpbmcgMSB0byAxMCBvZiA1NyBlbnRyaWVzXCIpIERhdGFUYWJsZXMgd2lsbCByZW5kZXIgbGFyZ2UgbnVtYmVyc1xuXHRcdCAqIHRvIGhhdmUgYSBjb21tYSBzZXBhcmF0b3IgZm9yIHRoZSAndGhvdXNhbmRzJyB1bml0cyAoZS5nLiAxIG1pbGxpb24gaXNcblx0XHQgKiByZW5kZXJlZCBhcyBcIjEsMDAwLDAwMFwiKSB0byBoZWxwIHJlYWRhYmlsaXR5IGZvciB0aGUgZW5kIHVzZXIuIFRoaXNcblx0XHQgKiBmdW5jdGlvbiB3aWxsIG92ZXJyaWRlIHRoZSBkZWZhdWx0IG1ldGhvZCBEYXRhVGFibGVzIHVzZXMuXG5cdFx0ICogIEB0eXBlIGZ1bmN0aW9uXG5cdFx0ICogIEBtZW1iZXJcblx0XHQgKiAgQHBhcmFtIHtpbnR9IHRvRm9ybWF0IG51bWJlciB0byBiZSBmb3JtYXR0ZWRcblx0XHQgKiAgQHJldHVybnMge3N0cmluZ30gZm9ybWF0dGVkIHN0cmluZyBmb3IgRGF0YVRhYmxlcyB0byBzaG93IHRoZSBudW1iZXJcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgQ2FsbGJhY2tzXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5mb3JtYXROdW1iZXJcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIEZvcm1hdCBhIG51bWJlciB1c2luZyBhIHNpbmdsZSBxdW90ZSBmb3IgdGhlIHNlcGFyYXRvciAobm90ZSB0aGF0XG5cdFx0ICogICAgLy8gdGhpcyBjYW4gYWxzbyBiZSBkb25lIHdpdGggdGhlIGxhbmd1YWdlLnRob3VzYW5kcyBvcHRpb24pXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJmb3JtYXROdW1iZXJcIjogZnVuY3Rpb24gKCB0b0Zvcm1hdCApIHtcblx0XHQgKiAgICAgICAgICByZXR1cm4gdG9Gb3JtYXQudG9TdHJpbmcoKS5yZXBsYWNlKFxuXHRcdCAqICAgICAgICAgICAgL1xcQig/PShcXGR7M30pKyg/IVxcZCkpL2csIFwiJ1wiXG5cdFx0ICogICAgICAgICAgKTtcblx0XHQgKiAgICAgICAgfTtcblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJmbkZvcm1hdE51bWJlclwiOiBmdW5jdGlvbiAoIHRvRm9ybWF0ICkge1xuXHRcdFx0cmV0dXJuIHRvRm9ybWF0LnRvU3RyaW5nKCkucmVwbGFjZShcblx0XHRcdFx0L1xcQig/PShcXGR7M30pKyg/IVxcZCkpL2csXG5cdFx0XHRcdHRoaXMub0xhbmd1YWdlLnNUaG91c2FuZHNcblx0XHRcdCk7XG5cdFx0fSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGV2ZXJ5ICdkcmF3JyBldmVudCwgYW5kIGFsbG93cyB5b3UgdG9cblx0XHQgKiBkeW5hbWljYWxseSBtb2RpZnkgdGhlIGhlYWRlciByb3cuIFRoaXMgY2FuIGJlIHVzZWQgdG8gY2FsY3VsYXRlIGFuZFxuXHRcdCAqIGRpc3BsYXkgdXNlZnVsIGluZm9ybWF0aW9uIGFib3V0IHRoZSB0YWJsZS5cblx0XHQgKiAgQHR5cGUgZnVuY3Rpb25cblx0XHQgKiAgQHBhcmFtIHtub2RlfSBoZWFkIFwiVFJcIiBlbGVtZW50IGZvciB0aGUgaGVhZGVyXG5cdFx0ICogIEBwYXJhbSB7YXJyYXl9IGRhdGEgRnVsbCB0YWJsZSBkYXRhIChhcyBkZXJpdmVkIGZyb20gdGhlIG9yaWdpbmFsIEhUTUwpXG5cdFx0ICogIEBwYXJhbSB7aW50fSBzdGFydCBJbmRleCBmb3IgdGhlIGN1cnJlbnQgZGlzcGxheSBzdGFydGluZyBwb2ludCBpbiB0aGVcblx0XHQgKiAgICBkaXNwbGF5IGFycmF5XG5cdFx0ICogIEBwYXJhbSB7aW50fSBlbmQgSW5kZXggZm9yIHRoZSBjdXJyZW50IGRpc3BsYXkgZW5kaW5nIHBvaW50IGluIHRoZVxuXHRcdCAqICAgIGRpc3BsYXkgYXJyYXlcblx0XHQgKiAgQHBhcmFtIHthcnJheSBpbnR9IGRpc3BsYXkgSW5kZXggYXJyYXkgdG8gdHJhbnNsYXRlIHRoZSB2aXN1YWwgcG9zaXRpb25cblx0XHQgKiAgICB0byB0aGUgZnVsbCBkYXRhIGFycmF5XG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IENhbGxiYWNrc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuaGVhZGVyQ2FsbGJhY2tcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwiZmhlYWRlckNhbGxiYWNrXCI6IGZ1bmN0aW9uKCBoZWFkLCBkYXRhLCBzdGFydCwgZW5kLCBkaXNwbGF5ICkge1xuXHRcdCAqICAgICAgICAgIGhlYWQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3RoJylbMF0uaW5uZXJIVE1MID0gXCJEaXNwbGF5aW5nIFwiKyhlbmQtc3RhcnQpK1wiIHJlY29yZHNcIjtcblx0XHQgKiAgICAgICAgfVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKVxuXHRcdCAqL1xuXHRcdFwiZm5IZWFkZXJDYWxsYmFja1wiOiBudWxsLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIGluZm9ybWF0aW9uIGVsZW1lbnQgY2FuIGJlIHVzZWQgdG8gY29udmV5IGluZm9ybWF0aW9uIGFib3V0IHRoZSBjdXJyZW50XG5cdFx0ICogc3RhdGUgb2YgdGhlIHRhYmxlLiBBbHRob3VnaCB0aGUgaW50ZXJuYXRpb25hbGlzYXRpb24gb3B0aW9ucyBwcmVzZW50ZWQgYnlcblx0XHQgKiBEYXRhVGFibGVzIGFyZSBxdWl0ZSBjYXBhYmxlIG9mIGRlYWxpbmcgd2l0aCBtb3N0IGN1c3RvbWlzYXRpb25zLCB0aGVyZSBtYXlcblx0XHQgKiBiZSB0aW1lcyB3aGVyZSB5b3Ugd2lzaCB0byBjdXN0b21pc2UgdGhlIHN0cmluZyBmdXJ0aGVyLiBUaGlzIGNhbGxiYWNrXG5cdFx0ICogYWxsb3dzIHlvdSB0byBkbyBleGFjdGx5IHRoYXQuXG5cdFx0ICogIEB0eXBlIGZ1bmN0aW9uXG5cdFx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0XHQgKiAgQHBhcmFtIHtpbnR9IHN0YXJ0IFN0YXJ0aW5nIHBvc2l0aW9uIGluIGRhdGEgZm9yIHRoZSBkcmF3XG5cdFx0ICogIEBwYXJhbSB7aW50fSBlbmQgRW5kIHBvc2l0aW9uIGluIGRhdGEgZm9yIHRoZSBkcmF3XG5cdFx0ICogIEBwYXJhbSB7aW50fSBtYXggVG90YWwgbnVtYmVyIG9mIHJvd3MgaW4gdGhlIHRhYmxlIChyZWdhcmRsZXNzIG9mXG5cdFx0ICogICAgZmlsdGVyaW5nKVxuXHRcdCAqICBAcGFyYW0ge2ludH0gdG90YWwgVG90YWwgbnVtYmVyIG9mIHJvd3MgaW4gdGhlIGRhdGEgc2V0LCBhZnRlciBmaWx0ZXJpbmdcblx0XHQgKiAgQHBhcmFtIHtzdHJpbmd9IHByZSBUaGUgc3RyaW5nIHRoYXQgRGF0YVRhYmxlcyBoYXMgZm9ybWF0dGVkIHVzaW5nIGl0J3Ncblx0XHQgKiAgICBvd24gcnVsZXNcblx0XHQgKiAgQHJldHVybnMge3N0cmluZ30gVGhlIHN0cmluZyB0byBiZSBkaXNwbGF5ZWQgaW4gdGhlIGluZm9ybWF0aW9uIGVsZW1lbnQuXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IENhbGxiYWNrc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuaW5mb0NhbGxiYWNrXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgXCJpbmZvQ2FsbGJhY2tcIjogZnVuY3Rpb24oIHNldHRpbmdzLCBzdGFydCwgZW5kLCBtYXgsIHRvdGFsLCBwcmUgKSB7XG5cdFx0ICogICAgICAgIHJldHVybiBzdGFydCArXCIgdG8gXCIrIGVuZDtcblx0XHQgKiAgICAgIH1cblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJmbkluZm9DYWxsYmFja1wiOiBudWxsLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogQ2FsbGVkIHdoZW4gdGhlIHRhYmxlIGhhcyBiZWVuIGluaXRpYWxpc2VkLiBOb3JtYWxseSBEYXRhVGFibGVzIHdpbGxcblx0XHQgKiBpbml0aWFsaXNlIHNlcXVlbnRpYWxseSBhbmQgdGhlcmUgd2lsbCBiZSBubyBuZWVkIGZvciB0aGlzIGZ1bmN0aW9uLFxuXHRcdCAqIGhvd2V2ZXIsIHRoaXMgZG9lcyBub3QgaG9sZCB0cnVlIHdoZW4gdXNpbmcgZXh0ZXJuYWwgbGFuZ3VhZ2UgaW5mb3JtYXRpb25cblx0XHQgKiBzaW5jZSB0aGF0IGlzIG9idGFpbmVkIHVzaW5nIGFuIGFzeW5jIFhIUiBjYWxsLlxuXHRcdCAqICBAdHlwZSBmdW5jdGlvblxuXHRcdCAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0XHQgKiAgQHBhcmFtIHtvYmplY3R9IGpzb24gVGhlIEpTT04gb2JqZWN0IHJlcXVlc3QgZnJvbSB0aGUgc2VydmVyIC0gb25seVxuXHRcdCAqICAgIHByZXNlbnQgaWYgY2xpZW50LXNpZGUgQWpheCBzb3VyY2VkIGRhdGEgaXMgdXNlZFxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBDYWxsYmFja3Ncblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmluaXRDb21wbGV0ZVxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJpbml0Q29tcGxldGVcIjogZnVuY3Rpb24oc2V0dGluZ3MsIGpzb24pIHtcblx0XHQgKiAgICAgICAgICBhbGVydCggJ0RhdGFUYWJsZXMgaGFzIGZpbmlzaGVkIGl0cyBpbml0aWFsaXNhdGlvbi4nICk7XG5cdFx0ICogICAgICAgIH1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9IClcblx0XHQgKi9cblx0XHRcImZuSW5pdENvbXBsZXRlXCI6IG51bGwsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBDYWxsZWQgYXQgdGhlIHZlcnkgc3RhcnQgb2YgZWFjaCB0YWJsZSBkcmF3IGFuZCBjYW4gYmUgdXNlZCB0byBjYW5jZWwgdGhlXG5cdFx0ICogZHJhdyBieSByZXR1cm5pbmcgZmFsc2UsIGFueSBvdGhlciByZXR1cm4gKGluY2x1ZGluZyB1bmRlZmluZWQpIHJlc3VsdHMgaW5cblx0XHQgKiB0aGUgZnVsbCBkcmF3IG9jY3VycmluZykuXG5cdFx0ICogIEB0eXBlIGZ1bmN0aW9uXG5cdFx0ICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHRcdCAqICBAcmV0dXJucyB7Ym9vbGVhbn0gRmFsc2Ugd2lsbCBjYW5jZWwgdGhlIGRyYXcsIGFueXRoaW5nIGVsc2UgKGluY2x1ZGluZyBub1xuXHRcdCAqICAgIHJldHVybikgd2lsbCBhbGxvdyBpdCB0byBjb21wbGV0ZS5cblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgQ2FsbGJhY2tzXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5wcmVEcmF3Q2FsbGJhY2tcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwicHJlRHJhd0NhbGxiYWNrXCI6IGZ1bmN0aW9uKCBzZXR0aW5ncyApIHtcblx0XHQgKiAgICAgICAgICBpZiAoICQoJyN0ZXN0JykudmFsKCkgPT0gMSApIHtcblx0XHQgKiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0XHQgKiAgICAgICAgICB9XG5cdFx0ICogICAgICAgIH1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJmblByZURyYXdDYWxsYmFja1wiOiBudWxsLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhpcyBmdW5jdGlvbiBhbGxvd3MgeW91IHRvICdwb3N0IHByb2Nlc3MnIGVhY2ggcm93IGFmdGVyIGl0IGhhdmUgYmVlblxuXHRcdCAqIGdlbmVyYXRlZCBmb3IgZWFjaCB0YWJsZSBkcmF3LCBidXQgYmVmb3JlIGl0IGlzIHJlbmRlcmVkIG9uIHNjcmVlbi4gVGhpc1xuXHRcdCAqIGZ1bmN0aW9uIG1pZ2h0IGJlIHVzZWQgZm9yIHNldHRpbmcgdGhlIHJvdyBjbGFzcyBuYW1lIGV0Yy5cblx0XHQgKiAgQHR5cGUgZnVuY3Rpb25cblx0XHQgKiAgQHBhcmFtIHtub2RlfSByb3cgXCJUUlwiIGVsZW1lbnQgZm9yIHRoZSBjdXJyZW50IHJvd1xuXHRcdCAqICBAcGFyYW0ge2FycmF5fSBkYXRhIFJhdyBkYXRhIGFycmF5IGZvciB0aGlzIHJvd1xuXHRcdCAqICBAcGFyYW0ge2ludH0gZGlzcGxheUluZGV4IFRoZSBkaXNwbGF5IGluZGV4IGZvciB0aGUgY3VycmVudCB0YWJsZSBkcmF3XG5cdFx0ICogIEBwYXJhbSB7aW50fSBkaXNwbGF5SW5kZXhGdWxsIFRoZSBpbmRleCBvZiB0aGUgZGF0YSBpbiB0aGUgZnVsbCBsaXN0IG9mXG5cdFx0ICogICAgcm93cyAoYWZ0ZXIgZmlsdGVyaW5nKVxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBDYWxsYmFja3Ncblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnJvd0NhbGxiYWNrXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcInJvd0NhbGxiYWNrXCI6IGZ1bmN0aW9uKCByb3csIGRhdGEsIGRpc3BsYXlJbmRleCwgZGlzcGxheUluZGV4RnVsbCApIHtcblx0XHQgKiAgICAgICAgICAvLyBCb2xkIHRoZSBncmFkZSBmb3IgYWxsICdBJyBncmFkZSBicm93c2Vyc1xuXHRcdCAqICAgICAgICAgIGlmICggZGF0YVs0XSA9PSBcIkFcIiApIHtcblx0XHQgKiAgICAgICAgICAgICQoJ3RkOmVxKDQpJywgcm93KS5odG1sKCAnPGI+QTwvYj4nICk7XG5cdFx0ICogICAgICAgICAgfVxuXHRcdCAqICAgICAgICB9XG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiZm5Sb3dDYWxsYmFja1wiOiBudWxsLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogX19EZXByZWNhdGVkX18gVGhlIGZ1bmN0aW9uYWxpdHkgcHJvdmlkZWQgYnkgdGhpcyBwYXJhbWV0ZXIgaGFzIG5vdyBiZWVuXG5cdFx0ICogc3VwZXJzZWRlZCBieSB0aGF0IHByb3ZpZGVkIHRocm91Z2ggYGFqYXhgLCB3aGljaCBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkLlxuXHRcdCAqXG5cdFx0ICogVGhpcyBwYXJhbWV0ZXIgYWxsb3dzIHlvdSB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBmdW5jdGlvbiB3aGljaCBvYnRhaW5zXG5cdFx0ICogdGhlIGRhdGEgZnJvbSB0aGUgc2VydmVyIHNvIHNvbWV0aGluZyBtb3JlIHN1aXRhYmxlIGZvciB5b3VyIGFwcGxpY2F0aW9uLlxuXHRcdCAqIEZvciBleGFtcGxlIHlvdSBjb3VsZCB1c2UgUE9TVCBkYXRhLCBvciBwdWxsIGluZm9ybWF0aW9uIGZyb20gYSBHZWFycyBvclxuXHRcdCAqIEFJUiBkYXRhYmFzZS5cblx0XHQgKiAgQHR5cGUgZnVuY3Rpb25cblx0XHQgKiAgQG1lbWJlclxuXHRcdCAqICBAcGFyYW0ge3N0cmluZ30gc291cmNlIEhUVFAgc291cmNlIHRvIG9idGFpbiB0aGUgZGF0YSBmcm9tIChgYWpheGApXG5cdFx0ICogIEBwYXJhbSB7YXJyYXl9IGRhdGEgQSBrZXkvdmFsdWUgcGFpciBvYmplY3QgY29udGFpbmluZyB0aGUgZGF0YSB0byBzZW5kXG5cdFx0ICogICAgdG8gdGhlIHNlcnZlclxuXHRcdCAqICBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayB0byBiZSBjYWxsZWQgb24gY29tcGxldGlvbiBvZiB0aGUgZGF0YSBnZXRcblx0XHQgKiAgICBwcm9jZXNzIHRoYXQgd2lsbCBkcmF3IHRoZSBkYXRhIG9uIHRoZSBwYWdlLlxuXHRcdCAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgQ2FsbGJhY2tzXG5cdFx0ICogIEBkdG9wdCBTZXJ2ZXItc2lkZVxuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuc2VydmVyRGF0YVxuXHRcdCAqXG5cdFx0ICogIEBkZXByZWNhdGVkIDEuMTAuIFBsZWFzZSB1c2UgYGFqYXhgIGZvciB0aGlzIGZ1bmN0aW9uYWxpdHkgbm93LlxuXHRcdCAqL1xuXHRcdFwiZm5TZXJ2ZXJEYXRhXCI6IG51bGwsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBfX0RlcHJlY2F0ZWRfXyBUaGUgZnVuY3Rpb25hbGl0eSBwcm92aWRlZCBieSB0aGlzIHBhcmFtZXRlciBoYXMgbm93IGJlZW5cblx0XHQgKiBzdXBlcnNlZGVkIGJ5IHRoYXQgcHJvdmlkZWQgdGhyb3VnaCBgYWpheGAsIHdoaWNoIHNob3VsZCBiZSB1c2VkIGluc3RlYWQuXG5cdFx0ICpcblx0XHQgKiAgSXQgaXMgb2Z0ZW4gdXNlZnVsIHRvIHNlbmQgZXh0cmEgZGF0YSB0byB0aGUgc2VydmVyIHdoZW4gbWFraW5nIGFuIEFqYXhcblx0XHQgKiByZXF1ZXN0IC0gZm9yIGV4YW1wbGUgY3VzdG9tIGZpbHRlcmluZyBpbmZvcm1hdGlvbiwgYW5kIHRoaXMgY2FsbGJhY2tcblx0XHQgKiBmdW5jdGlvbiBtYWtlcyBpdCB0cml2aWFsIHRvIHNlbmQgZXh0cmEgaW5mb3JtYXRpb24gdG8gdGhlIHNlcnZlci4gVGhlXG5cdFx0ICogcGFzc2VkIGluIHBhcmFtZXRlciBpcyB0aGUgZGF0YSBzZXQgdGhhdCBoYXMgYmVlbiBjb25zdHJ1Y3RlZCBieVxuXHRcdCAqIERhdGFUYWJsZXMsIGFuZCB5b3UgY2FuIGFkZCB0byB0aGlzIG9yIG1vZGlmeSBpdCBhcyB5b3UgcmVxdWlyZS5cblx0XHQgKiAgQHR5cGUgZnVuY3Rpb25cblx0XHQgKiAgQHBhcmFtIHthcnJheX0gZGF0YSBEYXRhIGFycmF5IChhcnJheSBvZiBvYmplY3RzIHdoaWNoIGFyZSBuYW1lL3ZhbHVlXG5cdFx0ICogICAgcGFpcnMpIHRoYXQgaGFzIGJlZW4gY29uc3RydWN0ZWQgYnkgRGF0YVRhYmxlcyBhbmQgd2lsbCBiZSBzZW50IHRvIHRoZVxuXHRcdCAqICAgIHNlcnZlci4gSW4gdGhlIGNhc2Ugb2YgQWpheCBzb3VyY2VkIGRhdGEgd2l0aCBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nXG5cdFx0ICogICAgdGhpcyB3aWxsIGJlIGFuIGVtcHR5IGFycmF5LCBmb3Igc2VydmVyLXNpZGUgcHJvY2Vzc2luZyB0aGVyZSB3aWxsIGJlIGFcblx0XHQgKiAgICBzaWduaWZpY2FudCBudW1iZXIgb2YgcGFyYW1ldGVycyFcblx0XHQgKiAgQHJldHVybnMge3VuZGVmaW5lZH0gRW5zdXJlIHRoYXQgeW91IG1vZGlmeSB0aGUgZGF0YSBhcnJheSBwYXNzZWQgaW4sXG5cdFx0ICogICAgYXMgdGhpcyBpcyBwYXNzZWQgYnkgcmVmZXJlbmNlLlxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBDYWxsYmFja3Ncblx0XHQgKiAgQGR0b3B0IFNlcnZlci1zaWRlXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5zZXJ2ZXJQYXJhbXNcblx0XHQgKlxuXHRcdCAqICBAZGVwcmVjYXRlZCAxLjEwLiBQbGVhc2UgdXNlIGBhamF4YCBmb3IgdGhpcyBmdW5jdGlvbmFsaXR5IG5vdy5cblx0XHQgKi9cblx0XHRcImZuU2VydmVyUGFyYW1zXCI6IG51bGwsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBMb2FkIHRoZSB0YWJsZSBzdGF0ZS4gV2l0aCB0aGlzIGZ1bmN0aW9uIHlvdSBjYW4gZGVmaW5lIGZyb20gd2hlcmUsIGFuZCBob3csIHRoZVxuXHRcdCAqIHN0YXRlIG9mIGEgdGFibGUgaXMgbG9hZGVkLiBCeSBkZWZhdWx0IERhdGFUYWJsZXMgd2lsbCBsb2FkIGZyb20gYGxvY2FsU3RvcmFnZWBcblx0XHQgKiBidXQgeW91IG1pZ2h0IHdpc2ggdG8gdXNlIGEgc2VydmVyLXNpZGUgZGF0YWJhc2Ugb3IgY29va2llcy5cblx0XHQgKiAgQHR5cGUgZnVuY3Rpb25cblx0XHQgKiAgQG1lbWJlclxuXHRcdCAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0XHQgKiAgQHBhcmFtIHtvYmplY3R9IGNhbGxiYWNrIENhbGxiYWNrIHRoYXQgY2FuIGJlIGV4ZWN1dGVkIHdoZW4gZG9uZS4gSXRcblx0XHQgKiAgICBzaG91bGQgYmUgcGFzc2VkIHRoZSBsb2FkZWQgc3RhdGUgb2JqZWN0LlxuXHRcdCAqICBAcmV0dXJuIHtvYmplY3R9IFRoZSBEYXRhVGFibGVzIHN0YXRlIG9iamVjdCB0byBiZSBsb2FkZWRcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgQ2FsbGJhY2tzXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5zdGF0ZUxvYWRDYWxsYmFja1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJzdGF0ZVNhdmVcIjogdHJ1ZSxcblx0XHQgKiAgICAgICAgXCJzdGF0ZUxvYWRDYWxsYmFja1wiOiBmdW5jdGlvbiAoc2V0dGluZ3MsIGNhbGxiYWNrKSB7XG5cdFx0ICogICAgICAgICAgJC5hamF4KCB7XG5cdFx0ICogICAgICAgICAgICBcInVybFwiOiBcIi9zdGF0ZV9sb2FkXCIsXG5cdFx0ICogICAgICAgICAgICBcImRhdGFUeXBlXCI6IFwianNvblwiLFxuXHRcdCAqICAgICAgICAgICAgXCJzdWNjZXNzXCI6IGZ1bmN0aW9uIChqc29uKSB7XG5cdFx0ICogICAgICAgICAgICAgIGNhbGxiYWNrKCBqc29uICk7XG5cdFx0ICogICAgICAgICAgICB9XG5cdFx0ICogICAgICAgICAgfSApO1xuXHRcdCAqICAgICAgICB9XG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiZm5TdGF0ZUxvYWRDYWxsYmFja1wiOiBmdW5jdGlvbiAoIHNldHRpbmdzICkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0cmV0dXJuIEpTT04ucGFyc2UoXG5cdFx0XHRcdFx0KHNldHRpbmdzLmlTdGF0ZUR1cmF0aW9uID09PSAtMSA/IHNlc3Npb25TdG9yYWdlIDogbG9jYWxTdG9yYWdlKS5nZXRJdGVtKFxuXHRcdFx0XHRcdFx0J0RhdGFUYWJsZXNfJytzZXR0aW5ncy5zSW5zdGFuY2UrJ18nK2xvY2F0aW9uLnBhdGhuYW1lXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHQpO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRyZXR1cm4ge307XG5cdFx0XHR9XG5cdFx0fSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIENhbGxiYWNrIHdoaWNoIGFsbG93cyBtb2RpZmljYXRpb24gb2YgdGhlIHNhdmVkIHN0YXRlIHByaW9yIHRvIGxvYWRpbmcgdGhhdCBzdGF0ZS5cblx0XHQgKiBUaGlzIGNhbGxiYWNrIGlzIGNhbGxlZCB3aGVuIHRoZSB0YWJsZSBpcyBsb2FkaW5nIHN0YXRlIGZyb20gdGhlIHN0b3JlZCBkYXRhLCBidXRcblx0XHQgKiBwcmlvciB0byB0aGUgc2V0dGluZ3Mgb2JqZWN0IGJlaW5nIG1vZGlmaWVkIGJ5IHRoZSBzYXZlZCBzdGF0ZS4gTm90ZSB0aGF0IGZvclxuXHRcdCAqIHBsdWctaW4gYXV0aG9ycywgeW91IHNob3VsZCB1c2UgdGhlIGBzdGF0ZUxvYWRQYXJhbXNgIGV2ZW50IHRvIGxvYWQgcGFyYW1ldGVycyBmb3Jcblx0XHQgKiBhIHBsdWctaW4uXG5cdFx0ICogIEB0eXBlIGZ1bmN0aW9uXG5cdFx0ICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHRcdCAqICBAcGFyYW0ge29iamVjdH0gZGF0YSBUaGUgc3RhdGUgb2JqZWN0IHRoYXQgaXMgdG8gYmUgbG9hZGVkXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IENhbGxiYWNrc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuc3RhdGVMb2FkUGFyYW1zXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBSZW1vdmUgYSBzYXZlZCBmaWx0ZXIsIHNvIGZpbHRlcmluZyBpcyBuZXZlciBsb2FkZWRcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcInN0YXRlU2F2ZVwiOiB0cnVlLFxuXHRcdCAqICAgICAgICBcInN0YXRlTG9hZFBhcmFtc1wiOiBmdW5jdGlvbiAoc2V0dGluZ3MsIGRhdGEpIHtcblx0XHQgKiAgICAgICAgICBkYXRhLm9TZWFyY2guc1NlYXJjaCA9IFwiXCI7XG5cdFx0ICogICAgICAgIH1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBEaXNhbGxvdyBzdGF0ZSBsb2FkaW5nIGJ5IHJldHVybmluZyBmYWxzZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwic3RhdGVTYXZlXCI6IHRydWUsXG5cdFx0ICogICAgICAgIFwic3RhdGVMb2FkUGFyYW1zXCI6IGZ1bmN0aW9uIChzZXR0aW5ncywgZGF0YSkge1xuXHRcdCAqICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0XHQgKiAgICAgICAgfVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcImZuU3RhdGVMb2FkUGFyYW1zXCI6IG51bGwsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBDYWxsYmFjayB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSBzdGF0ZSBoYXMgYmVlbiBsb2FkZWQgZnJvbSB0aGUgc3RhdGUgc2F2aW5nIG1ldGhvZFxuXHRcdCAqIGFuZCB0aGUgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3QgaGFzIGJlZW4gbW9kaWZpZWQgYXMgYSByZXN1bHQgb2YgdGhlIGxvYWRlZCBzdGF0ZS5cblx0XHQgKiAgQHR5cGUgZnVuY3Rpb25cblx0XHQgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdFx0ICogIEBwYXJhbSB7b2JqZWN0fSBkYXRhIFRoZSBzdGF0ZSBvYmplY3QgdGhhdCB3YXMgbG9hZGVkXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IENhbGxiYWNrc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuc3RhdGVMb2FkZWRcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIFNob3cgYW4gYWxlcnQgd2l0aCB0aGUgZmlsdGVyaW5nIHZhbHVlIHRoYXQgd2FzIHNhdmVkXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJzdGF0ZVNhdmVcIjogdHJ1ZSxcblx0XHQgKiAgICAgICAgXCJzdGF0ZUxvYWRlZFwiOiBmdW5jdGlvbiAoc2V0dGluZ3MsIGRhdGEpIHtcblx0XHQgKiAgICAgICAgICBhbGVydCggJ1NhdmVkIGZpbHRlciB3YXM6ICcrZGF0YS5vU2VhcmNoLnNTZWFyY2ggKTtcblx0XHQgKiAgICAgICAgfVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcImZuU3RhdGVMb2FkZWRcIjogbnVsbCxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFNhdmUgdGhlIHRhYmxlIHN0YXRlLiBUaGlzIGZ1bmN0aW9uIGFsbG93cyB5b3UgdG8gZGVmaW5lIHdoZXJlIGFuZCBob3cgdGhlIHN0YXRlXG5cdFx0ICogaW5mb3JtYXRpb24gZm9yIHRoZSB0YWJsZSBpcyBzdG9yZWQgQnkgZGVmYXVsdCBEYXRhVGFibGVzIHdpbGwgdXNlIGBsb2NhbFN0b3JhZ2VgXG5cdFx0ICogYnV0IHlvdSBtaWdodCB3aXNoIHRvIHVzZSBhIHNlcnZlci1zaWRlIGRhdGFiYXNlIG9yIGNvb2tpZXMuXG5cdFx0ICogIEB0eXBlIGZ1bmN0aW9uXG5cdFx0ICogIEBtZW1iZXJcblx0XHQgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdFx0ICogIEBwYXJhbSB7b2JqZWN0fSBkYXRhIFRoZSBzdGF0ZSBvYmplY3QgdG8gYmUgc2F2ZWRcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgQ2FsbGJhY2tzXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5zdGF0ZVNhdmVDYWxsYmFja1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJzdGF0ZVNhdmVcIjogdHJ1ZSxcblx0XHQgKiAgICAgICAgXCJzdGF0ZVNhdmVDYWxsYmFja1wiOiBmdW5jdGlvbiAoc2V0dGluZ3MsIGRhdGEpIHtcblx0XHQgKiAgICAgICAgICAvLyBTZW5kIGFuIEFqYXggcmVxdWVzdCB0byB0aGUgc2VydmVyIHdpdGggdGhlIHN0YXRlIG9iamVjdFxuXHRcdCAqICAgICAgICAgICQuYWpheCgge1xuXHRcdCAqICAgICAgICAgICAgXCJ1cmxcIjogXCIvc3RhdGVfc2F2ZVwiLFxuXHRcdCAqICAgICAgICAgICAgXCJkYXRhXCI6IGRhdGEsXG5cdFx0ICogICAgICAgICAgICBcImRhdGFUeXBlXCI6IFwianNvblwiLFxuXHRcdCAqICAgICAgICAgICAgXCJtZXRob2RcIjogXCJQT1NUXCJcblx0XHQgKiAgICAgICAgICAgIFwic3VjY2Vzc1wiOiBmdW5jdGlvbiAoKSB7fVxuXHRcdCAqICAgICAgICAgIH0gKTtcblx0XHQgKiAgICAgICAgfVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcImZuU3RhdGVTYXZlQ2FsbGJhY2tcIjogZnVuY3Rpb24gKCBzZXR0aW5ncywgZGF0YSApIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdChzZXR0aW5ncy5pU3RhdGVEdXJhdGlvbiA9PT0gLTEgPyBzZXNzaW9uU3RvcmFnZSA6IGxvY2FsU3RvcmFnZSkuc2V0SXRlbShcblx0XHRcdFx0XHQnRGF0YVRhYmxlc18nK3NldHRpbmdzLnNJbnN0YW5jZSsnXycrbG9jYXRpb24ucGF0aG5hbWUsXG5cdFx0XHRcdFx0SlNPTi5zdHJpbmdpZnkoIGRhdGEgKVxuXHRcdFx0XHQpO1xuXHRcdFx0fSBjYXRjaCAoZSkge31cblx0XHR9LFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogQ2FsbGJhY2sgd2hpY2ggYWxsb3dzIG1vZGlmaWNhdGlvbiBvZiB0aGUgc3RhdGUgdG8gYmUgc2F2ZWQuIENhbGxlZCB3aGVuIHRoZSB0YWJsZVxuXHRcdCAqIGhhcyBjaGFuZ2VkIHN0YXRlIGEgbmV3IHN0YXRlIHNhdmUgaXMgcmVxdWlyZWQuIFRoaXMgbWV0aG9kIGFsbG93cyBtb2RpZmljYXRpb24gb2Zcblx0XHQgKiB0aGUgc3RhdGUgc2F2aW5nIG9iamVjdCBwcmlvciB0byBhY3R1YWxseSBkb2luZyB0aGUgc2F2ZSwgaW5jbHVkaW5nIGFkZGl0aW9uIG9yXG5cdFx0ICogb3RoZXIgc3RhdGUgcHJvcGVydGllcyBvciBtb2RpZmljYXRpb24uIE5vdGUgdGhhdCBmb3IgcGx1Zy1pbiBhdXRob3JzLCB5b3Ugc2hvdWxkXG5cdFx0ICogdXNlIHRoZSBgc3RhdGVTYXZlUGFyYW1zYCBldmVudCB0byBzYXZlIHBhcmFtZXRlcnMgZm9yIGEgcGx1Zy1pbi5cblx0XHQgKiAgQHR5cGUgZnVuY3Rpb25cblx0XHQgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdFx0ICogIEBwYXJhbSB7b2JqZWN0fSBkYXRhIFRoZSBzdGF0ZSBvYmplY3QgdG8gYmUgc2F2ZWRcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgQ2FsbGJhY2tzXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5zdGF0ZVNhdmVQYXJhbXNcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIFJlbW92ZSBhIHNhdmVkIGZpbHRlciwgc28gZmlsdGVyaW5nIGlzIG5ldmVyIHNhdmVkXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJzdGF0ZVNhdmVcIjogdHJ1ZSxcblx0XHQgKiAgICAgICAgXCJzdGF0ZVNhdmVQYXJhbXNcIjogZnVuY3Rpb24gKHNldHRpbmdzLCBkYXRhKSB7XG5cdFx0ICogICAgICAgICAgZGF0YS5vU2VhcmNoLnNTZWFyY2ggPSBcIlwiO1xuXHRcdCAqICAgICAgICB9XG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiZm5TdGF0ZVNhdmVQYXJhbXNcIjogbnVsbCxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIER1cmF0aW9uIGZvciB3aGljaCB0aGUgc2F2ZWQgc3RhdGUgaW5mb3JtYXRpb24gaXMgY29uc2lkZXJlZCB2YWxpZC4gQWZ0ZXIgdGhpcyBwZXJpb2Rcblx0XHQgKiBoYXMgZWxhcHNlZCB0aGUgc3RhdGUgd2lsbCBiZSByZXR1cm5lZCB0byB0aGUgZGVmYXVsdC5cblx0XHQgKiBWYWx1ZSBpcyBnaXZlbiBpbiBzZWNvbmRzLlxuXHRcdCAqICBAdHlwZSBpbnRcblx0XHQgKiAgQGRlZmF1bHQgNzIwMCA8aT4oMiBob3Vycyk8L2k+XG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IE9wdGlvbnNcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnN0YXRlRHVyYXRpb25cblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwic3RhdGVEdXJhdGlvblwiOiA2MCo2MCoyNDsgLy8gMSBkYXlcblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9IClcblx0XHQgKi9cblx0XHRcImlTdGF0ZUR1cmF0aW9uXCI6IDcyMDAsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBXaGVuIGVuYWJsZWQgRGF0YVRhYmxlcyB3aWxsIG5vdCBtYWtlIGEgcmVxdWVzdCB0byB0aGUgc2VydmVyIGZvciB0aGUgZmlyc3Rcblx0XHQgKiBwYWdlIGRyYXcgLSByYXRoZXIgaXQgd2lsbCB1c2UgdGhlIGRhdGEgYWxyZWFkeSBvbiB0aGUgcGFnZSAobm8gc29ydGluZyBldGNcblx0XHQgKiB3aWxsIGJlIGFwcGxpZWQgdG8gaXQpLCB0aHVzIHNhdmluZyBvbiBhbiBYSFIgYXQgbG9hZCB0aW1lLiBgZGVmZXJMb2FkaW5nYFxuXHRcdCAqIGlzIHVzZWQgdG8gaW5kaWNhdGUgdGhhdCBkZWZlcnJlZCBsb2FkaW5nIGlzIHJlcXVpcmVkLCBidXQgaXQgaXMgYWxzbyB1c2VkXG5cdFx0ICogdG8gdGVsbCBEYXRhVGFibGVzIGhvdyBtYW55IHJlY29yZHMgdGhlcmUgYXJlIGluIHRoZSBmdWxsIHRhYmxlIChhbGxvd2luZ1xuXHRcdCAqIHRoZSBpbmZvcm1hdGlvbiBlbGVtZW50IGFuZCBwYWdpbmF0aW9uIHRvIGJlIGRpc3BsYXllZCBjb3JyZWN0bHkpLiBJbiB0aGUgY2FzZVxuXHRcdCAqIHdoZXJlIGEgZmlsdGVyaW5nIGlzIGFwcGxpZWQgdG8gdGhlIHRhYmxlIG9uIGluaXRpYWwgbG9hZCwgdGhpcyBjYW4gYmVcblx0XHQgKiBpbmRpY2F0ZWQgYnkgZ2l2aW5nIHRoZSBwYXJhbWV0ZXIgYXMgYW4gYXJyYXksIHdoZXJlIHRoZSBmaXJzdCBlbGVtZW50IGlzXG5cdFx0ICogdGhlIG51bWJlciBvZiByZWNvcmRzIGF2YWlsYWJsZSBhZnRlciBmaWx0ZXJpbmcgYW5kIHRoZSBzZWNvbmQgZWxlbWVudCBpcyB0aGVcblx0XHQgKiBudW1iZXIgb2YgcmVjb3JkcyB3aXRob3V0IGZpbHRlcmluZyAoYWxsb3dpbmcgdGhlIHRhYmxlIGluZm9ybWF0aW9uIGVsZW1lbnRcblx0XHQgKiB0byBiZSBzaG93biBjb3JyZWN0bHkpLlxuXHRcdCAqICBAdHlwZSBpbnQgfCBhcnJheVxuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IE9wdGlvbnNcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmRlZmVyTG9hZGluZ1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gNTcgcmVjb3JkcyBhdmFpbGFibGUgaW4gdGhlIHRhYmxlLCBubyBmaWx0ZXJpbmcgYXBwbGllZFxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwic2VydmVyU2lkZVwiOiB0cnVlLFxuXHRcdCAqICAgICAgICBcImFqYXhcIjogXCJzY3JpcHRzL3NlcnZlcl9wcm9jZXNzaW5nLnBocFwiLFxuXHRcdCAqICAgICAgICBcImRlZmVyTG9hZGluZ1wiOiA1N1xuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIDU3IHJlY29yZHMgYWZ0ZXIgZmlsdGVyaW5nLCAxMDAgd2l0aG91dCBmaWx0ZXJpbmcgKGFuIGluaXRpYWwgZmlsdGVyIGFwcGxpZWQpXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJzZXJ2ZXJTaWRlXCI6IHRydWUsXG5cdFx0ICogICAgICAgIFwiYWpheFwiOiBcInNjcmlwdHMvc2VydmVyX3Byb2Nlc3NpbmcucGhwXCIsXG5cdFx0ICogICAgICAgIFwiZGVmZXJMb2FkaW5nXCI6IFsgNTcsIDEwMCBdLFxuXHRcdCAqICAgICAgICBcInNlYXJjaFwiOiB7XG5cdFx0ICogICAgICAgICAgXCJzZWFyY2hcIjogXCJteV9maWx0ZXJcIlxuXHRcdCAqICAgICAgICB9XG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiaURlZmVyTG9hZGluZ1wiOiBudWxsLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogTnVtYmVyIG9mIHJvd3MgdG8gZGlzcGxheSBvbiBhIHNpbmdsZSBwYWdlIHdoZW4gdXNpbmcgcGFnaW5hdGlvbi4gSWZcblx0XHQgKiBmZWF0dXJlIGVuYWJsZWQgKGBsZW5ndGhDaGFuZ2VgKSB0aGVuIHRoZSBlbmQgdXNlciB3aWxsIGJlIGFibGUgdG8gb3ZlcnJpZGVcblx0XHQgKiB0aGlzIHRvIGEgY3VzdG9tIHNldHRpbmcgdXNpbmcgYSBwb3AtdXAgbWVudS5cblx0XHQgKiAgQHR5cGUgaW50XG5cdFx0ICogIEBkZWZhdWx0IDEwXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IE9wdGlvbnNcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnBhZ2VMZW5ndGhcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwicGFnZUxlbmd0aFwiOiA1MFxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKVxuXHRcdCAqL1xuXHRcdFwiaURpc3BsYXlMZW5ndGhcIjogMTAsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBEZWZpbmUgdGhlIHN0YXJ0aW5nIHBvaW50IGZvciBkYXRhIGRpc3BsYXkgd2hlbiB1c2luZyBEYXRhVGFibGVzIHdpdGhcblx0XHQgKiBwYWdpbmF0aW9uLiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgaXMgdGhlIG51bWJlciBvZiByZWNvcmRzLCByYXRoZXIgdGhhblxuXHRcdCAqIHRoZSBwYWdlIG51bWJlciwgc28gaWYgeW91IGhhdmUgMTAgcmVjb3JkcyBwZXIgcGFnZSBhbmQgd2FudCB0byBzdGFydCBvblxuXHRcdCAqIHRoZSB0aGlyZCBwYWdlLCBpdCBzaG91bGQgYmUgXCIyMFwiLlxuXHRcdCAqICBAdHlwZSBpbnRcblx0XHQgKiAgQGRlZmF1bHQgMFxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBPcHRpb25zXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5kaXNwbGF5U3RhcnRcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwiZGlzcGxheVN0YXJ0XCI6IDIwXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApXG5cdFx0ICovXG5cdFx0XCJpRGlzcGxheVN0YXJ0XCI6IDAsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBCeSBkZWZhdWx0IERhdGFUYWJsZXMgYWxsb3dzIGtleWJvYXJkIG5hdmlnYXRpb24gb2YgdGhlIHRhYmxlIChzb3J0aW5nLCBwYWdpbmcsXG5cdFx0ICogYW5kIGZpbHRlcmluZykgYnkgYWRkaW5nIGEgYHRhYmluZGV4YCBhdHRyaWJ1dGUgdG8gdGhlIHJlcXVpcmVkIGVsZW1lbnRzLiBUaGlzXG5cdFx0ICogYWxsb3dzIHlvdSB0byB0YWIgdGhyb3VnaCB0aGUgY29udHJvbHMgYW5kIHByZXNzIHRoZSBlbnRlciBrZXkgdG8gYWN0aXZhdGUgdGhlbS5cblx0XHQgKiBUaGUgdGFiaW5kZXggaXMgZGVmYXVsdCAwLCBtZWFuaW5nIHRoYXQgdGhlIHRhYiBmb2xsb3dzIHRoZSBmbG93IG9mIHRoZSBkb2N1bWVudC5cblx0XHQgKiBZb3UgY2FuIG92ZXJydWxlIHRoaXMgdXNpbmcgdGhpcyBwYXJhbWV0ZXIgaWYgeW91IHdpc2guIFVzZSBhIHZhbHVlIG9mIC0xIHRvXG5cdFx0ICogZGlzYWJsZSBidWlsdC1pbiBrZXlib2FyZCBuYXZpZ2F0aW9uLlxuXHRcdCAqICBAdHlwZSBpbnRcblx0XHQgKiAgQGRlZmF1bHQgMFxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBPcHRpb25zXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy50YWJJbmRleFxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJ0YWJJbmRleFwiOiAxXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiaVRhYkluZGV4XCI6IDAsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBDbGFzc2VzIHRoYXQgRGF0YVRhYmxlcyBhc3NpZ25zIHRvIHRoZSB2YXJpb3VzIGNvbXBvbmVudHMgYW5kIGZlYXR1cmVzXG5cdFx0ICogdGhhdCBpdCBhZGRzIHRvIHRoZSBIVE1MIHRhYmxlLiBUaGlzIGFsbG93cyBjbGFzc2VzIHRvIGJlIGNvbmZpZ3VyZWRcblx0XHQgKiBkdXJpbmcgaW5pdGlhbGlzYXRpb24gaW4gYWRkaXRpb24gdG8gdGhyb3VnaCB0aGUgc3RhdGljXG5cdFx0ICoge0BsaW5rIERhdGFUYWJsZS5leHQub1N0ZENsYXNzZXN9IG9iamVjdCkuXG5cdFx0ICogIEBuYW1lc3BhY2Vcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmNsYXNzZXNcblx0XHQgKi9cblx0XHRcIm9DbGFzc2VzXCI6IHt9LFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogQWxsIHN0cmluZ3MgdGhhdCBEYXRhVGFibGVzIHVzZXMgaW4gdGhlIHVzZXIgaW50ZXJmYWNlIHRoYXQgaXQgY3JlYXRlc1xuXHRcdCAqIGFyZSBkZWZpbmVkIGluIHRoaXMgb2JqZWN0LCBhbGxvd2luZyB5b3UgdG8gbW9kaWZpZWQgdGhlbSBpbmRpdmlkdWFsbHkgb3Jcblx0XHQgKiBjb21wbGV0ZWx5IHJlcGxhY2UgdGhlbSBhbGwgYXMgcmVxdWlyZWQuXG5cdFx0ICogIEBuYW1lc3BhY2Vcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlXG5cdFx0ICovXG5cdFx0XCJvTGFuZ3VhZ2VcIjoge1xuXHRcdFx0LyoqXG5cdFx0XHQgKiBTdHJpbmdzIHRoYXQgYXJlIHVzZWQgZm9yIFdBSS1BUklBIGxhYmVscyBhbmQgY29udHJvbHMgb25seSAodGhlc2UgYXJlIG5vdFxuXHRcdFx0ICogYWN0dWFsbHkgdmlzaWJsZSBvbiB0aGUgcGFnZSwgYnV0IHdpbGwgYmUgcmVhZCBieSBzY3JlZW5yZWFkZXJzLCBhbmQgdGh1c1xuXHRcdFx0ICogbXVzdCBiZSBpbnRlcm5hdGlvbmFsaXNlZCBhcyB3ZWxsKS5cblx0XHRcdCAqICBAbmFtZXNwYWNlXG5cdFx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLmFyaWFcblx0XHRcdCAqL1xuXHRcdFx0XCJvQXJpYVwiOiB7XG5cdFx0XHRcdC8qKlxuXHRcdFx0XHQgKiBBUklBIGxhYmVsIHRoYXQgaXMgYWRkZWQgdG8gdGhlIHRhYmxlIGhlYWRlcnMgd2hlbiB0aGUgY29sdW1uIG1heSBiZVxuXHRcdFx0XHQgKiBzb3J0ZWQgYXNjZW5kaW5nIGJ5IGFjdGl2aW5nIHRoZSBjb2x1bW4gKGNsaWNrIG9yIHJldHVybiB3aGVuIGZvY3VzZWQpLlxuXHRcdFx0XHQgKiBOb3RlIHRoYXQgdGhlIGNvbHVtbiBoZWFkZXIgaXMgcHJlZml4ZWQgdG8gdGhpcyBzdHJpbmcuXG5cdFx0XHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHRcdFx0ICogIEBkZWZhdWx0IDogYWN0aXZhdGUgdG8gc29ydCBjb2x1bW4gYXNjZW5kaW5nXG5cdFx0XHRcdCAqXG5cdFx0XHRcdCAqICBAZHRvcHQgTGFuZ3VhZ2Vcblx0XHRcdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sYW5ndWFnZS5hcmlhLnNvcnRBc2NlbmRpbmdcblx0XHRcdFx0ICpcblx0XHRcdFx0ICogIEBleGFtcGxlXG5cdFx0XHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdFx0XHQgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XG5cdFx0XHRcdCAqICAgICAgICAgIFwiYXJpYVwiOiB7XG5cdFx0XHRcdCAqICAgICAgICAgICAgXCJzb3J0QXNjZW5kaW5nXCI6IFwiIC0gY2xpY2svcmV0dXJuIHRvIHNvcnQgYXNjZW5kaW5nXCJcblx0XHRcdFx0ICogICAgICAgICAgfVxuXHRcdFx0XHQgKiAgICAgICAgfVxuXHRcdFx0XHQgKiAgICAgIH0gKTtcblx0XHRcdFx0ICogICAgfSApO1xuXHRcdFx0XHQgKi9cblx0XHRcdFx0XCJzU29ydEFzY2VuZGluZ1wiOiBcIjogYWN0aXZhdGUgdG8gc29ydCBjb2x1bW4gYXNjZW5kaW5nXCIsXG5cdFxuXHRcdFx0XHQvKipcblx0XHRcdFx0ICogQVJJQSBsYWJlbCB0aGF0IGlzIGFkZGVkIHRvIHRoZSB0YWJsZSBoZWFkZXJzIHdoZW4gdGhlIGNvbHVtbiBtYXkgYmVcblx0XHRcdFx0ICogc29ydGVkIGRlc2NlbmRpbmcgYnkgYWN0aXZpbmcgdGhlIGNvbHVtbiAoY2xpY2sgb3IgcmV0dXJuIHdoZW4gZm9jdXNlZCkuXG5cdFx0XHRcdCAqIE5vdGUgdGhhdCB0aGUgY29sdW1uIGhlYWRlciBpcyBwcmVmaXhlZCB0byB0aGlzIHN0cmluZy5cblx0XHRcdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdFx0XHQgKiAgQGRlZmF1bHQgOiBhY3RpdmF0ZSB0byBzb3J0IGNvbHVtbiBhc2NlbmRpbmdcblx0XHRcdFx0ICpcblx0XHRcdFx0ICogIEBkdG9wdCBMYW5ndWFnZVxuXHRcdFx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLmFyaWEuc29ydERlc2NlbmRpbmdcblx0XHRcdFx0ICpcblx0XHRcdFx0ICogIEBleGFtcGxlXG5cdFx0XHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdFx0XHQgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XG5cdFx0XHRcdCAqICAgICAgICAgIFwiYXJpYVwiOiB7XG5cdFx0XHRcdCAqICAgICAgICAgICAgXCJzb3J0RGVzY2VuZGluZ1wiOiBcIiAtIGNsaWNrL3JldHVybiB0byBzb3J0IGRlc2NlbmRpbmdcIlxuXHRcdFx0XHQgKiAgICAgICAgICB9XG5cdFx0XHRcdCAqICAgICAgICB9XG5cdFx0XHRcdCAqICAgICAgfSApO1xuXHRcdFx0XHQgKiAgICB9ICk7XG5cdFx0XHRcdCAqL1xuXHRcdFx0XHRcInNTb3J0RGVzY2VuZGluZ1wiOiBcIjogYWN0aXZhdGUgdG8gc29ydCBjb2x1bW4gZGVzY2VuZGluZ1wiXG5cdFx0XHR9LFxuXHRcblx0XHRcdC8qKlxuXHRcdFx0ICogUGFnaW5hdGlvbiBzdHJpbmcgdXNlZCBieSBEYXRhVGFibGVzIGZvciB0aGUgYnVpbHQtaW4gcGFnaW5hdGlvblxuXHRcdFx0ICogY29udHJvbCB0eXBlcy5cblx0XHRcdCAqICBAbmFtZXNwYWNlXG5cdFx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLnBhZ2luYXRlXG5cdFx0XHQgKi9cblx0XHRcdFwib1BhZ2luYXRlXCI6IHtcblx0XHRcdFx0LyoqXG5cdFx0XHRcdCAqIFRleHQgdG8gdXNlIHdoZW4gdXNpbmcgdGhlICdmdWxsX251bWJlcnMnIHR5cGUgb2YgcGFnaW5hdGlvbiBmb3IgdGhlXG5cdFx0XHRcdCAqIGJ1dHRvbiB0byB0YWtlIHRoZSB1c2VyIHRvIHRoZSBmaXJzdCBwYWdlLlxuXHRcdFx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0XHRcdCAqICBAZGVmYXVsdCBGaXJzdFxuXHRcdFx0XHQgKlxuXHRcdFx0XHQgKiAgQGR0b3B0IExhbmd1YWdlXG5cdFx0XHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2UucGFnaW5hdGUuZmlyc3Rcblx0XHRcdFx0ICpcblx0XHRcdFx0ICogIEBleGFtcGxlXG5cdFx0XHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdFx0XHQgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XG5cdFx0XHRcdCAqICAgICAgICAgIFwicGFnaW5hdGVcIjoge1xuXHRcdFx0XHQgKiAgICAgICAgICAgIFwiZmlyc3RcIjogXCJGaXJzdCBwYWdlXCJcblx0XHRcdFx0ICogICAgICAgICAgfVxuXHRcdFx0XHQgKiAgICAgICAgfVxuXHRcdFx0XHQgKiAgICAgIH0gKTtcblx0XHRcdFx0ICogICAgfSApO1xuXHRcdFx0XHQgKi9cblx0XHRcdFx0XCJzRmlyc3RcIjogXCJGaXJzdFwiLFxuXHRcblx0XG5cdFx0XHRcdC8qKlxuXHRcdFx0XHQgKiBUZXh0IHRvIHVzZSB3aGVuIHVzaW5nIHRoZSAnZnVsbF9udW1iZXJzJyB0eXBlIG9mIHBhZ2luYXRpb24gZm9yIHRoZVxuXHRcdFx0XHQgKiBidXR0b24gdG8gdGFrZSB0aGUgdXNlciB0byB0aGUgbGFzdCBwYWdlLlxuXHRcdFx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0XHRcdCAqICBAZGVmYXVsdCBMYXN0XG5cdFx0XHRcdCAqXG5cdFx0XHRcdCAqICBAZHRvcHQgTGFuZ3VhZ2Vcblx0XHRcdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sYW5ndWFnZS5wYWdpbmF0ZS5sYXN0XG5cdFx0XHRcdCAqXG5cdFx0XHRcdCAqICBAZXhhbXBsZVxuXHRcdFx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHRcdFx0ICogICAgICAgIFwibGFuZ3VhZ2VcIjoge1xuXHRcdFx0XHQgKiAgICAgICAgICBcInBhZ2luYXRlXCI6IHtcblx0XHRcdFx0ICogICAgICAgICAgICBcImxhc3RcIjogXCJMYXN0IHBhZ2VcIlxuXHRcdFx0XHQgKiAgICAgICAgICB9XG5cdFx0XHRcdCAqICAgICAgICB9XG5cdFx0XHRcdCAqICAgICAgfSApO1xuXHRcdFx0XHQgKiAgICB9ICk7XG5cdFx0XHRcdCAqL1xuXHRcdFx0XHRcInNMYXN0XCI6IFwiTGFzdFwiLFxuXHRcblx0XG5cdFx0XHRcdC8qKlxuXHRcdFx0XHQgKiBUZXh0IHRvIHVzZSBmb3IgdGhlICduZXh0JyBwYWdpbmF0aW9uIGJ1dHRvbiAodG8gdGFrZSB0aGUgdXNlciB0byB0aGVcblx0XHRcdFx0ICogbmV4dCBwYWdlKS5cblx0XHRcdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdFx0XHQgKiAgQGRlZmF1bHQgTmV4dFxuXHRcdFx0XHQgKlxuXHRcdFx0XHQgKiAgQGR0b3B0IExhbmd1YWdlXG5cdFx0XHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2UucGFnaW5hdGUubmV4dFxuXHRcdFx0XHQgKlxuXHRcdFx0XHQgKiAgQGV4YW1wbGVcblx0XHRcdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0XHRcdCAqICAgICAgICBcImxhbmd1YWdlXCI6IHtcblx0XHRcdFx0ICogICAgICAgICAgXCJwYWdpbmF0ZVwiOiB7XG5cdFx0XHRcdCAqICAgICAgICAgICAgXCJuZXh0XCI6IFwiTmV4dCBwYWdlXCJcblx0XHRcdFx0ICogICAgICAgICAgfVxuXHRcdFx0XHQgKiAgICAgICAgfVxuXHRcdFx0XHQgKiAgICAgIH0gKTtcblx0XHRcdFx0ICogICAgfSApO1xuXHRcdFx0XHQgKi9cblx0XHRcdFx0XCJzTmV4dFwiOiBcIk5leHRcIixcblx0XG5cdFxuXHRcdFx0XHQvKipcblx0XHRcdFx0ICogVGV4dCB0byB1c2UgZm9yIHRoZSAncHJldmlvdXMnIHBhZ2luYXRpb24gYnV0dG9uICh0byB0YWtlIHRoZSB1c2VyIHRvXG5cdFx0XHRcdCAqIHRoZSBwcmV2aW91cyBwYWdlKS5cblx0XHRcdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdFx0XHQgKiAgQGRlZmF1bHQgUHJldmlvdXNcblx0XHRcdFx0ICpcblx0XHRcdFx0ICogIEBkdG9wdCBMYW5ndWFnZVxuXHRcdFx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLnBhZ2luYXRlLnByZXZpb3VzXG5cdFx0XHRcdCAqXG5cdFx0XHRcdCAqICBAZXhhbXBsZVxuXHRcdFx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHRcdFx0ICogICAgICAgIFwibGFuZ3VhZ2VcIjoge1xuXHRcdFx0XHQgKiAgICAgICAgICBcInBhZ2luYXRlXCI6IHtcblx0XHRcdFx0ICogICAgICAgICAgICBcInByZXZpb3VzXCI6IFwiUHJldmlvdXMgcGFnZVwiXG5cdFx0XHRcdCAqICAgICAgICAgIH1cblx0XHRcdFx0ICogICAgICAgIH1cblx0XHRcdFx0ICogICAgICB9ICk7XG5cdFx0XHRcdCAqICAgIH0gKTtcblx0XHRcdFx0ICovXG5cdFx0XHRcdFwic1ByZXZpb3VzXCI6IFwiUHJldmlvdXNcIlxuXHRcdFx0fSxcblx0XG5cdFx0XHQvKipcblx0XHRcdCAqIFRoaXMgc3RyaW5nIGlzIHNob3duIGluIHByZWZlcmVuY2UgdG8gYHplcm9SZWNvcmRzYCB3aGVuIHRoZSB0YWJsZSBpc1xuXHRcdFx0ICogZW1wdHkgb2YgZGF0YSAocmVnYXJkbGVzcyBvZiBmaWx0ZXJpbmcpLiBOb3RlIHRoYXQgdGhpcyBpcyBhbiBvcHRpb25hbFxuXHRcdFx0ICogcGFyYW1ldGVyIC0gaWYgaXQgaXMgbm90IGdpdmVuLCB0aGUgdmFsdWUgb2YgYHplcm9SZWNvcmRzYCB3aWxsIGJlIHVzZWRcblx0XHRcdCAqIGluc3RlYWQgKGVpdGhlciB0aGUgZGVmYXVsdCBvciBnaXZlbiB2YWx1ZSkuXG5cdFx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0XHQgKiAgQGRlZmF1bHQgTm8gZGF0YSBhdmFpbGFibGUgaW4gdGFibGVcblx0XHRcdCAqXG5cdFx0XHQgKiAgQGR0b3B0IExhbmd1YWdlXG5cdFx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLmVtcHR5VGFibGVcblx0XHRcdCAqXG5cdFx0XHQgKiAgQGV4YW1wbGVcblx0XHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHRcdCAqICAgICAgICBcImxhbmd1YWdlXCI6IHtcblx0XHRcdCAqICAgICAgICAgIFwiZW1wdHlUYWJsZVwiOiBcIk5vIGRhdGEgYXZhaWxhYmxlIGluIHRhYmxlXCJcblx0XHRcdCAqICAgICAgICB9XG5cdFx0XHQgKiAgICAgIH0gKTtcblx0XHRcdCAqICAgIH0gKTtcblx0XHRcdCAqL1xuXHRcdFx0XCJzRW1wdHlUYWJsZVwiOiBcIk5vIGRhdGEgYXZhaWxhYmxlIGluIHRhYmxlXCIsXG5cdFxuXHRcblx0XHRcdC8qKlxuXHRcdFx0ICogVGhpcyBzdHJpbmcgZ2l2ZXMgaW5mb3JtYXRpb24gdG8gdGhlIGVuZCB1c2VyIGFib3V0IHRoZSBpbmZvcm1hdGlvblxuXHRcdFx0ICogdGhhdCBpcyBjdXJyZW50IG9uIGRpc3BsYXkgb24gdGhlIHBhZ2UuIFRoZSBmb2xsb3dpbmcgdG9rZW5zIGNhbiBiZVxuXHRcdFx0ICogdXNlZCBpbiB0aGUgc3RyaW5nIGFuZCB3aWxsIGJlIGR5bmFtaWNhbGx5IHJlcGxhY2VkIGFzIHRoZSB0YWJsZVxuXHRcdFx0ICogZGlzcGxheSB1cGRhdGVzLiBUaGlzIHRva2VucyBjYW4gYmUgcGxhY2VkIGFueXdoZXJlIGluIHRoZSBzdHJpbmcsIG9yXG5cdFx0XHQgKiByZW1vdmVkIGFzIG5lZWRlZCBieSB0aGUgbGFuZ3VhZ2UgcmVxdWlyZXM6XG5cdFx0XHQgKlxuXHRcdFx0ICogKiBgXFxfU1RBUlRcXF9gIC0gRGlzcGxheSBpbmRleCBvZiB0aGUgZmlyc3QgcmVjb3JkIG9uIHRoZSBjdXJyZW50IHBhZ2Vcblx0XHRcdCAqICogYFxcX0VORFxcX2AgLSBEaXNwbGF5IGluZGV4IG9mIHRoZSBsYXN0IHJlY29yZCBvbiB0aGUgY3VycmVudCBwYWdlXG5cdFx0XHQgKiAqIGBcXF9UT1RBTFxcX2AgLSBOdW1iZXIgb2YgcmVjb3JkcyBpbiB0aGUgdGFibGUgYWZ0ZXIgZmlsdGVyaW5nXG5cdFx0XHQgKiAqIGBcXF9NQVhcXF9gIC0gTnVtYmVyIG9mIHJlY29yZHMgaW4gdGhlIHRhYmxlIHdpdGhvdXQgZmlsdGVyaW5nXG5cdFx0XHQgKiAqIGBcXF9QQUdFXFxfYCAtIEN1cnJlbnQgcGFnZSBudW1iZXJcblx0XHRcdCAqICogYFxcX1BBR0VTXFxfYCAtIFRvdGFsIG51bWJlciBvZiBwYWdlcyBvZiBkYXRhIGluIHRoZSB0YWJsZVxuXHRcdFx0ICpcblx0XHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHRcdCAqICBAZGVmYXVsdCBTaG93aW5nIF9TVEFSVF8gdG8gX0VORF8gb2YgX1RPVEFMXyBlbnRyaWVzXG5cdFx0XHQgKlxuXHRcdFx0ICogIEBkdG9wdCBMYW5ndWFnZVxuXHRcdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sYW5ndWFnZS5pbmZvXG5cdFx0XHQgKlxuXHRcdFx0ICogIEBleGFtcGxlXG5cdFx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0XHQgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XG5cdFx0XHQgKiAgICAgICAgICBcImluZm9cIjogXCJTaG93aW5nIHBhZ2UgX1BBR0VfIG9mIF9QQUdFU19cIlxuXHRcdFx0ICogICAgICAgIH1cblx0XHRcdCAqICAgICAgfSApO1xuXHRcdFx0ICogICAgfSApO1xuXHRcdFx0ICovXG5cdFx0XHRcInNJbmZvXCI6IFwiU2hvd2luZyBfU1RBUlRfIHRvIF9FTkRfIG9mIF9UT1RBTF8gZW50cmllc1wiLFxuXHRcblx0XG5cdFx0XHQvKipcblx0XHRcdCAqIERpc3BsYXkgaW5mb3JtYXRpb24gc3RyaW5nIGZvciB3aGVuIHRoZSB0YWJsZSBpcyBlbXB0eS4gVHlwaWNhbGx5IHRoZVxuXHRcdFx0ICogZm9ybWF0IG9mIHRoaXMgc3RyaW5nIHNob3VsZCBtYXRjaCBgaW5mb2AuXG5cdFx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0XHQgKiAgQGRlZmF1bHQgU2hvd2luZyAwIHRvIDAgb2YgMCBlbnRyaWVzXG5cdFx0XHQgKlxuXHRcdFx0ICogIEBkdG9wdCBMYW5ndWFnZVxuXHRcdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sYW5ndWFnZS5pbmZvRW1wdHlcblx0XHRcdCAqXG5cdFx0XHQgKiAgQGV4YW1wbGVcblx0XHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHRcdCAqICAgICAgICBcImxhbmd1YWdlXCI6IHtcblx0XHRcdCAqICAgICAgICAgIFwiaW5mb0VtcHR5XCI6IFwiTm8gZW50cmllcyB0byBzaG93XCJcblx0XHRcdCAqICAgICAgICB9XG5cdFx0XHQgKiAgICAgIH0gKTtcblx0XHRcdCAqICAgIH0gKTtcblx0XHRcdCAqL1xuXHRcdFx0XCJzSW5mb0VtcHR5XCI6IFwiU2hvd2luZyAwIHRvIDAgb2YgMCBlbnRyaWVzXCIsXG5cdFxuXHRcblx0XHRcdC8qKlxuXHRcdFx0ICogV2hlbiBhIHVzZXIgZmlsdGVycyB0aGUgaW5mb3JtYXRpb24gaW4gYSB0YWJsZSwgdGhpcyBzdHJpbmcgaXMgYXBwZW5kZWRcblx0XHRcdCAqIHRvIHRoZSBpbmZvcm1hdGlvbiAoYGluZm9gKSB0byBnaXZlIGFuIGlkZWEgb2YgaG93IHN0cm9uZyB0aGUgZmlsdGVyaW5nXG5cdFx0XHQgKiBpcy4gVGhlIHZhcmlhYmxlIF9NQVhfIGlzIGR5bmFtaWNhbGx5IHVwZGF0ZWQuXG5cdFx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0XHQgKiAgQGRlZmF1bHQgKGZpbHRlcmVkIGZyb20gX01BWF8gdG90YWwgZW50cmllcylcblx0XHRcdCAqXG5cdFx0XHQgKiAgQGR0b3B0IExhbmd1YWdlXG5cdFx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLmluZm9GaWx0ZXJlZFxuXHRcdFx0ICpcblx0XHRcdCAqICBAZXhhbXBsZVxuXHRcdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdFx0ICogICAgICAgIFwibGFuZ3VhZ2VcIjoge1xuXHRcdFx0ICogICAgICAgICAgXCJpbmZvRmlsdGVyZWRcIjogXCIgLSBmaWx0ZXJpbmcgZnJvbSBfTUFYXyByZWNvcmRzXCJcblx0XHRcdCAqICAgICAgICB9XG5cdFx0XHQgKiAgICAgIH0gKTtcblx0XHRcdCAqICAgIH0gKTtcblx0XHRcdCAqL1xuXHRcdFx0XCJzSW5mb0ZpbHRlcmVkXCI6IFwiKGZpbHRlcmVkIGZyb20gX01BWF8gdG90YWwgZW50cmllcylcIixcblx0XG5cdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBJZiBjYW4gYmUgdXNlZnVsIHRvIGFwcGVuZCBleHRyYSBpbmZvcm1hdGlvbiB0byB0aGUgaW5mbyBzdHJpbmcgYXQgdGltZXMsXG5cdFx0XHQgKiBhbmQgdGhpcyB2YXJpYWJsZSBkb2VzIGV4YWN0bHkgdGhhdC4gVGhpcyBpbmZvcm1hdGlvbiB3aWxsIGJlIGFwcGVuZGVkIHRvXG5cdFx0XHQgKiB0aGUgYGluZm9gIChgaW5mb0VtcHR5YCBhbmQgYGluZm9GaWx0ZXJlZGAgaW4gd2hhdGV2ZXIgY29tYmluYXRpb24gdGhleSBhcmVcblx0XHRcdCAqIGJlaW5nIHVzZWQpIGF0IGFsbCB0aW1lcy5cblx0XHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHRcdCAqICBAZGVmYXVsdCA8aT5FbXB0eSBzdHJpbmc8L2k+XG5cdFx0XHQgKlxuXHRcdFx0ICogIEBkdG9wdCBMYW5ndWFnZVxuXHRcdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sYW5ndWFnZS5pbmZvUG9zdEZpeFxuXHRcdFx0ICpcblx0XHRcdCAqICBAZXhhbXBsZVxuXHRcdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdFx0ICogICAgICAgIFwibGFuZ3VhZ2VcIjoge1xuXHRcdFx0ICogICAgICAgICAgXCJpbmZvUG9zdEZpeFwiOiBcIkFsbCByZWNvcmRzIHNob3duIGFyZSBkZXJpdmVkIGZyb20gcmVhbCBpbmZvcm1hdGlvbi5cIlxuXHRcdFx0ICogICAgICAgIH1cblx0XHRcdCAqICAgICAgfSApO1xuXHRcdFx0ICogICAgfSApO1xuXHRcdFx0ICovXG5cdFx0XHRcInNJbmZvUG9zdEZpeFwiOiBcIlwiLFxuXHRcblx0XG5cdFx0XHQvKipcblx0XHRcdCAqIFRoaXMgZGVjaW1hbCBwbGFjZSBvcGVyYXRvciBpcyBhIGxpdHRsZSBkaWZmZXJlbnQgZnJvbSB0aGUgb3RoZXJcblx0XHRcdCAqIGxhbmd1YWdlIG9wdGlvbnMgc2luY2UgRGF0YVRhYmxlcyBkb2Vzbid0IG91dHB1dCBmbG9hdGluZyBwb2ludFxuXHRcdFx0ICogbnVtYmVycywgc28gaXQgd29uJ3QgZXZlciB1c2UgdGhpcyBmb3IgZGlzcGxheSBvZiBhIG51bWJlci4gUmF0aGVyLFxuXHRcdFx0ICogd2hhdCB0aGlzIHBhcmFtZXRlciBkb2VzIGlzIG1vZGlmeSB0aGUgc29ydCBtZXRob2RzIG9mIHRoZSB0YWJsZSBzb1xuXHRcdFx0ICogdGhhdCBudW1iZXJzIHdoaWNoIGFyZSBpbiBhIGZvcm1hdCB3aGljaCBoYXMgYSBjaGFyYWN0ZXIgb3RoZXIgdGhhblxuXHRcdFx0ICogYSBwZXJpb2QgKGAuYCkgYXMgYSBkZWNpbWFsIHBsYWNlIHdpbGwgYmUgc29ydGVkIG51bWVyaWNhbGx5LlxuXHRcdFx0ICpcblx0XHRcdCAqIE5vdGUgdGhhdCBudW1iZXJzIHdpdGggZGlmZmVyZW50IGRlY2ltYWwgcGxhY2VzIGNhbm5vdCBiZSBzaG93biBpblxuXHRcdFx0ICogdGhlIHNhbWUgdGFibGUgYW5kIHN0aWxsIGJlIHNvcnRhYmxlLCB0aGUgdGFibGUgbXVzdCBiZSBjb25zaXN0ZW50LlxuXHRcdFx0ICogSG93ZXZlciwgbXVsdGlwbGUgZGlmZmVyZW50IHRhYmxlcyBvbiB0aGUgcGFnZSBjYW4gdXNlIGRpZmZlcmVudFxuXHRcdFx0ICogZGVjaW1hbCBwbGFjZSBjaGFyYWN0ZXJzLlxuXHRcdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdFx0ICogIEBkZWZhdWx0IFxuXHRcdFx0ICpcblx0XHRcdCAqICBAZHRvcHQgTGFuZ3VhZ2Vcblx0XHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2UuZGVjaW1hbFxuXHRcdFx0ICpcblx0XHRcdCAqICBAZXhhbXBsZVxuXHRcdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdFx0ICogICAgICAgIFwibGFuZ3VhZ2VcIjoge1xuXHRcdFx0ICogICAgICAgICAgXCJkZWNpbWFsXCI6IFwiLFwiXG5cdFx0XHQgKiAgICAgICAgICBcInRob3VzYW5kc1wiOiBcIi5cIlxuXHRcdFx0ICogICAgICAgIH1cblx0XHRcdCAqICAgICAgfSApO1xuXHRcdFx0ICogICAgfSApO1xuXHRcdFx0ICovXG5cdFx0XHRcInNEZWNpbWFsXCI6IFwiXCIsXG5cdFxuXHRcblx0XHRcdC8qKlxuXHRcdFx0ICogRGF0YVRhYmxlcyBoYXMgYSBidWlsZCBpbiBudW1iZXIgZm9ybWF0dGVyIChgZm9ybWF0TnVtYmVyYCkgd2hpY2ggaXNcblx0XHRcdCAqIHVzZWQgdG8gZm9ybWF0IGxhcmdlIG51bWJlcnMgdGhhdCBhcmUgdXNlZCBpbiB0aGUgdGFibGUgaW5mb3JtYXRpb24uXG5cdFx0XHQgKiBCeSBkZWZhdWx0IGEgY29tbWEgaXMgdXNlZCwgYnV0IHRoaXMgY2FuIGJlIHRyaXZpYWxseSBjaGFuZ2VkIHRvIGFueVxuXHRcdFx0ICogY2hhcmFjdGVyIHlvdSB3aXNoIHdpdGggdGhpcyBwYXJhbWV0ZXIuXG5cdFx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0XHQgKiAgQGRlZmF1bHQgLFxuXHRcdFx0ICpcblx0XHRcdCAqICBAZHRvcHQgTGFuZ3VhZ2Vcblx0XHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2UudGhvdXNhbmRzXG5cdFx0XHQgKlxuXHRcdFx0ICogIEBleGFtcGxlXG5cdFx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0XHQgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XG5cdFx0XHQgKiAgICAgICAgICBcInRob3VzYW5kc1wiOiBcIidcIlxuXHRcdFx0ICogICAgICAgIH1cblx0XHRcdCAqICAgICAgfSApO1xuXHRcdFx0ICogICAgfSApO1xuXHRcdFx0ICovXG5cdFx0XHRcInNUaG91c2FuZHNcIjogXCIsXCIsXG5cdFxuXHRcblx0XHRcdC8qKlxuXHRcdFx0ICogRGV0YWlsIHRoZSBhY3Rpb24gdGhhdCB3aWxsIGJlIHRha2VuIHdoZW4gdGhlIGRyb3AgZG93biBtZW51IGZvciB0aGVcblx0XHRcdCAqIHBhZ2luYXRpb24gbGVuZ3RoIG9wdGlvbiBpcyBjaGFuZ2VkLiBUaGUgJ19NRU5VXycgdmFyaWFibGUgaXMgcmVwbGFjZWRcblx0XHRcdCAqIHdpdGggYSBkZWZhdWx0IHNlbGVjdCBsaXN0IG9mIDEwLCAyNSwgNTAgYW5kIDEwMCwgYW5kIGNhbiBiZSByZXBsYWNlZFxuXHRcdFx0ICogd2l0aCBhIGN1c3RvbSBzZWxlY3QgYm94IGlmIHJlcXVpcmVkLlxuXHRcdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdFx0ICogIEBkZWZhdWx0IFNob3cgX01FTlVfIGVudHJpZXNcblx0XHRcdCAqXG5cdFx0XHQgKiAgQGR0b3B0IExhbmd1YWdlXG5cdFx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLmxlbmd0aE1lbnVcblx0XHRcdCAqXG5cdFx0XHQgKiAgQGV4YW1wbGVcblx0XHRcdCAqICAgIC8vIExhbmd1YWdlIGNoYW5nZSBvbmx5XG5cdFx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0XHQgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XG5cdFx0XHQgKiAgICAgICAgICBcImxlbmd0aE1lbnVcIjogXCJEaXNwbGF5IF9NRU5VXyByZWNvcmRzXCJcblx0XHRcdCAqICAgICAgICB9XG5cdFx0XHQgKiAgICAgIH0gKTtcblx0XHRcdCAqICAgIH0gKTtcblx0XHRcdCAqXG5cdFx0XHQgKiAgQGV4YW1wbGVcblx0XHRcdCAqICAgIC8vIExhbmd1YWdlIGFuZCBvcHRpb25zIGNoYW5nZVxuXHRcdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdFx0ICogICAgICAgIFwibGFuZ3VhZ2VcIjoge1xuXHRcdFx0ICogICAgICAgICAgXCJsZW5ndGhNZW51XCI6ICdEaXNwbGF5IDxzZWxlY3Q+Jytcblx0XHRcdCAqICAgICAgICAgICAgJzxvcHRpb24gdmFsdWU9XCIxMFwiPjEwPC9vcHRpb24+Jytcblx0XHRcdCAqICAgICAgICAgICAgJzxvcHRpb24gdmFsdWU9XCIyMFwiPjIwPC9vcHRpb24+Jytcblx0XHRcdCAqICAgICAgICAgICAgJzxvcHRpb24gdmFsdWU9XCIzMFwiPjMwPC9vcHRpb24+Jytcblx0XHRcdCAqICAgICAgICAgICAgJzxvcHRpb24gdmFsdWU9XCI0MFwiPjQwPC9vcHRpb24+Jytcblx0XHRcdCAqICAgICAgICAgICAgJzxvcHRpb24gdmFsdWU9XCI1MFwiPjUwPC9vcHRpb24+Jytcblx0XHRcdCAqICAgICAgICAgICAgJzxvcHRpb24gdmFsdWU9XCItMVwiPkFsbDwvb3B0aW9uPicrXG5cdFx0XHQgKiAgICAgICAgICAgICc8L3NlbGVjdD4gcmVjb3Jkcydcblx0XHRcdCAqICAgICAgICB9XG5cdFx0XHQgKiAgICAgIH0gKTtcblx0XHRcdCAqICAgIH0gKTtcblx0XHRcdCAqL1xuXHRcdFx0XCJzTGVuZ3RoTWVudVwiOiBcIlNob3cgX01FTlVfIGVudHJpZXNcIixcblx0XG5cdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBXaGVuIHVzaW5nIEFqYXggc291cmNlZCBkYXRhIGFuZCBkdXJpbmcgdGhlIGZpcnN0IGRyYXcgd2hlbiBEYXRhVGFibGVzIGlzXG5cdFx0XHQgKiBnYXRoZXJpbmcgdGhlIGRhdGEsIHRoaXMgbWVzc2FnZSBpcyBzaG93biBpbiBhbiBlbXB0eSByb3cgaW4gdGhlIHRhYmxlIHRvXG5cdFx0XHQgKiBpbmRpY2F0ZSB0byB0aGUgZW5kIHVzZXIgdGhlIHRoZSBkYXRhIGlzIGJlaW5nIGxvYWRlZC4gTm90ZSB0aGF0IHRoaXNcblx0XHRcdCAqIHBhcmFtZXRlciBpcyBub3QgdXNlZCB3aGVuIGxvYWRpbmcgZGF0YSBieSBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nLCBqdXN0XG5cdFx0XHQgKiBBamF4IHNvdXJjZWQgZGF0YSB3aXRoIGNsaWVudC1zaWRlIHByb2Nlc3NpbmcuXG5cdFx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0XHQgKiAgQGRlZmF1bHQgTG9hZGluZy4uLlxuXHRcdFx0ICpcblx0XHRcdCAqICBAZHRvcHQgTGFuZ3VhZ2Vcblx0XHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2UubG9hZGluZ1JlY29yZHNcblx0XHRcdCAqXG5cdFx0XHQgKiAgQGV4YW1wbGVcblx0XHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHRcdCAqICAgICAgICBcImxhbmd1YWdlXCI6IHtcblx0XHRcdCAqICAgICAgICAgIFwibG9hZGluZ1JlY29yZHNcIjogXCJQbGVhc2Ugd2FpdCAtIGxvYWRpbmcuLi5cIlxuXHRcdFx0ICogICAgICAgIH1cblx0XHRcdCAqICAgICAgfSApO1xuXHRcdFx0ICogICAgfSApO1xuXHRcdFx0ICovXG5cdFx0XHRcInNMb2FkaW5nUmVjb3Jkc1wiOiBcIkxvYWRpbmcuLi5cIixcblx0XG5cdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBUZXh0IHdoaWNoIGlzIGRpc3BsYXllZCB3aGVuIHRoZSB0YWJsZSBpcyBwcm9jZXNzaW5nIGEgdXNlciBhY3Rpb25cblx0XHRcdCAqICh1c3VhbGx5IGEgc29ydCBjb21tYW5kIG9yIHNpbWlsYXIpLlxuXHRcdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdFx0ICogIEBkZWZhdWx0IFByb2Nlc3NpbmcuLi5cblx0XHRcdCAqXG5cdFx0XHQgKiAgQGR0b3B0IExhbmd1YWdlXG5cdFx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLnByb2Nlc3Npbmdcblx0XHRcdCAqXG5cdFx0XHQgKiAgQGV4YW1wbGVcblx0XHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHRcdCAqICAgICAgICBcImxhbmd1YWdlXCI6IHtcblx0XHRcdCAqICAgICAgICAgIFwicHJvY2Vzc2luZ1wiOiBcIkRhdGFUYWJsZXMgaXMgY3VycmVudGx5IGJ1c3lcIlxuXHRcdFx0ICogICAgICAgIH1cblx0XHRcdCAqICAgICAgfSApO1xuXHRcdFx0ICogICAgfSApO1xuXHRcdFx0ICovXG5cdFx0XHRcInNQcm9jZXNzaW5nXCI6IFwiUHJvY2Vzc2luZy4uLlwiLFxuXHRcblx0XG5cdFx0XHQvKipcblx0XHRcdCAqIERldGFpbHMgdGhlIGFjdGlvbnMgdGhhdCB3aWxsIGJlIHRha2VuIHdoZW4gdGhlIHVzZXIgdHlwZXMgaW50byB0aGVcblx0XHRcdCAqIGZpbHRlcmluZyBpbnB1dCB0ZXh0IGJveC4gVGhlIHZhcmlhYmxlIFwiX0lOUFVUX1wiLCBpZiB1c2VkIGluIHRoZSBzdHJpbmcsXG5cdFx0XHQgKiBpcyByZXBsYWNlZCB3aXRoIHRoZSBIVE1MIHRleHQgYm94IGZvciB0aGUgZmlsdGVyaW5nIGlucHV0IGFsbG93aW5nXG5cdFx0XHQgKiBjb250cm9sIG92ZXIgd2hlcmUgaXQgYXBwZWFycyBpbiB0aGUgc3RyaW5nLiBJZiBcIl9JTlBVVF9cIiBpcyBub3QgZ2l2ZW5cblx0XHRcdCAqIHRoZW4gdGhlIGlucHV0IGJveCBpcyBhcHBlbmRlZCB0byB0aGUgc3RyaW5nIGF1dG9tYXRpY2FsbHkuXG5cdFx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0XHQgKiAgQGRlZmF1bHQgU2VhcmNoOlxuXHRcdFx0ICpcblx0XHRcdCAqICBAZHRvcHQgTGFuZ3VhZ2Vcblx0XHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2Uuc2VhcmNoXG5cdFx0XHQgKlxuXHRcdFx0ICogIEBleGFtcGxlXG5cdFx0XHQgKiAgICAvLyBJbnB1dCB0ZXh0IGJveCB3aWxsIGJlIGFwcGVuZGVkIGF0IHRoZSBlbmQgYXV0b21hdGljYWxseVxuXHRcdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdFx0ICogICAgICAgIFwibGFuZ3VhZ2VcIjoge1xuXHRcdFx0ICogICAgICAgICAgXCJzZWFyY2hcIjogXCJGaWx0ZXIgcmVjb3JkczpcIlxuXHRcdFx0ICogICAgICAgIH1cblx0XHRcdCAqICAgICAgfSApO1xuXHRcdFx0ICogICAgfSApO1xuXHRcdFx0ICpcblx0XHRcdCAqICBAZXhhbXBsZVxuXHRcdFx0ICogICAgLy8gU3BlY2lmeSB3aGVyZSB0aGUgZmlsdGVyIHNob3VsZCBhcHBlYXJcblx0XHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHRcdCAqICAgICAgICBcImxhbmd1YWdlXCI6IHtcblx0XHRcdCAqICAgICAgICAgIFwic2VhcmNoXCI6IFwiQXBwbHkgZmlsdGVyIF9JTlBVVF8gdG8gdGFibGVcIlxuXHRcdFx0ICogICAgICAgIH1cblx0XHRcdCAqICAgICAgfSApO1xuXHRcdFx0ICogICAgfSApO1xuXHRcdFx0ICovXG5cdFx0XHRcInNTZWFyY2hcIjogXCJTZWFyY2g6XCIsXG5cdFxuXHRcblx0XHRcdC8qKlxuXHRcdFx0ICogQXNzaWduIGEgYHBsYWNlaG9sZGVyYCBhdHRyaWJ1dGUgdG8gdGhlIHNlYXJjaCBgaW5wdXRgIGVsZW1lbnRcblx0XHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHRcdCAqICBAZGVmYXVsdCBcblx0XHRcdCAqXG5cdFx0XHQgKiAgQGR0b3B0IExhbmd1YWdlXG5cdFx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLnNlYXJjaFBsYWNlaG9sZGVyXG5cdFx0XHQgKi9cblx0XHRcdFwic1NlYXJjaFBsYWNlaG9sZGVyXCI6IFwiXCIsXG5cdFxuXHRcblx0XHRcdC8qKlxuXHRcdFx0ICogQWxsIG9mIHRoZSBsYW5ndWFnZSBpbmZvcm1hdGlvbiBjYW4gYmUgc3RvcmVkIGluIGEgZmlsZSBvbiB0aGVcblx0XHRcdCAqIHNlcnZlci1zaWRlLCB3aGljaCBEYXRhVGFibGVzIHdpbGwgbG9vayB1cCBpZiB0aGlzIHBhcmFtZXRlciBpcyBwYXNzZWQuXG5cdFx0XHQgKiBJdCBtdXN0IHN0b3JlIHRoZSBVUkwgb2YgdGhlIGxhbmd1YWdlIGZpbGUsIHdoaWNoIGlzIGluIGEgSlNPTiBmb3JtYXQsXG5cdFx0XHQgKiBhbmQgdGhlIG9iamVjdCBoYXMgdGhlIHNhbWUgcHJvcGVydGllcyBhcyB0aGUgb0xhbmd1YWdlIG9iamVjdCBpbiB0aGVcblx0XHRcdCAqIGluaXRpYWxpc2VyIG9iamVjdCAoaS5lLiB0aGUgYWJvdmUgcGFyYW1ldGVycykuIFBsZWFzZSByZWZlciB0byBvbmUgb2Zcblx0XHRcdCAqIHRoZSBleGFtcGxlIGxhbmd1YWdlIGZpbGVzIHRvIHNlZSBob3cgdGhpcyB3b3JrcyBpbiBhY3Rpb24uXG5cdFx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0XHQgKiAgQGRlZmF1bHQgPGk+RW1wdHkgc3RyaW5nIC0gaS5lLiBkaXNhYmxlZDwvaT5cblx0XHRcdCAqXG5cdFx0XHQgKiAgQGR0b3B0IExhbmd1YWdlXG5cdFx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLnVybFxuXHRcdFx0ICpcblx0XHRcdCAqICBAZXhhbXBsZVxuXHRcdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdFx0ICogICAgICAgIFwibGFuZ3VhZ2VcIjoge1xuXHRcdFx0ICogICAgICAgICAgXCJ1cmxcIjogXCJodHRwOi8vd3d3LnNwcnltZWRpYS5jby51ay9kYXRhVGFibGVzL2xhbmcudHh0XCJcblx0XHRcdCAqICAgICAgICB9XG5cdFx0XHQgKiAgICAgIH0gKTtcblx0XHRcdCAqICAgIH0gKTtcblx0XHRcdCAqL1xuXHRcdFx0XCJzVXJsXCI6IFwiXCIsXG5cdFxuXHRcblx0XHRcdC8qKlxuXHRcdFx0ICogVGV4dCBzaG93biBpbnNpZGUgdGhlIHRhYmxlIHJlY29yZHMgd2hlbiB0aGUgaXMgbm8gaW5mb3JtYXRpb24gdG8gYmVcblx0XHRcdCAqIGRpc3BsYXllZCBhZnRlciBmaWx0ZXJpbmcuIGBlbXB0eVRhYmxlYCBpcyBzaG93biB3aGVuIHRoZXJlIGlzIHNpbXBseSBub1xuXHRcdFx0ICogaW5mb3JtYXRpb24gaW4gdGhlIHRhYmxlIGF0IGFsbCAocmVnYXJkbGVzcyBvZiBmaWx0ZXJpbmcpLlxuXHRcdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdFx0ICogIEBkZWZhdWx0IE5vIG1hdGNoaW5nIHJlY29yZHMgZm91bmRcblx0XHRcdCAqXG5cdFx0XHQgKiAgQGR0b3B0IExhbmd1YWdlXG5cdFx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLnplcm9SZWNvcmRzXG5cdFx0XHQgKlxuXHRcdFx0ICogIEBleGFtcGxlXG5cdFx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0XHQgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XG5cdFx0XHQgKiAgICAgICAgICBcInplcm9SZWNvcmRzXCI6IFwiTm8gcmVjb3JkcyB0byBkaXNwbGF5XCJcblx0XHRcdCAqICAgICAgICB9XG5cdFx0XHQgKiAgICAgIH0gKTtcblx0XHRcdCAqICAgIH0gKTtcblx0XHRcdCAqL1xuXHRcdFx0XCJzWmVyb1JlY29yZHNcIjogXCJObyBtYXRjaGluZyByZWNvcmRzIGZvdW5kXCJcblx0XHR9LFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhpcyBwYXJhbWV0ZXIgYWxsb3dzIHlvdSB0byBoYXZlIGRlZmluZSB0aGUgZ2xvYmFsIGZpbHRlcmluZyBzdGF0ZSBhdFxuXHRcdCAqIGluaXRpYWxpc2F0aW9uIHRpbWUuIEFzIGFuIG9iamVjdCB0aGUgYHNlYXJjaGAgcGFyYW1ldGVyIG11c3QgYmVcblx0XHQgKiBkZWZpbmVkLCBidXQgYWxsIG90aGVyIHBhcmFtZXRlcnMgYXJlIG9wdGlvbmFsLiBXaGVuIGByZWdleGAgaXMgdHJ1ZSxcblx0XHQgKiB0aGUgc2VhcmNoIHN0cmluZyB3aWxsIGJlIHRyZWF0ZWQgYXMgYSByZWd1bGFyIGV4cHJlc3Npb24sIHdoZW4gZmFsc2Vcblx0XHQgKiAoZGVmYXVsdCkgaXQgd2lsbCBiZSB0cmVhdGVkIGFzIGEgc3RyYWlnaHQgc3RyaW5nLiBXaGVuIGBzbWFydGBcblx0XHQgKiBEYXRhVGFibGVzIHdpbGwgdXNlIGl0J3Mgc21hcnQgZmlsdGVyaW5nIG1ldGhvZHMgKHRvIHdvcmQgbWF0Y2ggYXRcblx0XHQgKiBhbnkgcG9pbnQgaW4gdGhlIGRhdGEpLCB3aGVuIGZhbHNlIHRoaXMgd2lsbCBub3QgYmUgZG9uZS5cblx0XHQgKiAgQG5hbWVzcGFjZVxuXHRcdCAqICBAZXh0ZW5kcyBEYXRhVGFibGUubW9kZWxzLm9TZWFyY2hcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgT3B0aW9uc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuc2VhcmNoXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcInNlYXJjaFwiOiB7XCJzZWFyY2hcIjogXCJJbml0aWFsIHNlYXJjaFwifVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKVxuXHRcdCAqL1xuXHRcdFwib1NlYXJjaFwiOiAkLmV4dGVuZCgge30sIERhdGFUYWJsZS5tb2RlbHMub1NlYXJjaCApLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogX19EZXByZWNhdGVkX18gVGhlIGZ1bmN0aW9uYWxpdHkgcHJvdmlkZWQgYnkgdGhpcyBwYXJhbWV0ZXIgaGFzIG5vdyBiZWVuXG5cdFx0ICogc3VwZXJzZWRlZCBieSB0aGF0IHByb3ZpZGVkIHRocm91Z2ggYGFqYXhgLCB3aGljaCBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkLlxuXHRcdCAqXG5cdFx0ICogQnkgZGVmYXVsdCBEYXRhVGFibGVzIHdpbGwgbG9vayBmb3IgdGhlIHByb3BlcnR5IGBkYXRhYCAob3IgYGFhRGF0YWAgZm9yXG5cdFx0ICogY29tcGF0aWJpbGl0eSB3aXRoIERhdGFUYWJsZXMgMS45LSkgd2hlbiBvYnRhaW5pbmcgZGF0YSBmcm9tIGFuIEFqYXhcblx0XHQgKiBzb3VyY2Ugb3IgZm9yIHNlcnZlci1zaWRlIHByb2Nlc3NpbmcgLSB0aGlzIHBhcmFtZXRlciBhbGxvd3MgdGhhdFxuXHRcdCAqIHByb3BlcnR5IHRvIGJlIGNoYW5nZWQuIFlvdSBjYW4gdXNlIEphdmFzY3JpcHQgZG90dGVkIG9iamVjdCBub3RhdGlvbiB0b1xuXHRcdCAqIGdldCBhIGRhdGEgc291cmNlIGZvciBtdWx0aXBsZSBsZXZlbHMgb2YgbmVzdGluZy5cblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICogIEBkZWZhdWx0IGRhdGFcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgT3B0aW9uc1xuXHRcdCAqICBAZHRvcHQgU2VydmVyLXNpZGVcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmFqYXhEYXRhUHJvcFxuXHRcdCAqXG5cdFx0ICogIEBkZXByZWNhdGVkIDEuMTAuIFBsZWFzZSB1c2UgYGFqYXhgIGZvciB0aGlzIGZ1bmN0aW9uYWxpdHkgbm93LlxuXHRcdCAqL1xuXHRcdFwic0FqYXhEYXRhUHJvcFwiOiBcImRhdGFcIixcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIF9fRGVwcmVjYXRlZF9fIFRoZSBmdW5jdGlvbmFsaXR5IHByb3ZpZGVkIGJ5IHRoaXMgcGFyYW1ldGVyIGhhcyBub3cgYmVlblxuXHRcdCAqIHN1cGVyc2VkZWQgYnkgdGhhdCBwcm92aWRlZCB0aHJvdWdoIGBhamF4YCwgd2hpY2ggc2hvdWxkIGJlIHVzZWQgaW5zdGVhZC5cblx0XHQgKlxuXHRcdCAqIFlvdSBjYW4gaW5zdHJ1Y3QgRGF0YVRhYmxlcyB0byBsb2FkIGRhdGEgZnJvbSBhbiBleHRlcm5hbFxuXHRcdCAqIHNvdXJjZSB1c2luZyB0aGlzIHBhcmFtZXRlciAodXNlIGFEYXRhIGlmIHlvdSB3YW50IHRvIHBhc3MgZGF0YSBpbiB5b3Vcblx0XHQgKiBhbHJlYWR5IGhhdmUpLiBTaW1wbHkgcHJvdmlkZSBhIHVybCBhIEpTT04gb2JqZWN0IGNhbiBiZSBvYnRhaW5lZCBmcm9tLlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBPcHRpb25zXG5cdFx0ICogIEBkdG9wdCBTZXJ2ZXItc2lkZVxuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuYWpheFNvdXJjZVxuXHRcdCAqXG5cdFx0ICogIEBkZXByZWNhdGVkIDEuMTAuIFBsZWFzZSB1c2UgYGFqYXhgIGZvciB0aGlzIGZ1bmN0aW9uYWxpdHkgbm93LlxuXHRcdCAqL1xuXHRcdFwic0FqYXhTb3VyY2VcIjogbnVsbCxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgaW5pdGlhbGlzYXRpb24gdmFyaWFibGUgYWxsb3dzIHlvdSB0byBzcGVjaWZ5IGV4YWN0bHkgd2hlcmUgaW4gdGhlXG5cdFx0ICogRE9NIHlvdSB3YW50IERhdGFUYWJsZXMgdG8gaW5qZWN0IHRoZSB2YXJpb3VzIGNvbnRyb2xzIGl0IGFkZHMgdG8gdGhlIHBhZ2Vcblx0XHQgKiAoZm9yIGV4YW1wbGUgeW91IG1pZ2h0IHdhbnQgdGhlIHBhZ2luYXRpb24gY29udHJvbHMgYXQgdGhlIHRvcCBvZiB0aGVcblx0XHQgKiB0YWJsZSkuIERJViBlbGVtZW50cyAod2l0aCBvciB3aXRob3V0IGEgY3VzdG9tIGNsYXNzKSBjYW4gYWxzbyBiZSBhZGRlZCB0b1xuXHRcdCAqIGFpZCBzdHlsaW5nLiBUaGUgZm9sbG93IHN5bnRheCBpcyB1c2VkOlxuXHRcdCAqICAgPHVsPlxuXHRcdCAqICAgICA8bGk+VGhlIGZvbGxvd2luZyBvcHRpb25zIGFyZSBhbGxvd2VkOlxuXHRcdCAqICAgICAgIDx1bD5cblx0XHQgKiAgICAgICAgIDxsaT4nbCcgLSBMZW5ndGggY2hhbmdpbmc8L2xpPlxuXHRcdCAqICAgICAgICAgPGxpPidmJyAtIEZpbHRlcmluZyBpbnB1dDwvbGk+XG5cdFx0ICogICAgICAgICA8bGk+J3QnIC0gVGhlIHRhYmxlITwvbGk+XG5cdFx0ICogICAgICAgICA8bGk+J2knIC0gSW5mb3JtYXRpb248L2xpPlxuXHRcdCAqICAgICAgICAgPGxpPidwJyAtIFBhZ2luYXRpb248L2xpPlxuXHRcdCAqICAgICAgICAgPGxpPidyJyAtIHBSb2Nlc3Npbmc8L2xpPlxuXHRcdCAqICAgICAgIDwvdWw+XG5cdFx0ICogICAgIDwvbGk+XG5cdFx0ICogICAgIDxsaT5UaGUgZm9sbG93aW5nIGNvbnN0YW50cyBhcmUgYWxsb3dlZDpcblx0XHQgKiAgICAgICA8dWw+XG5cdFx0ICogICAgICAgICA8bGk+J0gnIC0galF1ZXJ5VUkgdGhlbWUgXCJoZWFkZXJcIiBjbGFzc2VzICgnZmctdG9vbGJhciB1aS13aWRnZXQtaGVhZGVyIHVpLWNvcm5lci10bCB1aS1jb3JuZXItdHIgdWktaGVscGVyLWNsZWFyZml4Jyk8L2xpPlxuXHRcdCAqICAgICAgICAgPGxpPidGJyAtIGpRdWVyeVVJIHRoZW1lIFwiZm9vdGVyXCIgY2xhc3NlcyAoJ2ZnLXRvb2xiYXIgdWktd2lkZ2V0LWhlYWRlciB1aS1jb3JuZXItYmwgdWktY29ybmVyLWJyIHVpLWhlbHBlci1jbGVhcmZpeCcpPC9saT5cblx0XHQgKiAgICAgICA8L3VsPlxuXHRcdCAqICAgICA8L2xpPlxuXHRcdCAqICAgICA8bGk+VGhlIGZvbGxvd2luZyBzeW50YXggaXMgZXhwZWN0ZWQ6XG5cdFx0ICogICAgICAgPHVsPlxuXHRcdCAqICAgICAgICAgPGxpPicmbHQ7JyBhbmQgJyZndDsnIC0gZGl2IGVsZW1lbnRzPC9saT5cblx0XHQgKiAgICAgICAgIDxsaT4nJmx0O1wiY2xhc3NcIiBhbmQgJyZndDsnIC0gZGl2IHdpdGggYSBjbGFzczwvbGk+XG5cdFx0ICogICAgICAgICA8bGk+JyZsdDtcIiNpZFwiIGFuZCAnJmd0OycgLSBkaXYgd2l0aCBhbiBJRDwvbGk+XG5cdFx0ICogICAgICAgPC91bD5cblx0XHQgKiAgICAgPC9saT5cblx0XHQgKiAgICAgPGxpPkV4YW1wbGVzOlxuXHRcdCAqICAgICAgIDx1bD5cblx0XHQgKiAgICAgICAgIDxsaT4nJmx0O1wid3JhcHBlclwiZmxpcHQmZ3Q7JzwvbGk+XG5cdFx0ICogICAgICAgICA8bGk+JyZsdDtsZiZsdDt0Jmd0O2lwJmd0Oyc8L2xpPlxuXHRcdCAqICAgICAgIDwvdWw+XG5cdFx0ICogICAgIDwvbGk+XG5cdFx0ICogICA8L3VsPlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgbGZydGlwIDxpPih3aGVuIGBqUXVlcnlVSWAgaXMgZmFsc2UpPC9pPiA8Yj5vcjwvYj5cblx0XHQgKiAgICA8XCJIXCJsZnI+dDxcIkZcImlwPiA8aT4od2hlbiBgalF1ZXJ5VUlgIGlzIHRydWUpPC9pPlxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBPcHRpb25zXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5kb21cblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwiZG9tXCI6ICcmbHQ7XCJ0b3BcImkmZ3Q7cnQmbHQ7XCJib3R0b21cImZscCZndDsmbHQ7XCJjbGVhclwiJmd0Oydcblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJzRG9tXCI6IFwibGZydGlwXCIsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBTZWFyY2ggZGVsYXkgb3B0aW9uLiBUaGlzIHdpbGwgdGhyb3R0bGUgZnVsbCB0YWJsZSBzZWFyY2hlcyB0aGF0IHVzZSB0aGVcblx0XHQgKiBEYXRhVGFibGVzIHByb3ZpZGVkIHNlYXJjaCBpbnB1dCBlbGVtZW50IChpdCBkb2VzIG5vdCBlZmZlY3QgY2FsbHMgdG9cblx0XHQgKiBgZHQtYXBpIHNlYXJjaCgpYCwgcHJvdmlkaW5nIGEgZGVsYXkgYmVmb3JlIHRoZSBzZWFyY2ggaXMgbWFkZS5cblx0XHQgKiAgQHR5cGUgaW50ZWdlclxuXHRcdCAqICBAZGVmYXVsdCAwXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IE9wdGlvbnNcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnNlYXJjaERlbGF5XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcInNlYXJjaERlbGF5XCI6IDIwMFxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKVxuXHRcdCAqL1xuXHRcdFwic2VhcmNoRGVsYXlcIjogbnVsbCxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIERhdGFUYWJsZXMgZmVhdHVyZXMgc2l4IGRpZmZlcmVudCBidWlsdC1pbiBvcHRpb25zIGZvciB0aGUgYnV0dG9ucyB0b1xuXHRcdCAqIGRpc3BsYXkgZm9yIHBhZ2luYXRpb24gY29udHJvbDpcblx0XHQgKlxuXHRcdCAqICogYG51bWJlcnNgIC0gUGFnZSBudW1iZXIgYnV0dG9ucyBvbmx5XG5cdFx0ICogKiBgc2ltcGxlYCAtICdQcmV2aW91cycgYW5kICdOZXh0JyBidXR0b25zIG9ubHlcblx0XHQgKiAqICdzaW1wbGVfbnVtYmVyc2AgLSAnUHJldmlvdXMnIGFuZCAnTmV4dCcgYnV0dG9ucywgcGx1cyBwYWdlIG51bWJlcnNcblx0XHQgKiAqIGBmdWxsYCAtICdGaXJzdCcsICdQcmV2aW91cycsICdOZXh0JyBhbmQgJ0xhc3QnIGJ1dHRvbnNcblx0XHQgKiAqIGBmdWxsX251bWJlcnNgIC0gJ0ZpcnN0JywgJ1ByZXZpb3VzJywgJ05leHQnIGFuZCAnTGFzdCcgYnV0dG9ucywgcGx1cyBwYWdlIG51bWJlcnNcblx0XHQgKiAqIGBmaXJzdF9sYXN0X251bWJlcnNgIC0gJ0ZpcnN0JyBhbmQgJ0xhc3QnIGJ1dHRvbnMsIHBsdXMgcGFnZSBudW1iZXJzXG5cdFx0ICogIFxuXHRcdCAqIEZ1cnRoZXIgbWV0aG9kcyBjYW4gYmUgYWRkZWQgdXNpbmcge0BsaW5rIERhdGFUYWJsZS5leHQub1BhZ2luYXRpb259LlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgc2ltcGxlX251bWJlcnNcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgT3B0aW9uc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMucGFnaW5nVHlwZVxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJwYWdpbmdUeXBlXCI6IFwiZnVsbF9udW1iZXJzXCJcblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9IClcblx0XHQgKi9cblx0XHRcInNQYWdpbmF0aW9uVHlwZVwiOiBcInNpbXBsZV9udW1iZXJzXCIsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBFbmFibGUgaG9yaXpvbnRhbCBzY3JvbGxpbmcuIFdoZW4gYSB0YWJsZSBpcyB0b28gd2lkZSB0byBmaXQgaW50byBhXG5cdFx0ICogY2VydGFpbiBsYXlvdXQsIG9yIHlvdSBoYXZlIGEgbGFyZ2UgbnVtYmVyIG9mIGNvbHVtbnMgaW4gdGhlIHRhYmxlLCB5b3Vcblx0XHQgKiBjYW4gZW5hYmxlIHgtc2Nyb2xsaW5nIHRvIHNob3cgdGhlIHRhYmxlIGluIGEgdmlld3BvcnQsIHdoaWNoIGNhbiBiZVxuXHRcdCAqIHNjcm9sbGVkLiBUaGlzIHByb3BlcnR5IGNhbiBiZSBgdHJ1ZWAgd2hpY2ggd2lsbCBhbGxvdyB0aGUgdGFibGUgdG9cblx0XHQgKiBzY3JvbGwgaG9yaXpvbnRhbGx5IHdoZW4gbmVlZGVkLCBvciBhbnkgQ1NTIHVuaXQsIG9yIGEgbnVtYmVyIChpbiB3aGljaFxuXHRcdCAqIGNhc2UgaXQgd2lsbCBiZSB0cmVhdGVkIGFzIGEgcGl4ZWwgbWVhc3VyZW1lbnQpLiBTZXR0aW5nIGFzIHNpbXBseSBgdHJ1ZWBcblx0XHQgKiBpcyByZWNvbW1lbmRlZC5cblx0XHQgKiAgQHR5cGUgYm9vbGVhbnxzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgPGk+Ymxhbmsgc3RyaW5nIC0gaS5lLiBkaXNhYmxlZDwvaT5cblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgRmVhdHVyZXNcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnNjcm9sbFhcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwic2Nyb2xsWFwiOiB0cnVlLFxuXHRcdCAqICAgICAgICBcInNjcm9sbENvbGxhcHNlXCI6IHRydWVcblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJzU2Nyb2xsWFwiOiBcIlwiLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhpcyBwcm9wZXJ0eSBjYW4gYmUgdXNlZCB0byBmb3JjZSBhIERhdGFUYWJsZSB0byB1c2UgbW9yZSB3aWR0aCB0aGFuIGl0XG5cdFx0ICogbWlnaHQgb3RoZXJ3aXNlIGRvIHdoZW4geC1zY3JvbGxpbmcgaXMgZW5hYmxlZC4gRm9yIGV4YW1wbGUgaWYgeW91IGhhdmUgYVxuXHRcdCAqIHRhYmxlIHdoaWNoIHJlcXVpcmVzIHRvIGJlIHdlbGwgc3BhY2VkLCB0aGlzIHBhcmFtZXRlciBpcyB1c2VmdWwgZm9yXG5cdFx0ICogXCJvdmVyLXNpemluZ1wiIHRoZSB0YWJsZSwgYW5kIHRodXMgZm9yY2luZyBzY3JvbGxpbmcuIFRoaXMgcHJvcGVydHkgY2FuIGJ5XG5cdFx0ICogYW55IENTUyB1bml0LCBvciBhIG51bWJlciAoaW4gd2hpY2ggY2FzZSBpdCB3aWxsIGJlIHRyZWF0ZWQgYXMgYSBwaXhlbFxuXHRcdCAqIG1lYXN1cmVtZW50KS5cblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICogIEBkZWZhdWx0IDxpPmJsYW5rIHN0cmluZyAtIGkuZS4gZGlzYWJsZWQ8L2k+XG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IE9wdGlvbnNcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnNjcm9sbFhJbm5lclxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJzY3JvbGxYXCI6IFwiMTAwJVwiLFxuXHRcdCAqICAgICAgICBcInNjcm9sbFhJbm5lclwiOiBcIjExMCVcIlxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcInNTY3JvbGxYSW5uZXJcIjogXCJcIixcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEVuYWJsZSB2ZXJ0aWNhbCBzY3JvbGxpbmcuIFZlcnRpY2FsIHNjcm9sbGluZyB3aWxsIGNvbnN0cmFpbiB0aGUgRGF0YVRhYmxlXG5cdFx0ICogdG8gdGhlIGdpdmVuIGhlaWdodCwgYW5kIGVuYWJsZSBzY3JvbGxpbmcgZm9yIGFueSBkYXRhIHdoaWNoIG92ZXJmbG93cyB0aGVcblx0XHQgKiBjdXJyZW50IHZpZXdwb3J0LiBUaGlzIGNhbiBiZSB1c2VkIGFzIGFuIGFsdGVybmF0aXZlIHRvIHBhZ2luZyB0byBkaXNwbGF5XG5cdFx0ICogYSBsb3Qgb2YgZGF0YSBpbiBhIHNtYWxsIGFyZWEgKGFsdGhvdWdoIHBhZ2luZyBhbmQgc2Nyb2xsaW5nIGNhbiBib3RoIGJlXG5cdFx0ICogZW5hYmxlZCBhdCB0aGUgc2FtZSB0aW1lKS4gVGhpcyBwcm9wZXJ0eSBjYW4gYmUgYW55IENTUyB1bml0LCBvciBhIG51bWJlclxuXHRcdCAqIChpbiB3aGljaCBjYXNlIGl0IHdpbGwgYmUgdHJlYXRlZCBhcyBhIHBpeGVsIG1lYXN1cmVtZW50KS5cblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICogIEBkZWZhdWx0IDxpPmJsYW5rIHN0cmluZyAtIGkuZS4gZGlzYWJsZWQ8L2k+XG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IEZlYXR1cmVzXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5zY3JvbGxZXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcInNjcm9sbFlcIjogXCIyMDBweFwiLFxuXHRcdCAqICAgICAgICBcInBhZ2luYXRlXCI6IGZhbHNlXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwic1Njcm9sbFlcIjogXCJcIixcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIF9fRGVwcmVjYXRlZF9fIFRoZSBmdW5jdGlvbmFsaXR5IHByb3ZpZGVkIGJ5IHRoaXMgcGFyYW1ldGVyIGhhcyBub3cgYmVlblxuXHRcdCAqIHN1cGVyc2VkZWQgYnkgdGhhdCBwcm92aWRlZCB0aHJvdWdoIGBhamF4YCwgd2hpY2ggc2hvdWxkIGJlIHVzZWQgaW5zdGVhZC5cblx0XHQgKlxuXHRcdCAqIFNldCB0aGUgSFRUUCBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIG1ha2UgdGhlIEFqYXggY2FsbCBmb3Igc2VydmVyLXNpZGVcblx0XHQgKiBwcm9jZXNzaW5nIG9yIEFqYXggc291cmNlZCBkYXRhLlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgR0VUXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IE9wdGlvbnNcblx0XHQgKiAgQGR0b3B0IFNlcnZlci1zaWRlXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5zZXJ2ZXJNZXRob2Rcblx0XHQgKlxuXHRcdCAqICBAZGVwcmVjYXRlZCAxLjEwLiBQbGVhc2UgdXNlIGBhamF4YCBmb3IgdGhpcyBmdW5jdGlvbmFsaXR5IG5vdy5cblx0XHQgKi9cblx0XHRcInNTZXJ2ZXJNZXRob2RcIjogXCJHRVRcIixcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIERhdGFUYWJsZXMgbWFrZXMgdXNlIG9mIHJlbmRlcmVycyB3aGVuIGRpc3BsYXlpbmcgSFRNTCBlbGVtZW50cyBmb3Jcblx0XHQgKiBhIHRhYmxlLiBUaGVzZSByZW5kZXJlcnMgY2FuIGJlIGFkZGVkIG9yIG1vZGlmaWVkIGJ5IHBsdWctaW5zIHRvXG5cdFx0ICogZ2VuZXJhdGUgc3VpdGFibGUgbWFyay11cCBmb3IgYSBzaXRlLiBGb3IgZXhhbXBsZSB0aGUgQm9vdHN0cmFwXG5cdFx0ICogaW50ZWdyYXRpb24gcGx1Zy1pbiBmb3IgRGF0YVRhYmxlcyB1c2VzIGEgcGFnaW5nIGJ1dHRvbiByZW5kZXJlciB0b1xuXHRcdCAqIGRpc3BsYXkgcGFnaW5hdGlvbiBidXR0b25zIGluIHRoZSBtYXJrLXVwIHJlcXVpcmVkIGJ5IEJvb3RzdHJhcC5cblx0XHQgKlxuXHRcdCAqIEZvciBmdXJ0aGVyIGluZm9ybWF0aW9uIGFib3V0IHRoZSByZW5kZXJlcnMgYXZhaWxhYmxlIHNlZVxuXHRcdCAqIERhdGFUYWJsZS5leHQucmVuZGVyZXJcblx0XHQgKiAgQHR5cGUgc3RyaW5nfG9iamVjdFxuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICpcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnJlbmRlcmVyXG5cdFx0ICpcblx0XHQgKi9cblx0XHRcInJlbmRlcmVyXCI6IG51bGwsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBTZXQgdGhlIGRhdGEgcHJvcGVydHkgbmFtZSB0aGF0IERhdGFUYWJsZXMgc2hvdWxkIHVzZSB0byBnZXQgYSByb3cncyBpZFxuXHRcdCAqIHRvIHNldCBhcyB0aGUgYGlkYCBwcm9wZXJ0eSBpbiB0aGUgbm9kZS5cblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICogIEBkZWZhdWx0IERUX1Jvd0lkXG5cdFx0ICpcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnJvd0lkXG5cdFx0ICovXG5cdFx0XCJyb3dJZFwiOiBcIkRUX1Jvd0lkXCJcblx0fTtcblx0XG5cdF9mbkh1bmdhcmlhbk1hcCggRGF0YVRhYmxlLmRlZmF1bHRzICk7XG5cdFxuXHRcblx0XG5cdC8qXG5cdCAqIERldmVsb3BlciBub3RlIC0gU2VlIG5vdGUgaW4gbW9kZWwuZGVmYXVsdHMuanMgYWJvdXQgdGhlIHVzZSBvZiBIdW5nYXJpYW5cblx0ICogbm90YXRpb24gYW5kIGNhbWVsIGNhc2UuXG5cdCAqL1xuXHRcblx0LyoqXG5cdCAqIENvbHVtbiBvcHRpb25zIHRoYXQgY2FuIGJlIGdpdmVuIHRvIERhdGFUYWJsZXMgYXQgaW5pdGlhbGlzYXRpb24gdGltZS5cblx0ICogIEBuYW1lc3BhY2Vcblx0ICovXG5cdERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4gPSB7XG5cdFx0LyoqXG5cdFx0ICogRGVmaW5lIHdoaWNoIGNvbHVtbihzKSBhbiBvcmRlciB3aWxsIG9jY3VyIG9uIGZvciB0aGlzIGNvbHVtbi4gVGhpc1xuXHRcdCAqIGFsbG93cyBhIGNvbHVtbidzIG9yZGVyaW5nIHRvIHRha2UgbXVsdGlwbGUgY29sdW1ucyBpbnRvIGFjY291bnQgd2hlblxuXHRcdCAqIGRvaW5nIGEgc29ydCBvciB1c2UgdGhlIGRhdGEgZnJvbSBhIGRpZmZlcmVudCBjb2x1bW4uIEZvciBleGFtcGxlIGZpcnN0XG5cdFx0ICogbmFtZSAvIGxhc3QgbmFtZSBjb2x1bW5zIG1ha2Ugc2Vuc2UgdG8gZG8gYSBtdWx0aS1jb2x1bW4gc29ydCBvdmVyIHRoZVxuXHRcdCAqIHR3byBjb2x1bW5zLlxuXHRcdCAqICBAdHlwZSBhcnJheXxpbnRcblx0XHQgKiAgQGRlZmF1bHQgbnVsbCA8aT5UYWtlcyB0aGUgdmFsdWUgb2YgdGhlIGNvbHVtbiBpbmRleCBhdXRvbWF0aWNhbGx5PC9pPlxuXHRcdCAqXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4ub3JkZXJEYXRhXG5cdFx0ICogIEBkdG9wdCBDb2x1bW5zXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBVc2luZyBgY29sdW1uRGVmc2Bcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImNvbHVtbkRlZnNcIjogW1xuXHRcdCAqICAgICAgICAgIHsgXCJvcmRlckRhdGFcIjogWyAwLCAxIF0sIFwidGFyZ2V0c1wiOiBbIDAgXSB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJvcmRlckRhdGFcIjogWyAxLCAwIF0sIFwidGFyZ2V0c1wiOiBbIDEgXSB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJvcmRlckRhdGFcIjogMiwgXCJ0YXJnZXRzXCI6IFsgMiBdIH1cblx0XHQgKiAgICAgICAgXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIFVzaW5nIGBjb2x1bW5zYFxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwiY29sdW1uc1wiOiBbXG5cdFx0ICogICAgICAgICAgeyBcIm9yZGVyRGF0YVwiOiBbIDAsIDEgXSB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJvcmRlckRhdGFcIjogWyAxLCAwIF0gfSxcblx0XHQgKiAgICAgICAgICB7IFwib3JkZXJEYXRhXCI6IDIgfSxcblx0XHQgKiAgICAgICAgICBudWxsLFxuXHRcdCAqICAgICAgICAgIG51bGxcblx0XHQgKiAgICAgICAgXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcImFEYXRhU29ydFwiOiBudWxsLFxuXHRcdFwiaURhdGFTb3J0XCI6IC0xLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogWW91IGNhbiBjb250cm9sIHRoZSBkZWZhdWx0IG9yZGVyaW5nIGRpcmVjdGlvbiwgYW5kIGV2ZW4gYWx0ZXIgdGhlXG5cdFx0ICogYmVoYXZpb3VyIG9mIHRoZSBzb3J0IGhhbmRsZXIgKGkuZS4gb25seSBhbGxvdyBhc2NlbmRpbmcgb3JkZXJpbmcgZXRjKVxuXHRcdCAqIHVzaW5nIHRoaXMgcGFyYW1ldGVyLlxuXHRcdCAqICBAdHlwZSBhcnJheVxuXHRcdCAqICBAZGVmYXVsdCBbICdhc2MnLCAnZGVzYycgXVxuXHRcdCAqXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4ub3JkZXJTZXF1ZW5jZVxuXHRcdCAqICBAZHRvcHQgQ29sdW1uc1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gVXNpbmcgYGNvbHVtbkRlZnNgXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJjb2x1bW5EZWZzXCI6IFtcblx0XHQgKiAgICAgICAgICB7IFwib3JkZXJTZXF1ZW5jZVwiOiBbIFwiYXNjXCIgXSwgXCJ0YXJnZXRzXCI6IFsgMSBdIH0sXG5cdFx0ICogICAgICAgICAgeyBcIm9yZGVyU2VxdWVuY2VcIjogWyBcImRlc2NcIiwgXCJhc2NcIiwgXCJhc2NcIiBdLCBcInRhcmdldHNcIjogWyAyIF0gfSxcblx0XHQgKiAgICAgICAgICB7IFwib3JkZXJTZXF1ZW5jZVwiOiBbIFwiZGVzY1wiIF0sIFwidGFyZ2V0c1wiOiBbIDMgXSB9XG5cdFx0ICogICAgICAgIF1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBVc2luZyBgY29sdW1uc2Bcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImNvbHVtbnNcIjogW1xuXHRcdCAqICAgICAgICAgIG51bGwsXG5cdFx0ICogICAgICAgICAgeyBcIm9yZGVyU2VxdWVuY2VcIjogWyBcImFzY1wiIF0gfSxcblx0XHQgKiAgICAgICAgICB7IFwib3JkZXJTZXF1ZW5jZVwiOiBbIFwiZGVzY1wiLCBcImFzY1wiLCBcImFzY1wiIF0gfSxcblx0XHQgKiAgICAgICAgICB7IFwib3JkZXJTZXF1ZW5jZVwiOiBbIFwiZGVzY1wiIF0gfSxcblx0XHQgKiAgICAgICAgICBudWxsXG5cdFx0ICogICAgICAgIF1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJhc1NvcnRpbmdcIjogWyAnYXNjJywgJ2Rlc2MnIF0sXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBFbmFibGUgb3IgZGlzYWJsZSBmaWx0ZXJpbmcgb24gdGhlIGRhdGEgaW4gdGhpcyBjb2x1bW4uXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKiAgQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4uc2VhcmNoYWJsZVxuXHRcdCAqICBAZHRvcHQgQ29sdW1uc1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gVXNpbmcgYGNvbHVtbkRlZnNgXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJjb2x1bW5EZWZzXCI6IFtcblx0XHQgKiAgICAgICAgICB7IFwic2VhcmNoYWJsZVwiOiBmYWxzZSwgXCJ0YXJnZXRzXCI6IFsgMCBdIH1cblx0XHQgKiAgICAgICAgXSB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gVXNpbmcgYGNvbHVtbnNgXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJjb2x1bW5zXCI6IFtcblx0XHQgKiAgICAgICAgICB7IFwic2VhcmNoYWJsZVwiOiBmYWxzZSB9LFxuXHRcdCAqICAgICAgICAgIG51bGwsXG5cdFx0ICogICAgICAgICAgbnVsbCxcblx0XHQgKiAgICAgICAgICBudWxsLFxuXHRcdCAqICAgICAgICAgIG51bGxcblx0XHQgKiAgICAgICAgXSB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiYlNlYXJjaGFibGVcIjogdHJ1ZSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEVuYWJsZSBvciBkaXNhYmxlIG9yZGVyaW5nIG9uIHRoaXMgY29sdW1uLlxuXHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0ICogIEBkZWZhdWx0IHRydWVcblx0XHQgKlxuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uLm9yZGVyYWJsZVxuXHRcdCAqICBAZHRvcHQgQ29sdW1uc1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gVXNpbmcgYGNvbHVtbkRlZnNgXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJjb2x1bW5EZWZzXCI6IFtcblx0XHQgKiAgICAgICAgICB7IFwib3JkZXJhYmxlXCI6IGZhbHNlLCBcInRhcmdldHNcIjogWyAwIF0gfVxuXHRcdCAqICAgICAgICBdIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBVc2luZyBgY29sdW1uc2Bcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImNvbHVtbnNcIjogW1xuXHRcdCAqICAgICAgICAgIHsgXCJvcmRlcmFibGVcIjogZmFsc2UgfSxcblx0XHQgKiAgICAgICAgICBudWxsLFxuXHRcdCAqICAgICAgICAgIG51bGwsXG5cdFx0ICogICAgICAgICAgbnVsbCxcblx0XHQgKiAgICAgICAgICBudWxsXG5cdFx0ICogICAgICAgIF0gfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcImJTb3J0YWJsZVwiOiB0cnVlLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogRW5hYmxlIG9yIGRpc2FibGUgdGhlIGRpc3BsYXkgb2YgdGhpcyBjb2x1bW4uXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKiAgQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4udmlzaWJsZVxuXHRcdCAqICBAZHRvcHQgQ29sdW1uc1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gVXNpbmcgYGNvbHVtbkRlZnNgXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJjb2x1bW5EZWZzXCI6IFtcblx0XHQgKiAgICAgICAgICB7IFwidmlzaWJsZVwiOiBmYWxzZSwgXCJ0YXJnZXRzXCI6IFsgMCBdIH1cblx0XHQgKiAgICAgICAgXSB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gVXNpbmcgYGNvbHVtbnNgXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJjb2x1bW5zXCI6IFtcblx0XHQgKiAgICAgICAgICB7IFwidmlzaWJsZVwiOiBmYWxzZSB9LFxuXHRcdCAqICAgICAgICAgIG51bGwsXG5cdFx0ICogICAgICAgICAgbnVsbCxcblx0XHQgKiAgICAgICAgICBudWxsLFxuXHRcdCAqICAgICAgICAgIG51bGxcblx0XHQgKiAgICAgICAgXSB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiYlZpc2libGVcIjogdHJ1ZSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIERldmVsb3BlciBkZWZpbmFibGUgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2hlbmV2ZXIgYSBjZWxsIGlzIGNyZWF0ZWQgKEFqYXggc291cmNlLFxuXHRcdCAqIGV0Yykgb3IgcHJvY2Vzc2VkIGZvciBpbnB1dCAoRE9NIHNvdXJjZSkuIFRoaXMgY2FuIGJlIHVzZWQgYXMgYSBjb21wbGltZW50IHRvIG1SZW5kZXJcblx0XHQgKiBhbGxvd2luZyB5b3UgdG8gbW9kaWZ5IHRoZSBET00gZWxlbWVudCAoYWRkIGJhY2tncm91bmQgY29sb3VyIGZvciBleGFtcGxlKSB3aGVuIHRoZVxuXHRcdCAqIGVsZW1lbnQgaXMgYXZhaWxhYmxlLlxuXHRcdCAqICBAdHlwZSBmdW5jdGlvblxuXHRcdCAqICBAcGFyYW0ge2VsZW1lbnR9IHRkIFRoZSBURCBub2RlIHRoYXQgaGFzIGJlZW4gY3JlYXRlZFxuXHRcdCAqICBAcGFyYW0geyp9IGNlbGxEYXRhIFRoZSBEYXRhIGZvciB0aGUgY2VsbFxuXHRcdCAqICBAcGFyYW0ge2FycmF5fG9iamVjdH0gcm93RGF0YSBUaGUgZGF0YSBmb3IgdGhlIHdob2xlIHJvd1xuXHRcdCAqICBAcGFyYW0ge2ludH0gcm93IFRoZSByb3cgaW5kZXggZm9yIHRoZSBhb0RhdGEgZGF0YSBzdG9yZVxuXHRcdCAqICBAcGFyYW0ge2ludH0gY29sIFRoZSBjb2x1bW4gaW5kZXggZm9yIGFvQ29sdW1uc1xuXHRcdCAqXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4uY3JlYXRlZENlbGxcblx0XHQgKiAgQGR0b3B0IENvbHVtbnNcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwiY29sdW1uRGVmc1wiOiBbIHtcblx0XHQgKiAgICAgICAgICBcInRhcmdldHNcIjogWzNdLFxuXHRcdCAqICAgICAgICAgIFwiY3JlYXRlZENlbGxcIjogZnVuY3Rpb24gKHRkLCBjZWxsRGF0YSwgcm93RGF0YSwgcm93LCBjb2wpIHtcblx0XHQgKiAgICAgICAgICAgIGlmICggY2VsbERhdGEgPT0gXCIxLjdcIiApIHtcblx0XHQgKiAgICAgICAgICAgICAgJCh0ZCkuY3NzKCdjb2xvcicsICdibHVlJylcblx0XHQgKiAgICAgICAgICAgIH1cblx0XHQgKiAgICAgICAgICB9XG5cdFx0ICogICAgICAgIH0gXVxuXHRcdCAqICAgICAgfSk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiZm5DcmVhdGVkQ2VsbFwiOiBudWxsLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhpcyBwYXJhbWV0ZXIgaGFzIGJlZW4gcmVwbGFjZWQgYnkgYGRhdGFgIGluIERhdGFUYWJsZXMgdG8gZW5zdXJlIG5hbWluZ1xuXHRcdCAqIGNvbnNpc3RlbmN5LiBgZGF0YVByb3BgIGNhbiBzdGlsbCBiZSB1c2VkLCBhcyB0aGVyZSBpcyBiYWNrd2FyZHNcblx0XHQgKiBjb21wYXRpYmlsaXR5IGluIERhdGFUYWJsZXMgZm9yIHRoaXMgb3B0aW9uLCBidXQgaXQgaXMgc3Ryb25nbHlcblx0XHQgKiByZWNvbW1lbmRlZCB0aGF0IHlvdSB1c2UgYGRhdGFgIGluIHByZWZlcmVuY2UgdG8gYGRhdGFQcm9wYC5cblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbi5kYXRhUHJvcFxuXHRcdCAqL1xuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhpcyBwcm9wZXJ0eSBjYW4gYmUgdXNlZCB0byByZWFkIGRhdGEgZnJvbSBhbnkgZGF0YSBzb3VyY2UgcHJvcGVydHksXG5cdFx0ICogaW5jbHVkaW5nIGRlZXBseSBuZXN0ZWQgb2JqZWN0cyAvIHByb3BlcnRpZXMuIGBkYXRhYCBjYW4gYmUgZ2l2ZW4gaW4gYVxuXHRcdCAqIG51bWJlciBvZiBkaWZmZXJlbnQgd2F5cyB3aGljaCBlZmZlY3QgaXRzIGJlaGF2aW91cjpcblx0XHQgKlxuXHRcdCAqICogYGludGVnZXJgIC0gdHJlYXRlZCBhcyBhbiBhcnJheSBpbmRleCBmb3IgdGhlIGRhdGEgc291cmNlLiBUaGlzIGlzIHRoZVxuXHRcdCAqICAgZGVmYXVsdCB0aGF0IERhdGFUYWJsZXMgdXNlcyAoaW5jcmVtZW50YWxseSBpbmNyZWFzZWQgZm9yIGVhY2ggY29sdW1uKS5cblx0XHQgKiAqIGBzdHJpbmdgIC0gcmVhZCBhbiBvYmplY3QgcHJvcGVydHkgZnJvbSB0aGUgZGF0YSBzb3VyY2UuIFRoZXJlIGFyZVxuXHRcdCAqICAgdGhyZWUgJ3NwZWNpYWwnIG9wdGlvbnMgdGhhdCBjYW4gYmUgdXNlZCBpbiB0aGUgc3RyaW5nIHRvIGFsdGVyIGhvd1xuXHRcdCAqICAgRGF0YVRhYmxlcyByZWFkcyB0aGUgZGF0YSBmcm9tIHRoZSBzb3VyY2Ugb2JqZWN0OlxuXHRcdCAqICAgICogYC5gIC0gRG90dGVkIEphdmFzY3JpcHQgbm90YXRpb24uIEp1c3QgYXMgeW91IHVzZSBhIGAuYCBpblxuXHRcdCAqICAgICAgSmF2YXNjcmlwdCB0byByZWFkIGZyb20gbmVzdGVkIG9iamVjdHMsIHNvIHRvIGNhbiB0aGUgb3B0aW9uc1xuXHRcdCAqICAgICAgc3BlY2lmaWVkIGluIGBkYXRhYC4gRm9yIGV4YW1wbGU6IGBicm93c2VyLnZlcnNpb25gIG9yXG5cdFx0ICogICAgICBgYnJvd3Nlci5uYW1lYC4gSWYgeW91ciBvYmplY3QgcGFyYW1ldGVyIG5hbWUgY29udGFpbnMgYSBwZXJpb2QsIHVzZVxuXHRcdCAqICAgICAgYFxcXFxgIHRvIGVzY2FwZSBpdCAtIGkuZS4gYGZpcnN0XFxcXC5uYW1lYC5cblx0XHQgKiAgICAqIGBbXWAgLSBBcnJheSBub3RhdGlvbi4gRGF0YVRhYmxlcyBjYW4gYXV0b21hdGljYWxseSBjb21iaW5lIGRhdGFcblx0XHQgKiAgICAgIGZyb20gYW5kIGFycmF5IHNvdXJjZSwgam9pbmluZyB0aGUgZGF0YSB3aXRoIHRoZSBjaGFyYWN0ZXJzIHByb3ZpZGVkXG5cdFx0ICogICAgICBiZXR3ZWVuIHRoZSB0d28gYnJhY2tldHMuIEZvciBleGFtcGxlOiBgbmFtZVssIF1gIHdvdWxkIHByb3ZpZGUgYVxuXHRcdCAqICAgICAgY29tbWEtc3BhY2Ugc2VwYXJhdGVkIGxpc3QgZnJvbSB0aGUgc291cmNlIGFycmF5LiBJZiBubyBjaGFyYWN0ZXJzXG5cdFx0ICogICAgICBhcmUgcHJvdmlkZWQgYmV0d2VlbiB0aGUgYnJhY2tldHMsIHRoZSBvcmlnaW5hbCBhcnJheSBzb3VyY2UgaXNcblx0XHQgKiAgICAgIHJldHVybmVkLlxuXHRcdCAqICAgICogYCgpYCAtIEZ1bmN0aW9uIG5vdGF0aW9uLiBBZGRpbmcgYCgpYCB0byB0aGUgZW5kIG9mIGEgcGFyYW1ldGVyIHdpbGxcblx0XHQgKiAgICAgIGV4ZWN1dGUgYSBmdW5jdGlvbiBvZiB0aGUgbmFtZSBnaXZlbi4gRm9yIGV4YW1wbGU6IGBicm93c2VyKClgIGZvciBhXG5cdFx0ICogICAgICBzaW1wbGUgZnVuY3Rpb24gb24gdGhlIGRhdGEgc291cmNlLCBgYnJvd3Nlci52ZXJzaW9uKClgIGZvciBhXG5cdFx0ICogICAgICBmdW5jdGlvbiBpbiBhIG5lc3RlZCBwcm9wZXJ0eSBvciBldmVuIGBicm93c2VyKCkudmVyc2lvbmAgdG8gZ2V0IGFuXG5cdFx0ICogICAgICBvYmplY3QgcHJvcGVydHkgaWYgdGhlIGZ1bmN0aW9uIGNhbGxlZCByZXR1cm5zIGFuIG9iamVjdC4gTm90ZSB0aGF0XG5cdFx0ICogICAgICBmdW5jdGlvbiBub3RhdGlvbiBpcyByZWNvbW1lbmRlZCBmb3IgdXNlIGluIGByZW5kZXJgIHJhdGhlciB0aGFuXG5cdFx0ICogICAgICBgZGF0YWAgYXMgaXQgaXMgbXVjaCBzaW1wbGVyIHRvIHVzZSBhcyBhIHJlbmRlcmVyLlxuXHRcdCAqICogYG51bGxgIC0gdXNlIHRoZSBvcmlnaW5hbCBkYXRhIHNvdXJjZSBmb3IgdGhlIHJvdyByYXRoZXIgdGhhbiBwbHVja2luZ1xuXHRcdCAqICAgZGF0YSBkaXJlY3RseSBmcm9tIGl0LiBUaGlzIGFjdGlvbiBoYXMgZWZmZWN0cyBvbiB0d28gb3RoZXJcblx0XHQgKiAgIGluaXRpYWxpc2F0aW9uIG9wdGlvbnM6XG5cdFx0ICogICAgKiBgZGVmYXVsdENvbnRlbnRgIC0gV2hlbiBudWxsIGlzIGdpdmVuIGFzIHRoZSBgZGF0YWAgb3B0aW9uIGFuZFxuXHRcdCAqICAgICAgYGRlZmF1bHRDb250ZW50YCBpcyBzcGVjaWZpZWQgZm9yIHRoZSBjb2x1bW4sIHRoZSB2YWx1ZSBkZWZpbmVkIGJ5XG5cdFx0ICogICAgICBgZGVmYXVsdENvbnRlbnRgIHdpbGwgYmUgdXNlZCBmb3IgdGhlIGNlbGwuXG5cdFx0ICogICAgKiBgcmVuZGVyYCAtIFdoZW4gbnVsbCBpcyB1c2VkIGZvciB0aGUgYGRhdGFgIG9wdGlvbiBhbmQgdGhlIGByZW5kZXJgXG5cdFx0ICogICAgICBvcHRpb24gaXMgc3BlY2lmaWVkIGZvciB0aGUgY29sdW1uLCB0aGUgd2hvbGUgZGF0YSBzb3VyY2UgZm9yIHRoZVxuXHRcdCAqICAgICAgcm93IGlzIHVzZWQgZm9yIHRoZSByZW5kZXJlci5cblx0XHQgKiAqIGBmdW5jdGlvbmAgLSB0aGUgZnVuY3Rpb24gZ2l2ZW4gd2lsbCBiZSBleGVjdXRlZCB3aGVuZXZlciBEYXRhVGFibGVzXG5cdFx0ICogICBuZWVkcyB0byBzZXQgb3IgZ2V0IHRoZSBkYXRhIGZvciBhIGNlbGwgaW4gdGhlIGNvbHVtbi4gVGhlIGZ1bmN0aW9uXG5cdFx0ICogICB0YWtlcyB0aHJlZSBwYXJhbWV0ZXJzOlxuXHRcdCAqICAgICogUGFyYW1ldGVyczpcblx0XHQgKiAgICAgICogYHthcnJheXxvYmplY3R9YCBUaGUgZGF0YSBzb3VyY2UgZm9yIHRoZSByb3dcblx0XHQgKiAgICAgICogYHtzdHJpbmd9YCBUaGUgdHlwZSBjYWxsIGRhdGEgcmVxdWVzdGVkIC0gdGhpcyB3aWxsIGJlICdzZXQnIHdoZW5cblx0XHQgKiAgICAgICAgc2V0dGluZyBkYXRhIG9yICdmaWx0ZXInLCAnZGlzcGxheScsICd0eXBlJywgJ3NvcnQnIG9yIHVuZGVmaW5lZFxuXHRcdCAqICAgICAgICB3aGVuIGdhdGhlcmluZyBkYXRhLiBOb3RlIHRoYXQgd2hlbiBgdW5kZWZpbmVkYCBpcyBnaXZlbiBmb3IgdGhlXG5cdFx0ICogICAgICAgIHR5cGUgRGF0YVRhYmxlcyBleHBlY3RzIHRvIGdldCB0aGUgcmF3IGRhdGEgZm9yIHRoZSBvYmplY3QgYmFjazxcblx0XHQgKiAgICAgICogYHsqfWAgRGF0YSB0byBzZXQgd2hlbiB0aGUgc2Vjb25kIHBhcmFtZXRlciBpcyAnc2V0Jy5cblx0XHQgKiAgICAqIFJldHVybjpcblx0XHQgKiAgICAgICogVGhlIHJldHVybiB2YWx1ZSBmcm9tIHRoZSBmdW5jdGlvbiBpcyBub3QgcmVxdWlyZWQgd2hlbiAnc2V0JyBpc1xuXHRcdCAqICAgICAgICB0aGUgdHlwZSBvZiBjYWxsLCBidXQgb3RoZXJ3aXNlIHRoZSByZXR1cm4gaXMgd2hhdCB3aWxsIGJlIHVzZWRcblx0XHQgKiAgICAgICAgZm9yIHRoZSBkYXRhIHJlcXVlc3RlZC5cblx0XHQgKlxuXHRcdCAqIE5vdGUgdGhhdCBgZGF0YWAgaXMgYSBnZXR0ZXIgYW5kIHNldHRlciBvcHRpb24uIElmIHlvdSBqdXN0IHJlcXVpcmVcblx0XHQgKiBmb3JtYXR0aW5nIG9mIGRhdGEgZm9yIG91dHB1dCwgeW91IHdpbGwgbGlrZWx5IHdhbnQgdG8gdXNlIGByZW5kZXJgIHdoaWNoXG5cdFx0ICogaXMgc2ltcGx5IGEgZ2V0dGVyIGFuZCB0aHVzIHNpbXBsZXIgdG8gdXNlLlxuXHRcdCAqXG5cdFx0ICogTm90ZSB0aGF0IHByaW9yIHRvIERhdGFUYWJsZXMgMS45LjIgYGRhdGFgIHdhcyBjYWxsZWQgYG1EYXRhUHJvcGAuIFRoZVxuXHRcdCAqIG5hbWUgY2hhbmdlIHJlZmxlY3RzIHRoZSBmbGV4aWJpbGl0eSBvZiB0aGlzIHByb3BlcnR5IGFuZCBpcyBjb25zaXN0ZW50XG5cdFx0ICogd2l0aCB0aGUgbmFtaW5nIG9mIG1SZW5kZXIuIElmICdtRGF0YVByb3AnIGlzIGdpdmVuLCB0aGVuIGl0IHdpbGwgc3RpbGxcblx0XHQgKiBiZSB1c2VkIGJ5IERhdGFUYWJsZXMsIGFzIGl0IGF1dG9tYXRpY2FsbHkgbWFwcyB0aGUgb2xkIG5hbWUgdG8gdGhlIG5ld1xuXHRcdCAqIGlmIHJlcXVpcmVkLlxuXHRcdCAqXG5cdFx0ICogIEB0eXBlIHN0cmluZ3xpbnR8ZnVuY3Rpb258bnVsbFxuXHRcdCAqICBAZGVmYXVsdCBudWxsIDxpPlVzZSBhdXRvbWF0aWNhbGx5IGNhbGN1bGF0ZWQgY29sdW1uIGluZGV4PC9pPlxuXHRcdCAqXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4uZGF0YVxuXHRcdCAqICBAZHRvcHQgQ29sdW1uc1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gUmVhZCB0YWJsZSBkYXRhIGZyb20gb2JqZWN0c1xuXHRcdCAqICAgIC8vIEpTT04gc3RydWN0dXJlIGZvciBlYWNoIHJvdzpcblx0XHQgKiAgICAvLyAgIHtcblx0XHQgKiAgICAvLyAgICAgIFwiZW5naW5lXCI6IHt2YWx1ZX0sXG5cdFx0ICogICAgLy8gICAgICBcImJyb3dzZXJcIjoge3ZhbHVlfSxcblx0XHQgKiAgICAvLyAgICAgIFwicGxhdGZvcm1cIjoge3ZhbHVlfSxcblx0XHQgKiAgICAvLyAgICAgIFwidmVyc2lvblwiOiB7dmFsdWV9LFxuXHRcdCAqICAgIC8vICAgICAgXCJncmFkZVwiOiB7dmFsdWV9XG5cdFx0ICogICAgLy8gICB9XG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJhamF4U291cmNlXCI6IFwic291cmNlcy9vYmplY3RzLnR4dFwiLFxuXHRcdCAqICAgICAgICBcImNvbHVtbnNcIjogW1xuXHRcdCAqICAgICAgICAgIHsgXCJkYXRhXCI6IFwiZW5naW5lXCIgfSxcblx0XHQgKiAgICAgICAgICB7IFwiZGF0YVwiOiBcImJyb3dzZXJcIiB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJkYXRhXCI6IFwicGxhdGZvcm1cIiB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJkYXRhXCI6IFwidmVyc2lvblwiIH0sXG5cdFx0ICogICAgICAgICAgeyBcImRhdGFcIjogXCJncmFkZVwiIH1cblx0XHQgKiAgICAgICAgXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIFJlYWQgaW5mb3JtYXRpb24gZnJvbSBkZWVwbHkgbmVzdGVkIG9iamVjdHNcblx0XHQgKiAgICAvLyBKU09OIHN0cnVjdHVyZSBmb3IgZWFjaCByb3c6XG5cdFx0ICogICAgLy8gICB7XG5cdFx0ICogICAgLy8gICAgICBcImVuZ2luZVwiOiB7dmFsdWV9LFxuXHRcdCAqICAgIC8vICAgICAgXCJicm93c2VyXCI6IHt2YWx1ZX0sXG5cdFx0ICogICAgLy8gICAgICBcInBsYXRmb3JtXCI6IHtcblx0XHQgKiAgICAvLyAgICAgICAgIFwiaW5uZXJcIjoge3ZhbHVlfVxuXHRcdCAqICAgIC8vICAgICAgfSxcblx0XHQgKiAgICAvLyAgICAgIFwiZGV0YWlsc1wiOiBbXG5cdFx0ICogICAgLy8gICAgICAgICB7dmFsdWV9LCB7dmFsdWV9XG5cdFx0ICogICAgLy8gICAgICBdXG5cdFx0ICogICAgLy8gICB9XG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJhamF4U291cmNlXCI6IFwic291cmNlcy9kZWVwLnR4dFwiLFxuXHRcdCAqICAgICAgICBcImNvbHVtbnNcIjogW1xuXHRcdCAqICAgICAgICAgIHsgXCJkYXRhXCI6IFwiZW5naW5lXCIgfSxcblx0XHQgKiAgICAgICAgICB7IFwiZGF0YVwiOiBcImJyb3dzZXJcIiB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJkYXRhXCI6IFwicGxhdGZvcm0uaW5uZXJcIiB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJkYXRhXCI6IFwiZGV0YWlscy4wXCIgfSxcblx0XHQgKiAgICAgICAgICB7IFwiZGF0YVwiOiBcImRldGFpbHMuMVwiIH1cblx0XHQgKiAgICAgICAgXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIFVzaW5nIGBkYXRhYCBhcyBhIGZ1bmN0aW9uIHRvIHByb3ZpZGUgZGlmZmVyZW50IGluZm9ybWF0aW9uIGZvclxuXHRcdCAqICAgIC8vIHNvcnRpbmcsIGZpbHRlcmluZyBhbmQgZGlzcGxheS4gSW4gdGhpcyBjYXNlLCBjdXJyZW5jeSAocHJpY2UpXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJjb2x1bW5EZWZzXCI6IFsge1xuXHRcdCAqICAgICAgICAgIFwidGFyZ2V0c1wiOiBbIDAgXSxcblx0XHQgKiAgICAgICAgICBcImRhdGFcIjogZnVuY3Rpb24gKCBzb3VyY2UsIHR5cGUsIHZhbCApIHtcblx0XHQgKiAgICAgICAgICAgIGlmICh0eXBlID09PSAnc2V0Jykge1xuXHRcdCAqICAgICAgICAgICAgICBzb3VyY2UucHJpY2UgPSB2YWw7XG5cdFx0ICogICAgICAgICAgICAgIC8vIFN0b3JlIHRoZSBjb21wdXRlZCBkaXNsYXkgYW5kIGZpbHRlciB2YWx1ZXMgZm9yIGVmZmljaWVuY3lcblx0XHQgKiAgICAgICAgICAgICAgc291cmNlLnByaWNlX2Rpc3BsYXkgPSB2YWw9PVwiXCIgPyBcIlwiIDogXCIkXCIrbnVtYmVyRm9ybWF0KHZhbCk7XG5cdFx0ICogICAgICAgICAgICAgIHNvdXJjZS5wcmljZV9maWx0ZXIgID0gdmFsPT1cIlwiID8gXCJcIiA6IFwiJFwiK251bWJlckZvcm1hdCh2YWwpK1wiIFwiK3ZhbDtcblx0XHQgKiAgICAgICAgICAgICAgcmV0dXJuO1xuXHRcdCAqICAgICAgICAgICAgfVxuXHRcdCAqICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ2Rpc3BsYXknKSB7XG5cdFx0ICogICAgICAgICAgICAgIHJldHVybiBzb3VyY2UucHJpY2VfZGlzcGxheTtcblx0XHQgKiAgICAgICAgICAgIH1cblx0XHQgKiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdmaWx0ZXInKSB7XG5cdFx0ICogICAgICAgICAgICAgIHJldHVybiBzb3VyY2UucHJpY2VfZmlsdGVyO1xuXHRcdCAqICAgICAgICAgICAgfVxuXHRcdCAqICAgICAgICAgICAgLy8gJ3NvcnQnLCAndHlwZScgYW5kIHVuZGVmaW5lZCBhbGwganVzdCB1c2UgdGhlIGludGVnZXJcblx0XHQgKiAgICAgICAgICAgIHJldHVybiBzb3VyY2UucHJpY2U7XG5cdFx0ICogICAgICAgICAgfVxuXHRcdCAqICAgICAgICB9IF1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBVc2luZyBkZWZhdWx0IGNvbnRlbnRcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImNvbHVtbkRlZnNcIjogWyB7XG5cdFx0ICogICAgICAgICAgXCJ0YXJnZXRzXCI6IFsgMCBdLFxuXHRcdCAqICAgICAgICAgIFwiZGF0YVwiOiBudWxsLFxuXHRcdCAqICAgICAgICAgIFwiZGVmYXVsdENvbnRlbnRcIjogXCJDbGljayB0byBlZGl0XCJcblx0XHQgKiAgICAgICAgfSBdXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gVXNpbmcgYXJyYXkgbm90YXRpb24gLSBvdXRwdXR0aW5nIGEgbGlzdCBmcm9tIGFuIGFycmF5XG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJjb2x1bW5EZWZzXCI6IFsge1xuXHRcdCAqICAgICAgICAgIFwidGFyZ2V0c1wiOiBbIDAgXSxcblx0XHQgKiAgICAgICAgICBcImRhdGFcIjogXCJuYW1lWywgXVwiXG5cdFx0ICogICAgICAgIH0gXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKlxuXHRcdCAqL1xuXHRcdFwibURhdGFcIjogbnVsbCxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgcHJvcGVydHkgaXMgdGhlIHJlbmRlcmluZyBwYXJ0bmVyIHRvIGBkYXRhYCBhbmQgaXQgaXMgc3VnZ2VzdGVkIHRoYXRcblx0XHQgKiB3aGVuIHlvdSB3YW50IHRvIG1hbmlwdWxhdGUgZGF0YSBmb3IgZGlzcGxheSAoaW5jbHVkaW5nIGZpbHRlcmluZyxcblx0XHQgKiBzb3J0aW5nIGV0Yykgd2l0aG91dCBhbHRlcmluZyB0aGUgdW5kZXJseWluZyBkYXRhIGZvciB0aGUgdGFibGUsIHVzZSB0aGlzXG5cdFx0ICogcHJvcGVydHkuIGByZW5kZXJgIGNhbiBiZSBjb25zaWRlcmVkIHRvIGJlIHRoZSB0aGUgcmVhZCBvbmx5IGNvbXBhbmlvbiB0b1xuXHRcdCAqIGBkYXRhYCB3aGljaCBpcyByZWFkIC8gd3JpdGUgKHRoZW4gYXMgc3VjaCBtb3JlIGNvbXBsZXgpLiBMaWtlIGBkYXRhYFxuXHRcdCAqIHRoaXMgb3B0aW9uIGNhbiBiZSBnaXZlbiBpbiBhIG51bWJlciBvZiBkaWZmZXJlbnQgd2F5cyB0byBlZmZlY3QgaXRzXG5cdFx0ICogYmVoYXZpb3VyOlxuXHRcdCAqXG5cdFx0ICogKiBgaW50ZWdlcmAgLSB0cmVhdGVkIGFzIGFuIGFycmF5IGluZGV4IGZvciB0aGUgZGF0YSBzb3VyY2UuIFRoaXMgaXMgdGhlXG5cdFx0ICogICBkZWZhdWx0IHRoYXQgRGF0YVRhYmxlcyB1c2VzIChpbmNyZW1lbnRhbGx5IGluY3JlYXNlZCBmb3IgZWFjaCBjb2x1bW4pLlxuXHRcdCAqICogYHN0cmluZ2AgLSByZWFkIGFuIG9iamVjdCBwcm9wZXJ0eSBmcm9tIHRoZSBkYXRhIHNvdXJjZS4gVGhlcmUgYXJlXG5cdFx0ICogICB0aHJlZSAnc3BlY2lhbCcgb3B0aW9ucyB0aGF0IGNhbiBiZSB1c2VkIGluIHRoZSBzdHJpbmcgdG8gYWx0ZXIgaG93XG5cdFx0ICogICBEYXRhVGFibGVzIHJlYWRzIHRoZSBkYXRhIGZyb20gdGhlIHNvdXJjZSBvYmplY3Q6XG5cdFx0ICogICAgKiBgLmAgLSBEb3R0ZWQgSmF2YXNjcmlwdCBub3RhdGlvbi4gSnVzdCBhcyB5b3UgdXNlIGEgYC5gIGluXG5cdFx0ICogICAgICBKYXZhc2NyaXB0IHRvIHJlYWQgZnJvbSBuZXN0ZWQgb2JqZWN0cywgc28gdG8gY2FuIHRoZSBvcHRpb25zXG5cdFx0ICogICAgICBzcGVjaWZpZWQgaW4gYGRhdGFgLiBGb3IgZXhhbXBsZTogYGJyb3dzZXIudmVyc2lvbmAgb3Jcblx0XHQgKiAgICAgIGBicm93c2VyLm5hbWVgLiBJZiB5b3VyIG9iamVjdCBwYXJhbWV0ZXIgbmFtZSBjb250YWlucyBhIHBlcmlvZCwgdXNlXG5cdFx0ICogICAgICBgXFxcXGAgdG8gZXNjYXBlIGl0IC0gaS5lLiBgZmlyc3RcXFxcLm5hbWVgLlxuXHRcdCAqICAgICogYFtdYCAtIEFycmF5IG5vdGF0aW9uLiBEYXRhVGFibGVzIGNhbiBhdXRvbWF0aWNhbGx5IGNvbWJpbmUgZGF0YVxuXHRcdCAqICAgICAgZnJvbSBhbmQgYXJyYXkgc291cmNlLCBqb2luaW5nIHRoZSBkYXRhIHdpdGggdGhlIGNoYXJhY3RlcnMgcHJvdmlkZWRcblx0XHQgKiAgICAgIGJldHdlZW4gdGhlIHR3byBicmFja2V0cy4gRm9yIGV4YW1wbGU6IGBuYW1lWywgXWAgd291bGQgcHJvdmlkZSBhXG5cdFx0ICogICAgICBjb21tYS1zcGFjZSBzZXBhcmF0ZWQgbGlzdCBmcm9tIHRoZSBzb3VyY2UgYXJyYXkuIElmIG5vIGNoYXJhY3RlcnNcblx0XHQgKiAgICAgIGFyZSBwcm92aWRlZCBiZXR3ZWVuIHRoZSBicmFja2V0cywgdGhlIG9yaWdpbmFsIGFycmF5IHNvdXJjZSBpc1xuXHRcdCAqICAgICAgcmV0dXJuZWQuXG5cdFx0ICogICAgKiBgKClgIC0gRnVuY3Rpb24gbm90YXRpb24uIEFkZGluZyBgKClgIHRvIHRoZSBlbmQgb2YgYSBwYXJhbWV0ZXIgd2lsbFxuXHRcdCAqICAgICAgZXhlY3V0ZSBhIGZ1bmN0aW9uIG9mIHRoZSBuYW1lIGdpdmVuLiBGb3IgZXhhbXBsZTogYGJyb3dzZXIoKWAgZm9yIGFcblx0XHQgKiAgICAgIHNpbXBsZSBmdW5jdGlvbiBvbiB0aGUgZGF0YSBzb3VyY2UsIGBicm93c2VyLnZlcnNpb24oKWAgZm9yIGFcblx0XHQgKiAgICAgIGZ1bmN0aW9uIGluIGEgbmVzdGVkIHByb3BlcnR5IG9yIGV2ZW4gYGJyb3dzZXIoKS52ZXJzaW9uYCB0byBnZXQgYW5cblx0XHQgKiAgICAgIG9iamVjdCBwcm9wZXJ0eSBpZiB0aGUgZnVuY3Rpb24gY2FsbGVkIHJldHVybnMgYW4gb2JqZWN0LlxuXHRcdCAqICogYG9iamVjdGAgLSB1c2UgZGlmZmVyZW50IGRhdGEgZm9yIHRoZSBkaWZmZXJlbnQgZGF0YSB0eXBlcyByZXF1ZXN0ZWQgYnlcblx0XHQgKiAgIERhdGFUYWJsZXMgKCdmaWx0ZXInLCAnZGlzcGxheScsICd0eXBlJyBvciAnc29ydCcpLiBUaGUgcHJvcGVydHkgbmFtZXNcblx0XHQgKiAgIG9mIHRoZSBvYmplY3QgaXMgdGhlIGRhdGEgdHlwZSB0aGUgcHJvcGVydHkgcmVmZXJzIHRvIGFuZCB0aGUgdmFsdWUgY2FuXG5cdFx0ICogICBkZWZpbmVkIHVzaW5nIGFuIGludGVnZXIsIHN0cmluZyBvciBmdW5jdGlvbiB1c2luZyB0aGUgc2FtZSBydWxlcyBhc1xuXHRcdCAqICAgYHJlbmRlcmAgbm9ybWFsbHkgZG9lcy4gTm90ZSB0aGF0IGFuIGBfYCBvcHRpb24gX211c3RfIGJlIHNwZWNpZmllZC5cblx0XHQgKiAgIFRoaXMgaXMgdGhlIGRlZmF1bHQgdmFsdWUgdG8gdXNlIGlmIHlvdSBoYXZlbid0IHNwZWNpZmllZCBhIHZhbHVlIGZvclxuXHRcdCAqICAgdGhlIGRhdGEgdHlwZSByZXF1ZXN0ZWQgYnkgRGF0YVRhYmxlcy5cblx0XHQgKiAqIGBmdW5jdGlvbmAgLSB0aGUgZnVuY3Rpb24gZ2l2ZW4gd2lsbCBiZSBleGVjdXRlZCB3aGVuZXZlciBEYXRhVGFibGVzXG5cdFx0ICogICBuZWVkcyB0byBzZXQgb3IgZ2V0IHRoZSBkYXRhIGZvciBhIGNlbGwgaW4gdGhlIGNvbHVtbi4gVGhlIGZ1bmN0aW9uXG5cdFx0ICogICB0YWtlcyB0aHJlZSBwYXJhbWV0ZXJzOlxuXHRcdCAqICAgICogUGFyYW1ldGVyczpcblx0XHQgKiAgICAgICoge2FycmF5fG9iamVjdH0gVGhlIGRhdGEgc291cmNlIGZvciB0aGUgcm93IChiYXNlZCBvbiBgZGF0YWApXG5cdFx0ICogICAgICAqIHtzdHJpbmd9IFRoZSB0eXBlIGNhbGwgZGF0YSByZXF1ZXN0ZWQgLSB0aGlzIHdpbGwgYmUgJ2ZpbHRlcicsXG5cdFx0ICogICAgICAgICdkaXNwbGF5JywgJ3R5cGUnIG9yICdzb3J0Jy5cblx0XHQgKiAgICAgICoge2FycmF5fG9iamVjdH0gVGhlIGZ1bGwgZGF0YSBzb3VyY2UgZm9yIHRoZSByb3cgKG5vdCBiYXNlZCBvblxuXHRcdCAqICAgICAgICBgZGF0YWApXG5cdFx0ICogICAgKiBSZXR1cm46XG5cdFx0ICogICAgICAqIFRoZSByZXR1cm4gdmFsdWUgZnJvbSB0aGUgZnVuY3Rpb24gaXMgd2hhdCB3aWxsIGJlIHVzZWQgZm9yIHRoZVxuXHRcdCAqICAgICAgICBkYXRhIHJlcXVlc3RlZC5cblx0XHQgKlxuXHRcdCAqICBAdHlwZSBzdHJpbmd8aW50fGZ1bmN0aW9ufG9iamVjdHxudWxsXG5cdFx0ICogIEBkZWZhdWx0IG51bGwgVXNlIHRoZSBkYXRhIHNvdXJjZSB2YWx1ZS5cblx0XHQgKlxuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uLnJlbmRlclxuXHRcdCAqICBAZHRvcHQgQ29sdW1uc1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gQ3JlYXRlIGEgY29tbWEgc2VwYXJhdGVkIGxpc3QgZnJvbSBhbiBhcnJheSBvZiBvYmplY3RzXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJhamF4U291cmNlXCI6IFwic291cmNlcy9kZWVwLnR4dFwiLFxuXHRcdCAqICAgICAgICBcImNvbHVtbnNcIjogW1xuXHRcdCAqICAgICAgICAgIHsgXCJkYXRhXCI6IFwiZW5naW5lXCIgfSxcblx0XHQgKiAgICAgICAgICB7IFwiZGF0YVwiOiBcImJyb3dzZXJcIiB9LFxuXHRcdCAqICAgICAgICAgIHtcblx0XHQgKiAgICAgICAgICAgIFwiZGF0YVwiOiBcInBsYXRmb3JtXCIsXG5cdFx0ICogICAgICAgICAgICBcInJlbmRlclwiOiBcIlssIF0ubmFtZVwiXG5cdFx0ICogICAgICAgICAgfVxuXHRcdCAqICAgICAgICBdXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gRXhlY3V0ZSBhIGZ1bmN0aW9uIHRvIG9idGFpbiBkYXRhXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJjb2x1bW5EZWZzXCI6IFsge1xuXHRcdCAqICAgICAgICAgIFwidGFyZ2V0c1wiOiBbIDAgXSxcblx0XHQgKiAgICAgICAgICBcImRhdGFcIjogbnVsbCwgLy8gVXNlIHRoZSBmdWxsIGRhdGEgc291cmNlIG9iamVjdCBmb3IgdGhlIHJlbmRlcmVyJ3Mgc291cmNlXG5cdFx0ICogICAgICAgICAgXCJyZW5kZXJcIjogXCJicm93c2VyTmFtZSgpXCJcblx0XHQgKiAgICAgICAgfSBdXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gQXMgYW4gb2JqZWN0LCBleHRyYWN0aW5nIGRpZmZlcmVudCBkYXRhIGZvciB0aGUgZGlmZmVyZW50IHR5cGVzXG5cdFx0ICogICAgLy8gVGhpcyB3b3VsZCBiZSB1c2VkIHdpdGggYSBkYXRhIHNvdXJjZSBzdWNoIGFzOlxuXHRcdCAqICAgIC8vICAgeyBcInBob25lXCI6IDU1NTIzNjgsIFwicGhvbmVfZmlsdGVyXCI6IFwiNTU1MjM2OCA1NTUtMjM2OFwiLCBcInBob25lX2Rpc3BsYXlcIjogXCI1NTUtMjM2OFwiIH1cblx0XHQgKiAgICAvLyBIZXJlIHRoZSBgcGhvbmVgIGludGVnZXIgaXMgdXNlZCBmb3Igc29ydGluZyBhbmQgdHlwZSBkZXRlY3Rpb24sIHdoaWxlIGBwaG9uZV9maWx0ZXJgXG5cdFx0ICogICAgLy8gKHdoaWNoIGhhcyBib3RoIGZvcm1zKSBpcyB1c2VkIGZvciBmaWx0ZXJpbmcgZm9yIGlmIGEgdXNlciBpbnB1dHMgZWl0aGVyIGZvcm1hdCwgd2hpbGVcblx0XHQgKiAgICAvLyB0aGUgZm9ybWF0dGVkIHBob25lIG51bWJlciBpcyB0aGUgb25lIHRoYXQgaXMgc2hvd24gaW4gdGhlIHRhYmxlLlxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwiY29sdW1uRGVmc1wiOiBbIHtcblx0XHQgKiAgICAgICAgICBcInRhcmdldHNcIjogWyAwIF0sXG5cdFx0ICogICAgICAgICAgXCJkYXRhXCI6IG51bGwsIC8vIFVzZSB0aGUgZnVsbCBkYXRhIHNvdXJjZSBvYmplY3QgZm9yIHRoZSByZW5kZXJlcidzIHNvdXJjZVxuXHRcdCAqICAgICAgICAgIFwicmVuZGVyXCI6IHtcblx0XHQgKiAgICAgICAgICAgIFwiX1wiOiBcInBob25lXCIsXG5cdFx0ICogICAgICAgICAgICBcImZpbHRlclwiOiBcInBob25lX2ZpbHRlclwiLFxuXHRcdCAqICAgICAgICAgICAgXCJkaXNwbGF5XCI6IFwicGhvbmVfZGlzcGxheVwiXG5cdFx0ICogICAgICAgICAgfVxuXHRcdCAqICAgICAgICB9IF1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBVc2UgYXMgYSBmdW5jdGlvbiB0byBjcmVhdGUgYSBsaW5rIGZyb20gdGhlIGRhdGEgc291cmNlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJjb2x1bW5EZWZzXCI6IFsge1xuXHRcdCAqICAgICAgICAgIFwidGFyZ2V0c1wiOiBbIDAgXSxcblx0XHQgKiAgICAgICAgICBcImRhdGFcIjogXCJkb3dubG9hZF9saW5rXCIsXG5cdFx0ICogICAgICAgICAgXCJyZW5kZXJcIjogZnVuY3Rpb24gKCBkYXRhLCB0eXBlLCBmdWxsICkge1xuXHRcdCAqICAgICAgICAgICAgcmV0dXJuICc8YSBocmVmPVwiJytkYXRhKydcIj5Eb3dubG9hZDwvYT4nO1xuXHRcdCAqICAgICAgICAgIH1cblx0XHQgKiAgICAgICAgfSBdXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwibVJlbmRlclwiOiBudWxsLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogQ2hhbmdlIHRoZSBjZWxsIHR5cGUgY3JlYXRlZCBmb3IgdGhlIGNvbHVtbiAtIGVpdGhlciBURCBjZWxscyBvciBUSCBjZWxscy4gVGhpc1xuXHRcdCAqIGNhbiBiZSB1c2VmdWwgYXMgVEggY2VsbHMgaGF2ZSBzZW1hbnRpYyBtZWFuaW5nIGluIHRoZSB0YWJsZSBib2R5LCBhbGxvd2luZyB0aGVtXG5cdFx0ICogdG8gYWN0IGFzIGEgaGVhZGVyIGZvciBhIHJvdyAoeW91IG1heSB3aXNoIHRvIGFkZCBzY29wZT0ncm93JyB0byB0aGUgVEggZWxlbWVudHMpLlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgdGRcblx0XHQgKlxuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uLmNlbGxUeXBlXG5cdFx0ICogIEBkdG9wdCBDb2x1bW5zXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBNYWtlIHRoZSBmaXJzdCBjb2x1bW4gdXNlIFRIIGNlbGxzXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJjb2x1bW5EZWZzXCI6IFsge1xuXHRcdCAqICAgICAgICAgIFwidGFyZ2V0c1wiOiBbIDAgXSxcblx0XHQgKiAgICAgICAgICBcImNlbGxUeXBlXCI6IFwidGhcIlxuXHRcdCAqICAgICAgICB9IF1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJzQ2VsbFR5cGVcIjogXCJ0ZFwiLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogQ2xhc3MgdG8gZ2l2ZSB0byBlYWNoIGNlbGwgaW4gdGhpcyBjb2x1bW4uXG5cdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdCAqICBAZGVmYXVsdCA8aT5FbXB0eSBzdHJpbmc8L2k+XG5cdFx0ICpcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbi5jbGFzc1xuXHRcdCAqICBAZHRvcHQgQ29sdW1uc1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gVXNpbmcgYGNvbHVtbkRlZnNgXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJjb2x1bW5EZWZzXCI6IFtcblx0XHQgKiAgICAgICAgICB7IFwiY2xhc3NcIjogXCJteV9jbGFzc1wiLCBcInRhcmdldHNcIjogWyAwIF0gfVxuXHRcdCAqICAgICAgICBdXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gVXNpbmcgYGNvbHVtbnNgXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJjb2x1bW5zXCI6IFtcblx0XHQgKiAgICAgICAgICB7IFwiY2xhc3NcIjogXCJteV9jbGFzc1wiIH0sXG5cdFx0ICogICAgICAgICAgbnVsbCxcblx0XHQgKiAgICAgICAgICBudWxsLFxuXHRcdCAqICAgICAgICAgIG51bGwsXG5cdFx0ICogICAgICAgICAgbnVsbFxuXHRcdCAqICAgICAgICBdXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwic0NsYXNzXCI6IFwiXCIsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFdoZW4gRGF0YVRhYmxlcyBjYWxjdWxhdGVzIHRoZSBjb2x1bW4gd2lkdGhzIHRvIGFzc2lnbiB0byBlYWNoIGNvbHVtbixcblx0XHQgKiBpdCBmaW5kcyB0aGUgbG9uZ2VzdCBzdHJpbmcgaW4gZWFjaCBjb2x1bW4gYW5kIHRoZW4gY29uc3RydWN0cyBhXG5cdFx0ICogdGVtcG9yYXJ5IHRhYmxlIGFuZCByZWFkcyB0aGUgd2lkdGhzIGZyb20gdGhhdC4gVGhlIHByb2JsZW0gd2l0aCB0aGlzXG5cdFx0ICogaXMgdGhhdCBcIm1tbVwiIGlzIG11Y2ggd2lkZXIgdGhlbiBcImlpaWlcIiwgYnV0IHRoZSBsYXR0ZXIgaXMgYSBsb25nZXJcblx0XHQgKiBzdHJpbmcgLSB0aHVzIHRoZSBjYWxjdWxhdGlvbiBjYW4gZ28gd3JvbmcgKGRvaW5nIGl0IHByb3Blcmx5IGFuZCBwdXR0aW5nXG5cdFx0ICogaXQgaW50byBhbiBET00gb2JqZWN0IGFuZCBtZWFzdXJpbmcgdGhhdCBpcyBob3JyaWJseSghKSBzbG93KS4gVGh1cyBhc1xuXHRcdCAqIGEgXCJ3b3JrIGFyb3VuZFwiIHdlIHByb3ZpZGUgdGhpcyBvcHRpb24uIEl0IHdpbGwgYXBwZW5kIGl0cyB2YWx1ZSB0byB0aGVcblx0XHQgKiB0ZXh0IHRoYXQgaXMgZm91bmQgdG8gYmUgdGhlIGxvbmdlc3Qgc3RyaW5nIGZvciB0aGUgY29sdW1uIC0gaS5lLiBwYWRkaW5nLlxuXHRcdCAqIEdlbmVyYWxseSB5b3Ugc2hvdWxkbid0IG5lZWQgdGhpcyFcblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICogIEBkZWZhdWx0IDxpPkVtcHR5IHN0cmluZzxpPlxuXHRcdCAqXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4uY29udGVudFBhZGRpbmdcblx0XHQgKiAgQGR0b3B0IENvbHVtbnNcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIFVzaW5nIGBjb2x1bW5zYFxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwiY29sdW1uc1wiOiBbXG5cdFx0ICogICAgICAgICAgbnVsbCxcblx0XHQgKiAgICAgICAgICBudWxsLFxuXHRcdCAqICAgICAgICAgIG51bGwsXG5cdFx0ICogICAgICAgICAge1xuXHRcdCAqICAgICAgICAgICAgXCJjb250ZW50UGFkZGluZ1wiOiBcIm1tbVwiXG5cdFx0ICogICAgICAgICAgfVxuXHRcdCAqICAgICAgICBdXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwic0NvbnRlbnRQYWRkaW5nXCI6IFwiXCIsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBBbGxvd3MgYSBkZWZhdWx0IHZhbHVlIHRvIGJlIGdpdmVuIGZvciBhIGNvbHVtbidzIGRhdGEsIGFuZCB3aWxsIGJlIHVzZWRcblx0XHQgKiB3aGVuZXZlciBhIG51bGwgZGF0YSBzb3VyY2UgaXMgZW5jb3VudGVyZWQgKHRoaXMgY2FuIGJlIGJlY2F1c2UgYGRhdGFgXG5cdFx0ICogaXMgc2V0IHRvIG51bGwsIG9yIGJlY2F1c2UgdGhlIGRhdGEgc291cmNlIGl0c2VsZiBpcyBudWxsKS5cblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKlxuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uLmRlZmF1bHRDb250ZW50XG5cdFx0ICogIEBkdG9wdCBDb2x1bW5zXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBVc2luZyBgY29sdW1uRGVmc2Bcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImNvbHVtbkRlZnNcIjogW1xuXHRcdCAqICAgICAgICAgIHtcblx0XHQgKiAgICAgICAgICAgIFwiZGF0YVwiOiBudWxsLFxuXHRcdCAqICAgICAgICAgICAgXCJkZWZhdWx0Q29udGVudFwiOiBcIkVkaXRcIixcblx0XHQgKiAgICAgICAgICAgIFwidGFyZ2V0c1wiOiBbIC0xIF1cblx0XHQgKiAgICAgICAgICB9XG5cdFx0ICogICAgICAgIF1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBVc2luZyBgY29sdW1uc2Bcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImNvbHVtbnNcIjogW1xuXHRcdCAqICAgICAgICAgIG51bGwsXG5cdFx0ICogICAgICAgICAgbnVsbCxcblx0XHQgKiAgICAgICAgICBudWxsLFxuXHRcdCAqICAgICAgICAgIHtcblx0XHQgKiAgICAgICAgICAgIFwiZGF0YVwiOiBudWxsLFxuXHRcdCAqICAgICAgICAgICAgXCJkZWZhdWx0Q29udGVudFwiOiBcIkVkaXRcIlxuXHRcdCAqICAgICAgICAgIH1cblx0XHQgKiAgICAgICAgXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcInNEZWZhdWx0Q29udGVudFwiOiBudWxsLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhpcyBwYXJhbWV0ZXIgaXMgb25seSB1c2VkIGluIERhdGFUYWJsZXMnIHNlcnZlci1zaWRlIHByb2Nlc3NpbmcuIEl0IGNhblxuXHRcdCAqIGJlIGV4Y2VwdGlvbmFsbHkgdXNlZnVsIHRvIGtub3cgd2hhdCBjb2x1bW5zIGFyZSBiZWluZyBkaXNwbGF5ZWQgb24gdGhlXG5cdFx0ICogY2xpZW50IHNpZGUsIGFuZCB0byBtYXAgdGhlc2UgdG8gZGF0YWJhc2UgZmllbGRzLiBXaGVuIGRlZmluZWQsIHRoZSBuYW1lc1xuXHRcdCAqIGFsc28gYWxsb3cgRGF0YVRhYmxlcyB0byByZW9yZGVyIGluZm9ybWF0aW9uIGZyb20gdGhlIHNlcnZlciBpZiBpdCBjb21lc1xuXHRcdCAqIGJhY2sgaW4gYW4gdW5leHBlY3RlZCBvcmRlciAoaS5lLiBpZiB5b3Ugc3dpdGNoIHlvdXIgY29sdW1ucyBhcm91bmQgb24gdGhlXG5cdFx0ICogY2xpZW50LXNpZGUsIHlvdXIgc2VydmVyLXNpZGUgY29kZSBkb2VzIG5vdCBhbHNvIG5lZWQgdXBkYXRpbmcpLlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgPGk+RW1wdHkgc3RyaW5nPC9pPlxuXHRcdCAqXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4ubmFtZVxuXHRcdCAqICBAZHRvcHQgQ29sdW1uc1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gVXNpbmcgYGNvbHVtbkRlZnNgXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJjb2x1bW5EZWZzXCI6IFtcblx0XHQgKiAgICAgICAgICB7IFwibmFtZVwiOiBcImVuZ2luZVwiLCBcInRhcmdldHNcIjogWyAwIF0gfSxcblx0XHQgKiAgICAgICAgICB7IFwibmFtZVwiOiBcImJyb3dzZXJcIiwgXCJ0YXJnZXRzXCI6IFsgMSBdIH0sXG5cdFx0ICogICAgICAgICAgeyBcIm5hbWVcIjogXCJwbGF0Zm9ybVwiLCBcInRhcmdldHNcIjogWyAyIF0gfSxcblx0XHQgKiAgICAgICAgICB7IFwibmFtZVwiOiBcInZlcnNpb25cIiwgXCJ0YXJnZXRzXCI6IFsgMyBdIH0sXG5cdFx0ICogICAgICAgICAgeyBcIm5hbWVcIjogXCJncmFkZVwiLCBcInRhcmdldHNcIjogWyA0IF0gfVxuXHRcdCAqICAgICAgICBdXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gVXNpbmcgYGNvbHVtbnNgXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJjb2x1bW5zXCI6IFtcblx0XHQgKiAgICAgICAgICB7IFwibmFtZVwiOiBcImVuZ2luZVwiIH0sXG5cdFx0ICogICAgICAgICAgeyBcIm5hbWVcIjogXCJicm93c2VyXCIgfSxcblx0XHQgKiAgICAgICAgICB7IFwibmFtZVwiOiBcInBsYXRmb3JtXCIgfSxcblx0XHQgKiAgICAgICAgICB7IFwibmFtZVwiOiBcInZlcnNpb25cIiB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJuYW1lXCI6IFwiZ3JhZGVcIiB9XG5cdFx0ICogICAgICAgIF1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJzTmFtZVwiOiBcIlwiLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogRGVmaW5lcyBhIGRhdGEgc291cmNlIHR5cGUgZm9yIHRoZSBvcmRlcmluZyB3aGljaCBjYW4gYmUgdXNlZCB0byByZWFkXG5cdFx0ICogcmVhbC10aW1lIGluZm9ybWF0aW9uIGZyb20gdGhlIHRhYmxlICh1cGRhdGluZyB0aGUgaW50ZXJuYWxseSBjYWNoZWRcblx0XHQgKiB2ZXJzaW9uKSBwcmlvciB0byBvcmRlcmluZy4gVGhpcyBhbGxvd3Mgb3JkZXJpbmcgdG8gb2NjdXIgb24gdXNlclxuXHRcdCAqIGVkaXRhYmxlIGVsZW1lbnRzIHN1Y2ggYXMgZm9ybSBpbnB1dHMuXG5cdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdCAqICBAZGVmYXVsdCBzdGRcblx0XHQgKlxuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uLm9yZGVyRGF0YVR5cGVcblx0XHQgKiAgQGR0b3B0IENvbHVtbnNcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIFVzaW5nIGBjb2x1bW5EZWZzYFxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwiY29sdW1uRGVmc1wiOiBbXG5cdFx0ICogICAgICAgICAgeyBcIm9yZGVyRGF0YVR5cGVcIjogXCJkb20tdGV4dFwiLCBcInRhcmdldHNcIjogWyAyLCAzIF0gfSxcblx0XHQgKiAgICAgICAgICB7IFwidHlwZVwiOiBcIm51bWVyaWNcIiwgXCJ0YXJnZXRzXCI6IFsgMyBdIH0sXG5cdFx0ICogICAgICAgICAgeyBcIm9yZGVyRGF0YVR5cGVcIjogXCJkb20tc2VsZWN0XCIsIFwidGFyZ2V0c1wiOiBbIDQgXSB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJvcmRlckRhdGFUeXBlXCI6IFwiZG9tLWNoZWNrYm94XCIsIFwidGFyZ2V0c1wiOiBbIDUgXSB9XG5cdFx0ICogICAgICAgIF1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBVc2luZyBgY29sdW1uc2Bcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImNvbHVtbnNcIjogW1xuXHRcdCAqICAgICAgICAgIG51bGwsXG5cdFx0ICogICAgICAgICAgbnVsbCxcblx0XHQgKiAgICAgICAgICB7IFwib3JkZXJEYXRhVHlwZVwiOiBcImRvbS10ZXh0XCIgfSxcblx0XHQgKiAgICAgICAgICB7IFwib3JkZXJEYXRhVHlwZVwiOiBcImRvbS10ZXh0XCIsIFwidHlwZVwiOiBcIm51bWVyaWNcIiB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJvcmRlckRhdGFUeXBlXCI6IFwiZG9tLXNlbGVjdFwiIH0sXG5cdFx0ICogICAgICAgICAgeyBcIm9yZGVyRGF0YVR5cGVcIjogXCJkb20tY2hlY2tib3hcIiB9XG5cdFx0ICogICAgICAgIF1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJzU29ydERhdGFUeXBlXCI6IFwic3RkXCIsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgdGl0bGUgb2YgdGhpcyBjb2x1bW4uXG5cdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdCAqICBAZGVmYXVsdCBudWxsIDxpPkRlcml2ZWQgZnJvbSB0aGUgJ1RIJyB2YWx1ZSBmb3IgdGhpcyBjb2x1bW4gaW4gdGhlXG5cdFx0ICogICAgb3JpZ2luYWwgSFRNTCB0YWJsZS48L2k+XG5cdFx0ICpcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbi50aXRsZVxuXHRcdCAqICBAZHRvcHQgQ29sdW1uc1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gVXNpbmcgYGNvbHVtbkRlZnNgXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJjb2x1bW5EZWZzXCI6IFtcblx0XHQgKiAgICAgICAgICB7IFwidGl0bGVcIjogXCJNeSBjb2x1bW4gdGl0bGVcIiwgXCJ0YXJnZXRzXCI6IFsgMCBdIH1cblx0XHQgKiAgICAgICAgXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIFVzaW5nIGBjb2x1bW5zYFxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwiY29sdW1uc1wiOiBbXG5cdFx0ICogICAgICAgICAgeyBcInRpdGxlXCI6IFwiTXkgY29sdW1uIHRpdGxlXCIgfSxcblx0XHQgKiAgICAgICAgICBudWxsLFxuXHRcdCAqICAgICAgICAgIG51bGwsXG5cdFx0ICogICAgICAgICAgbnVsbCxcblx0XHQgKiAgICAgICAgICBudWxsXG5cdFx0ICogICAgICAgIF1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJzVGl0bGVcIjogbnVsbCxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSB0eXBlIGFsbG93cyB5b3UgdG8gc3BlY2lmeSBob3cgdGhlIGRhdGEgZm9yIHRoaXMgY29sdW1uIHdpbGwgYmVcblx0XHQgKiBvcmRlcmVkLiBGb3VyIHR5cGVzIChzdHJpbmcsIG51bWVyaWMsIGRhdGUgYW5kIGh0bWwgKHdoaWNoIHdpbGwgc3RyaXBcblx0XHQgKiBIVE1MIHRhZ3MgYmVmb3JlIG9yZGVyaW5nKSkgYXJlIGN1cnJlbnRseSBhdmFpbGFibGUuIE5vdGUgdGhhdCBvbmx5IGRhdGVcblx0XHQgKiBmb3JtYXRzIHVuZGVyc3Rvb2QgYnkgSmF2YXNjcmlwdCdzIERhdGUoKSBvYmplY3Qgd2lsbCBiZSBhY2NlcHRlZCBhcyB0eXBlXG5cdFx0ICogZGF0ZS4gRm9yIGV4YW1wbGU6IFwiTWFyIDI2LCAyMDA4IDU6MDMgUE1cIi4gTWF5IHRha2UgdGhlIHZhbHVlczogJ3N0cmluZycsXG5cdFx0ICogJ251bWVyaWMnLCAnZGF0ZScgb3IgJ2h0bWwnIChieSBkZWZhdWx0KS4gRnVydGhlciB0eXBlcyBjYW4gYmUgYWRkaW5nXG5cdFx0ICogdGhyb3VnaCBwbHVnLWlucy5cblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICogIEBkZWZhdWx0IG51bGwgPGk+QXV0by1kZXRlY3RlZCBmcm9tIHJhdyBkYXRhPC9pPlxuXHRcdCAqXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4udHlwZVxuXHRcdCAqICBAZHRvcHQgQ29sdW1uc1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gVXNpbmcgYGNvbHVtbkRlZnNgXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJjb2x1bW5EZWZzXCI6IFtcblx0XHQgKiAgICAgICAgICB7IFwidHlwZVwiOiBcImh0bWxcIiwgXCJ0YXJnZXRzXCI6IFsgMCBdIH1cblx0XHQgKiAgICAgICAgXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIFVzaW5nIGBjb2x1bW5zYFxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwiY29sdW1uc1wiOiBbXG5cdFx0ICogICAgICAgICAgeyBcInR5cGVcIjogXCJodG1sXCIgfSxcblx0XHQgKiAgICAgICAgICBudWxsLFxuXHRcdCAqICAgICAgICAgIG51bGwsXG5cdFx0ICogICAgICAgICAgbnVsbCxcblx0XHQgKiAgICAgICAgICBudWxsXG5cdFx0ICogICAgICAgIF1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJzVHlwZVwiOiBudWxsLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogRGVmaW5pbmcgdGhlIHdpZHRoIG9mIHRoZSBjb2x1bW4sIHRoaXMgcGFyYW1ldGVyIG1heSB0YWtlIGFueSBDU1MgdmFsdWVcblx0XHQgKiAoM2VtLCAyMHB4IGV0YykuIERhdGFUYWJsZXMgYXBwbGllcyAnc21hcnQnIHdpZHRocyB0byBjb2x1bW5zIHdoaWNoIGhhdmUgbm90XG5cdFx0ICogYmVlbiBnaXZlbiBhIHNwZWNpZmljIHdpZHRoIHRocm91Z2ggdGhpcyBpbnRlcmZhY2UgZW5zdXJpbmcgdGhhdCB0aGUgdGFibGVcblx0XHQgKiByZW1haW5zIHJlYWRhYmxlLlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgbnVsbCA8aT5BdXRvbWF0aWM8L2k+XG5cdFx0ICpcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbi53aWR0aFxuXHRcdCAqICBAZHRvcHQgQ29sdW1uc1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gVXNpbmcgYGNvbHVtbkRlZnNgXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJjb2x1bW5EZWZzXCI6IFtcblx0XHQgKiAgICAgICAgICB7IFwid2lkdGhcIjogXCIyMCVcIiwgXCJ0YXJnZXRzXCI6IFsgMCBdIH1cblx0XHQgKiAgICAgICAgXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIFVzaW5nIGBjb2x1bW5zYFxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwiY29sdW1uc1wiOiBbXG5cdFx0ICogICAgICAgICAgeyBcIndpZHRoXCI6IFwiMjAlXCIgfSxcblx0XHQgKiAgICAgICAgICBudWxsLFxuXHRcdCAqICAgICAgICAgIG51bGwsXG5cdFx0ICogICAgICAgICAgbnVsbCxcblx0XHQgKiAgICAgICAgICBudWxsXG5cdFx0ICogICAgICAgIF1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJzV2lkdGhcIjogbnVsbFxuXHR9O1xuXHRcblx0X2ZuSHVuZ2FyaWFuTWFwKCBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uICk7XG5cdFxuXHRcblx0XG5cdC8qKlxuXHQgKiBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdCAtIHRoaXMgaG9sZHMgYWxsIHRoZSBpbmZvcm1hdGlvbiBuZWVkZWQgZm9yIGFcblx0ICogZ2l2ZW4gdGFibGUsIGluY2x1ZGluZyBjb25maWd1cmF0aW9uLCBkYXRhIGFuZCBjdXJyZW50IGFwcGxpY2F0aW9uIG9mIHRoZVxuXHQgKiB0YWJsZSBvcHRpb25zLiBEYXRhVGFibGVzIGRvZXMgbm90IGhhdmUgYSBzaW5nbGUgaW5zdGFuY2UgZm9yIGVhY2ggRGF0YVRhYmxlXG5cdCAqIHdpdGggdGhlIHNldHRpbmdzIGF0dGFjaGVkIHRvIHRoYXQgaW5zdGFuY2UsIGJ1dCByYXRoZXIgaW5zdGFuY2VzIG9mIHRoZVxuXHQgKiBEYXRhVGFibGUgXCJjbGFzc1wiIGFyZSBjcmVhdGVkIG9uLXRoZS1mbHkgYXMgbmVlZGVkICh0eXBpY2FsbHkgYnkgYVxuXHQgKiAkKCkuZGF0YVRhYmxlKCkgY2FsbCkgYW5kIHRoZSBzZXR0aW5ncyBvYmplY3QgaXMgdGhlbiBhcHBsaWVkIHRvIHRoYXRcblx0ICogaW5zdGFuY2UuXG5cdCAqXG5cdCAqIE5vdGUgdGhhdCB0aGlzIG9iamVjdCBpcyByZWxhdGVkIHRvIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9IGJ1dCB0aGlzXG5cdCAqIG9uZSBpcyB0aGUgaW50ZXJuYWwgZGF0YSBzdG9yZSBmb3IgRGF0YVRhYmxlcydzIGNhY2hlIG9mIGNvbHVtbnMuIEl0IHNob3VsZFxuXHQgKiBOT1QgYmUgbWFuaXB1bGF0ZWQgb3V0c2lkZSBvZiBEYXRhVGFibGVzLiBBbnkgY29uZmlndXJhdGlvbiBzaG91bGQgYmUgZG9uZVxuXHQgKiB0aHJvdWdoIHRoZSBpbml0aWFsaXNhdGlvbiBvcHRpb25zLlxuXHQgKiAgQG5hbWVzcGFjZVxuXHQgKiAgQHRvZG8gUmVhbGx5IHNob3VsZCBhdHRhY2ggdGhlIHNldHRpbmdzIG9iamVjdCB0byBpbmRpdmlkdWFsIGluc3RhbmNlcyBzbyB3ZVxuXHQgKiAgICBkb24ndCBuZWVkIHRvIGNyZWF0ZSBuZXcgaW5zdGFuY2VzIG9uIGVhY2ggJCgpLmRhdGFUYWJsZSgpIGNhbGwgKGlmIHRoZVxuXHQgKiAgICB0YWJsZSBhbHJlYWR5IGV4aXN0cykuIEl0IHdvdWxkIGFsc28gc2F2ZSBwYXNzaW5nIG9TZXR0aW5ncyBhcm91bmQgYW5kXG5cdCAqICAgIGludG8gZXZlcnkgc2luZ2xlIGZ1bmN0aW9uLiBIb3dldmVyLCB0aGlzIGlzIGEgdmVyeSBzaWduaWZpY2FudFxuXHQgKiAgICBhcmNoaXRlY3R1cmUgY2hhbmdlIGZvciBEYXRhVGFibGVzIGFuZCB3aWxsIGFsbW9zdCBjZXJ0YWlubHkgYnJlYWtcblx0ICogICAgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2l0aCBvbGRlciBpbnN0YWxsYXRpb25zLiBUaGlzIGlzIHNvbWV0aGluZyB0aGF0XG5cdCAqICAgIHdpbGwgYmUgZG9uZSBpbiAyLjAuXG5cdCAqL1xuXHREYXRhVGFibGUubW9kZWxzLm9TZXR0aW5ncyA9IHtcblx0XHQvKipcblx0XHQgKiBQcmltYXJ5IGZlYXR1cmVzIG9mIERhdGFUYWJsZXMgYW5kIHRoZWlyIGVuYWJsZW1lbnQgc3RhdGUuXG5cdFx0ICogIEBuYW1lc3BhY2Vcblx0XHQgKi9cblx0XHRcIm9GZWF0dXJlc1wiOiB7XG5cdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBGbGFnIHRvIHNheSBpZiBEYXRhVGFibGVzIHNob3VsZCBhdXRvbWF0aWNhbGx5IHRyeSB0byBjYWxjdWxhdGUgdGhlXG5cdFx0XHQgKiBvcHRpbXVtIHRhYmxlIGFuZCBjb2x1bW5zIHdpZHRocyAodHJ1ZSkgb3Igbm90IChmYWxzZSkuXG5cdFx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0XHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0XHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0XHQgKi9cblx0XHRcdFwiYkF1dG9XaWR0aFwiOiBudWxsLFxuXHRcblx0XHRcdC8qKlxuXHRcdFx0ICogRGVsYXkgdGhlIGNyZWF0aW9uIG9mIFRSIGFuZCBURCBlbGVtZW50cyB1bnRpbCB0aGV5IGFyZSBhY3R1YWxseVxuXHRcdFx0ICogbmVlZGVkIGJ5IGEgZHJpdmVuIHBhZ2UgZHJhdy4gVGhpcyBjYW4gZ2l2ZSBhIHNpZ25pZmljYW50IHNwZWVkXG5cdFx0XHQgKiBpbmNyZWFzZSBmb3IgQWpheCBzb3VyY2UgYW5kIEphdmFzY3JpcHQgc291cmNlIGRhdGEsIGJ1dCBtYWtlcyBub1xuXHRcdFx0ICogZGlmZmVyZW5jZSBhdCBhbGwgZnJvIERPTSBhbmQgc2VydmVyLXNpZGUgcHJvY2Vzc2luZyB0YWJsZXMuXG5cdFx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0XHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0XHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0XHQgKi9cblx0XHRcdFwiYkRlZmVyUmVuZGVyXCI6IG51bGwsXG5cdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBFbmFibGUgZmlsdGVyaW5nIG9uIHRoZSB0YWJsZSBvciBub3QuIE5vdGUgdGhhdCBpZiB0aGlzIGlzIGRpc2FibGVkXG5cdFx0XHQgKiB0aGVuIHRoZXJlIGlzIG5vIGZpbHRlcmluZyBhdCBhbGwgb24gdGhlIHRhYmxlLCBpbmNsdWRpbmcgZm5GaWx0ZXIuXG5cdFx0XHQgKiBUbyBqdXN0IHJlbW92ZSB0aGUgZmlsdGVyaW5nIGlucHV0IHVzZSBzRG9tIGFuZCByZW1vdmUgdGhlICdmJyBvcHRpb24uXG5cdFx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0XHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0XHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0XHQgKi9cblx0XHRcdFwiYkZpbHRlclwiOiBudWxsLFxuXHRcblx0XHRcdC8qKlxuXHRcdFx0ICogVGFibGUgaW5mb3JtYXRpb24gZWxlbWVudCAodGhlICdTaG93aW5nIHggb2YgeSByZWNvcmRzJyBkaXYpIGVuYWJsZVxuXHRcdFx0ICogZmxhZy5cblx0XHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHRcdCAqL1xuXHRcdFx0XCJiSW5mb1wiOiBudWxsLFxuXHRcblx0XHRcdC8qKlxuXHRcdFx0ICogUHJlc2VudCBhIHVzZXIgY29udHJvbCBhbGxvd2luZyB0aGUgZW5kIHVzZXIgdG8gY2hhbmdlIHRoZSBwYWdlIHNpemVcblx0XHRcdCAqIHdoZW4gcGFnaW5hdGlvbiBpcyBlbmFibGVkLlxuXHRcdFx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHRcdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdFx0ICovXG5cdFx0XHRcImJMZW5ndGhDaGFuZ2VcIjogbnVsbCxcblx0XG5cdFx0XHQvKipcblx0XHRcdCAqIFBhZ2luYXRpb24gZW5hYmxlZCBvciBub3QuIE5vdGUgdGhhdCBpZiB0aGlzIGlzIGRpc2FibGVkIHRoZW4gbGVuZ3RoXG5cdFx0XHQgKiBjaGFuZ2luZyBtdXN0IGFsc28gYmUgZGlzYWJsZWQuXG5cdFx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0XHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0XHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0XHQgKi9cblx0XHRcdFwiYlBhZ2luYXRlXCI6IG51bGwsXG5cdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBQcm9jZXNzaW5nIGluZGljYXRvciBlbmFibGUgZmxhZyB3aGVuZXZlciBEYXRhVGFibGVzIGlzIGVuYWN0aW5nIGFcblx0XHRcdCAqIHVzZXIgcmVxdWVzdCAtIHR5cGljYWxseSBhbiBBamF4IHJlcXVlc3QgZm9yIHNlcnZlci1zaWRlIHByb2Nlc3NpbmcuXG5cdFx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0XHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0XHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0XHQgKi9cblx0XHRcdFwiYlByb2Nlc3NpbmdcIjogbnVsbCxcblx0XG5cdFx0XHQvKipcblx0XHRcdCAqIFNlcnZlci1zaWRlIHByb2Nlc3NpbmcgZW5hYmxlZCBmbGFnIC0gd2hlbiBlbmFibGVkIERhdGFUYWJsZXMgd2lsbFxuXHRcdFx0ICogZ2V0IGFsbCBkYXRhIGZyb20gdGhlIHNlcnZlciBmb3IgZXZlcnkgZHJhdyAtIHRoZXJlIGlzIG5vIGZpbHRlcmluZyxcblx0XHRcdCAqIHNvcnRpbmcgb3IgcGFnaW5nIGRvbmUgb24gdGhlIGNsaWVudC1zaWRlLlxuXHRcdFx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHRcdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdFx0ICovXG5cdFx0XHRcImJTZXJ2ZXJTaWRlXCI6IG51bGwsXG5cdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTb3J0aW5nIGVuYWJsZW1lbnQgZmxhZy5cblx0XHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHRcdCAqL1xuXHRcdFx0XCJiU29ydFwiOiBudWxsLFxuXHRcblx0XHRcdC8qKlxuXHRcdFx0ICogTXVsdGktY29sdW1uIHNvcnRpbmdcblx0XHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHRcdCAqL1xuXHRcdFx0XCJiU29ydE11bHRpXCI6IG51bGwsXG5cdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBBcHBseSBhIGNsYXNzIHRvIHRoZSBjb2x1bW5zIHdoaWNoIGFyZSBiZWluZyBzb3J0ZWQgdG8gcHJvdmlkZSBhXG5cdFx0XHQgKiB2aXN1YWwgaGlnaGxpZ2h0IG9yIG5vdC4gVGhpcyBjYW4gc2xvdyB0aGluZ3MgZG93biB3aGVuIGVuYWJsZWQgc2luY2Vcblx0XHRcdCAqIHRoZXJlIGlzIGEgbG90IG9mIERPTSBpbnRlcmFjdGlvbi5cblx0XHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHRcdCAqL1xuXHRcdFx0XCJiU29ydENsYXNzZXNcIjogbnVsbCxcblx0XG5cdFx0XHQvKipcblx0XHRcdCAqIFN0YXRlIHNhdmluZyBlbmFibGVtZW50IGZsYWcuXG5cdFx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0XHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0XHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0XHQgKi9cblx0XHRcdFwiYlN0YXRlU2F2ZVwiOiBudWxsXG5cdFx0fSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFNjcm9sbGluZyBzZXR0aW5ncyBmb3IgYSB0YWJsZS5cblx0XHQgKiAgQG5hbWVzcGFjZVxuXHRcdCAqL1xuXHRcdFwib1Njcm9sbFwiOiB7XG5cdFx0XHQvKipcblx0XHRcdCAqIFdoZW4gdGhlIHRhYmxlIGlzIHNob3J0ZXIgaW4gaGVpZ2h0IHRoYW4gc1Njcm9sbFksIGNvbGxhcHNlIHRoZVxuXHRcdFx0ICogdGFibGUgY29udGFpbmVyIGRvd24gdG8gdGhlIGhlaWdodCBvZiB0aGUgdGFibGUgKHdoZW4gdHJ1ZSkuXG5cdFx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0XHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0XHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0XHQgKi9cblx0XHRcdFwiYkNvbGxhcHNlXCI6IG51bGwsXG5cdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBXaWR0aCBvZiB0aGUgc2Nyb2xsYmFyIGZvciB0aGUgd2ViLWJyb3dzZXIncyBwbGF0Zm9ybS4gQ2FsY3VsYXRlZFxuXHRcdFx0ICogZHVyaW5nIHRhYmxlIGluaXRpYWxpc2F0aW9uLlxuXHRcdFx0ICogIEB0eXBlIGludFxuXHRcdFx0ICogIEBkZWZhdWx0IDBcblx0XHRcdCAqL1xuXHRcdFx0XCJpQmFyV2lkdGhcIjogMCxcblx0XG5cdFx0XHQvKipcblx0XHRcdCAqIFZpZXdwb3J0IHdpZHRoIGZvciBob3Jpem9udGFsIHNjcm9sbGluZy4gSG9yaXpvbnRhbCBzY3JvbGxpbmcgaXNcblx0XHRcdCAqIGRpc2FibGVkIGlmIGFuIGVtcHR5IHN0cmluZy5cblx0XHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdFx0ICovXG5cdFx0XHRcInNYXCI6IG51bGwsXG5cdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBXaWR0aCB0byBleHBhbmQgdGhlIHRhYmxlIHRvIHdoZW4gdXNpbmcgeC1zY3JvbGxpbmcuIFR5cGljYWxseSB5b3Vcblx0XHRcdCAqIHNob3VsZCBub3QgbmVlZCB0byB1c2UgdGhpcy5cblx0XHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdFx0ICogIEBkZXByZWNhdGVkXG5cdFx0XHQgKi9cblx0XHRcdFwic1hJbm5lclwiOiBudWxsLFxuXHRcblx0XHRcdC8qKlxuXHRcdFx0ICogVmlld3BvcnQgaGVpZ2h0IGZvciB2ZXJ0aWNhbCBzY3JvbGxpbmcuIFZlcnRpY2FsIHNjcm9sbGluZyBpcyBkaXNhYmxlZFxuXHRcdFx0ICogaWYgYW4gZW1wdHkgc3RyaW5nLlxuXHRcdFx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHRcdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0XHQgKi9cblx0XHRcdFwic1lcIjogbnVsbFxuXHRcdH0sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIExhbmd1YWdlIGluZm9ybWF0aW9uIGZvciB0aGUgdGFibGUuXG5cdFx0ICogIEBuYW1lc3BhY2Vcblx0XHQgKiAgQGV4dGVuZHMgRGF0YVRhYmxlLmRlZmF1bHRzLm9MYW5ndWFnZVxuXHRcdCAqL1xuXHRcdFwib0xhbmd1YWdlXCI6IHtcblx0XHRcdC8qKlxuXHRcdFx0ICogSW5mb3JtYXRpb24gY2FsbGJhY2sgZnVuY3Rpb24uIFNlZVxuXHRcdFx0ICoge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0cy5mbkluZm9DYWxsYmFja31cblx0XHRcdCAqICBAdHlwZSBmdW5jdGlvblxuXHRcdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHRcdCAqL1xuXHRcdFx0XCJmbkluZm9DYWxsYmFja1wiOiBudWxsXG5cdFx0fSxcblx0XG5cdFx0LyoqXG5cdFx0ICogQnJvd3NlciBzdXBwb3J0IHBhcmFtZXRlcnNcblx0XHQgKiAgQG5hbWVzcGFjZVxuXHRcdCAqL1xuXHRcdFwib0Jyb3dzZXJcIjoge1xuXHRcdFx0LyoqXG5cdFx0XHQgKiBJbmRpY2F0ZSBpZiB0aGUgYnJvd3NlciBpbmNvcnJlY3RseSBjYWxjdWxhdGVzIHdpZHRoOjEwMCUgaW5zaWRlIGFcblx0XHRcdCAqIHNjcm9sbGluZyBlbGVtZW50IChJRTYvNylcblx0XHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0XHQgKiAgQGRlZmF1bHQgZmFsc2Vcblx0XHRcdCAqL1xuXHRcdFx0XCJiU2Nyb2xsT3ZlcnNpemVcIjogZmFsc2UsXG5cdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBEZXRlcm1pbmUgaWYgdGhlIHZlcnRpY2FsIHNjcm9sbGJhciBpcyBvbiB0aGUgcmlnaHQgb3IgbGVmdCBvZiB0aGVcblx0XHRcdCAqIHNjcm9sbGluZyBjb250YWluZXIgLSBuZWVkZWQgZm9yIHJ0bCBsYW5ndWFnZSBsYXlvdXQsIGFsdGhvdWdoIG5vdFxuXHRcdFx0ICogYWxsIGJyb3dzZXJzIG1vdmUgdGhlIHNjcm9sbGJhciAoU2FmYXJpKS5cblx0XHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0XHQgKiAgQGRlZmF1bHQgZmFsc2Vcblx0XHRcdCAqL1xuXHRcdFx0XCJiU2Nyb2xsYmFyTGVmdFwiOiBmYWxzZSxcblx0XG5cdFx0XHQvKipcblx0XHRcdCAqIEZsYWcgZm9yIGlmIGBnZXRCb3VuZGluZ0NsaWVudFJlY3RgIGlzIGZ1bGx5IHN1cHBvcnRlZCBvciBub3Rcblx0XHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0XHQgKiAgQGRlZmF1bHQgZmFsc2Vcblx0XHRcdCAqL1xuXHRcdFx0XCJiQm91bmRpbmdcIjogZmFsc2UsXG5cdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBCcm93c2VyIHNjcm9sbGJhciB3aWR0aFxuXHRcdFx0ICogIEB0eXBlIGludGVnZXJcblx0XHRcdCAqICBAZGVmYXVsdCAwXG5cdFx0XHQgKi9cblx0XHRcdFwiYmFyV2lkdGhcIjogMFxuXHRcdH0sXG5cdFxuXHRcblx0XHRcImFqYXhcIjogbnVsbCxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEFycmF5IHJlZmVyZW5jaW5nIHRoZSBub2RlcyB3aGljaCBhcmUgdXNlZCBmb3IgdGhlIGZlYXR1cmVzLiBUaGVcblx0XHQgKiBwYXJhbWV0ZXJzIG9mIHRoaXMgb2JqZWN0IG1hdGNoIHdoYXQgaXMgYWxsb3dlZCBieSBzRG9tIC0gaS5lLlxuXHRcdCAqICAgPHVsPlxuXHRcdCAqICAgICA8bGk+J2wnIC0gTGVuZ3RoIGNoYW5naW5nPC9saT5cblx0XHQgKiAgICAgPGxpPidmJyAtIEZpbHRlcmluZyBpbnB1dDwvbGk+XG5cdFx0ICogICAgIDxsaT4ndCcgLSBUaGUgdGFibGUhPC9saT5cblx0XHQgKiAgICAgPGxpPidpJyAtIEluZm9ybWF0aW9uPC9saT5cblx0XHQgKiAgICAgPGxpPidwJyAtIFBhZ2luYXRpb248L2xpPlxuXHRcdCAqICAgICA8bGk+J3InIC0gcFJvY2Vzc2luZzwvbGk+XG5cdFx0ICogICA8L3VsPlxuXHRcdCAqICBAdHlwZSBhcnJheVxuXHRcdCAqICBAZGVmYXVsdCBbXVxuXHRcdCAqL1xuXHRcdFwiYWFuRmVhdHVyZXNcIjogW10sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFN0b3JlIGRhdGEgaW5mb3JtYXRpb24gLSBzZWUge0BsaW5rIERhdGFUYWJsZS5tb2RlbHMub1Jvd30gZm9yIGRldGFpbGVkXG5cdFx0ICogaW5mb3JtYXRpb24uXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IFtdXG5cdFx0ICovXG5cdFx0XCJhb0RhdGFcIjogW10sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEFycmF5IG9mIGluZGV4ZXMgd2hpY2ggYXJlIGluIHRoZSBjdXJyZW50IGRpc3BsYXkgKGFmdGVyIGZpbHRlcmluZyBldGMpXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IFtdXG5cdFx0ICovXG5cdFx0XCJhaURpc3BsYXlcIjogW10sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEFycmF5IG9mIGluZGV4ZXMgZm9yIGRpc3BsYXkgLSBubyBmaWx0ZXJpbmdcblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgW11cblx0XHQgKi9cblx0XHRcImFpRGlzcGxheU1hc3RlclwiOiBbXSxcblx0XG5cdFx0LyoqXG5cdFx0ICogTWFwIG9mIHJvdyBpZHMgdG8gZGF0YSBpbmRleGVzXG5cdFx0ICogIEB0eXBlIG9iamVjdFxuXHRcdCAqICBAZGVmYXVsdCB7fVxuXHRcdCAqL1xuXHRcdFwiYUlkc1wiOiB7fSxcblx0XG5cdFx0LyoqXG5cdFx0ICogU3RvcmUgaW5mb3JtYXRpb24gYWJvdXQgZWFjaCBjb2x1bW4gdGhhdCBpcyBpbiB1c2Vcblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgW11cblx0XHQgKi9cblx0XHRcImFvQ29sdW1uc1wiOiBbXSxcblx0XG5cdFx0LyoqXG5cdFx0ICogU3RvcmUgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHRhYmxlJ3MgaGVhZGVyXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IFtdXG5cdFx0ICovXG5cdFx0XCJhb0hlYWRlclwiOiBbXSxcblx0XG5cdFx0LyoqXG5cdFx0ICogU3RvcmUgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHRhYmxlJ3MgZm9vdGVyXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IFtdXG5cdFx0ICovXG5cdFx0XCJhb0Zvb3RlclwiOiBbXSxcblx0XG5cdFx0LyoqXG5cdFx0ICogU3RvcmUgdGhlIGFwcGxpZWQgZ2xvYmFsIHNlYXJjaCBpbmZvcm1hdGlvbiBpbiBjYXNlIHdlIHdhbnQgdG8gZm9yY2UgYVxuXHRcdCAqIHJlc2VhcmNoIG9yIGNvbXBhcmUgdGhlIG9sZCBzZWFyY2ggdG8gYSBuZXcgb25lLlxuXHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0XHQgKiAgQG5hbWVzcGFjZVxuXHRcdCAqICBAZXh0ZW5kcyBEYXRhVGFibGUubW9kZWxzLm9TZWFyY2hcblx0XHQgKi9cblx0XHRcIm9QcmV2aW91c1NlYXJjaFwiOiB7fSxcblx0XG5cdFx0LyoqXG5cdFx0ICogU3RvcmUgdGhlIGFwcGxpZWQgc2VhcmNoIGZvciBlYWNoIGNvbHVtbiAtIHNlZVxuXHRcdCAqIHtAbGluayBEYXRhVGFibGUubW9kZWxzLm9TZWFyY2h9IGZvciB0aGUgZm9ybWF0IHRoYXQgaXMgdXNlZCBmb3IgdGhlXG5cdFx0ICogZmlsdGVyaW5nIGluZm9ybWF0aW9uIGZvciBlYWNoIGNvbHVtbi5cblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgW11cblx0XHQgKi9cblx0XHRcImFvUHJlU2VhcmNoQ29sc1wiOiBbXSxcblx0XG5cdFx0LyoqXG5cdFx0ICogU29ydGluZyB0aGF0IGlzIGFwcGxpZWQgdG8gdGhlIHRhYmxlLiBOb3RlIHRoYXQgdGhlIGlubmVyIGFycmF5cyBhcmVcblx0XHQgKiB1c2VkIGluIHRoZSBmb2xsb3dpbmcgbWFubmVyOlxuXHRcdCAqIDx1bD5cblx0XHQgKiAgIDxsaT5JbmRleCAwIC0gY29sdW1uIG51bWJlcjwvbGk+XG5cdFx0ICogICA8bGk+SW5kZXggMSAtIGN1cnJlbnQgc29ydGluZyBkaXJlY3Rpb248L2xpPlxuXHRcdCAqIDwvdWw+XG5cdFx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdCAqICBAdHlwZSBhcnJheVxuXHRcdCAqICBAdG9kbyBUaGVzZSBpbm5lciBhcnJheXMgc2hvdWxkIHJlYWxseSBiZSBvYmplY3RzXG5cdFx0ICovXG5cdFx0XCJhYVNvcnRpbmdcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogU29ydGluZyB0aGF0IGlzIGFsd2F5cyBhcHBsaWVkIHRvIHRoZSB0YWJsZSAoaS5lLiBwcmVmaXhlZCBpbiBmcm9udCBvZlxuXHRcdCAqIGFhU29ydGluZykuXG5cdFx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdCAqICBAdHlwZSBhcnJheVxuXHRcdCAqICBAZGVmYXVsdCBbXVxuXHRcdCAqL1xuXHRcdFwiYWFTb3J0aW5nRml4ZWRcIjogW10sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIENsYXNzZXMgdG8gdXNlIGZvciB0aGUgc3RyaXBpbmcgb2YgYSB0YWJsZS5cblx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IFtdXG5cdFx0ICovXG5cdFx0XCJhc1N0cmlwZUNsYXNzZXNcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogSWYgcmVzdG9yaW5nIGEgdGFibGUgLSB3ZSBzaG91bGQgcmVzdG9yZSBpdHMgc3RyaXBpbmcgY2xhc3NlcyBhcyB3ZWxsXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IFtdXG5cdFx0ICovXG5cdFx0XCJhc0Rlc3Ryb3lTdHJpcGVzXCI6IFtdLFxuXHRcblx0XHQvKipcblx0XHQgKiBJZiByZXN0b3JpbmcgYSB0YWJsZSAtIHdlIHNob3VsZCByZXN0b3JlIGl0cyB3aWR0aFxuXHRcdCAqICBAdHlwZSBpbnRcblx0XHQgKiAgQGRlZmF1bHQgMFxuXHRcdCAqL1xuXHRcdFwic0Rlc3Ryb3lXaWR0aFwiOiAwLFxuXHRcblx0XHQvKipcblx0XHQgKiBDYWxsYmFjayBmdW5jdGlvbnMgYXJyYXkgZm9yIGV2ZXJ5IHRpbWUgYSByb3cgaXMgaW5zZXJ0ZWQgKGkuZS4gb24gYSBkcmF3KS5cblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgW11cblx0XHQgKi9cblx0XHRcImFvUm93Q2FsbGJhY2tcIjogW10sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIENhbGxiYWNrIGZ1bmN0aW9ucyBmb3IgdGhlIGhlYWRlciBvbiBlYWNoIGRyYXcuXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IFtdXG5cdFx0ICovXG5cdFx0XCJhb0hlYWRlckNhbGxiYWNrXCI6IFtdLFxuXHRcblx0XHQvKipcblx0XHQgKiBDYWxsYmFjayBmdW5jdGlvbiBmb3IgdGhlIGZvb3RlciBvbiBlYWNoIGRyYXcuXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IFtdXG5cdFx0ICovXG5cdFx0XCJhb0Zvb3RlckNhbGxiYWNrXCI6IFtdLFxuXHRcblx0XHQvKipcblx0XHQgKiBBcnJheSBvZiBjYWxsYmFjayBmdW5jdGlvbnMgZm9yIGRyYXcgY2FsbGJhY2sgZnVuY3Rpb25zXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IFtdXG5cdFx0ICovXG5cdFx0XCJhb0RyYXdDYWxsYmFja1wiOiBbXSxcblx0XG5cdFx0LyoqXG5cdFx0ICogQXJyYXkgb2YgY2FsbGJhY2sgZnVuY3Rpb25zIGZvciByb3cgY3JlYXRlZCBmdW5jdGlvblxuXHRcdCAqICBAdHlwZSBhcnJheVxuXHRcdCAqICBAZGVmYXVsdCBbXVxuXHRcdCAqL1xuXHRcdFwiYW9Sb3dDcmVhdGVkQ2FsbGJhY2tcIjogW10sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIENhbGxiYWNrIGZ1bmN0aW9ucyBmb3IganVzdCBiZWZvcmUgdGhlIHRhYmxlIGlzIHJlZHJhd24uIEEgcmV0dXJuIG9mXG5cdFx0ICogZmFsc2Ugd2lsbCBiZSB1c2VkIHRvIGNhbmNlbCB0aGUgZHJhdy5cblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgW11cblx0XHQgKi9cblx0XHRcImFvUHJlRHJhd0NhbGxiYWNrXCI6IFtdLFxuXHRcblx0XHQvKipcblx0XHQgKiBDYWxsYmFjayBmdW5jdGlvbnMgZm9yIHdoZW4gdGhlIHRhYmxlIGhhcyBiZWVuIGluaXRpYWxpc2VkLlxuXHRcdCAqICBAdHlwZSBhcnJheVxuXHRcdCAqICBAZGVmYXVsdCBbXVxuXHRcdCAqL1xuXHRcdFwiYW9Jbml0Q29tcGxldGVcIjogW10sXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBDYWxsYmFja3MgZm9yIG1vZGlmeWluZyB0aGUgc2V0dGluZ3MgdG8gYmUgc3RvcmVkIGZvciBzdGF0ZSBzYXZpbmcsIHByaW9yIHRvXG5cdFx0ICogc2F2aW5nIHN0YXRlLlxuXHRcdCAqICBAdHlwZSBhcnJheVxuXHRcdCAqICBAZGVmYXVsdCBbXVxuXHRcdCAqL1xuXHRcdFwiYW9TdGF0ZVNhdmVQYXJhbXNcIjogW10sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIENhbGxiYWNrcyBmb3IgbW9kaWZ5aW5nIHRoZSBzZXR0aW5ncyB0aGF0IGhhdmUgYmVlbiBzdG9yZWQgZm9yIHN0YXRlIHNhdmluZ1xuXHRcdCAqIHByaW9yIHRvIHVzaW5nIHRoZSBzdG9yZWQgdmFsdWVzIHRvIHJlc3RvcmUgdGhlIHN0YXRlLlxuXHRcdCAqICBAdHlwZSBhcnJheVxuXHRcdCAqICBAZGVmYXVsdCBbXVxuXHRcdCAqL1xuXHRcdFwiYW9TdGF0ZUxvYWRQYXJhbXNcIjogW10sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIENhbGxiYWNrcyBmb3Igb3BlcmF0aW5nIG9uIHRoZSBzZXR0aW5ncyBvYmplY3Qgb25jZSB0aGUgc2F2ZWQgc3RhdGUgaGFzIGJlZW5cblx0XHQgKiBsb2FkZWRcblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgW11cblx0XHQgKi9cblx0XHRcImFvU3RhdGVMb2FkZWRcIjogW10sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIENhY2hlIHRoZSB0YWJsZSBJRCBmb3IgcXVpY2sgYWNjZXNzXG5cdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdCAqICBAZGVmYXVsdCA8aT5FbXB0eSBzdHJpbmc8L2k+XG5cdFx0ICovXG5cdFx0XCJzVGFibGVJZFwiOiBcIlwiLFxuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgVEFCTEUgbm9kZSBmb3IgdGhlIG1haW4gdGFibGVcblx0XHQgKiAgQHR5cGUgbm9kZVxuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0XCJuVGFibGVcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogUGVybWFuZW50IHJlZiB0byB0aGUgdGhlYWQgZWxlbWVudFxuXHRcdCAqICBAdHlwZSBub2RlXG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHRcIm5USGVhZFwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBQZXJtYW5lbnQgcmVmIHRvIHRoZSB0Zm9vdCBlbGVtZW50IC0gaWYgaXQgZXhpc3RzXG5cdFx0ICogIEB0eXBlIG5vZGVcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdFwiblRGb290XCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFBlcm1hbmVudCByZWYgdG8gdGhlIHRib2R5IGVsZW1lbnRcblx0XHQgKiAgQHR5cGUgbm9kZVxuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0XCJuVEJvZHlcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogQ2FjaGUgdGhlIHdyYXBwZXIgbm9kZSAoY29udGFpbnMgYWxsIERhdGFUYWJsZXMgY29udHJvbGxlZCBlbGVtZW50cylcblx0XHQgKiAgQHR5cGUgbm9kZVxuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0XCJuVGFibGVXcmFwcGVyXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlIGlmIHdoZW4gdXNpbmcgc2VydmVyLXNpZGUgcHJvY2Vzc2luZyB0aGUgbG9hZGluZyBvZiBkYXRhXG5cdFx0ICogc2hvdWxkIGJlIGRlZmVycmVkIHVudGlsIHRoZSBzZWNvbmQgZHJhdy5cblx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKiAgQGRlZmF1bHQgZmFsc2Vcblx0XHQgKi9cblx0XHRcImJEZWZlckxvYWRpbmdcIjogZmFsc2UsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlIGlmIGFsbCByZXF1aXJlZCBpbmZvcm1hdGlvbiBoYXMgYmVlbiByZWFkIGluXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKiAgQGRlZmF1bHQgZmFsc2Vcblx0XHQgKi9cblx0XHRcImJJbml0aWFsaXNlZFwiOiBmYWxzZSxcblx0XG5cdFx0LyoqXG5cdFx0ICogSW5mb3JtYXRpb24gYWJvdXQgb3BlbiByb3dzLiBFYWNoIG9iamVjdCBpbiB0aGUgYXJyYXkgaGFzIHRoZSBwYXJhbWV0ZXJzXG5cdFx0ICogJ25UcicgYW5kICduUGFyZW50J1xuXHRcdCAqICBAdHlwZSBhcnJheVxuXHRcdCAqICBAZGVmYXVsdCBbXVxuXHRcdCAqL1xuXHRcdFwiYW9PcGVuUm93c1wiOiBbXSxcblx0XG5cdFx0LyoqXG5cdFx0ICogRGljdGF0ZSB0aGUgcG9zaXRpb25pbmcgb2YgRGF0YVRhYmxlcycgY29udHJvbCBlbGVtZW50cyAtIHNlZVxuXHRcdCAqIHtAbGluayBEYXRhVGFibGUubW9kZWwub0luaXQuc0RvbX0uXG5cdFx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdFwic0RvbVwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBTZWFyY2ggZGVsYXkgKGluIG1TKVxuXHRcdCAqICBAdHlwZSBpbnRlZ2VyXG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHRcInNlYXJjaERlbGF5XCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFdoaWNoIHR5cGUgb2YgcGFnaW5hdGlvbiBzaG91bGQgYmUgdXNlZC5cblx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdCAqICBAZGVmYXVsdCB0d29fYnV0dG9uXG5cdFx0ICovXG5cdFx0XCJzUGFnaW5hdGlvblR5cGVcIjogXCJ0d29fYnV0dG9uXCIsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBzdGF0ZSBkdXJhdGlvbiAoZm9yIGBzdGF0ZVNhdmVgKSBpbiBzZWNvbmRzLlxuXHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0XHQgKiAgQHR5cGUgaW50XG5cdFx0ICogIEBkZWZhdWx0IDBcblx0XHQgKi9cblx0XHRcImlTdGF0ZUR1cmF0aW9uXCI6IDAsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEFycmF5IG9mIGNhbGxiYWNrIGZ1bmN0aW9ucyBmb3Igc3RhdGUgc2F2aW5nLiBFYWNoIGFycmF5IGVsZW1lbnQgaXMgYW5cblx0XHQgKiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnM6XG5cdFx0ICogICA8dWw+XG5cdFx0ICogICAgIDxsaT5mdW5jdGlvbjpmbiAtIGZ1bmN0aW9uIHRvIGNhbGwuIFRha2VzIHR3byBwYXJhbWV0ZXJzLCBvU2V0dGluZ3Ncblx0XHQgKiAgICAgICBhbmQgdGhlIEpTT04gc3RyaW5nIHRvIHNhdmUgdGhhdCBoYXMgYmVlbiB0aHVzIGZhciBjcmVhdGVkLiBSZXR1cm5zXG5cdFx0ICogICAgICAgYSBKU09OIHN0cmluZyB0byBiZSBpbnNlcnRlZCBpbnRvIGEganNvbiBvYmplY3Rcblx0XHQgKiAgICAgICAoaS5lLiAnXCJwYXJhbVwiOiBbIDAsIDEsIDJdJyk8L2xpPlxuXHRcdCAqICAgICA8bGk+c3RyaW5nOnNOYW1lIC0gbmFtZSBvZiBjYWxsYmFjazwvbGk+XG5cdFx0ICogICA8L3VsPlxuXHRcdCAqICBAdHlwZSBhcnJheVxuXHRcdCAqICBAZGVmYXVsdCBbXVxuXHRcdCAqL1xuXHRcdFwiYW9TdGF0ZVNhdmVcIjogW10sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEFycmF5IG9mIGNhbGxiYWNrIGZ1bmN0aW9ucyBmb3Igc3RhdGUgbG9hZGluZy4gRWFjaCBhcnJheSBlbGVtZW50IGlzIGFuXG5cdFx0ICogb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwYXJhbWV0ZXJzOlxuXHRcdCAqICAgPHVsPlxuXHRcdCAqICAgICA8bGk+ZnVuY3Rpb246Zm4gLSBmdW5jdGlvbiB0byBjYWxsLiBUYWtlcyB0d28gcGFyYW1ldGVycywgb1NldHRpbmdzXG5cdFx0ICogICAgICAgYW5kIHRoZSBvYmplY3Qgc3RvcmVkLiBNYXkgcmV0dXJuIGZhbHNlIHRvIGNhbmNlbCBzdGF0ZSBsb2FkaW5nPC9saT5cblx0XHQgKiAgICAgPGxpPnN0cmluZzpzTmFtZSAtIG5hbWUgb2YgY2FsbGJhY2s8L2xpPlxuXHRcdCAqICAgPC91bD5cblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgW11cblx0XHQgKi9cblx0XHRcImFvU3RhdGVMb2FkXCI6IFtdLFxuXHRcblx0XHQvKipcblx0XHQgKiBTdGF0ZSB0aGF0IHdhcyBzYXZlZC4gVXNlZnVsIGZvciBiYWNrIHJlZmVyZW5jZVxuXHRcdCAqICBAdHlwZSBvYmplY3Rcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdFwib1NhdmVkU3RhdGVcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogU3RhdGUgdGhhdCB3YXMgbG9hZGVkLiBVc2VmdWwgZm9yIGJhY2sgcmVmZXJlbmNlXG5cdFx0ICogIEB0eXBlIG9iamVjdFxuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0XCJvTG9hZGVkU3RhdGVcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogU291cmNlIHVybCBmb3IgQUpBWCBkYXRhIGZvciB0aGUgdGFibGUuXG5cdFx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdFwic0FqYXhTb3VyY2VcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogUHJvcGVydHkgZnJvbSBhIGdpdmVuIG9iamVjdCBmcm9tIHdoaWNoIHRvIHJlYWQgdGhlIHRhYmxlIGRhdGEgZnJvbS4gVGhpc1xuXHRcdCAqIGNhbiBiZSBhbiBlbXB0eSBzdHJpbmcgKHdoZW4gbm90IHNlcnZlci1zaWRlIHByb2Nlc3NpbmcpLCBpbiB3aGljaCBjYXNlXG5cdFx0ICogaXQgaXMgIGFzc3VtZWQgYW4gYW4gYXJyYXkgaXMgZ2l2ZW4gZGlyZWN0bHkuXG5cdFx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKi9cblx0XHRcInNBamF4RGF0YVByb3BcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogTm90ZSBpZiBkcmF3IHNob3VsZCBiZSBibG9ja2VkIHdoaWxlIGdldHRpbmcgZGF0YVxuXHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0ICogIEBkZWZhdWx0IHRydWVcblx0XHQgKi9cblx0XHRcImJBamF4RGF0YUdldFwiOiB0cnVlLFxuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgbGFzdCBqUXVlcnkgWEhSIG9iamVjdCB0aGF0IHdhcyB1c2VkIGZvciBzZXJ2ZXItc2lkZSBkYXRhIGdhdGhlcmluZy5cblx0XHQgKiBUaGlzIGNhbiBiZSB1c2VkIGZvciB3b3JraW5nIHdpdGggdGhlIFhIUiBpbmZvcm1hdGlvbiBpbiBvbmUgb2YgdGhlXG5cdFx0ICogY2FsbGJhY2tzXG5cdFx0ICogIEB0eXBlIG9iamVjdFxuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0XCJqcVhIUlwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBKU09OIHJldHVybmVkIGZyb20gdGhlIHNlcnZlciBpbiB0aGUgbGFzdCBBamF4IHJlcXVlc3Rcblx0XHQgKiAgQHR5cGUgb2JqZWN0XG5cdFx0ICogIEBkZWZhdWx0IHVuZGVmaW5lZFxuXHRcdCAqL1xuXHRcdFwianNvblwiOiB1bmRlZmluZWQsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIERhdGEgc3VibWl0dGVkIGFzIHBhcnQgb2YgdGhlIGxhc3QgQWpheCByZXF1ZXN0XG5cdFx0ICogIEB0eXBlIG9iamVjdFxuXHRcdCAqICBAZGVmYXVsdCB1bmRlZmluZWRcblx0XHQgKi9cblx0XHRcIm9BamF4RGF0YVwiOiB1bmRlZmluZWQsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEZ1bmN0aW9uIHRvIGdldCB0aGUgc2VydmVyLXNpZGUgZGF0YS5cblx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0ICogIEB0eXBlIGZ1bmN0aW9uXG5cdFx0ICovXG5cdFx0XCJmblNlcnZlckRhdGFcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogRnVuY3Rpb25zIHdoaWNoIGFyZSBjYWxsZWQgcHJpb3IgdG8gc2VuZGluZyBhbiBBamF4IHJlcXVlc3Qgc28gZXh0cmFcblx0XHQgKiBwYXJhbWV0ZXJzIGNhbiBlYXNpbHkgYmUgc2VudCB0byB0aGUgc2VydmVyXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IFtdXG5cdFx0ICovXG5cdFx0XCJhb1NlcnZlclBhcmFtc1wiOiBbXSxcblx0XG5cdFx0LyoqXG5cdFx0ICogU2VuZCB0aGUgWEhSIEhUVFAgbWV0aG9kIC0gR0VUIG9yIFBPU1QgKGNvdWxkIGJlIFBVVCBvciBERUxFVEUgaWZcblx0XHQgKiByZXF1aXJlZCkuXG5cdFx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKi9cblx0XHRcInNTZXJ2ZXJNZXRob2RcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogRm9ybWF0IG51bWJlcnMgZm9yIGRpc3BsYXkuXG5cdFx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdCAqICBAdHlwZSBmdW5jdGlvblxuXHRcdCAqL1xuXHRcdFwiZm5Gb3JtYXROdW1iZXJcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogTGlzdCBvZiBvcHRpb25zIHRoYXQgY2FuIGJlIHVzZWQgZm9yIHRoZSB1c2VyIHNlbGVjdGFibGUgbGVuZ3RoIG1lbnUuXG5cdFx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdCAqICBAdHlwZSBhcnJheVxuXHRcdCAqICBAZGVmYXVsdCBbXVxuXHRcdCAqL1xuXHRcdFwiYUxlbmd0aE1lbnVcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogQ291bnRlciBmb3IgdGhlIGRyYXdzIHRoYXQgdGhlIHRhYmxlIGRvZXMuIEFsc28gdXNlZCBhcyBhIHRyYWNrZXIgZm9yXG5cdFx0ICogc2VydmVyLXNpZGUgcHJvY2Vzc2luZ1xuXHRcdCAqICBAdHlwZSBpbnRcblx0XHQgKiAgQGRlZmF1bHQgMFxuXHRcdCAqL1xuXHRcdFwiaURyYXdcIjogMCxcblx0XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGUgaWYgYSByZWRyYXcgaXMgYmVpbmcgZG9uZSAtIHVzZWZ1bCBmb3IgQWpheFxuXHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0ICogIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICovXG5cdFx0XCJiRHJhd2luZ1wiOiBmYWxzZSxcblx0XG5cdFx0LyoqXG5cdFx0ICogRHJhdyBpbmRleCAoaURyYXcpIG9mIHRoZSBsYXN0IGVycm9yIHdoZW4gcGFyc2luZyB0aGUgcmV0dXJuZWQgZGF0YVxuXHRcdCAqICBAdHlwZSBpbnRcblx0XHQgKiAgQGRlZmF1bHQgLTFcblx0XHQgKi9cblx0XHRcImlEcmF3RXJyb3JcIjogLTEsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFBhZ2luZyBkaXNwbGF5IGxlbmd0aFxuXHRcdCAqICBAdHlwZSBpbnRcblx0XHQgKiAgQGRlZmF1bHQgMTBcblx0XHQgKi9cblx0XHRcIl9pRGlzcGxheUxlbmd0aFwiOiAxMCxcblx0XG5cdFx0LyoqXG5cdFx0ICogUGFnaW5nIHN0YXJ0IHBvaW50IC0gYWlEaXNwbGF5IGluZGV4XG5cdFx0ICogIEB0eXBlIGludFxuXHRcdCAqICBAZGVmYXVsdCAwXG5cdFx0ICovXG5cdFx0XCJfaURpc3BsYXlTdGFydFwiOiAwLFxuXHRcblx0XHQvKipcblx0XHQgKiBTZXJ2ZXItc2lkZSBwcm9jZXNzaW5nIC0gbnVtYmVyIG9mIHJlY29yZHMgaW4gdGhlIHJlc3VsdCBzZXRcblx0XHQgKiAoaS5lLiBiZWZvcmUgZmlsdGVyaW5nKSwgVXNlIGZuUmVjb3Jkc1RvdGFsIHJhdGhlciB0aGFuXG5cdFx0ICogdGhpcyBwcm9wZXJ0eSB0byBnZXQgdGhlIHZhbHVlIG9mIHRoZSBudW1iZXIgb2YgcmVjb3JkcywgcmVnYXJkbGVzcyBvZlxuXHRcdCAqIHRoZSBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nIHNldHRpbmcuXG5cdFx0ICogIEB0eXBlIGludFxuXHRcdCAqICBAZGVmYXVsdCAwXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0XCJfaVJlY29yZHNUb3RhbFwiOiAwLFxuXHRcblx0XHQvKipcblx0XHQgKiBTZXJ2ZXItc2lkZSBwcm9jZXNzaW5nIC0gbnVtYmVyIG9mIHJlY29yZHMgaW4gdGhlIGN1cnJlbnQgZGlzcGxheSBzZXRcblx0XHQgKiAoaS5lLiBhZnRlciBmaWx0ZXJpbmcpLiBVc2UgZm5SZWNvcmRzRGlzcGxheSByYXRoZXIgdGhhblxuXHRcdCAqIHRoaXMgcHJvcGVydHkgdG8gZ2V0IHRoZSB2YWx1ZSBvZiB0aGUgbnVtYmVyIG9mIHJlY29yZHMsIHJlZ2FyZGxlc3Mgb2Zcblx0XHQgKiB0aGUgc2VydmVyLXNpZGUgcHJvY2Vzc2luZyBzZXR0aW5nLlxuXHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0ICogIEBkZWZhdWx0IDBcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0XHRcIl9pUmVjb3Jkc0Rpc3BsYXlcIjogMCxcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIGNsYXNzZXMgdG8gdXNlIGZvciB0aGUgdGFibGVcblx0XHQgKiAgQHR5cGUgb2JqZWN0XG5cdFx0ICogIEBkZWZhdWx0IHt9XG5cdFx0ICovXG5cdFx0XCJvQ2xhc3Nlc1wiOiB7fSxcblx0XG5cdFx0LyoqXG5cdFx0ICogRmxhZyBhdHRhY2hlZCB0byB0aGUgc2V0dGluZ3Mgb2JqZWN0IHNvIHlvdSBjYW4gY2hlY2sgaW4gdGhlIGRyYXdcblx0XHQgKiBjYWxsYmFjayBpZiBmaWx0ZXJpbmcgaGFzIGJlZW4gZG9uZSBpbiB0aGUgZHJhdy4gRGVwcmVjYXRlZCBpbiBmYXZvdXIgb2Zcblx0XHQgKiBldmVudHMuXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKiAgQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiAgQGRlcHJlY2F0ZWRcblx0XHQgKi9cblx0XHRcImJGaWx0ZXJlZFwiOiBmYWxzZSxcblx0XG5cdFx0LyoqXG5cdFx0ICogRmxhZyBhdHRhY2hlZCB0byB0aGUgc2V0dGluZ3Mgb2JqZWN0IHNvIHlvdSBjYW4gY2hlY2sgaW4gdGhlIGRyYXdcblx0XHQgKiBjYWxsYmFjayBpZiBzb3J0aW5nIGhhcyBiZWVuIGRvbmUgaW4gdGhlIGRyYXcuIERlcHJlY2F0ZWQgaW4gZmF2b3VyIG9mXG5cdFx0ICogZXZlbnRzLlxuXHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0ICogIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICogIEBkZXByZWNhdGVkXG5cdFx0ICovXG5cdFx0XCJiU29ydGVkXCI6IGZhbHNlLFxuXHRcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZSB0aGF0IGlmIG11bHRpcGxlIHJvd3MgYXJlIGluIHRoZSBoZWFkZXIgYW5kIHRoZXJlIGlzIG1vcmUgdGhhblxuXHRcdCAqIG9uZSB1bmlxdWUgY2VsbCBwZXIgY29sdW1uLCBpZiB0aGUgdG9wIG9uZSAodHJ1ZSkgb3IgYm90dG9tIG9uZSAoZmFsc2UpXG5cdFx0ICogc2hvdWxkIGJlIHVzZWQgZm9yIHNvcnRpbmcgLyB0aXRsZSBieSBEYXRhVGFibGVzLlxuXHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdCAqL1xuXHRcdFwiYlNvcnRDZWxsc1RvcFwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBJbml0aWFsaXNhdGlvbiBvYmplY3QgdGhhdCBpcyB1c2VkIGZvciB0aGUgdGFibGVcblx0XHQgKiAgQHR5cGUgb2JqZWN0XG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHRcIm9Jbml0XCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIERlc3Ryb3kgY2FsbGJhY2sgZnVuY3Rpb25zIC0gZm9yIHBsdWctaW5zIHRvIGF0dGFjaCB0aGVtc2VsdmVzIHRvIHRoZVxuXHRcdCAqIGRlc3Ryb3kgc28gdGhleSBjYW4gY2xlYW4gdXAgbWFya3VwIGFuZCBldmVudHMuXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IFtdXG5cdFx0ICovXG5cdFx0XCJhb0Rlc3Ryb3lDYWxsYmFja1wiOiBbXSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEdldCB0aGUgbnVtYmVyIG9mIHJlY29yZHMgaW4gdGhlIGN1cnJlbnQgcmVjb3JkIHNldCwgYmVmb3JlIGZpbHRlcmluZ1xuXHRcdCAqICBAdHlwZSBmdW5jdGlvblxuXHRcdCAqL1xuXHRcdFwiZm5SZWNvcmRzVG90YWxcIjogZnVuY3Rpb24gKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gX2ZuRGF0YVNvdXJjZSggdGhpcyApID09ICdzc3AnID9cblx0XHRcdFx0dGhpcy5faVJlY29yZHNUb3RhbCAqIDEgOlxuXHRcdFx0XHR0aGlzLmFpRGlzcGxheU1hc3Rlci5sZW5ndGg7XG5cdFx0fSxcblx0XG5cdFx0LyoqXG5cdFx0ICogR2V0IHRoZSBudW1iZXIgb2YgcmVjb3JkcyBpbiB0aGUgY3VycmVudCByZWNvcmQgc2V0LCBhZnRlciBmaWx0ZXJpbmdcblx0XHQgKiAgQHR5cGUgZnVuY3Rpb25cblx0XHQgKi9cblx0XHRcImZuUmVjb3Jkc0Rpc3BsYXlcIjogZnVuY3Rpb24gKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gX2ZuRGF0YVNvdXJjZSggdGhpcyApID09ICdzc3AnID9cblx0XHRcdFx0dGhpcy5faVJlY29yZHNEaXNwbGF5ICogMSA6XG5cdFx0XHRcdHRoaXMuYWlEaXNwbGF5Lmxlbmd0aDtcblx0XHR9LFxuXHRcblx0XHQvKipcblx0XHQgKiBHZXQgdGhlIGRpc3BsYXkgZW5kIHBvaW50IC0gYWlEaXNwbGF5IGluZGV4XG5cdFx0ICogIEB0eXBlIGZ1bmN0aW9uXG5cdFx0ICovXG5cdFx0XCJmbkRpc3BsYXlFbmRcIjogZnVuY3Rpb24gKClcblx0XHR7XG5cdFx0XHR2YXJcblx0XHRcdFx0bGVuICAgICAgPSB0aGlzLl9pRGlzcGxheUxlbmd0aCxcblx0XHRcdFx0c3RhcnQgICAgPSB0aGlzLl9pRGlzcGxheVN0YXJ0LFxuXHRcdFx0XHRjYWxjICAgICA9IHN0YXJ0ICsgbGVuLFxuXHRcdFx0XHRyZWNvcmRzICA9IHRoaXMuYWlEaXNwbGF5Lmxlbmd0aCxcblx0XHRcdFx0ZmVhdHVyZXMgPSB0aGlzLm9GZWF0dXJlcyxcblx0XHRcdFx0cGFnaW5hdGUgPSBmZWF0dXJlcy5iUGFnaW5hdGU7XG5cdFxuXHRcdFx0aWYgKCBmZWF0dXJlcy5iU2VydmVyU2lkZSApIHtcblx0XHRcdFx0cmV0dXJuIHBhZ2luYXRlID09PSBmYWxzZSB8fCBsZW4gPT09IC0xID9cblx0XHRcdFx0XHRzdGFydCArIHJlY29yZHMgOlxuXHRcdFx0XHRcdE1hdGgubWluKCBzdGFydCtsZW4sIHRoaXMuX2lSZWNvcmRzRGlzcGxheSApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHJldHVybiAhIHBhZ2luYXRlIHx8IGNhbGM+cmVjb3JkcyB8fCBsZW49PT0tMSA/XG5cdFx0XHRcdFx0cmVjb3JkcyA6XG5cdFx0XHRcdFx0Y2FsYztcblx0XHRcdH1cblx0XHR9LFxuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgRGF0YVRhYmxlcyBvYmplY3QgZm9yIHRoaXMgdGFibGVcblx0XHQgKiAgQHR5cGUgb2JqZWN0XG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHRcIm9JbnN0YW5jZVwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBVbmlxdWUgaWRlbnRpZmllciBmb3IgZWFjaCBpbnN0YW5jZSBvZiB0aGUgRGF0YVRhYmxlcyBvYmplY3QuIElmIHRoZXJlXG5cdFx0ICogaXMgYW4gSUQgb24gdGhlIHRhYmxlIG5vZGUsIHRoZW4gaXQgdGFrZXMgdGhhdCB2YWx1ZSwgb3RoZXJ3aXNlIGFuXG5cdFx0ICogaW5jcmVtZW50aW5nIGludGVybmFsIGNvdW50ZXIgaXMgdXNlZC5cblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHRcInNJbnN0YW5jZVwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiB0YWJpbmRleCBhdHRyaWJ1dGUgdmFsdWUgdGhhdCBpcyBhZGRlZCB0byBEYXRhVGFibGVzIGNvbnRyb2wgZWxlbWVudHMsIGFsbG93aW5nXG5cdFx0ICoga2V5Ym9hcmQgbmF2aWdhdGlvbiBvZiB0aGUgdGFibGUgYW5kIGl0cyBjb250cm9scy5cblx0XHQgKi9cblx0XHRcImlUYWJJbmRleFwiOiAwLFxuXHRcblx0XHQvKipcblx0XHQgKiBESVYgY29udGFpbmVyIGZvciB0aGUgZm9vdGVyIHNjcm9sbGluZyB0YWJsZSBpZiBzY3JvbGxpbmdcblx0XHQgKi9cblx0XHRcIm5TY3JvbGxIZWFkXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIERJViBjb250YWluZXIgZm9yIHRoZSBmb290ZXIgc2Nyb2xsaW5nIHRhYmxlIGlmIHNjcm9sbGluZ1xuXHRcdCAqL1xuXHRcdFwiblNjcm9sbEZvb3RcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogTGFzdCBhcHBsaWVkIHNvcnRcblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgW11cblx0XHQgKi9cblx0XHRcImFMYXN0U29ydFwiOiBbXSxcblx0XG5cdFx0LyoqXG5cdFx0ICogU3RvcmVkIHBsdWctaW4gaW5zdGFuY2VzXG5cdFx0ICogIEB0eXBlIG9iamVjdFxuXHRcdCAqICBAZGVmYXVsdCB7fVxuXHRcdCAqL1xuXHRcdFwib1BsdWdpbnNcIjoge30sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEZ1bmN0aW9uIHVzZWQgdG8gZ2V0IGEgcm93J3MgaWQgZnJvbSB0aGUgcm93J3MgZGF0YVxuXHRcdCAqICBAdHlwZSBmdW5jdGlvblxuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0XCJyb3dJZEZuXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIERhdGEgbG9jYXRpb24gd2hlcmUgdG8gc3RvcmUgYSByb3cncyBpZFxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdFwicm93SWRcIjogbnVsbFxuXHR9O1xuXG5cdC8qKlxuXHQgKiBFeHRlbnNpb24gb2JqZWN0IGZvciBEYXRhVGFibGVzIHRoYXQgaXMgdXNlZCB0byBwcm92aWRlIGFsbCBleHRlbnNpb25cblx0ICogb3B0aW9ucy5cblx0ICpcblx0ICogTm90ZSB0aGF0IHRoZSBgRGF0YVRhYmxlLmV4dGAgb2JqZWN0IGlzIGF2YWlsYWJsZSB0aHJvdWdoXG5cdCAqIGBqUXVlcnkuZm4uZGF0YVRhYmxlLmV4dGAgd2hlcmUgaXQgbWF5IGJlIGFjY2Vzc2VkIGFuZCBtYW5pcHVsYXRlZC4gSXQgaXNcblx0ICogYWxzbyBhbGlhc2VkIHRvIGBqUXVlcnkuZm4uZGF0YVRhYmxlRXh0YCBmb3IgaGlzdG9yaWMgcmVhc29ucy5cblx0ICogIEBuYW1lc3BhY2Vcblx0ICogIEBleHRlbmRzIERhdGFUYWJsZS5tb2RlbHMuZXh0XG5cdCAqL1xuXHRcblx0XG5cdC8qKlxuXHQgKiBEYXRhVGFibGVzIGV4dGVuc2lvbnNcblx0ICogXG5cdCAqIFRoaXMgbmFtZXNwYWNlIGFjdHMgYXMgYSBjb2xsZWN0aW9uIGFyZWEgZm9yIHBsdWctaW5zIHRoYXQgY2FuIGJlIHVzZWQgdG9cblx0ICogZXh0ZW5kIERhdGFUYWJsZXMgY2FwYWJpbGl0aWVzLiBJbmRlZWQgbWFueSBvZiB0aGUgYnVpbGQgaW4gbWV0aG9kc1xuXHQgKiB1c2UgdGhpcyBtZXRob2QgdG8gcHJvdmlkZSB0aGVpciBvd24gY2FwYWJpbGl0aWVzIChzb3J0aW5nIG1ldGhvZHMgZm9yXG5cdCAqIGV4YW1wbGUpLlxuXHQgKlxuXHQgKiBOb3RlIHRoYXQgdGhpcyBuYW1lc3BhY2UgaXMgYWxpYXNlZCB0byBgalF1ZXJ5LmZuLmRhdGFUYWJsZUV4dGAgZm9yIGxlZ2FjeVxuXHQgKiByZWFzb25zXG5cdCAqXG5cdCAqICBAbmFtZXNwYWNlXG5cdCAqL1xuXHREYXRhVGFibGUuZXh0ID0gX2V4dCA9IHtcblx0XHQvKipcblx0XHQgKiBCdXR0b25zLiBGb3IgdXNlIHdpdGggdGhlIEJ1dHRvbnMgZXh0ZW5zaW9uIGZvciBEYXRhVGFibGVzLiBUaGlzIGlzXG5cdFx0ICogZGVmaW5lZCBoZXJlIHNvIG90aGVyIGV4dGVuc2lvbnMgY2FuIGRlZmluZSBidXR0b25zIHJlZ2FyZGxlc3Mgb2YgbG9hZFxuXHRcdCAqIG9yZGVyLiBJdCBpcyBfbm90XyB1c2VkIGJ5IERhdGFUYWJsZXMgY29yZS5cblx0XHQgKlxuXHRcdCAqICBAdHlwZSBvYmplY3Rcblx0XHQgKiAgQGRlZmF1bHQge31cblx0XHQgKi9cblx0XHRidXR0b25zOiB7fSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEVsZW1lbnQgY2xhc3MgbmFtZXNcblx0XHQgKlxuXHRcdCAqICBAdHlwZSBvYmplY3Rcblx0XHQgKiAgQGRlZmF1bHQge31cblx0XHQgKi9cblx0XHRjbGFzc2VzOiB7fSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIERhdGFUYWJsZXMgYnVpbGQgdHlwZSAoZXhwYW5kZWQgYnkgdGhlIGRvd25sb2FkIGJ1aWxkZXIpXG5cdFx0ICpcblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICovXG5cdFx0YnVpbGRlcjogXCItc291cmNlLVwiLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogRXJyb3IgcmVwb3J0aW5nLlxuXHRcdCAqIFxuXHRcdCAqIEhvdyBzaG91bGQgRGF0YVRhYmxlcyByZXBvcnQgYW4gZXJyb3IuIENhbiB0YWtlIHRoZSB2YWx1ZSAnYWxlcnQnLFxuXHRcdCAqICd0aHJvdycsICdub25lJyBvciBhIGZ1bmN0aW9uLlxuXHRcdCAqXG5cdFx0ICogIEB0eXBlIHN0cmluZ3xmdW5jdGlvblxuXHRcdCAqICBAZGVmYXVsdCBhbGVydFxuXHRcdCAqL1xuXHRcdGVyck1vZGU6IFwiYWxlcnRcIixcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEZlYXR1cmUgcGx1Zy1pbnMuXG5cdFx0ICogXG5cdFx0ICogVGhpcyBpcyBhbiBhcnJheSBvZiBvYmplY3RzIHdoaWNoIGRlc2NyaWJlIHRoZSBmZWF0dXJlIHBsdWctaW5zIHRoYXQgYXJlXG5cdFx0ICogYXZhaWxhYmxlIHRvIERhdGFUYWJsZXMuIFRoZXNlIGZlYXR1cmUgcGx1Zy1pbnMgYXJlIHRoZW4gYXZhaWxhYmxlIGZvclxuXHRcdCAqIHVzZSB0aHJvdWdoIHRoZSBgZG9tYCBpbml0aWFsaXNhdGlvbiBvcHRpb24uXG5cdFx0ICogXG5cdFx0ICogRWFjaCBmZWF0dXJlIHBsdWctaW4gaXMgZGVzY3JpYmVkIGJ5IGFuIG9iamVjdCB3aGljaCBtdXN0IGhhdmUgdGhlXG5cdFx0ICogZm9sbG93aW5nIHByb3BlcnRpZXM6XG5cdFx0ICogXG5cdFx0ICogKiBgZm5Jbml0YCAtIGZ1bmN0aW9uIHRoYXQgaXMgdXNlZCB0byBpbml0aWFsaXNlIHRoZSBwbHVnLWluLFxuXHRcdCAqICogYGNGZWF0dXJlYCAtIGEgY2hhcmFjdGVyIHNvIHRoZSBmZWF0dXJlIGNhbiBiZSBlbmFibGVkIGJ5IHRoZSBgZG9tYFxuXHRcdCAqICAgaW5zdGlsbGF0aW9uIG9wdGlvbi4gVGhpcyBpcyBjYXNlIHNlbnNpdGl2ZS5cblx0XHQgKlxuXHRcdCAqIFRoZSBgZm5Jbml0YCBmdW5jdGlvbiBoYXMgdGhlIGZvbGxvd2luZyBpbnB1dCBwYXJhbWV0ZXJzOlxuXHRcdCAqXG5cdFx0ICogMS4gYHtvYmplY3R9YCBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdDogc2VlXG5cdFx0ICogICAge0BsaW5rIERhdGFUYWJsZS5tb2RlbHMub1NldHRpbmdzfVxuXHRcdCAqXG5cdFx0ICogQW5kIHRoZSBmb2xsb3dpbmcgcmV0dXJuIGlzIGV4cGVjdGVkOlxuXHRcdCAqIFxuXHRcdCAqICoge25vZGV8bnVsbH0gVGhlIGVsZW1lbnQgd2hpY2ggY29udGFpbnMgeW91ciBmZWF0dXJlLiBOb3RlIHRoYXQgdGhlXG5cdFx0ICogICByZXR1cm4gbWF5IGFsc28gYmUgdm9pZCBpZiB5b3VyIHBsdWctaW4gZG9lcyBub3QgcmVxdWlyZSB0byBpbmplY3QgYW55XG5cdFx0ICogICBET00gZWxlbWVudHMgaW50byBEYXRhVGFibGVzIGNvbnRyb2wgKGBkb21gKSAtIGZvciBleGFtcGxlIHRoaXMgbWlnaHRcblx0XHQgKiAgIGJlIHVzZWZ1bCB3aGVuIGRldmVsb3BpbmcgYSBwbHVnLWluIHdoaWNoIGFsbG93cyB0YWJsZSBjb250cm9sIHZpYVxuXHRcdCAqICAga2V5Ym9hcmQgZW50cnlcblx0XHQgKlxuXHRcdCAqICBAdHlwZSBhcnJheVxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJC5mbi5kYXRhVGFibGUuZXh0LmZlYXR1cmVzLnB1c2goIHtcblx0XHQgKiAgICAgIFwiZm5Jbml0XCI6IGZ1bmN0aW9uKCBvU2V0dGluZ3MgKSB7XG5cdFx0ICogICAgICAgIHJldHVybiBuZXcgVGFibGVUb29scyggeyBcIm9EVFNldHRpbmdzXCI6IG9TZXR0aW5ncyB9ICk7XG5cdFx0ICogICAgICB9LFxuXHRcdCAqICAgICAgXCJjRmVhdHVyZVwiOiBcIlRcIlxuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRmZWF0dXJlOiBbXSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFJvdyBzZWFyY2hpbmcuXG5cdFx0ICogXG5cdFx0ICogVGhpcyBtZXRob2Qgb2Ygc2VhcmNoaW5nIGlzIGNvbXBsaW1lbnRhcnkgdG8gdGhlIGRlZmF1bHQgdHlwZSBiYXNlZFxuXHRcdCAqIHNlYXJjaGluZywgYW5kIGEgbG90IG1vcmUgY29tcHJlaGVuc2l2ZSBhcyBpdCBhbGxvd3MgeW91IGNvbXBsZXRlIGNvbnRyb2xcblx0XHQgKiBvdmVyIHRoZSBzZWFyY2hpbmcgbG9naWMuIEVhY2ggZWxlbWVudCBpbiB0aGlzIGFycmF5IGlzIGEgZnVuY3Rpb25cblx0XHQgKiAocGFyYW1ldGVycyBkZXNjcmliZWQgYmVsb3cpIHRoYXQgaXMgY2FsbGVkIGZvciBldmVyeSByb3cgaW4gdGhlIHRhYmxlLFxuXHRcdCAqIGFuZCB5b3VyIGxvZ2ljIGRlY2lkZXMgaWYgaXQgc2hvdWxkIGJlIGluY2x1ZGVkIGluIHRoZSBzZWFyY2hpbmcgZGF0YSBzZXRcblx0XHQgKiBvciBub3QuXG5cdFx0ICpcblx0XHQgKiBTZWFyY2hpbmcgZnVuY3Rpb25zIGhhdmUgdGhlIGZvbGxvd2luZyBpbnB1dCBwYXJhbWV0ZXJzOlxuXHRcdCAqXG5cdFx0ICogMS4gYHtvYmplY3R9YCBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdDogc2VlXG5cdFx0ICogICAge0BsaW5rIERhdGFUYWJsZS5tb2RlbHMub1NldHRpbmdzfVxuXHRcdCAqIDIuIGB7YXJyYXl8b2JqZWN0fWAgRGF0YSBmb3IgdGhlIHJvdyB0byBiZSBwcm9jZXNzZWQgKHNhbWUgYXMgdGhlXG5cdFx0ICogICAgb3JpZ2luYWwgZm9ybWF0IHRoYXQgd2FzIHBhc3NlZCBpbiBhcyB0aGUgZGF0YSBzb3VyY2UsIG9yIGFuIGFycmF5XG5cdFx0ICogICAgZnJvbSBhIERPTSBkYXRhIHNvdXJjZVxuXHRcdCAqIDMuIGB7aW50fWAgUm93IGluZGV4ICh7QGxpbmsgRGF0YVRhYmxlLm1vZGVscy5vU2V0dGluZ3MuYW9EYXRhfSksIHdoaWNoXG5cdFx0ICogICAgY2FuIGJlIHVzZWZ1bCB0byByZXRyaWV2ZSB0aGUgYFRSYCBlbGVtZW50IGlmIHlvdSBuZWVkIERPTSBpbnRlcmFjdGlvbi5cblx0XHQgKlxuXHRcdCAqIEFuZCB0aGUgZm9sbG93aW5nIHJldHVybiBpcyBleHBlY3RlZDpcblx0XHQgKlxuXHRcdCAqICoge2Jvb2xlYW59IEluY2x1ZGUgdGhlIHJvdyBpbiB0aGUgc2VhcmNoZWQgcmVzdWx0IHNldCAodHJ1ZSkgb3Igbm90XG5cdFx0ICogICAoZmFsc2UpXG5cdFx0ICpcblx0XHQgKiBOb3RlIHRoYXQgYXMgd2l0aCB0aGUgbWFpbiBzZWFyY2ggYWJpbGl0eSBpbiBEYXRhVGFibGVzLCB0ZWNobmljYWxseSB0aGlzXG5cdFx0ICogaXMgXCJmaWx0ZXJpbmdcIiwgc2luY2UgaXQgaXMgc3VidHJhY3RpdmUuIEhvd2V2ZXIsIGZvciBjb25zaXN0ZW5jeSBpblxuXHRcdCAqIG5hbWluZyB3ZSBjYWxsIGl0IHNlYXJjaGluZyBoZXJlLlxuXHRcdCAqXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IFtdXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBUaGUgZm9sbG93aW5nIGV4YW1wbGUgc2hvd3MgY3VzdG9tIHNlYXJjaCBiZWluZyBhcHBsaWVkIHRvIHRoZVxuXHRcdCAqICAgIC8vIGZvdXJ0aCBjb2x1bW4gKGkuZS4gdGhlIGRhdGFbM10gaW5kZXgpIGJhc2VkIG9uIHR3byBpbnB1dCB2YWx1ZXNcblx0XHQgKiAgICAvLyBmcm9tIHRoZSBlbmQtdXNlciwgbWF0Y2hpbmcgdGhlIGRhdGEgaW4gYSBjZXJ0YWluIHJhbmdlLlxuXHRcdCAqICAgICQuZm4uZGF0YVRhYmxlLmV4dC5zZWFyY2gucHVzaChcblx0XHQgKiAgICAgIGZ1bmN0aW9uKCBzZXR0aW5ncywgZGF0YSwgZGF0YUluZGV4ICkge1xuXHRcdCAqICAgICAgICB2YXIgbWluID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21pbicpLnZhbHVlICogMTtcblx0XHQgKiAgICAgICAgdmFyIG1heCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtYXgnKS52YWx1ZSAqIDE7XG5cdFx0ICogICAgICAgIHZhciB2ZXJzaW9uID0gZGF0YVszXSA9PSBcIi1cIiA/IDAgOiBkYXRhWzNdKjE7XG5cdFx0ICpcblx0XHQgKiAgICAgICAgaWYgKCBtaW4gPT0gXCJcIiAmJiBtYXggPT0gXCJcIiApIHtcblx0XHQgKiAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0XHQgKiAgICAgICAgfVxuXHRcdCAqICAgICAgICBlbHNlIGlmICggbWluID09IFwiXCIgJiYgdmVyc2lvbiA8IG1heCApIHtcblx0XHQgKiAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0XHQgKiAgICAgICAgfVxuXHRcdCAqICAgICAgICBlbHNlIGlmICggbWluIDwgdmVyc2lvbiAmJiBcIlwiID09IG1heCApIHtcblx0XHQgKiAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0XHQgKiAgICAgICAgfVxuXHRcdCAqICAgICAgICBlbHNlIGlmICggbWluIDwgdmVyc2lvbiAmJiB2ZXJzaW9uIDwgbWF4ICkge1xuXHRcdCAqICAgICAgICAgIHJldHVybiB0cnVlO1xuXHRcdCAqICAgICAgICB9XG5cdFx0ICogICAgICAgIHJldHVybiBmYWxzZTtcblx0XHQgKiAgICAgIH1cblx0XHQgKiAgICApO1xuXHRcdCAqL1xuXHRcdHNlYXJjaDogW10sXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBTZWxlY3RvciBleHRlbnNpb25zXG5cdFx0ICpcblx0XHQgKiBUaGUgYHNlbGVjdG9yYCBvcHRpb24gY2FuIGJlIHVzZWQgdG8gZXh0ZW5kIHRoZSBvcHRpb25zIGF2YWlsYWJsZSBmb3IgdGhlXG5cdFx0ICogc2VsZWN0b3IgbW9kaWZpZXIgb3B0aW9ucyAoYHNlbGVjdG9yLW1vZGlmaWVyYCBvYmplY3QgZGF0YSB0eXBlKSB0aGF0XG5cdFx0ICogZWFjaCBvZiB0aGUgdGhyZWUgYnVpbHQgaW4gc2VsZWN0b3IgdHlwZXMgb2ZmZXIgKHJvdywgY29sdW1uIGFuZCBjZWxsICtcblx0XHQgKiB0aGVpciBwbHVyYWwgY291bnRlcnBhcnRzKS4gRm9yIGV4YW1wbGUgdGhlIFNlbGVjdCBleHRlbnNpb24gdXNlcyB0aGlzXG5cdFx0ICogbWVjaGFuaXNtIHRvIHByb3ZpZGUgYW4gb3B0aW9uIHRvIHNlbGVjdCBvbmx5IHJvd3MsIGNvbHVtbnMgYW5kIGNlbGxzXG5cdFx0ICogdGhhdCBoYXZlIGJlZW4gbWFya2VkIGFzIHNlbGVjdGVkIGJ5IHRoZSBlbmQgdXNlciAoYHtzZWxlY3RlZDogdHJ1ZX1gKSxcblx0XHQgKiB3aGljaCBjYW4gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSBleGlzdGluZyBidWlsdCBpbiBzZWxlY3RvclxuXHRcdCAqIG9wdGlvbnMuXG5cdFx0ICpcblx0XHQgKiBFYWNoIHByb3BlcnR5IGlzIGFuIGFycmF5IHRvIHdoaWNoIGZ1bmN0aW9ucyBjYW4gYmUgcHVzaGVkLiBUaGUgZnVuY3Rpb25zXG5cdFx0ICogdGFrZSB0aHJlZSBhdHRyaWJ1dGVzOlxuXHRcdCAqXG5cdFx0ICogKiBTZXR0aW5ncyBvYmplY3QgZm9yIHRoZSBob3N0IHRhYmxlXG5cdFx0ICogKiBPcHRpb25zIG9iamVjdCAoYHNlbGVjdG9yLW1vZGlmaWVyYCBvYmplY3QgdHlwZSlcblx0XHQgKiAqIEFycmF5IG9mIHNlbGVjdGVkIGl0ZW0gaW5kZXhlc1xuXHRcdCAqXG5cdFx0ICogVGhlIHJldHVybiBpcyBhbiBhcnJheSBvZiB0aGUgcmVzdWx0aW5nIGl0ZW0gaW5kZXhlcyBhZnRlciB0aGUgY3VzdG9tXG5cdFx0ICogc2VsZWN0b3IgaGFzIGJlZW4gYXBwbGllZC5cblx0XHQgKlxuXHRcdCAqICBAdHlwZSBvYmplY3Rcblx0XHQgKi9cblx0XHRzZWxlY3Rvcjoge1xuXHRcdFx0Y2VsbDogW10sXG5cdFx0XHRjb2x1bW46IFtdLFxuXHRcdFx0cm93OiBbXVxuXHRcdH0sXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBJbnRlcm5hbCBmdW5jdGlvbnMsIGV4cG9zZWQgZm9yIHVzZWQgaW4gcGx1Zy1pbnMuXG5cdFx0ICogXG5cdFx0ICogUGxlYXNlIG5vdGUgdGhhdCB5b3Ugc2hvdWxkIG5vdCBuZWVkIHRvIHVzZSB0aGUgaW50ZXJuYWwgbWV0aG9kcyBmb3Jcblx0XHQgKiBhbnl0aGluZyBvdGhlciB0aGFuIGEgcGx1Zy1pbiAoYW5kIGV2ZW4gdGhlbiwgdHJ5IHRvIGF2b2lkIGlmIHBvc3NpYmxlKS5cblx0XHQgKiBUaGUgaW50ZXJuYWwgZnVuY3Rpb24gbWF5IGNoYW5nZSBiZXR3ZWVuIHJlbGVhc2VzLlxuXHRcdCAqXG5cdFx0ICogIEB0eXBlIG9iamVjdFxuXHRcdCAqICBAZGVmYXVsdCB7fVxuXHRcdCAqL1xuXHRcdGludGVybmFsOiB7fSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIExlZ2FjeSBjb25maWd1cmF0aW9uIG9wdGlvbnMuIEVuYWJsZSBhbmQgZGlzYWJsZSBsZWdhY3kgb3B0aW9ucyB0aGF0XG5cdFx0ICogYXJlIGF2YWlsYWJsZSBpbiBEYXRhVGFibGVzLlxuXHRcdCAqXG5cdFx0ICogIEB0eXBlIG9iamVjdFxuXHRcdCAqL1xuXHRcdGxlZ2FjeToge1xuXHRcdFx0LyoqXG5cdFx0XHQgKiBFbmFibGUgLyBkaXNhYmxlIERhdGFUYWJsZXMgMS45IGNvbXBhdGlibGUgc2VydmVyLXNpZGUgcHJvY2Vzc2luZ1xuXHRcdFx0ICogcmVxdWVzdHNcblx0XHRcdCAqXG5cdFx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHRcdCAqL1xuXHRcdFx0YWpheDogbnVsbFxuXHRcdH0sXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBQYWdpbmF0aW9uIHBsdWctaW4gbWV0aG9kcy5cblx0XHQgKiBcblx0XHQgKiBFYWNoIGVudHJ5IGluIHRoaXMgb2JqZWN0IGlzIGEgZnVuY3Rpb24gYW5kIGRlZmluZXMgd2hpY2ggYnV0dG9ucyBzaG91bGRcblx0XHQgKiBiZSBzaG93biBieSB0aGUgcGFnaW5hdGlvbiByZW5kZXJpbmcgbWV0aG9kIHRoYXQgaXMgdXNlZCBmb3IgdGhlIHRhYmxlOlxuXHRcdCAqIHtAbGluayBEYXRhVGFibGUuZXh0LnJlbmRlcmVyLnBhZ2VCdXR0b259LiBUaGUgcmVuZGVyZXIgYWRkcmVzc2VzIGhvdyB0aGVcblx0XHQgKiBidXR0b25zIGFyZSBkaXNwbGF5ZWQgaW4gdGhlIGRvY3VtZW50LCB3aGlsZSB0aGUgZnVuY3Rpb25zIGhlcmUgdGVsbCBpdFxuXHRcdCAqIHdoYXQgYnV0dG9ucyB0byBkaXNwbGF5LiBUaGlzIGlzIGRvbmUgYnkgcmV0dXJuaW5nIGFuIGFycmF5IG9mIGJ1dHRvblxuXHRcdCAqIGRlc2NyaXB0aW9ucyAod2hhdCBlYWNoIGJ1dHRvbiB3aWxsIGRvKS5cblx0XHQgKlxuXHRcdCAqIFBhZ2luYXRpb24gdHlwZXMgKHRoZSBmb3VyIGJ1aWx0IGluIG9wdGlvbnMgYW5kIGFueSBhZGRpdGlvbmFsIHBsdWctaW5cblx0XHQgKiBvcHRpb25zIGRlZmluZWQgaGVyZSkgY2FuIGJlIHVzZWQgdGhyb3VnaCB0aGUgYHBhZ2luYXRpb25UeXBlYFxuXHRcdCAqIGluaXRpYWxpc2F0aW9uIHBhcmFtZXRlci5cblx0XHQgKlxuXHRcdCAqIFRoZSBmdW5jdGlvbnMgZGVmaW5lZCB0YWtlIHR3byBwYXJhbWV0ZXJzOlxuXHRcdCAqXG5cdFx0ICogMS4gYHtpbnR9IHBhZ2VgIFRoZSBjdXJyZW50IHBhZ2UgaW5kZXhcblx0XHQgKiAyLiBge2ludH0gcGFnZXNgIFRoZSBudW1iZXIgb2YgcGFnZXMgaW4gdGhlIHRhYmxlXG5cdFx0ICpcblx0XHQgKiBFYWNoIGZ1bmN0aW9uIGlzIGV4cGVjdGVkIHRvIHJldHVybiBhbiBhcnJheSB3aGVyZSBlYWNoIGVsZW1lbnQgb2YgdGhlXG5cdFx0ICogYXJyYXkgY2FuIGJlIG9uZSBvZjpcblx0XHQgKlxuXHRcdCAqICogYGZpcnN0YCAtIEp1bXAgdG8gZmlyc3QgcGFnZSB3aGVuIGFjdGl2YXRlZFxuXHRcdCAqICogYGxhc3RgIC0gSnVtcCB0byBsYXN0IHBhZ2Ugd2hlbiBhY3RpdmF0ZWRcblx0XHQgKiAqIGBwcmV2aW91c2AgLSBTaG93IHByZXZpb3VzIHBhZ2Ugd2hlbiBhY3RpdmF0ZWRcblx0XHQgKiAqIGBuZXh0YCAtIFNob3cgbmV4dCBwYWdlIHdoZW4gYWN0aXZhdGVkXG5cdFx0ICogKiBge2ludH1gIC0gU2hvdyBwYWdlIG9mIHRoZSBpbmRleCBnaXZlblxuXHRcdCAqICogYHthcnJheX1gIC0gQSBuZXN0ZWQgYXJyYXkgY29udGFpbmluZyB0aGUgYWJvdmUgZWxlbWVudHMgdG8gYWRkIGFcblx0XHQgKiAgIGNvbnRhaW5pbmcgJ0RJVicgZWxlbWVudCAobWlnaHQgYmUgdXNlZnVsIGZvciBzdHlsaW5nKS5cblx0XHQgKlxuXHRcdCAqIE5vdGUgdGhhdCBEYXRhVGFibGVzIHYxLjktIHVzZWQgdGhpcyBvYmplY3Qgc2xpZ2h0bHkgZGlmZmVyZW50bHkgd2hlcmVieVxuXHRcdCAqIGFuIG9iamVjdCB3aXRoIHR3byBmdW5jdGlvbnMgd291bGQgYmUgZGVmaW5lZCBmb3IgZWFjaCBwbHVnLWluLiBUaGF0XG5cdFx0ICogYWJpbGl0eSBpcyBzdGlsbCBzdXBwb3J0ZWQgYnkgRGF0YVRhYmxlcyAxLjEwKyB0byBwcm92aWRlIGJhY2t3YXJkc1xuXHRcdCAqIGNvbXBhdGliaWxpdHksIGJ1dCB0aGlzIG9wdGlvbiBvZiB1c2UgaXMgbm93IGRlY3JlbWVudGVkIGFuZCBubyBsb25nZXJcblx0XHQgKiBkb2N1bWVudGVkIGluIERhdGFUYWJsZXMgMS4xMCsuXG5cdFx0ICpcblx0XHQgKiAgQHR5cGUgb2JqZWN0XG5cdFx0ICogIEBkZWZhdWx0IHt9XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBTaG93IHByZXZpb3VzLCBuZXh0IGFuZCBjdXJyZW50IHBhZ2UgYnV0dG9ucyBvbmx5XG5cdFx0ICogICAgJC5mbi5kYXRhVGFibGVFeHQub1BhZ2luYXRpb24uY3VycmVudCA9IGZ1bmN0aW9uICggcGFnZSwgcGFnZXMgKSB7XG5cdFx0ICogICAgICByZXR1cm4gWyAncHJldmlvdXMnLCBwYWdlLCAnbmV4dCcgXTtcblx0XHQgKiAgICB9O1xuXHRcdCAqL1xuXHRcdHBhZ2VyOiB7fSxcblx0XG5cdFxuXHRcdHJlbmRlcmVyOiB7XG5cdFx0XHRwYWdlQnV0dG9uOiB7fSxcblx0XHRcdGhlYWRlcjoge31cblx0XHR9LFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogT3JkZXJpbmcgcGx1Zy1pbnMgLSBjdXN0b20gZGF0YSBzb3VyY2Vcblx0XHQgKiBcblx0XHQgKiBUaGUgZXh0ZW5zaW9uIG9wdGlvbnMgZm9yIG9yZGVyaW5nIG9mIGRhdGEgYXZhaWxhYmxlIGhlcmUgaXMgY29tcGxpbWVudGFyeVxuXHRcdCAqIHRvIHRoZSBkZWZhdWx0IHR5cGUgYmFzZWQgb3JkZXJpbmcgdGhhdCBEYXRhVGFibGVzIHR5cGljYWxseSB1c2VzLiBJdFxuXHRcdCAqIGFsbG93cyBtdWNoIGdyZWF0ZXIgY29udHJvbCBvdmVyIHRoZSB0aGUgZGF0YSB0aGF0IGlzIGJlaW5nIHVzZWQgdG9cblx0XHQgKiBvcmRlciBhIGNvbHVtbiwgYnV0IGlzIG5lY2Vzc2FyaWx5IHRoZXJlZm9yZSBtb3JlIGNvbXBsZXguXG5cdFx0ICogXG5cdFx0ICogVGhpcyB0eXBlIG9mIG9yZGVyaW5nIGlzIHVzZWZ1bCBpZiB5b3Ugd2FudCB0byBkbyBvcmRlcmluZyBiYXNlZCBvbiBkYXRhXG5cdFx0ICogbGl2ZSBmcm9tIHRoZSBET00gKGZvciBleGFtcGxlIHRoZSBjb250ZW50cyBvZiBhbiAnaW5wdXQnIGVsZW1lbnQpIHJhdGhlclxuXHRcdCAqIHRoYW4ganVzdCB0aGUgc3RhdGljIHN0cmluZyB0aGF0IERhdGFUYWJsZXMga25vd3Mgb2YuXG5cdFx0ICogXG5cdFx0ICogVGhlIHdheSB0aGVzZSBwbHVnLWlucyB3b3JrIGlzIHRoYXQgeW91IGNyZWF0ZSBhbiBhcnJheSBvZiB0aGUgdmFsdWVzIHlvdVxuXHRcdCAqIHdpc2ggdG8gYmUgb3JkZXJpbmcgZm9yIHRoZSBjb2x1bW4gaW4gcXVlc3Rpb24gYW5kIHRoZW4gcmV0dXJuIHRoYXRcblx0XHQgKiBhcnJheS4gVGhlIGRhdGEgaW4gdGhlIGFycmF5IG11Y2ggYmUgaW4gdGhlIGluZGV4IG9yZGVyIG9mIHRoZSByb3dzIGluXG5cdFx0ICogdGhlIHRhYmxlIChub3QgdGhlIGN1cnJlbnRseSBvcmRlcmluZyBvcmRlciEpLiBXaGljaCBvcmRlciBkYXRhIGdhdGhlcmluZ1xuXHRcdCAqIGZ1bmN0aW9uIGlzIHJ1biBoZXJlIGRlcGVuZHMgb24gdGhlIGBkdC1pbml0IGNvbHVtbnMub3JkZXJEYXRhVHlwZWBcblx0XHQgKiBwYXJhbWV0ZXIgdGhhdCBpcyB1c2VkIGZvciB0aGUgY29sdW1uIChpZiBhbnkpLlxuXHRcdCAqXG5cdFx0ICogVGhlIGZ1bmN0aW9ucyBkZWZpbmVkIHRha2UgdHdvIHBhcmFtZXRlcnM6XG5cdFx0ICpcblx0XHQgKiAxLiBge29iamVjdH1gIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0OiBzZWVcblx0XHQgKiAgICB7QGxpbmsgRGF0YVRhYmxlLm1vZGVscy5vU2V0dGluZ3N9XG5cdFx0ICogMi4gYHtpbnR9YCBUYXJnZXQgY29sdW1uIGluZGV4XG5cdFx0ICpcblx0XHQgKiBFYWNoIGZ1bmN0aW9uIGlzIGV4cGVjdGVkIHRvIHJldHVybiBhbiBhcnJheTpcblx0XHQgKlxuXHRcdCAqICogYHthcnJheX1gIERhdGEgZm9yIHRoZSBjb2x1bW4gdG8gYmUgb3JkZXJpbmcgdXBvblxuXHRcdCAqXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBPcmRlcmluZyB1c2luZyBgaW5wdXRgIG5vZGUgdmFsdWVzXG5cdFx0ICogICAgJC5mbi5kYXRhVGFibGUuZXh0Lm9yZGVyWydkb20tdGV4dCddID0gZnVuY3Rpb24gICggc2V0dGluZ3MsIGNvbCApXG5cdFx0ICogICAge1xuXHRcdCAqICAgICAgcmV0dXJuIHRoaXMuYXBpKCkuY29sdW1uKCBjb2wsIHtvcmRlcjonaW5kZXgnfSApLm5vZGVzKCkubWFwKCBmdW5jdGlvbiAoIHRkLCBpICkge1xuXHRcdCAqICAgICAgICByZXR1cm4gJCgnaW5wdXQnLCB0ZCkudmFsKCk7XG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfVxuXHRcdCAqL1xuXHRcdG9yZGVyOiB7fSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFR5cGUgYmFzZWQgcGx1Zy1pbnMuXG5cdFx0ICpcblx0XHQgKiBFYWNoIGNvbHVtbiBpbiBEYXRhVGFibGVzIGhhcyBhIHR5cGUgYXNzaWduZWQgdG8gaXQsIGVpdGhlciBieSBhdXRvbWF0aWNcblx0XHQgKiBkZXRlY3Rpb24gb3IgYnkgZGlyZWN0IGFzc2lnbm1lbnQgdXNpbmcgdGhlIGB0eXBlYCBvcHRpb24gZm9yIHRoZSBjb2x1bW4uXG5cdFx0ICogVGhlIHR5cGUgb2YgYSBjb2x1bW4gd2lsbCBlZmZlY3QgaG93IGl0IGlzIG9yZGVyaW5nIGFuZCBzZWFyY2ggKHBsdWctaW5zXG5cdFx0ICogY2FuIGFsc28gbWFrZSB1c2Ugb2YgdGhlIGNvbHVtbiB0eXBlIGlmIHJlcXVpcmVkKS5cblx0XHQgKlxuXHRcdCAqIEBuYW1lc3BhY2Vcblx0XHQgKi9cblx0XHR0eXBlOiB7XG5cdFx0XHQvKipcblx0XHRcdCAqIFR5cGUgZGV0ZWN0aW9uIGZ1bmN0aW9ucy5cblx0XHRcdCAqXG5cdFx0XHQgKiBUaGUgZnVuY3Rpb25zIGRlZmluZWQgaW4gdGhpcyBvYmplY3QgYXJlIHVzZWQgdG8gYXV0b21hdGljYWxseSBkZXRlY3Rcblx0XHRcdCAqIGEgY29sdW1uJ3MgdHlwZSwgbWFraW5nIGluaXRpYWxpc2F0aW9uIG9mIERhdGFUYWJsZXMgc3VwZXIgZWFzeSwgZXZlblxuXHRcdFx0ICogd2hlbiBjb21wbGV4IGRhdGEgaXMgaW4gdGhlIHRhYmxlLlxuXHRcdFx0ICpcblx0XHRcdCAqIFRoZSBmdW5jdGlvbnMgZGVmaW5lZCB0YWtlIHR3byBwYXJhbWV0ZXJzOlxuXHRcdFx0ICpcblx0XHQgICAgICogIDEuIGB7Kn1gIERhdGEgZnJvbSB0aGUgY29sdW1uIGNlbGwgdG8gYmUgYW5hbHlzZWRcblx0XHQgICAgICogIDIuIGB7c2V0dGluZ3N9YCBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdC4gVGhpcyBjYW4gYmUgdXNlZCB0b1xuXHRcdCAgICAgKiAgICAgcGVyZm9ybSBjb250ZXh0IHNwZWNpZmljIHR5cGUgZGV0ZWN0aW9uIC0gZm9yIGV4YW1wbGUgZGV0ZWN0aW9uXG5cdFx0ICAgICAqICAgICBiYXNlZCBvbiBsYW5ndWFnZSBzZXR0aW5ncyBzdWNoIGFzIHVzaW5nIGEgY29tbWEgZm9yIGEgZGVjaW1hbFxuXHRcdCAgICAgKiAgICAgcGxhY2UuIEdlbmVyYWxseSBzcGVha2luZyB0aGUgb3B0aW9ucyBmcm9tIHRoZSBzZXR0aW5ncyB3aWxsIG5vdFxuXHRcdCAgICAgKiAgICAgYmUgcmVxdWlyZWRcblx0XHRcdCAqXG5cdFx0XHQgKiBFYWNoIGZ1bmN0aW9uIGlzIGV4cGVjdGVkIHRvIHJldHVybjpcblx0XHRcdCAqXG5cdFx0XHQgKiAqIGB7c3RyaW5nfG51bGx9YCBEYXRhIHR5cGUgZGV0ZWN0ZWQsIG9yIG51bGwgaWYgdW5rbm93biAoYW5kIHRodXNcblx0XHRcdCAqICAgcGFzcyBpdCBvbiB0byB0aGUgb3RoZXIgdHlwZSBkZXRlY3Rpb24gZnVuY3Rpb25zLlxuXHRcdFx0ICpcblx0XHRcdCAqICBAdHlwZSBhcnJheVxuXHRcdFx0ICpcblx0XHRcdCAqICBAZXhhbXBsZVxuXHRcdFx0ICogICAgLy8gQ3VycmVuY3kgdHlwZSBkZXRlY3Rpb24gcGx1Zy1pbjpcblx0XHRcdCAqICAgICQuZm4uZGF0YVRhYmxlLmV4dC50eXBlLmRldGVjdC5wdXNoKFxuXHRcdFx0ICogICAgICBmdW5jdGlvbiAoIGRhdGEsIHNldHRpbmdzICkge1xuXHRcdFx0ICogICAgICAgIC8vIENoZWNrIHRoZSBudW1lcmljIHBhcnRcblx0XHRcdCAqICAgICAgICBpZiAoICEgZGF0YS5zdWJzdHJpbmcoMSkubWF0Y2goL1swLTldLykgKSB7XG5cdFx0XHQgKiAgICAgICAgICByZXR1cm4gbnVsbDtcblx0XHRcdCAqICAgICAgICB9XG5cdFx0XHQgKlxuXHRcdFx0ICogICAgICAgIC8vIENoZWNrIHByZWZpeGVkIGJ5IGN1cnJlbmN5XG5cdFx0XHQgKiAgICAgICAgaWYgKCBkYXRhLmNoYXJBdCgwKSA9PSAnJCcgfHwgZGF0YS5jaGFyQXQoMCkgPT0gJyZwb3VuZDsnICkge1xuXHRcdFx0ICogICAgICAgICAgcmV0dXJuICdjdXJyZW5jeSc7XG5cdFx0XHQgKiAgICAgICAgfVxuXHRcdFx0ICogICAgICAgIHJldHVybiBudWxsO1xuXHRcdFx0ICogICAgICB9XG5cdFx0XHQgKiAgICApO1xuXHRcdFx0ICovXG5cdFx0XHRkZXRlY3Q6IFtdLFxuXHRcblx0XG5cdFx0XHQvKipcblx0XHRcdCAqIFR5cGUgYmFzZWQgc2VhcmNoIGZvcm1hdHRpbmcuXG5cdFx0XHQgKlxuXHRcdFx0ICogVGhlIHR5cGUgYmFzZWQgc2VhcmNoaW5nIGZ1bmN0aW9ucyBjYW4gYmUgdXNlZCB0byBwcmUtZm9ybWF0IHRoZVxuXHRcdFx0ICogZGF0YSB0byBiZSBzZWFyY2ggb24uIEZvciBleGFtcGxlLCBpdCBjYW4gYmUgdXNlZCB0byBzdHJpcCBIVE1MXG5cdFx0XHQgKiB0YWdzIG9yIHRvIGRlLWZvcm1hdCB0ZWxlcGhvbmUgbnVtYmVycyBmb3IgbnVtZXJpYyBvbmx5IHNlYXJjaGluZy5cblx0XHRcdCAqXG5cdFx0XHQgKiBOb3RlIHRoYXQgaXMgYSBzZWFyY2ggaXMgbm90IGRlZmluZWQgZm9yIGEgY29sdW1uIG9mIGEgZ2l2ZW4gdHlwZSxcblx0XHRcdCAqIG5vIHNlYXJjaCBmb3JtYXR0aW5nIHdpbGwgYmUgcGVyZm9ybWVkLlxuXHRcdFx0ICogXG5cdFx0XHQgKiBQcmUtcHJvY2Vzc2luZyBvZiBzZWFyY2hpbmcgZGF0YSBwbHVnLWlucyAtIFdoZW4geW91IGFzc2lnbiB0aGUgc1R5cGVcblx0XHRcdCAqIGZvciBhIGNvbHVtbiAob3IgaGF2ZSBpdCBhdXRvbWF0aWNhbGx5IGRldGVjdGVkIGZvciB5b3UgYnkgRGF0YVRhYmxlc1xuXHRcdFx0ICogb3IgYSB0eXBlIGRldGVjdGlvbiBwbHVnLWluKSwgeW91IHdpbGwgdHlwaWNhbGx5IGJlIHVzaW5nIHRoaXMgZm9yXG5cdFx0XHQgKiBjdXN0b20gc29ydGluZywgYnV0IGl0IGNhbiBhbHNvIGJlIHVzZWQgdG8gcHJvdmlkZSBjdXN0b20gc2VhcmNoaW5nXG5cdFx0XHQgKiBieSBhbGxvd2luZyB5b3UgdG8gcHJlLXByb2Nlc3NpbmcgdGhlIGRhdGEgYW5kIHJldHVybmluZyB0aGUgZGF0YSBpblxuXHRcdFx0ICogdGhlIGZvcm1hdCB0aGF0IHNob3VsZCBiZSBzZWFyY2hlZCB1cG9uLiBUaGlzIGlzIGRvbmUgYnkgYWRkaW5nXG5cdFx0XHQgKiBmdW5jdGlvbnMgdGhpcyBvYmplY3Qgd2l0aCBhIHBhcmFtZXRlciBuYW1lIHdoaWNoIG1hdGNoZXMgdGhlIHNUeXBlXG5cdFx0XHQgKiBmb3IgdGhhdCB0YXJnZXQgY29sdW1uLiBUaGlzIGlzIHRoZSBjb3JvbGxhcnkgb2YgPGk+YWZuU29ydERhdGE8L2k+XG5cdFx0XHQgKiBmb3Igc2VhcmNoaW5nIGRhdGEuXG5cdFx0XHQgKlxuXHRcdFx0ICogVGhlIGZ1bmN0aW9ucyBkZWZpbmVkIHRha2UgYSBzaW5nbGUgcGFyYW1ldGVyOlxuXHRcdFx0ICpcblx0XHQgICAgICogIDEuIGB7Kn1gIERhdGEgZnJvbSB0aGUgY29sdW1uIGNlbGwgdG8gYmUgcHJlcGFyZWQgZm9yIHNlYXJjaGluZ1xuXHRcdFx0ICpcblx0XHRcdCAqIEVhY2ggZnVuY3Rpb24gaXMgZXhwZWN0ZWQgdG8gcmV0dXJuOlxuXHRcdFx0ICpcblx0XHRcdCAqICogYHtzdHJpbmd8bnVsbH1gIEZvcm1hdHRlZCBzdHJpbmcgdGhhdCB3aWxsIGJlIHVzZWQgZm9yIHRoZSBzZWFyY2hpbmcuXG5cdFx0XHQgKlxuXHRcdFx0ICogIEB0eXBlIG9iamVjdFxuXHRcdFx0ICogIEBkZWZhdWx0IHt9XG5cdFx0XHQgKlxuXHRcdFx0ICogIEBleGFtcGxlXG5cdFx0XHQgKiAgICAkLmZuLmRhdGFUYWJsZS5leHQudHlwZS5zZWFyY2hbJ3RpdGxlLW51bWVyaWMnXSA9IGZ1bmN0aW9uICggZCApIHtcblx0XHRcdCAqICAgICAgcmV0dXJuIGQucmVwbGFjZSgvXFxuL2csXCIgXCIpLnJlcGxhY2UoIC88Lio/Pi9nLCBcIlwiICk7XG5cdFx0XHQgKiAgICB9XG5cdFx0XHQgKi9cblx0XHRcdHNlYXJjaDoge30sXG5cdFxuXHRcblx0XHRcdC8qKlxuXHRcdFx0ICogVHlwZSBiYXNlZCBvcmRlcmluZy5cblx0XHRcdCAqXG5cdFx0XHQgKiBUaGUgY29sdW1uIHR5cGUgdGVsbHMgRGF0YVRhYmxlcyB3aGF0IG9yZGVyaW5nIHRvIGFwcGx5IHRvIHRoZSB0YWJsZVxuXHRcdFx0ICogd2hlbiBhIGNvbHVtbiBpcyBzb3J0ZWQgdXBvbi4gVGhlIG9yZGVyIGZvciBlYWNoIHR5cGUgdGhhdCBpcyBkZWZpbmVkLFxuXHRcdFx0ICogaXMgZGVmaW5lZCBieSB0aGUgZnVuY3Rpb25zIGF2YWlsYWJsZSBpbiB0aGlzIG9iamVjdC5cblx0XHRcdCAqXG5cdFx0XHQgKiBFYWNoIG9yZGVyaW5nIG9wdGlvbiBjYW4gYmUgZGVzY3JpYmVkIGJ5IHRocmVlIHByb3BlcnRpZXMgYWRkZWQgdG9cblx0XHRcdCAqIHRoaXMgb2JqZWN0OlxuXHRcdFx0ICpcblx0XHRcdCAqICogYHt0eXBlfS1wcmVgIC0gUHJlLWZvcm1hdHRpbmcgZnVuY3Rpb25cblx0XHRcdCAqICogYHt0eXBlfS1hc2NgIC0gQXNjZW5kaW5nIG9yZGVyIGZ1bmN0aW9uXG5cdFx0XHQgKiAqIGB7dHlwZX0tZGVzY2AgLSBEZXNjZW5kaW5nIG9yZGVyIGZ1bmN0aW9uXG5cdFx0XHQgKlxuXHRcdFx0ICogQWxsIHRocmVlIGNhbiBiZSB1c2VkIHRvZ2V0aGVyLCBvbmx5IGB7dHlwZX0tcHJlYCBvciBvbmx5XG5cdFx0XHQgKiBge3R5cGV9LWFzY2AgYW5kIGB7dHlwZX0tZGVzY2AgdG9nZXRoZXIuIEl0IGlzIGdlbmVyYWxseSByZWNvbW1lbmRlZFxuXHRcdFx0ICogdGhhdCBvbmx5IGB7dHlwZX0tcHJlYCBpcyB1c2VkLCBhcyB0aGlzIHByb3ZpZGVzIHRoZSBvcHRpbWFsXG5cdFx0XHQgKiBpbXBsZW1lbnRhdGlvbiBpbiB0ZXJtcyBvZiBzcGVlZCwgYWx0aG91Z2ggdGhlIG90aGVycyBhcmUgcHJvdmlkZWRcblx0XHRcdCAqIGZvciBjb21wYXRpYmlsaXR5IHdpdGggZXhpc3RpbmcgSmF2YXNjcmlwdCBzb3J0IGZ1bmN0aW9ucy5cblx0XHRcdCAqXG5cdFx0XHQgKiBge3R5cGV9LXByZWA6IEZ1bmN0aW9ucyBkZWZpbmVkIHRha2UgYSBzaW5nbGUgcGFyYW1ldGVyOlxuXHRcdFx0ICpcblx0XHQgICAgICogIDEuIGB7Kn1gIERhdGEgZnJvbSB0aGUgY29sdW1uIGNlbGwgdG8gYmUgcHJlcGFyZWQgZm9yIG9yZGVyaW5nXG5cdFx0XHQgKlxuXHRcdFx0ICogQW5kIHJldHVybjpcblx0XHRcdCAqXG5cdFx0XHQgKiAqIGB7Kn1gIERhdGEgdG8gYmUgc29ydGVkIHVwb25cblx0XHRcdCAqXG5cdFx0XHQgKiBge3R5cGV9LWFzY2AgYW5kIGB7dHlwZX0tZGVzY2A6IEZ1bmN0aW9ucyBhcmUgdHlwaWNhbCBKYXZhc2NyaXB0IHNvcnRcblx0XHRcdCAqIGZ1bmN0aW9ucywgdGFraW5nIHR3byBwYXJhbWV0ZXJzOlxuXHRcdFx0ICpcblx0XHQgICAgICogIDEuIGB7Kn1gIERhdGEgdG8gY29tcGFyZSB0byB0aGUgc2Vjb25kIHBhcmFtZXRlclxuXHRcdCAgICAgKiAgMi4gYHsqfWAgRGF0YSB0byBjb21wYXJlIHRvIHRoZSBmaXJzdCBwYXJhbWV0ZXJcblx0XHRcdCAqXG5cdFx0XHQgKiBBbmQgcmV0dXJuaW5nOlxuXHRcdFx0ICpcblx0XHRcdCAqICogYHsqfWAgT3JkZXJpbmcgbWF0Y2g6IDwwIGlmIGZpcnN0IHBhcmFtZXRlciBzaG91bGQgYmUgc29ydGVkIGxvd2VyXG5cdFx0XHQgKiAgIHRoYW4gdGhlIHNlY29uZCBwYXJhbWV0ZXIsID09PTAgaWYgdGhlIHR3byBwYXJhbWV0ZXJzIGFyZSBlcXVhbCBhbmRcblx0XHRcdCAqICAgPjAgaWYgdGhlIGZpcnN0IHBhcmFtZXRlciBzaG91bGQgYmUgc29ydGVkIGhlaWdodCB0aGFuIHRoZSBzZWNvbmRcblx0XHRcdCAqICAgcGFyYW1ldGVyLlxuXHRcdFx0ICogXG5cdFx0XHQgKiAgQHR5cGUgb2JqZWN0XG5cdFx0XHQgKiAgQGRlZmF1bHQge31cblx0XHRcdCAqXG5cdFx0XHQgKiAgQGV4YW1wbGVcblx0XHRcdCAqICAgIC8vIE51bWVyaWMgb3JkZXJpbmcgb2YgZm9ybWF0dGVkIG51bWJlcnMgd2l0aCBhIHByZS1mb3JtYXR0ZXJcblx0XHRcdCAqICAgICQuZXh0ZW5kKCAkLmZuLmRhdGFUYWJsZS5leHQudHlwZS5vcmRlciwge1xuXHRcdFx0ICogICAgICBcInN0cmluZy1wcmVcIjogZnVuY3Rpb24oeCkge1xuXHRcdFx0ICogICAgICAgIGEgPSAoYSA9PT0gXCItXCIgfHwgYSA9PT0gXCJcIikgPyAwIDogYS5yZXBsYWNlKCAvW15cXGRcXC1cXC5dL2csIFwiXCIgKTtcblx0XHRcdCAqICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCggYSApO1xuXHRcdFx0ICogICAgICB9XG5cdFx0XHQgKiAgICB9ICk7XG5cdFx0XHQgKlxuXHRcdFx0ICogIEBleGFtcGxlXG5cdFx0XHQgKiAgICAvLyBDYXNlLXNlbnNpdGl2ZSBzdHJpbmcgb3JkZXJpbmcsIHdpdGggbm8gcHJlLWZvcm1hdHRpbmcgbWV0aG9kXG5cdFx0XHQgKiAgICAkLmV4dGVuZCggJC5mbi5kYXRhVGFibGUuZXh0Lm9yZGVyLCB7XG5cdFx0XHQgKiAgICAgIFwic3RyaW5nLWNhc2UtYXNjXCI6IGZ1bmN0aW9uKHgseSkge1xuXHRcdFx0ICogICAgICAgIHJldHVybiAoKHggPCB5KSA/IC0xIDogKCh4ID4geSkgPyAxIDogMCkpO1xuXHRcdFx0ICogICAgICB9LFxuXHRcdFx0ICogICAgICBcInN0cmluZy1jYXNlLWRlc2NcIjogZnVuY3Rpb24oeCx5KSB7XG5cdFx0XHQgKiAgICAgICAgcmV0dXJuICgoeCA8IHkpID8gMSA6ICgoeCA+IHkpID8gLTEgOiAwKSk7XG5cdFx0XHQgKiAgICAgIH1cblx0XHRcdCAqICAgIH0gKTtcblx0XHRcdCAqL1xuXHRcdFx0b3JkZXI6IHt9XG5cdFx0fSxcblx0XG5cdFx0LyoqXG5cdFx0ICogVW5pcXVlIERhdGFUYWJsZXMgaW5zdGFuY2UgY291bnRlclxuXHRcdCAqXG5cdFx0ICogQHR5cGUgaW50XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHRfdW5pcXVlOiAwLFxuXHRcblx0XG5cdFx0Ly9cblx0XHQvLyBEZXByZWNpYXRlZFxuXHRcdC8vIFRoZSBmb2xsb3dpbmcgcHJvcGVydGllcyBhcmUgcmV0YWluZWQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmxpdHkgb25seS5cblx0XHQvLyBUaGUgc2hvdWxkIG5vdCBiZSB1c2VkIGluIG5ldyBwcm9qZWN0cyBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlXG5cdFx0Ly8gdmVyc2lvblxuXHRcdC8vXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFZlcnNpb24gY2hlY2sgZnVuY3Rpb24uXG5cdFx0ICogIEB0eXBlIGZ1bmN0aW9uXG5cdFx0ICogIEBkZXByZWNpYXRlZCBTaW5jZSAxLjEwXG5cdFx0ICovXG5cdFx0Zm5WZXJzaW9uQ2hlY2s6IERhdGFUYWJsZS5mblZlcnNpb25DaGVjayxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEluZGV4IGZvciB3aGF0ICd0aGlzJyBpbmRleCBBUEkgZnVuY3Rpb25zIHNob3VsZCB1c2Vcblx0XHQgKiAgQHR5cGUgaW50XG5cdFx0ICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXG5cdFx0ICovXG5cdFx0aUFwaUluZGV4OiAwLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogalF1ZXJ5IFVJIGNsYXNzIGNvbnRhaW5lclxuXHRcdCAqICBAdHlwZSBvYmplY3Rcblx0XHQgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcblx0XHQgKi9cblx0XHRvSlVJQ2xhc3Nlczoge30sXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBTb2Z0d2FyZSB2ZXJzaW9uXG5cdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdCAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxuXHRcdCAqL1xuXHRcdHNWZXJzaW9uOiBEYXRhVGFibGUudmVyc2lvblxuXHR9O1xuXHRcblx0XG5cdC8vXG5cdC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LiBBbGlhcyB0byBwcmUgMS4xMCBIdW5nYXJpYW4gbm90YXRpb24gY291bnRlciBwYXJ0c1xuXHQvL1xuXHQkLmV4dGVuZCggX2V4dCwge1xuXHRcdGFmbkZpbHRlcmluZzogX2V4dC5zZWFyY2gsXG5cdFx0YVR5cGVzOiAgICAgICBfZXh0LnR5cGUuZGV0ZWN0LFxuXHRcdG9mblNlYXJjaDogICAgX2V4dC50eXBlLnNlYXJjaCxcblx0XHRvU29ydDogICAgICAgIF9leHQudHlwZS5vcmRlcixcblx0XHRhZm5Tb3J0RGF0YTogIF9leHQub3JkZXIsXG5cdFx0YW9GZWF0dXJlczogICBfZXh0LmZlYXR1cmUsXG5cdFx0b0FwaTogICAgICAgICBfZXh0LmludGVybmFsLFxuXHRcdG9TdGRDbGFzc2VzOiAgX2V4dC5jbGFzc2VzLFxuXHRcdG9QYWdpbmF0aW9uOiAgX2V4dC5wYWdlclxuXHR9ICk7XG5cdFxuXHRcblx0JC5leHRlbmQoIERhdGFUYWJsZS5leHQuY2xhc3Nlcywge1xuXHRcdFwic1RhYmxlXCI6IFwiZGF0YVRhYmxlXCIsXG5cdFx0XCJzTm9Gb290ZXJcIjogXCJuby1mb290ZXJcIixcblx0XG5cdFx0LyogUGFnaW5nIGJ1dHRvbnMgKi9cblx0XHRcInNQYWdlQnV0dG9uXCI6IFwicGFnaW5hdGVfYnV0dG9uXCIsXG5cdFx0XCJzUGFnZUJ1dHRvbkFjdGl2ZVwiOiBcImN1cnJlbnRcIixcblx0XHRcInNQYWdlQnV0dG9uRGlzYWJsZWRcIjogXCJkaXNhYmxlZFwiLFxuXHRcblx0XHQvKiBTdHJpcGluZyBjbGFzc2VzICovXG5cdFx0XCJzU3RyaXBlT2RkXCI6IFwib2RkXCIsXG5cdFx0XCJzU3RyaXBlRXZlblwiOiBcImV2ZW5cIixcblx0XG5cdFx0LyogRW1wdHkgcm93ICovXG5cdFx0XCJzUm93RW1wdHlcIjogXCJkYXRhVGFibGVzX2VtcHR5XCIsXG5cdFxuXHRcdC8qIEZlYXR1cmVzICovXG5cdFx0XCJzV3JhcHBlclwiOiBcImRhdGFUYWJsZXNfd3JhcHBlclwiLFxuXHRcdFwic0ZpbHRlclwiOiBcImRhdGFUYWJsZXNfZmlsdGVyXCIsXG5cdFx0XCJzSW5mb1wiOiBcImRhdGFUYWJsZXNfaW5mb1wiLFxuXHRcdFwic1BhZ2luZ1wiOiBcImRhdGFUYWJsZXNfcGFnaW5hdGUgcGFnaW5nX1wiLCAvKiBOb3RlIHRoYXQgdGhlIHR5cGUgaXMgcG9zdGZpeGVkICovXG5cdFx0XCJzTGVuZ3RoXCI6IFwiZGF0YVRhYmxlc19sZW5ndGhcIixcblx0XHRcInNQcm9jZXNzaW5nXCI6IFwiZGF0YVRhYmxlc19wcm9jZXNzaW5nXCIsXG5cdFxuXHRcdC8qIFNvcnRpbmcgKi9cblx0XHRcInNTb3J0QXNjXCI6IFwic29ydGluZ19hc2NcIixcblx0XHRcInNTb3J0RGVzY1wiOiBcInNvcnRpbmdfZGVzY1wiLFxuXHRcdFwic1NvcnRhYmxlXCI6IFwic29ydGluZ1wiLCAvKiBTb3J0YWJsZSBpbiBib3RoIGRpcmVjdGlvbnMgKi9cblx0XHRcInNTb3J0YWJsZUFzY1wiOiBcInNvcnRpbmdfYXNjX2Rpc2FibGVkXCIsXG5cdFx0XCJzU29ydGFibGVEZXNjXCI6IFwic29ydGluZ19kZXNjX2Rpc2FibGVkXCIsXG5cdFx0XCJzU29ydGFibGVOb25lXCI6IFwic29ydGluZ19kaXNhYmxlZFwiLFxuXHRcdFwic1NvcnRDb2x1bW5cIjogXCJzb3J0aW5nX1wiLCAvKiBOb3RlIHRoYXQgYW4gaW50IGlzIHBvc3RmaXhlZCBmb3IgdGhlIHNvcnRpbmcgb3JkZXIgKi9cblx0XG5cdFx0LyogRmlsdGVyaW5nICovXG5cdFx0XCJzRmlsdGVySW5wdXRcIjogXCJcIixcblx0XG5cdFx0LyogUGFnZSBsZW5ndGggKi9cblx0XHRcInNMZW5ndGhTZWxlY3RcIjogXCJcIixcblx0XG5cdFx0LyogU2Nyb2xsaW5nICovXG5cdFx0XCJzU2Nyb2xsV3JhcHBlclwiOiBcImRhdGFUYWJsZXNfc2Nyb2xsXCIsXG5cdFx0XCJzU2Nyb2xsSGVhZFwiOiBcImRhdGFUYWJsZXNfc2Nyb2xsSGVhZFwiLFxuXHRcdFwic1Njcm9sbEhlYWRJbm5lclwiOiBcImRhdGFUYWJsZXNfc2Nyb2xsSGVhZElubmVyXCIsXG5cdFx0XCJzU2Nyb2xsQm9keVwiOiBcImRhdGFUYWJsZXNfc2Nyb2xsQm9keVwiLFxuXHRcdFwic1Njcm9sbEZvb3RcIjogXCJkYXRhVGFibGVzX3Njcm9sbEZvb3RcIixcblx0XHRcInNTY3JvbGxGb290SW5uZXJcIjogXCJkYXRhVGFibGVzX3Njcm9sbEZvb3RJbm5lclwiLFxuXHRcblx0XHQvKiBNaXNjICovXG5cdFx0XCJzSGVhZGVyVEhcIjogXCJcIixcblx0XHRcInNGb290ZXJUSFwiOiBcIlwiLFxuXHRcblx0XHQvLyBEZXByZWNhdGVkXG5cdFx0XCJzU29ydEpVSUFzY1wiOiBcIlwiLFxuXHRcdFwic1NvcnRKVUlEZXNjXCI6IFwiXCIsXG5cdFx0XCJzU29ydEpVSVwiOiBcIlwiLFxuXHRcdFwic1NvcnRKVUlBc2NBbGxvd2VkXCI6IFwiXCIsXG5cdFx0XCJzU29ydEpVSURlc2NBbGxvd2VkXCI6IFwiXCIsXG5cdFx0XCJzU29ydEpVSVdyYXBwZXJcIjogXCJcIixcblx0XHRcInNTb3J0SWNvblwiOiBcIlwiLFxuXHRcdFwic0pVSUhlYWRlclwiOiBcIlwiLFxuXHRcdFwic0pVSUZvb3RlclwiOiBcIlwiXG5cdH0gKTtcblx0XG5cdFxuXHR2YXIgZXh0UGFnaW5hdGlvbiA9IERhdGFUYWJsZS5leHQucGFnZXI7XG5cdFxuXHRmdW5jdGlvbiBfbnVtYmVycyAoIHBhZ2UsIHBhZ2VzICkge1xuXHRcdHZhclxuXHRcdFx0bnVtYmVycyA9IFtdLFxuXHRcdFx0YnV0dG9ucyA9IGV4dFBhZ2luYXRpb24ubnVtYmVyc19sZW5ndGgsXG5cdFx0XHRoYWxmID0gTWF0aC5mbG9vciggYnV0dG9ucyAvIDIgKSxcblx0XHRcdGkgPSAxO1xuXHRcblx0XHRpZiAoIHBhZ2VzIDw9IGJ1dHRvbnMgKSB7XG5cdFx0XHRudW1iZXJzID0gX3JhbmdlKCAwLCBwYWdlcyApO1xuXHRcdH1cblx0XHRlbHNlIGlmICggcGFnZSA8PSBoYWxmICkge1xuXHRcdFx0bnVtYmVycyA9IF9yYW5nZSggMCwgYnV0dG9ucy0yICk7XG5cdFx0XHRudW1iZXJzLnB1c2goICdlbGxpcHNpcycgKTtcblx0XHRcdG51bWJlcnMucHVzaCggcGFnZXMtMSApO1xuXHRcdH1cblx0XHRlbHNlIGlmICggcGFnZSA+PSBwYWdlcyAtIDEgLSBoYWxmICkge1xuXHRcdFx0bnVtYmVycyA9IF9yYW5nZSggcGFnZXMtKGJ1dHRvbnMtMiksIHBhZ2VzICk7XG5cdFx0XHRudW1iZXJzLnNwbGljZSggMCwgMCwgJ2VsbGlwc2lzJyApOyAvLyBubyB1bnNoaWZ0IGluIGllNlxuXHRcdFx0bnVtYmVycy5zcGxpY2UoIDAsIDAsIDAgKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRudW1iZXJzID0gX3JhbmdlKCBwYWdlLWhhbGYrMiwgcGFnZStoYWxmLTEgKTtcblx0XHRcdG51bWJlcnMucHVzaCggJ2VsbGlwc2lzJyApO1xuXHRcdFx0bnVtYmVycy5wdXNoKCBwYWdlcy0xICk7XG5cdFx0XHRudW1iZXJzLnNwbGljZSggMCwgMCwgJ2VsbGlwc2lzJyApO1xuXHRcdFx0bnVtYmVycy5zcGxpY2UoIDAsIDAsIDAgKTtcblx0XHR9XG5cdFxuXHRcdG51bWJlcnMuRFRfZWwgPSAnc3Bhbic7XG5cdFx0cmV0dXJuIG51bWJlcnM7XG5cdH1cblx0XG5cdFxuXHQkLmV4dGVuZCggZXh0UGFnaW5hdGlvbiwge1xuXHRcdHNpbXBsZTogZnVuY3Rpb24gKCBwYWdlLCBwYWdlcyApIHtcblx0XHRcdHJldHVybiBbICdwcmV2aW91cycsICduZXh0JyBdO1xuXHRcdH0sXG5cdFxuXHRcdGZ1bGw6IGZ1bmN0aW9uICggcGFnZSwgcGFnZXMgKSB7XG5cdFx0XHRyZXR1cm4gWyAgJ2ZpcnN0JywgJ3ByZXZpb3VzJywgJ25leHQnLCAnbGFzdCcgXTtcblx0XHR9LFxuXHRcblx0XHRudW1iZXJzOiBmdW5jdGlvbiAoIHBhZ2UsIHBhZ2VzICkge1xuXHRcdFx0cmV0dXJuIFsgX251bWJlcnMocGFnZSwgcGFnZXMpIF07XG5cdFx0fSxcblx0XG5cdFx0c2ltcGxlX251bWJlcnM6IGZ1bmN0aW9uICggcGFnZSwgcGFnZXMgKSB7XG5cdFx0XHRyZXR1cm4gWyAncHJldmlvdXMnLCBfbnVtYmVycyhwYWdlLCBwYWdlcyksICduZXh0JyBdO1xuXHRcdH0sXG5cdFxuXHRcdGZ1bGxfbnVtYmVyczogZnVuY3Rpb24gKCBwYWdlLCBwYWdlcyApIHtcblx0XHRcdHJldHVybiBbICdmaXJzdCcsICdwcmV2aW91cycsIF9udW1iZXJzKHBhZ2UsIHBhZ2VzKSwgJ25leHQnLCAnbGFzdCcgXTtcblx0XHR9LFxuXHRcdFxuXHRcdGZpcnN0X2xhc3RfbnVtYmVyczogZnVuY3Rpb24gKHBhZ2UsIHBhZ2VzKSB7XG5cdCBcdFx0cmV0dXJuIFsnZmlyc3QnLCBfbnVtYmVycyhwYWdlLCBwYWdlcyksICdsYXN0J107XG5cdCBcdH0sXG5cdFxuXHRcdC8vIEZvciB0ZXN0aW5nIGFuZCBwbHVnLWlucyB0byB1c2Vcblx0XHRfbnVtYmVyczogX251bWJlcnMsXG5cdFxuXHRcdC8vIE51bWJlciBvZiBudW1iZXIgYnV0dG9ucyAoaW5jbHVkaW5nIGVsbGlwc2lzKSB0byBzaG93LiBfTXVzdCBiZSBvZGQhX1xuXHRcdG51bWJlcnNfbGVuZ3RoOiA3XG5cdH0gKTtcblx0XG5cdFxuXHQkLmV4dGVuZCggdHJ1ZSwgRGF0YVRhYmxlLmV4dC5yZW5kZXJlciwge1xuXHRcdHBhZ2VCdXR0b246IHtcblx0XHRcdF86IGZ1bmN0aW9uICggc2V0dGluZ3MsIGhvc3QsIGlkeCwgYnV0dG9ucywgcGFnZSwgcGFnZXMgKSB7XG5cdFx0XHRcdHZhciBjbGFzc2VzID0gc2V0dGluZ3Mub0NsYXNzZXM7XG5cdFx0XHRcdHZhciBsYW5nID0gc2V0dGluZ3Mub0xhbmd1YWdlLm9QYWdpbmF0ZTtcblx0XHRcdFx0dmFyIGFyaWEgPSBzZXR0aW5ncy5vTGFuZ3VhZ2Uub0FyaWEucGFnaW5hdGUgfHwge307XG5cdFx0XHRcdHZhciBidG5EaXNwbGF5LCBidG5DbGFzcywgY291bnRlcj0wO1xuXHRcblx0XHRcdFx0dmFyIGF0dGFjaCA9IGZ1bmN0aW9uKCBjb250YWluZXIsIGJ1dHRvbnMgKSB7XG5cdFx0XHRcdFx0dmFyIGksIGllbiwgbm9kZSwgYnV0dG9uLCB0YWJJbmRleDtcblx0XHRcdFx0XHR2YXIgZGlzYWJsZWRDbGFzcyA9IGNsYXNzZXMuc1BhZ2VCdXR0b25EaXNhYmxlZDtcblx0XHRcdFx0XHR2YXIgY2xpY2tIYW5kbGVyID0gZnVuY3Rpb24gKCBlICkge1xuXHRcdFx0XHRcdFx0X2ZuUGFnZUNoYW5nZSggc2V0dGluZ3MsIGUuZGF0YS5hY3Rpb24sIHRydWUgKTtcblx0XHRcdFx0XHR9O1xuXHRcblx0XHRcdFx0XHRmb3IgKCBpPTAsIGllbj1idXR0b25zLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRcdFx0YnV0dG9uID0gYnV0dG9uc1tpXTtcblx0XG5cdFx0XHRcdFx0XHRpZiAoICQuaXNBcnJheSggYnV0dG9uICkgKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBpbm5lciA9ICQoICc8JysoYnV0dG9uLkRUX2VsIHx8ICdkaXYnKSsnLz4nIClcblx0XHRcdFx0XHRcdFx0XHQuYXBwZW5kVG8oIGNvbnRhaW5lciApO1xuXHRcdFx0XHRcdFx0XHRhdHRhY2goIGlubmVyLCBidXR0b24gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRidG5EaXNwbGF5ID0gbnVsbDtcblx0XHRcdFx0XHRcdFx0YnRuQ2xhc3MgPSBidXR0b247XG5cdFx0XHRcdFx0XHRcdHRhYkluZGV4ID0gc2V0dGluZ3MuaVRhYkluZGV4O1xuXHRcblx0XHRcdFx0XHRcdFx0c3dpdGNoICggYnV0dG9uICkge1xuXHRcdFx0XHRcdFx0XHRcdGNhc2UgJ2VsbGlwc2lzJzpcblx0XHRcdFx0XHRcdFx0XHRcdGNvbnRhaW5lci5hcHBlbmQoJzxzcGFuIGNsYXNzPVwiZWxsaXBzaXNcIj4mI3gyMDI2Ozwvc3Bhbj4nKTtcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcblx0XHRcdFx0XHRcdFx0XHRjYXNlICdmaXJzdCc6XG5cdFx0XHRcdFx0XHRcdFx0XHRidG5EaXNwbGF5ID0gbGFuZy5zRmlyc3Q7XG5cdFxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBwYWdlID09PSAwICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0YWJJbmRleCA9IC0xO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRidG5DbGFzcyArPSAnICcgKyBkaXNhYmxlZENsYXNzO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFxuXHRcdFx0XHRcdFx0XHRcdGNhc2UgJ3ByZXZpb3VzJzpcblx0XHRcdFx0XHRcdFx0XHRcdGJ0bkRpc3BsYXkgPSBsYW5nLnNQcmV2aW91cztcblx0XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHBhZ2UgPT09IDAgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRhYkluZGV4ID0gLTE7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGJ0bkNsYXNzICs9ICcgJyArIGRpc2FibGVkQ2xhc3M7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSAnbmV4dCc6XG5cdFx0XHRcdFx0XHRcdFx0XHRidG5EaXNwbGF5ID0gbGFuZy5zTmV4dDtcblx0XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHBhZ2VzID09PSAwIHx8IHBhZ2UgPT09IHBhZ2VzLTEgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRhYkluZGV4ID0gLTE7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGJ0bkNsYXNzICs9ICcgJyArIGRpc2FibGVkQ2xhc3M7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSAnbGFzdCc6XG5cdFx0XHRcdFx0XHRcdFx0XHRidG5EaXNwbGF5ID0gbGFuZy5zTGFzdDtcblx0XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHBhZ2UgPT09IHBhZ2VzLTEgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRhYkluZGV4ID0gLTE7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGJ0bkNsYXNzICs9ICcgJyArIGRpc2FibGVkQ2xhc3M7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XG5cdFx0XHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0XHRcdGJ0bkRpc3BsYXkgPSBidXR0b24gKyAxO1xuXHRcdFx0XHRcdFx0XHRcdFx0YnRuQ2xhc3MgPSBwYWdlID09PSBidXR0b24gP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRjbGFzc2VzLnNQYWdlQnV0dG9uQWN0aXZlIDogJyc7XG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHRcdFx0aWYgKCBidG5EaXNwbGF5ICE9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0XHRcdG5vZGUgPSAkKCc8YT4nLCB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdCdjbGFzcyc6IGNsYXNzZXMuc1BhZ2VCdXR0b24rJyAnK2J0bkNsYXNzLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQnYXJpYS1jb250cm9scyc6IHNldHRpbmdzLnNUYWJsZUlkLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQnYXJpYS1sYWJlbCc6IGFyaWFbIGJ1dHRvbiBdLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQnZGF0YS1kdC1pZHgnOiBjb3VudGVyLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQndGFiaW5kZXgnOiB0YWJJbmRleCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0J2lkJzogaWR4ID09PSAwICYmIHR5cGVvZiBidXR0b24gPT09ICdzdHJpbmcnID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRzZXR0aW5ncy5zVGFibGVJZCArJ18nKyBidXR0b24gOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG51bGxcblx0XHRcdFx0XHRcdFx0XHRcdH0gKVxuXHRcdFx0XHRcdFx0XHRcdFx0Lmh0bWwoIGJ0bkRpc3BsYXkgKVxuXHRcdFx0XHRcdFx0XHRcdFx0LmFwcGVuZFRvKCBjb250YWluZXIgKTtcblx0XG5cdFx0XHRcdFx0XHRcdFx0X2ZuQmluZEFjdGlvbihcblx0XHRcdFx0XHRcdFx0XHRcdG5vZGUsIHthY3Rpb246IGJ1dHRvbn0sIGNsaWNrSGFuZGxlclxuXHRcdFx0XHRcdFx0XHRcdCk7XG5cdFxuXHRcdFx0XHRcdFx0XHRcdGNvdW50ZXIrKztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XG5cdFx0XHRcdC8vIElFOSB0aHJvd3MgYW4gJ3Vua25vd24gZXJyb3InIGlmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgaXMgdXNlZFxuXHRcdFx0XHQvLyBpbnNpZGUgYW4gaWZyYW1lIG9yIGZyYW1lLiBUcnkgLyBjYXRjaCB0aGUgZXJyb3IuIE5vdCBnb29kIGZvclxuXHRcdFx0XHQvLyBhY2Nlc3NpYmlsaXR5LCBidXQgbmVpdGhlciBhcmUgZnJhbWVzLlxuXHRcdFx0XHR2YXIgYWN0aXZlRWw7XG5cdFxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdC8vIEJlY2F1c2UgdGhpcyBhcHByb2FjaCBpcyBkZXN0cm95aW5nIGFuZCByZWNyZWF0aW5nIHRoZSBwYWdpbmdcblx0XHRcdFx0XHQvLyBlbGVtZW50cywgZm9jdXMgaXMgbG9zdCBvbiB0aGUgc2VsZWN0IGJ1dHRvbiB3aGljaCBpcyBiYWQgZm9yXG5cdFx0XHRcdFx0Ly8gYWNjZXNzaWJpbGl0eS4gU28gd2Ugd2FudCB0byByZXN0b3JlIGZvY3VzIG9uY2UgdGhlIGRyYXcgaGFzXG5cdFx0XHRcdFx0Ly8gY29tcGxldGVkXG5cdFx0XHRcdFx0YWN0aXZlRWwgPSAkKGhvc3QpLmZpbmQoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkuZGF0YSgnZHQtaWR4Jyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2F0Y2ggKGUpIHt9XG5cdFxuXHRcdFx0XHRhdHRhY2goICQoaG9zdCkuZW1wdHkoKSwgYnV0dG9ucyApO1xuXHRcblx0XHRcdFx0aWYgKCBhY3RpdmVFbCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdCQoaG9zdCkuZmluZCggJ1tkYXRhLWR0LWlkeD0nK2FjdGl2ZUVsKyddJyApLnRyaWdnZXIoJ2ZvY3VzJyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0gKTtcblx0XG5cdFxuXHRcblx0Ly8gQnVpbHQgaW4gdHlwZSBkZXRlY3Rpb24uIFNlZSBtb2RlbC5leHQuYVR5cGVzIGZvciBpbmZvcm1hdGlvbiBhYm91dFxuXHQvLyB3aGF0IGlzIHJlcXVpcmVkIGZyb20gdGhpcyBtZXRob2RzLlxuXHQkLmV4dGVuZCggRGF0YVRhYmxlLmV4dC50eXBlLmRldGVjdCwgW1xuXHRcdC8vIFBsYWluIG51bWJlcnMgLSBmaXJzdCBzaW5jZSBWOCBkZXRlY3RzIHNvbWUgcGxhaW4gbnVtYmVycyBhcyBkYXRlc1xuXHRcdC8vIGUuZy4gRGF0ZS5wYXJzZSgnNTUnKSAoYnV0IG5vdCBhbGwsIGUuZy4gRGF0ZS5wYXJzZSgnMjInKS4uLikuXG5cdFx0ZnVuY3Rpb24gKCBkLCBzZXR0aW5ncyApXG5cdFx0e1xuXHRcdFx0dmFyIGRlY2ltYWwgPSBzZXR0aW5ncy5vTGFuZ3VhZ2Uuc0RlY2ltYWw7XG5cdFx0XHRyZXR1cm4gX2lzTnVtYmVyKCBkLCBkZWNpbWFsICkgPyAnbnVtJytkZWNpbWFsIDogbnVsbDtcblx0XHR9LFxuXHRcblx0XHQvLyBEYXRlcyAob25seSB0aG9zZSByZWNvZ25pc2VkIGJ5IHRoZSBicm93c2VyJ3MgRGF0ZS5wYXJzZSlcblx0XHRmdW5jdGlvbiAoIGQsIHNldHRpbmdzIClcblx0XHR7XG5cdFx0XHQvLyBWOCB0cmllcyBfdmVyeV8gaGFyZCB0byBtYWtlIGEgc3RyaW5nIHBhc3NlZCBpbnRvIGBEYXRlLnBhcnNlKClgXG5cdFx0XHQvLyB2YWxpZCwgc28gd2UgbmVlZCB0byB1c2UgYSByZWdleCB0byByZXN0cmljdCBkYXRlIGZvcm1hdHMuIFVzZSBhXG5cdFx0XHQvLyBwbHVnLWluIGZvciBhbnl0aGluZyBvdGhlciB0aGFuIElTTzg2MDEgc3R5bGUgc3RyaW5nc1xuXHRcdFx0aWYgKCBkICYmICEoZCBpbnN0YW5jZW9mIERhdGUpICYmICEgX3JlX2RhdGUudGVzdChkKSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHR2YXIgcGFyc2VkID0gRGF0ZS5wYXJzZShkKTtcblx0XHRcdHJldHVybiAocGFyc2VkICE9PSBudWxsICYmICFpc05hTihwYXJzZWQpKSB8fCBfZW1wdHkoZCkgPyAnZGF0ZScgOiBudWxsO1xuXHRcdH0sXG5cdFxuXHRcdC8vIEZvcm1hdHRlZCBudW1iZXJzXG5cdFx0ZnVuY3Rpb24gKCBkLCBzZXR0aW5ncyApXG5cdFx0e1xuXHRcdFx0dmFyIGRlY2ltYWwgPSBzZXR0aW5ncy5vTGFuZ3VhZ2Uuc0RlY2ltYWw7XG5cdFx0XHRyZXR1cm4gX2lzTnVtYmVyKCBkLCBkZWNpbWFsLCB0cnVlICkgPyAnbnVtLWZtdCcrZGVjaW1hbCA6IG51bGw7XG5cdFx0fSxcblx0XG5cdFx0Ly8gSFRNTCBudW1lcmljXG5cdFx0ZnVuY3Rpb24gKCBkLCBzZXR0aW5ncyApXG5cdFx0e1xuXHRcdFx0dmFyIGRlY2ltYWwgPSBzZXR0aW5ncy5vTGFuZ3VhZ2Uuc0RlY2ltYWw7XG5cdFx0XHRyZXR1cm4gX2h0bWxOdW1lcmljKCBkLCBkZWNpbWFsICkgPyAnaHRtbC1udW0nK2RlY2ltYWwgOiBudWxsO1xuXHRcdH0sXG5cdFxuXHRcdC8vIEhUTUwgbnVtZXJpYywgZm9ybWF0dGVkXG5cdFx0ZnVuY3Rpb24gKCBkLCBzZXR0aW5ncyApXG5cdFx0e1xuXHRcdFx0dmFyIGRlY2ltYWwgPSBzZXR0aW5ncy5vTGFuZ3VhZ2Uuc0RlY2ltYWw7XG5cdFx0XHRyZXR1cm4gX2h0bWxOdW1lcmljKCBkLCBkZWNpbWFsLCB0cnVlICkgPyAnaHRtbC1udW0tZm10JytkZWNpbWFsIDogbnVsbDtcblx0XHR9LFxuXHRcblx0XHQvLyBIVE1MICh0aGlzIGlzIHN0cmljdCBjaGVja2luZyAtIHRoZXJlIG11c3QgYmUgaHRtbClcblx0XHRmdW5jdGlvbiAoIGQsIHNldHRpbmdzIClcblx0XHR7XG5cdFx0XHRyZXR1cm4gX2VtcHR5KCBkICkgfHwgKHR5cGVvZiBkID09PSAnc3RyaW5nJyAmJiBkLmluZGV4T2YoJzwnKSAhPT0gLTEpID9cblx0XHRcdFx0J2h0bWwnIDogbnVsbDtcblx0XHR9XG5cdF0gKTtcblx0XG5cdFxuXHRcblx0Ly8gRmlsdGVyIGZvcm1hdHRpbmcgZnVuY3Rpb25zLiBTZWUgbW9kZWwuZXh0Lm9mblNlYXJjaCBmb3IgaW5mb3JtYXRpb24gYWJvdXRcblx0Ly8gd2hhdCBpcyByZXF1aXJlZCBmcm9tIHRoZXNlIG1ldGhvZHMuXG5cdC8vIFxuXHQvLyBOb3RlIHRoYXQgYWRkaXRpb25hbCBzZWFyY2ggbWV0aG9kcyBhcmUgYWRkZWQgZm9yIHRoZSBodG1sIG51bWJlcnMgYW5kXG5cdC8vIGh0bWwgZm9ybWF0dGVkIG51bWJlcnMgYnkgYF9hZGROdW1lcmljU29ydCgpYCB3aGVuIHdlIGtub3cgd2hhdCB0aGUgZGVjaW1hbFxuXHQvLyBwbGFjZSBpc1xuXHRcblx0XG5cdCQuZXh0ZW5kKCBEYXRhVGFibGUuZXh0LnR5cGUuc2VhcmNoLCB7XG5cdFx0aHRtbDogZnVuY3Rpb24gKCBkYXRhICkge1xuXHRcdFx0cmV0dXJuIF9lbXB0eShkYXRhKSA/XG5cdFx0XHRcdGRhdGEgOlxuXHRcdFx0XHR0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycgP1xuXHRcdFx0XHRcdGRhdGFcblx0XHRcdFx0XHRcdC5yZXBsYWNlKCBfcmVfbmV3X2xpbmVzLCBcIiBcIiApXG5cdFx0XHRcdFx0XHQucmVwbGFjZSggX3JlX2h0bWwsIFwiXCIgKSA6XG5cdFx0XHRcdFx0Jyc7XG5cdFx0fSxcblx0XG5cdFx0c3RyaW5nOiBmdW5jdGlvbiAoIGRhdGEgKSB7XG5cdFx0XHRyZXR1cm4gX2VtcHR5KGRhdGEpID9cblx0XHRcdFx0ZGF0YSA6XG5cdFx0XHRcdHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJyA/XG5cdFx0XHRcdFx0ZGF0YS5yZXBsYWNlKCBfcmVfbmV3X2xpbmVzLCBcIiBcIiApIDpcblx0XHRcdFx0XHRkYXRhO1xuXHRcdH1cblx0fSApO1xuXHRcblx0XG5cdFxuXHR2YXIgX19udW1lcmljUmVwbGFjZSA9IGZ1bmN0aW9uICggZCwgZGVjaW1hbFBsYWNlLCByZTEsIHJlMiApIHtcblx0XHRpZiAoIGQgIT09IDAgJiYgKCFkIHx8IGQgPT09ICctJykgKSB7XG5cdFx0XHRyZXR1cm4gLUluZmluaXR5O1xuXHRcdH1cblx0XG5cdFx0Ly8gSWYgYSBkZWNpbWFsIHBsYWNlIG90aGVyIHRoYW4gYC5gIGlzIHVzZWQsIGl0IG5lZWRzIHRvIGJlIGdpdmVuIHRvIHRoZVxuXHRcdC8vIGZ1bmN0aW9uIHNvIHdlIGNhbiBkZXRlY3QgaXQgYW5kIHJlcGxhY2Ugd2l0aCBhIGAuYCB3aGljaCBpcyB0aGUgb25seVxuXHRcdC8vIGRlY2ltYWwgcGxhY2UgSmF2YXNjcmlwdCByZWNvZ25pc2VzIC0gaXQgaXMgbm90IGxvY2FsZSBhd2FyZS5cblx0XHRpZiAoIGRlY2ltYWxQbGFjZSApIHtcblx0XHRcdGQgPSBfbnVtVG9EZWNpbWFsKCBkLCBkZWNpbWFsUGxhY2UgKTtcblx0XHR9XG5cdFxuXHRcdGlmICggZC5yZXBsYWNlICkge1xuXHRcdFx0aWYgKCByZTEgKSB7XG5cdFx0XHRcdGQgPSBkLnJlcGxhY2UoIHJlMSwgJycgKTtcblx0XHRcdH1cblx0XG5cdFx0XHRpZiAoIHJlMiApIHtcblx0XHRcdFx0ZCA9IGQucmVwbGFjZSggcmUyLCAnJyApO1xuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0cmV0dXJuIGQgKiAxO1xuXHR9O1xuXHRcblx0XG5cdC8vIEFkZCB0aGUgbnVtZXJpYyAnZGVmb3JtYXR0aW5nJyBmdW5jdGlvbnMgZm9yIHNvcnRpbmcgYW5kIHNlYXJjaC4gVGhpcyBpcyBkb25lXG5cdC8vIGluIGEgZnVuY3Rpb24gdG8gcHJvdmlkZSBhbiBlYXN5IGFiaWxpdHkgZm9yIHRoZSBsYW5ndWFnZSBvcHRpb25zIHRvIGFkZFxuXHQvLyBhZGRpdGlvbmFsIG1ldGhvZHMgaWYgYSBub24tcGVyaW9kIGRlY2ltYWwgcGxhY2UgaXMgdXNlZC5cblx0ZnVuY3Rpb24gX2FkZE51bWVyaWNTb3J0ICggZGVjaW1hbFBsYWNlICkge1xuXHRcdCQuZWFjaChcblx0XHRcdHtcblx0XHRcdFx0Ly8gUGxhaW4gbnVtYmVyc1xuXHRcdFx0XHRcIm51bVwiOiBmdW5jdGlvbiAoIGQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIF9fbnVtZXJpY1JlcGxhY2UoIGQsIGRlY2ltYWxQbGFjZSApO1xuXHRcdFx0XHR9LFxuXHRcblx0XHRcdFx0Ly8gRm9ybWF0dGVkIG51bWJlcnNcblx0XHRcdFx0XCJudW0tZm10XCI6IGZ1bmN0aW9uICggZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gX19udW1lcmljUmVwbGFjZSggZCwgZGVjaW1hbFBsYWNlLCBfcmVfZm9ybWF0dGVkX251bWVyaWMgKTtcblx0XHRcdFx0fSxcblx0XG5cdFx0XHRcdC8vIEhUTUwgbnVtZXJpY1xuXHRcdFx0XHRcImh0bWwtbnVtXCI6IGZ1bmN0aW9uICggZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gX19udW1lcmljUmVwbGFjZSggZCwgZGVjaW1hbFBsYWNlLCBfcmVfaHRtbCApO1xuXHRcdFx0XHR9LFxuXHRcblx0XHRcdFx0Ly8gSFRNTCBudW1lcmljLCBmb3JtYXR0ZWRcblx0XHRcdFx0XCJodG1sLW51bS1mbXRcIjogZnVuY3Rpb24gKCBkICkge1xuXHRcdFx0XHRcdHJldHVybiBfX251bWVyaWNSZXBsYWNlKCBkLCBkZWNpbWFsUGxhY2UsIF9yZV9odG1sLCBfcmVfZm9ybWF0dGVkX251bWVyaWMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGZ1bmN0aW9uICgga2V5LCBmbiApIHtcblx0XHRcdFx0Ly8gQWRkIHRoZSBvcmRlcmluZyBtZXRob2Rcblx0XHRcdFx0X2V4dC50eXBlLm9yZGVyWyBrZXkrZGVjaW1hbFBsYWNlKyctcHJlJyBdID0gZm47XG5cdFxuXHRcdFx0XHQvLyBGb3IgSFRNTCB0eXBlcyBhZGQgYSBzZWFyY2ggZm9ybWF0dGVyIHRoYXQgd2lsbCBzdHJpcCB0aGUgSFRNTFxuXHRcdFx0XHRpZiAoIGtleS5tYXRjaCgvXmh0bWxcXC0vKSApIHtcblx0XHRcdFx0XHRfZXh0LnR5cGUuc2VhcmNoWyBrZXkrZGVjaW1hbFBsYWNlIF0gPSBfZXh0LnR5cGUuc2VhcmNoLmh0bWw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHQpO1xuXHR9XG5cdFxuXHRcblx0Ly8gRGVmYXVsdCBzb3J0IG1ldGhvZHNcblx0JC5leHRlbmQoIF9leHQudHlwZS5vcmRlciwge1xuXHRcdC8vIERhdGVzXG5cdFx0XCJkYXRlLXByZVwiOiBmdW5jdGlvbiAoIGQgKSB7XG5cdFx0XHR2YXIgdHMgPSBEYXRlLnBhcnNlKCBkICk7XG5cdFx0XHRyZXR1cm4gaXNOYU4odHMpID8gLUluZmluaXR5IDogdHM7XG5cdFx0fSxcblx0XG5cdFx0Ly8gaHRtbFxuXHRcdFwiaHRtbC1wcmVcIjogZnVuY3Rpb24gKCBhICkge1xuXHRcdFx0cmV0dXJuIF9lbXB0eShhKSA/XG5cdFx0XHRcdCcnIDpcblx0XHRcdFx0YS5yZXBsYWNlID9cblx0XHRcdFx0XHRhLnJlcGxhY2UoIC88Lio/Pi9nLCBcIlwiICkudG9Mb3dlckNhc2UoKSA6XG5cdFx0XHRcdFx0YSsnJztcblx0XHR9LFxuXHRcblx0XHQvLyBzdHJpbmdcblx0XHRcInN0cmluZy1wcmVcIjogZnVuY3Rpb24gKCBhICkge1xuXHRcdFx0Ly8gVGhpcyBpcyBhIGxpdHRsZSBjb21wbGV4LCBidXQgZmFzdGVyIHRoYW4gYWx3YXlzIGNhbGxpbmcgdG9TdHJpbmcsXG5cdFx0XHQvLyBodHRwOi8vanNwZXJmLmNvbS90b3N0cmluZy12LWNoZWNrXG5cdFx0XHRyZXR1cm4gX2VtcHR5KGEpID9cblx0XHRcdFx0JycgOlxuXHRcdFx0XHR0eXBlb2YgYSA9PT0gJ3N0cmluZycgP1xuXHRcdFx0XHRcdGEudG9Mb3dlckNhc2UoKSA6XG5cdFx0XHRcdFx0ISBhLnRvU3RyaW5nID9cblx0XHRcdFx0XHRcdCcnIDpcblx0XHRcdFx0XHRcdGEudG9TdHJpbmcoKTtcblx0XHR9LFxuXHRcblx0XHQvLyBzdHJpbmctYXNjIGFuZCAtZGVzYyBhcmUgcmV0YWluZWQgb25seSBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIHRoZSBvbGRcblx0XHQvLyBzb3J0IG1ldGhvZHNcblx0XHRcInN0cmluZy1hc2NcIjogZnVuY3Rpb24gKCB4LCB5ICkge1xuXHRcdFx0cmV0dXJuICgoeCA8IHkpID8gLTEgOiAoKHggPiB5KSA/IDEgOiAwKSk7XG5cdFx0fSxcblx0XG5cdFx0XCJzdHJpbmctZGVzY1wiOiBmdW5jdGlvbiAoIHgsIHkgKSB7XG5cdFx0XHRyZXR1cm4gKCh4IDwgeSkgPyAxIDogKCh4ID4geSkgPyAtMSA6IDApKTtcblx0XHR9XG5cdH0gKTtcblx0XG5cdFxuXHQvLyBOdW1lcmljIHNvcnRpbmcgdHlwZXMgLSBvcmRlciBkb2Vzbid0IG1hdHRlciBoZXJlXG5cdF9hZGROdW1lcmljU29ydCggJycgKTtcblx0XG5cdFxuXHQkLmV4dGVuZCggdHJ1ZSwgRGF0YVRhYmxlLmV4dC5yZW5kZXJlciwge1xuXHRcdGhlYWRlcjoge1xuXHRcdFx0XzogZnVuY3Rpb24gKCBzZXR0aW5ncywgY2VsbCwgY29sdW1uLCBjbGFzc2VzICkge1xuXHRcdFx0XHQvLyBObyBhZGRpdGlvbmFsIG1hcmstdXAgcmVxdWlyZWRcblx0XHRcdFx0Ly8gQXR0YWNoIGEgc29ydCBsaXN0ZW5lciB0byB1cGRhdGUgb24gc29ydCAtIG5vdGUgdGhhdCB1c2luZyB0aGVcblx0XHRcdFx0Ly8gYERUYCBuYW1lc3BhY2Ugd2lsbCBhbGxvdyB0aGUgZXZlbnQgdG8gYmUgcmVtb3ZlZCBhdXRvbWF0aWNhbGx5XG5cdFx0XHRcdC8vIG9uIGRlc3Ryb3ksIHdoaWxlIHRoZSBgZHRgIG5hbWVzcGFjZWQgZXZlbnQgaXMgdGhlIG9uZSB3ZSBhcmVcblx0XHRcdFx0Ly8gbGlzdGVuaW5nIGZvclxuXHRcdFx0XHQkKHNldHRpbmdzLm5UYWJsZSkub24oICdvcmRlci5kdC5EVCcsIGZ1bmN0aW9uICggZSwgY3R4LCBzb3J0aW5nLCBjb2x1bW5zICkge1xuXHRcdFx0XHRcdGlmICggc2V0dGluZ3MgIT09IGN0eCApIHsgLy8gbmVlZCB0byBjaGVjayB0aGlzIHRoaXMgaXMgdGhlIGhvc3Rcblx0XHRcdFx0XHRcdHJldHVybjsgICAgICAgICAgICAgICAvLyB0YWJsZSwgbm90IGEgbmVzdGVkIG9uZVxuXHRcdFx0XHRcdH1cblx0XG5cdFx0XHRcdFx0dmFyIGNvbElkeCA9IGNvbHVtbi5pZHg7XG5cdFxuXHRcdFx0XHRcdGNlbGxcblx0XHRcdFx0XHRcdC5yZW1vdmVDbGFzcyhcblx0XHRcdFx0XHRcdFx0Y29sdW1uLnNTb3J0aW5nQ2xhc3MgKycgJytcblx0XHRcdFx0XHRcdFx0Y2xhc3Nlcy5zU29ydEFzYyArJyAnK1xuXHRcdFx0XHRcdFx0XHRjbGFzc2VzLnNTb3J0RGVzY1xuXHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0LmFkZENsYXNzKCBjb2x1bW5zWyBjb2xJZHggXSA9PSAnYXNjJyA/XG5cdFx0XHRcdFx0XHRcdGNsYXNzZXMuc1NvcnRBc2MgOiBjb2x1bW5zWyBjb2xJZHggXSA9PSAnZGVzYycgP1xuXHRcdFx0XHRcdFx0XHRcdGNsYXNzZXMuc1NvcnREZXNjIDpcblx0XHRcdFx0XHRcdFx0XHRjb2x1bW4uc1NvcnRpbmdDbGFzc1xuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fSxcblx0XG5cdFx0XHRqcXVlcnl1aTogZnVuY3Rpb24gKCBzZXR0aW5ncywgY2VsbCwgY29sdW1uLCBjbGFzc2VzICkge1xuXHRcdFx0XHQkKCc8ZGl2Lz4nKVxuXHRcdFx0XHRcdC5hZGRDbGFzcyggY2xhc3Nlcy5zU29ydEpVSVdyYXBwZXIgKVxuXHRcdFx0XHRcdC5hcHBlbmQoIGNlbGwuY29udGVudHMoKSApXG5cdFx0XHRcdFx0LmFwcGVuZCggJCgnPHNwYW4vPicpXG5cdFx0XHRcdFx0XHQuYWRkQ2xhc3MoIGNsYXNzZXMuc1NvcnRJY29uKycgJytjb2x1bW4uc1NvcnRpbmdDbGFzc0pVSSApXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHRcdC5hcHBlbmRUbyggY2VsbCApO1xuXHRcblx0XHRcdFx0Ly8gQXR0YWNoIGEgc29ydCBsaXN0ZW5lciB0byB1cGRhdGUgb24gc29ydFxuXHRcdFx0XHQkKHNldHRpbmdzLm5UYWJsZSkub24oICdvcmRlci5kdC5EVCcsIGZ1bmN0aW9uICggZSwgY3R4LCBzb3J0aW5nLCBjb2x1bW5zICkge1xuXHRcdFx0XHRcdGlmICggc2V0dGluZ3MgIT09IGN0eCApIHtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRcdHZhciBjb2xJZHggPSBjb2x1bW4uaWR4O1xuXHRcblx0XHRcdFx0XHRjZWxsXG5cdFx0XHRcdFx0XHQucmVtb3ZlQ2xhc3MoIGNsYXNzZXMuc1NvcnRBc2MgK1wiIFwiK2NsYXNzZXMuc1NvcnREZXNjIClcblx0XHRcdFx0XHRcdC5hZGRDbGFzcyggY29sdW1uc1sgY29sSWR4IF0gPT0gJ2FzYycgP1xuXHRcdFx0XHRcdFx0XHRjbGFzc2VzLnNTb3J0QXNjIDogY29sdW1uc1sgY29sSWR4IF0gPT0gJ2Rlc2MnID9cblx0XHRcdFx0XHRcdFx0XHRjbGFzc2VzLnNTb3J0RGVzYyA6XG5cdFx0XHRcdFx0XHRcdFx0Y29sdW1uLnNTb3J0aW5nQ2xhc3Ncblx0XHRcdFx0XHRcdCk7XG5cdFxuXHRcdFx0XHRcdGNlbGxcblx0XHRcdFx0XHRcdC5maW5kKCAnc3Bhbi4nK2NsYXNzZXMuc1NvcnRJY29uIClcblx0XHRcdFx0XHRcdC5yZW1vdmVDbGFzcyhcblx0XHRcdFx0XHRcdFx0Y2xhc3Nlcy5zU29ydEpVSUFzYyArXCIgXCIrXG5cdFx0XHRcdFx0XHRcdGNsYXNzZXMuc1NvcnRKVUlEZXNjICtcIiBcIitcblx0XHRcdFx0XHRcdFx0Y2xhc3Nlcy5zU29ydEpVSSArXCIgXCIrXG5cdFx0XHRcdFx0XHRcdGNsYXNzZXMuc1NvcnRKVUlBc2NBbGxvd2VkICtcIiBcIitcblx0XHRcdFx0XHRcdFx0Y2xhc3Nlcy5zU29ydEpVSURlc2NBbGxvd2VkXG5cdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQuYWRkQ2xhc3MoIGNvbHVtbnNbIGNvbElkeCBdID09ICdhc2MnID9cblx0XHRcdFx0XHRcdFx0Y2xhc3Nlcy5zU29ydEpVSUFzYyA6IGNvbHVtbnNbIGNvbElkeCBdID09ICdkZXNjJyA/XG5cdFx0XHRcdFx0XHRcdFx0Y2xhc3Nlcy5zU29ydEpVSURlc2MgOlxuXHRcdFx0XHRcdFx0XHRcdGNvbHVtbi5zU29ydGluZ0NsYXNzSlVJXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9ICk7XG5cdFxuXHQvKlxuXHQgKiBQdWJsaWMgaGVscGVyIGZ1bmN0aW9ucy4gVGhlc2UgYXJlbid0IHVzZWQgaW50ZXJuYWxseSBieSBEYXRhVGFibGVzLCBvclxuXHQgKiBjYWxsZWQgYnkgYW55IG9mIHRoZSBvcHRpb25zIHBhc3NlZCBpbnRvIERhdGFUYWJsZXMsIGJ1dCB0aGV5IGNhbiBiZSB1c2VkXG5cdCAqIGV4dGVybmFsbHkgYnkgZGV2ZWxvcGVycyB3b3JraW5nIHdpdGggRGF0YVRhYmxlcy4gVGhleSBhcmUgaGVscGVyIGZ1bmN0aW9uc1xuXHQgKiB0byBtYWtlIHdvcmtpbmcgd2l0aCBEYXRhVGFibGVzIGEgbGl0dGxlIGJpdCBlYXNpZXIuXG5cdCAqL1xuXHRcblx0dmFyIF9faHRtbEVzY2FwZUVudGl0aWVzID0gZnVuY3Rpb24gKCBkICkge1xuXHRcdHJldHVybiB0eXBlb2YgZCA9PT0gJ3N0cmluZycgP1xuXHRcdFx0ZFxuXHRcdFx0XHQucmVwbGFjZSgvJi9nLCAnJmFtcDsnKVxuXHRcdFx0XHQucmVwbGFjZSgvPC9nLCAnJmx0OycpXG5cdFx0XHRcdC5yZXBsYWNlKC8+L2csICcmZ3Q7Jylcblx0XHRcdFx0LnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKSA6XG5cdFx0XHRkO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIEhlbHBlcnMgZm9yIGBjb2x1bW5zLnJlbmRlcmAuXG5cdCAqXG5cdCAqIFRoZSBvcHRpb25zIGRlZmluZWQgaGVyZSBjYW4gYmUgdXNlZCB3aXRoIHRoZSBgY29sdW1ucy5yZW5kZXJgIGluaXRpYWxpc2F0aW9uXG5cdCAqIG9wdGlvbiB0byBwcm92aWRlIGEgZGlzcGxheSByZW5kZXJlci4gVGhlIGZvbGxvd2luZyBmdW5jdGlvbnMgYXJlIGRlZmluZWQ6XG5cdCAqXG5cdCAqICogYG51bWJlcmAgLSBXaWxsIGZvcm1hdCBudW1lcmljIGRhdGEgKGRlZmluZWQgYnkgYGNvbHVtbnMuZGF0YWApIGZvclxuXHQgKiAgIGRpc3BsYXksIHJldGFpbmluZyB0aGUgb3JpZ2luYWwgdW5mb3JtYXR0ZWQgZGF0YSBmb3Igc29ydGluZyBhbmQgZmlsdGVyaW5nLlxuXHQgKiAgIEl0IHRha2VzIDUgcGFyYW1ldGVyczpcblx0ICogICAqIGBzdHJpbmdgIC0gVGhvdXNhbmRzIGdyb3VwaW5nIHNlcGFyYXRvclxuXHQgKiAgICogYHN0cmluZ2AgLSBEZWNpbWFsIHBvaW50IGluZGljYXRvclxuXHQgKiAgICogYGludGVnZXJgIC0gTnVtYmVyIG9mIGRlY2ltYWwgcG9pbnRzIHRvIHNob3dcblx0ICogICAqIGBzdHJpbmdgIChvcHRpb25hbCkgLSBQcmVmaXguXG5cdCAqICAgKiBgc3RyaW5nYCAob3B0aW9uYWwpIC0gUG9zdGZpeCAoL3N1ZmZpeCkuXG5cdCAqICogYHRleHRgIC0gRXNjYXBlIEhUTUwgdG8gaGVscCBwcmV2ZW50IFhTUyBhdHRhY2tzLiBJdCBoYXMgbm8gb3B0aW9uYWxcblx0ICogICBwYXJhbWV0ZXJzLlxuXHQgKlxuXHQgKiBAZXhhbXBsZVxuXHQgKiAgIC8vIENvbHVtbiBkZWZpbml0aW9uIHVzaW5nIHRoZSBudW1iZXIgcmVuZGVyZXJcblx0ICogICB7XG5cdCAqICAgICBkYXRhOiBcInNhbGFyeVwiLFxuXHQgKiAgICAgcmVuZGVyOiAkLmZuLmRhdGFUYWJsZS5yZW5kZXIubnVtYmVyKCAnXFwnJywgJy4nLCAwLCAnJCcgKVxuXHQgKiAgIH1cblx0ICpcblx0ICogQG5hbWVzcGFjZVxuXHQgKi9cblx0RGF0YVRhYmxlLnJlbmRlciA9IHtcblx0XHRudW1iZXI6IGZ1bmN0aW9uICggdGhvdXNhbmRzLCBkZWNpbWFsLCBwcmVjaXNpb24sIHByZWZpeCwgcG9zdGZpeCApIHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGRpc3BsYXk6IGZ1bmN0aW9uICggZCApIHtcblx0XHRcdFx0XHRpZiAoIHR5cGVvZiBkICE9PSAnbnVtYmVyJyAmJiB0eXBlb2YgZCAhPT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZDtcblx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRcdHZhciBuZWdhdGl2ZSA9IGQgPCAwID8gJy0nIDogJyc7XG5cdFx0XHRcdFx0dmFyIGZsbyA9IHBhcnNlRmxvYXQoIGQgKTtcblx0XG5cdFx0XHRcdFx0Ly8gSWYgTmFOIHRoZW4gdGhlcmUgaXNuJ3QgbXVjaCBmb3JtYXR0aW5nIHRoYXQgd2UgY2FuIGRvIC0ganVzdFxuXHRcdFx0XHRcdC8vIHJldHVybiBpbW1lZGlhdGVseSwgZXNjYXBpbmcgYW55IEhUTUwgKHRoaXMgd2FzIHN1cHBvc2VkIHRvXG5cdFx0XHRcdFx0Ly8gYmUgYSBudW1iZXIgYWZ0ZXIgYWxsKVxuXHRcdFx0XHRcdGlmICggaXNOYU4oIGZsbyApICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIF9faHRtbEVzY2FwZUVudGl0aWVzKCBkICk7XG5cdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHRmbG8gPSBmbG8udG9GaXhlZCggcHJlY2lzaW9uICk7XG5cdFx0XHRcdFx0ZCA9IE1hdGguYWJzKCBmbG8gKTtcblx0XG5cdFx0XHRcdFx0dmFyIGludFBhcnQgPSBwYXJzZUludCggZCwgMTAgKTtcblx0XHRcdFx0XHR2YXIgZmxvYXRQYXJ0ID0gcHJlY2lzaW9uID9cblx0XHRcdFx0XHRcdGRlY2ltYWwrKGQgLSBpbnRQYXJ0KS50b0ZpeGVkKCBwcmVjaXNpb24gKS5zdWJzdHJpbmcoIDIgKTpcblx0XHRcdFx0XHRcdCcnO1xuXHRcblx0XHRcdFx0XHRyZXR1cm4gbmVnYXRpdmUgKyAocHJlZml4fHwnJykgK1xuXHRcdFx0XHRcdFx0aW50UGFydC50b1N0cmluZygpLnJlcGxhY2UoXG5cdFx0XHRcdFx0XHRcdC9cXEIoPz0oXFxkezN9KSsoPyFcXGQpKS9nLCB0aG91c2FuZHNcblx0XHRcdFx0XHRcdCkgK1xuXHRcdFx0XHRcdFx0ZmxvYXRQYXJ0ICtcblx0XHRcdFx0XHRcdChwb3N0Zml4fHwnJyk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fSxcblx0XG5cdFx0dGV4dDogZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGlzcGxheTogX19odG1sRXNjYXBlRW50aXRpZXMsXG5cdFx0XHRcdGZpbHRlcjogX19odG1sRXNjYXBlRW50aXRpZXNcblx0XHRcdH07XG5cdFx0fVxuXHR9O1xuXHRcblx0XG5cdC8qXG5cdCAqIFRoaXMgaXMgcmVhbGx5IGEgZ29vZCBiaXQgcnViYmlzaCB0aGlzIG1ldGhvZCBvZiBleHBvc2luZyB0aGUgaW50ZXJuYWwgbWV0aG9kc1xuXHQgKiBwdWJsaWNseS4uLiAtIFRvIGJlIGZpeGVkIGluIDIuMCB1c2luZyBtZXRob2RzIG9uIHRoZSBwcm90b3R5cGVcblx0ICovXG5cdFxuXHRcblx0LyoqXG5cdCAqIENyZWF0ZSBhIHdyYXBwZXIgZnVuY3Rpb24gZm9yIGV4cG9ydGluZyBhbiBpbnRlcm5hbCBmdW5jdGlvbnMgdG8gYW4gZXh0ZXJuYWwgQVBJLlxuXHQgKiAgQHBhcmFtIHtzdHJpbmd9IGZuIEFQSSBmdW5jdGlvbiBuYW1lXG5cdCAqICBAcmV0dXJucyB7ZnVuY3Rpb259IHdyYXBwZWQgZnVuY3Rpb25cblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjaW50ZXJuYWxcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkV4dGVybkFwaUZ1bmMgKGZuKVxuXHR7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGFyZ3MgPSBbX2ZuU2V0dGluZ3NGcm9tTm9kZSggdGhpc1tEYXRhVGFibGUuZXh0LmlBcGlJbmRleF0gKV0uY29uY2F0KFxuXHRcdFx0XHRBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpXG5cdFx0XHQpO1xuXHRcdFx0cmV0dXJuIERhdGFUYWJsZS5leHQuaW50ZXJuYWxbZm5dLmFwcGx5KCB0aGlzLCBhcmdzICk7XG5cdFx0fTtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBSZWZlcmVuY2UgdG8gaW50ZXJuYWwgZnVuY3Rpb25zIGZvciB1c2UgYnkgcGx1Zy1pbiBkZXZlbG9wZXJzLiBOb3RlIHRoYXRcblx0ICogdGhlc2UgbWV0aG9kcyBhcmUgcmVmZXJlbmNlcyB0byBpbnRlcm5hbCBmdW5jdGlvbnMgYW5kIGFyZSBjb25zaWRlcmVkIHRvIGJlXG5cdCAqIHByaXZhdGUuIElmIHlvdSB1c2UgdGhlc2UgbWV0aG9kcywgYmUgYXdhcmUgdGhhdCB0aGV5IGFyZSBsaWFibGUgdG8gY2hhbmdlXG5cdCAqIGJldHdlZW4gdmVyc2lvbnMuXG5cdCAqICBAbmFtZXNwYWNlXG5cdCAqL1xuXHQkLmV4dGVuZCggRGF0YVRhYmxlLmV4dC5pbnRlcm5hbCwge1xuXHRcdF9mbkV4dGVybkFwaUZ1bmM6IF9mbkV4dGVybkFwaUZ1bmMsXG5cdFx0X2ZuQnVpbGRBamF4OiBfZm5CdWlsZEFqYXgsXG5cdFx0X2ZuQWpheFVwZGF0ZTogX2ZuQWpheFVwZGF0ZSxcblx0XHRfZm5BamF4UGFyYW1ldGVyczogX2ZuQWpheFBhcmFtZXRlcnMsXG5cdFx0X2ZuQWpheFVwZGF0ZURyYXc6IF9mbkFqYXhVcGRhdGVEcmF3LFxuXHRcdF9mbkFqYXhEYXRhU3JjOiBfZm5BamF4RGF0YVNyYyxcblx0XHRfZm5BZGRDb2x1bW46IF9mbkFkZENvbHVtbixcblx0XHRfZm5Db2x1bW5PcHRpb25zOiBfZm5Db2x1bW5PcHRpb25zLFxuXHRcdF9mbkFkanVzdENvbHVtblNpemluZzogX2ZuQWRqdXN0Q29sdW1uU2l6aW5nLFxuXHRcdF9mblZpc2libGVUb0NvbHVtbkluZGV4OiBfZm5WaXNpYmxlVG9Db2x1bW5JbmRleCxcblx0XHRfZm5Db2x1bW5JbmRleFRvVmlzaWJsZTogX2ZuQ29sdW1uSW5kZXhUb1Zpc2libGUsXG5cdFx0X2ZuVmlzYmxlQ29sdW1uczogX2ZuVmlzYmxlQ29sdW1ucyxcblx0XHRfZm5HZXRDb2x1bW5zOiBfZm5HZXRDb2x1bW5zLFxuXHRcdF9mbkNvbHVtblR5cGVzOiBfZm5Db2x1bW5UeXBlcyxcblx0XHRfZm5BcHBseUNvbHVtbkRlZnM6IF9mbkFwcGx5Q29sdW1uRGVmcyxcblx0XHRfZm5IdW5nYXJpYW5NYXA6IF9mbkh1bmdhcmlhbk1hcCxcblx0XHRfZm5DYW1lbFRvSHVuZ2FyaWFuOiBfZm5DYW1lbFRvSHVuZ2FyaWFuLFxuXHRcdF9mbkxhbmd1YWdlQ29tcGF0OiBfZm5MYW5ndWFnZUNvbXBhdCxcblx0XHRfZm5Ccm93c2VyRGV0ZWN0OiBfZm5Ccm93c2VyRGV0ZWN0LFxuXHRcdF9mbkFkZERhdGE6IF9mbkFkZERhdGEsXG5cdFx0X2ZuQWRkVHI6IF9mbkFkZFRyLFxuXHRcdF9mbk5vZGVUb0RhdGFJbmRleDogX2ZuTm9kZVRvRGF0YUluZGV4LFxuXHRcdF9mbk5vZGVUb0NvbHVtbkluZGV4OiBfZm5Ob2RlVG9Db2x1bW5JbmRleCxcblx0XHRfZm5HZXRDZWxsRGF0YTogX2ZuR2V0Q2VsbERhdGEsXG5cdFx0X2ZuU2V0Q2VsbERhdGE6IF9mblNldENlbGxEYXRhLFxuXHRcdF9mblNwbGl0T2JqTm90YXRpb246IF9mblNwbGl0T2JqTm90YXRpb24sXG5cdFx0X2ZuR2V0T2JqZWN0RGF0YUZuOiBfZm5HZXRPYmplY3REYXRhRm4sXG5cdFx0X2ZuU2V0T2JqZWN0RGF0YUZuOiBfZm5TZXRPYmplY3REYXRhRm4sXG5cdFx0X2ZuR2V0RGF0YU1hc3RlcjogX2ZuR2V0RGF0YU1hc3Rlcixcblx0XHRfZm5DbGVhclRhYmxlOiBfZm5DbGVhclRhYmxlLFxuXHRcdF9mbkRlbGV0ZUluZGV4OiBfZm5EZWxldGVJbmRleCxcblx0XHRfZm5JbnZhbGlkYXRlOiBfZm5JbnZhbGlkYXRlLFxuXHRcdF9mbkdldFJvd0VsZW1lbnRzOiBfZm5HZXRSb3dFbGVtZW50cyxcblx0XHRfZm5DcmVhdGVUcjogX2ZuQ3JlYXRlVHIsXG5cdFx0X2ZuQnVpbGRIZWFkOiBfZm5CdWlsZEhlYWQsXG5cdFx0X2ZuRHJhd0hlYWQ6IF9mbkRyYXdIZWFkLFxuXHRcdF9mbkRyYXc6IF9mbkRyYXcsXG5cdFx0X2ZuUmVEcmF3OiBfZm5SZURyYXcsXG5cdFx0X2ZuQWRkT3B0aW9uc0h0bWw6IF9mbkFkZE9wdGlvbnNIdG1sLFxuXHRcdF9mbkRldGVjdEhlYWRlcjogX2ZuRGV0ZWN0SGVhZGVyLFxuXHRcdF9mbkdldFVuaXF1ZVRoczogX2ZuR2V0VW5pcXVlVGhzLFxuXHRcdF9mbkZlYXR1cmVIdG1sRmlsdGVyOiBfZm5GZWF0dXJlSHRtbEZpbHRlcixcblx0XHRfZm5GaWx0ZXJDb21wbGV0ZTogX2ZuRmlsdGVyQ29tcGxldGUsXG5cdFx0X2ZuRmlsdGVyQ3VzdG9tOiBfZm5GaWx0ZXJDdXN0b20sXG5cdFx0X2ZuRmlsdGVyQ29sdW1uOiBfZm5GaWx0ZXJDb2x1bW4sXG5cdFx0X2ZuRmlsdGVyOiBfZm5GaWx0ZXIsXG5cdFx0X2ZuRmlsdGVyQ3JlYXRlU2VhcmNoOiBfZm5GaWx0ZXJDcmVhdGVTZWFyY2gsXG5cdFx0X2ZuRXNjYXBlUmVnZXg6IF9mbkVzY2FwZVJlZ2V4LFxuXHRcdF9mbkZpbHRlckRhdGE6IF9mbkZpbHRlckRhdGEsXG5cdFx0X2ZuRmVhdHVyZUh0bWxJbmZvOiBfZm5GZWF0dXJlSHRtbEluZm8sXG5cdFx0X2ZuVXBkYXRlSW5mbzogX2ZuVXBkYXRlSW5mbyxcblx0XHRfZm5JbmZvTWFjcm9zOiBfZm5JbmZvTWFjcm9zLFxuXHRcdF9mbkluaXRpYWxpc2U6IF9mbkluaXRpYWxpc2UsXG5cdFx0X2ZuSW5pdENvbXBsZXRlOiBfZm5Jbml0Q29tcGxldGUsXG5cdFx0X2ZuTGVuZ3RoQ2hhbmdlOiBfZm5MZW5ndGhDaGFuZ2UsXG5cdFx0X2ZuRmVhdHVyZUh0bWxMZW5ndGg6IF9mbkZlYXR1cmVIdG1sTGVuZ3RoLFxuXHRcdF9mbkZlYXR1cmVIdG1sUGFnaW5hdGU6IF9mbkZlYXR1cmVIdG1sUGFnaW5hdGUsXG5cdFx0X2ZuUGFnZUNoYW5nZTogX2ZuUGFnZUNoYW5nZSxcblx0XHRfZm5GZWF0dXJlSHRtbFByb2Nlc3Npbmc6IF9mbkZlYXR1cmVIdG1sUHJvY2Vzc2luZyxcblx0XHRfZm5Qcm9jZXNzaW5nRGlzcGxheTogX2ZuUHJvY2Vzc2luZ0Rpc3BsYXksXG5cdFx0X2ZuRmVhdHVyZUh0bWxUYWJsZTogX2ZuRmVhdHVyZUh0bWxUYWJsZSxcblx0XHRfZm5TY3JvbGxEcmF3OiBfZm5TY3JvbGxEcmF3LFxuXHRcdF9mbkFwcGx5VG9DaGlsZHJlbjogX2ZuQXBwbHlUb0NoaWxkcmVuLFxuXHRcdF9mbkNhbGN1bGF0ZUNvbHVtbldpZHRoczogX2ZuQ2FsY3VsYXRlQ29sdW1uV2lkdGhzLFxuXHRcdF9mblRocm90dGxlOiBfZm5UaHJvdHRsZSxcblx0XHRfZm5Db252ZXJ0VG9XaWR0aDogX2ZuQ29udmVydFRvV2lkdGgsXG5cdFx0X2ZuR2V0V2lkZXN0Tm9kZTogX2ZuR2V0V2lkZXN0Tm9kZSxcblx0XHRfZm5HZXRNYXhMZW5TdHJpbmc6IF9mbkdldE1heExlblN0cmluZyxcblx0XHRfZm5TdHJpbmdUb0NzczogX2ZuU3RyaW5nVG9Dc3MsXG5cdFx0X2ZuU29ydEZsYXR0ZW46IF9mblNvcnRGbGF0dGVuLFxuXHRcdF9mblNvcnQ6IF9mblNvcnQsXG5cdFx0X2ZuU29ydEFyaWE6IF9mblNvcnRBcmlhLFxuXHRcdF9mblNvcnRMaXN0ZW5lcjogX2ZuU29ydExpc3RlbmVyLFxuXHRcdF9mblNvcnRBdHRhY2hMaXN0ZW5lcjogX2ZuU29ydEF0dGFjaExpc3RlbmVyLFxuXHRcdF9mblNvcnRpbmdDbGFzc2VzOiBfZm5Tb3J0aW5nQ2xhc3Nlcyxcblx0XHRfZm5Tb3J0RGF0YTogX2ZuU29ydERhdGEsXG5cdFx0X2ZuU2F2ZVN0YXRlOiBfZm5TYXZlU3RhdGUsXG5cdFx0X2ZuTG9hZFN0YXRlOiBfZm5Mb2FkU3RhdGUsXG5cdFx0X2ZuU2V0dGluZ3NGcm9tTm9kZTogX2ZuU2V0dGluZ3NGcm9tTm9kZSxcblx0XHRfZm5Mb2c6IF9mbkxvZyxcblx0XHRfZm5NYXA6IF9mbk1hcCxcblx0XHRfZm5CaW5kQWN0aW9uOiBfZm5CaW5kQWN0aW9uLFxuXHRcdF9mbkNhbGxiYWNrUmVnOiBfZm5DYWxsYmFja1JlZyxcblx0XHRfZm5DYWxsYmFja0ZpcmU6IF9mbkNhbGxiYWNrRmlyZSxcblx0XHRfZm5MZW5ndGhPdmVyZmxvdzogX2ZuTGVuZ3RoT3ZlcmZsb3csXG5cdFx0X2ZuUmVuZGVyZXI6IF9mblJlbmRlcmVyLFxuXHRcdF9mbkRhdGFTb3VyY2U6IF9mbkRhdGFTb3VyY2UsXG5cdFx0X2ZuUm93QXR0cmlidXRlczogX2ZuUm93QXR0cmlidXRlcyxcblx0XHRfZm5FeHRlbmQ6IF9mbkV4dGVuZCxcblx0XHRfZm5DYWxjdWxhdGVFbmQ6IGZ1bmN0aW9uICgpIHt9IC8vIFVzZWQgYnkgYSBsb3Qgb2YgcGx1Zy1pbnMsIGJ1dCByZWR1bmRhbnRcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluIDEuMTAsIHNvIHRoaXMgZGVhZC1lbmQgZnVuY3Rpb24gaXNcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZGVkIHRvIHByZXZlbnQgZXJyb3JzXG5cdH0gKTtcblx0XG5cblx0Ly8galF1ZXJ5IGFjY2Vzc1xuXHQkLmZuLmRhdGFUYWJsZSA9IERhdGFUYWJsZTtcblxuXHQvLyBQcm92aWRlIGFjY2VzcyB0byB0aGUgaG9zdCBqUXVlcnkgb2JqZWN0IChjaXJjdWxhciByZWZlcmVuY2UpXG5cdERhdGFUYWJsZS4kID0gJDtcblxuXHQvLyBMZWdhY3kgYWxpYXNlc1xuXHQkLmZuLmRhdGFUYWJsZVNldHRpbmdzID0gRGF0YVRhYmxlLnNldHRpbmdzO1xuXHQkLmZuLmRhdGFUYWJsZUV4dCA9IERhdGFUYWJsZS5leHQ7XG5cblx0Ly8gV2l0aCBhIGNhcGl0YWwgYERgIHdlIHJldHVybiBhIERhdGFUYWJsZXMgQVBJIGluc3RhbmNlIHJhdGhlciB0aGFuIGFcblx0Ly8galF1ZXJ5IG9iamVjdFxuXHQkLmZuLkRhdGFUYWJsZSA9IGZ1bmN0aW9uICggb3B0cyApIHtcblx0XHRyZXR1cm4gJCh0aGlzKS5kYXRhVGFibGUoIG9wdHMgKS5hcGkoKTtcblx0fTtcblxuXHQvLyBBbGwgcHJvcGVydGllcyB0aGF0IGFyZSBhdmFpbGFibGUgdG8gJC5mbi5kYXRhVGFibGUgc2hvdWxkIGFsc28gYmVcblx0Ly8gYXZhaWxhYmxlIG9uICQuZm4uRGF0YVRhYmxlXG5cdCQuZWFjaCggRGF0YVRhYmxlLCBmdW5jdGlvbiAoIHByb3AsIHZhbCApIHtcblx0XHQkLmZuLkRhdGFUYWJsZVsgcHJvcCBdID0gdmFsO1xuXHR9ICk7XG5cblxuXHQvLyBJbmZvcm1hdGlvbiBhYm91dCBldmVudHMgZmlyZWQgYnkgRGF0YVRhYmxlcyAtIGZvciBkb2N1bWVudGF0aW9uLlxuXHQvKipcblx0ICogRHJhdyBldmVudCwgZmlyZWQgd2hlbmV2ZXIgdGhlIHRhYmxlIGlzIHJlZHJhd24gb24gdGhlIHBhZ2UsIGF0IHRoZSBzYW1lXG5cdCAqIHBvaW50IGFzIGZuRHJhd0NhbGxiYWNrLiBUaGlzIG1heSBiZSB1c2VmdWwgZm9yIGJpbmRpbmcgZXZlbnRzIG9yXG5cdCAqIHBlcmZvcm1pbmcgY2FsY3VsYXRpb25zIHdoZW4gdGhlIHRhYmxlIGlzIGFsdGVyZWQgYXQgYWxsLlxuXHQgKiAgQG5hbWUgRGF0YVRhYmxlI2RyYXcuZHRcblx0ICogIEBldmVudFxuXHQgKiAgQHBhcmFtIHtldmVudH0gZSBqUXVlcnkgZXZlbnQgb2JqZWN0XG5cdCAqICBAcGFyYW0ge29iamVjdH0gbyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdCB7QGxpbmsgRGF0YVRhYmxlLm1vZGVscy5vU2V0dGluZ3N9XG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBTZWFyY2ggZXZlbnQsIGZpcmVkIHdoZW4gdGhlIHNlYXJjaGluZyBhcHBsaWVkIHRvIHRoZSB0YWJsZSAodXNpbmcgdGhlXG5cdCAqIGJ1aWx0LWluIGdsb2JhbCBzZWFyY2gsIG9yIGNvbHVtbiBmaWx0ZXJzKSBpcyBhbHRlcmVkLlxuXHQgKiAgQG5hbWUgRGF0YVRhYmxlI3NlYXJjaC5kdFxuXHQgKiAgQGV2ZW50XG5cdCAqICBAcGFyYW0ge2V2ZW50fSBlIGpRdWVyeSBldmVudCBvYmplY3Rcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0IHtAbGluayBEYXRhVGFibGUubW9kZWxzLm9TZXR0aW5nc31cblx0ICovXG5cblx0LyoqXG5cdCAqIFBhZ2UgY2hhbmdlIGV2ZW50LCBmaXJlZCB3aGVuIHRoZSBwYWdpbmcgb2YgdGhlIHRhYmxlIGlzIGFsdGVyZWQuXG5cdCAqICBAbmFtZSBEYXRhVGFibGUjcGFnZS5kdFxuXHQgKiAgQGV2ZW50XG5cdCAqICBAcGFyYW0ge2V2ZW50fSBlIGpRdWVyeSBldmVudCBvYmplY3Rcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0IHtAbGluayBEYXRhVGFibGUubW9kZWxzLm9TZXR0aW5nc31cblx0ICovXG5cblx0LyoqXG5cdCAqIE9yZGVyIGV2ZW50LCBmaXJlZCB3aGVuIHRoZSBvcmRlcmluZyBhcHBsaWVkIHRvIHRoZSB0YWJsZSBpcyBhbHRlcmVkLlxuXHQgKiAgQG5hbWUgRGF0YVRhYmxlI29yZGVyLmR0XG5cdCAqICBAZXZlbnRcblx0ICogIEBwYXJhbSB7ZXZlbnR9IGUgalF1ZXJ5IGV2ZW50IG9iamVjdFxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG8gRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Qge0BsaW5rIERhdGFUYWJsZS5tb2RlbHMub1NldHRpbmdzfVxuXHQgKi9cblxuXHQvKipcblx0ICogRGF0YVRhYmxlcyBpbml0aWFsaXNhdGlvbiBjb21wbGV0ZSBldmVudCwgZmlyZWQgd2hlbiB0aGUgdGFibGUgaXMgZnVsbHlcblx0ICogZHJhd24sIGluY2x1ZGluZyBBamF4IGRhdGEgbG9hZGVkLCBpZiBBamF4IGRhdGEgaXMgcmVxdWlyZWQuXG5cdCAqICBAbmFtZSBEYXRhVGFibGUjaW5pdC5kdFxuXHQgKiAgQGV2ZW50XG5cdCAqICBAcGFyYW0ge2V2ZW50fSBlIGpRdWVyeSBldmVudCBvYmplY3Rcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBqc29uIFRoZSBKU09OIG9iamVjdCByZXF1ZXN0IGZyb20gdGhlIHNlcnZlciAtIG9ubHlcblx0ICogICAgcHJlc2VudCBpZiBjbGllbnQtc2lkZSBBamF4IHNvdXJjZWQgZGF0YSBpcyB1c2VkPC9saT48L29sPlxuXHQgKi9cblxuXHQvKipcblx0ICogU3RhdGUgc2F2ZSBldmVudCwgZmlyZWQgd2hlbiB0aGUgdGFibGUgaGFzIGNoYW5nZWQgc3RhdGUgYSBuZXcgc3RhdGUgc2F2ZVxuXHQgKiBpcyByZXF1aXJlZC4gVGhpcyBldmVudCBhbGxvd3MgbW9kaWZpY2F0aW9uIG9mIHRoZSBzdGF0ZSBzYXZpbmcgb2JqZWN0XG5cdCAqIHByaW9yIHRvIGFjdHVhbGx5IGRvaW5nIHRoZSBzYXZlLCBpbmNsdWRpbmcgYWRkaXRpb24gb3Igb3RoZXIgc3RhdGVcblx0ICogcHJvcGVydGllcyAoZm9yIHBsdWctaW5zKSBvciBtb2RpZmljYXRpb24gb2YgYSBEYXRhVGFibGVzIGNvcmUgcHJvcGVydHkuXG5cdCAqICBAbmFtZSBEYXRhVGFibGUjc3RhdGVTYXZlUGFyYW1zLmR0XG5cdCAqICBAZXZlbnRcblx0ICogIEBwYXJhbSB7ZXZlbnR9IGUgalF1ZXJ5IGV2ZW50IG9iamVjdFxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IGpzb24gVGhlIHN0YXRlIGluZm9ybWF0aW9uIHRvIGJlIHNhdmVkXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBTdGF0ZSBsb2FkIGV2ZW50LCBmaXJlZCB3aGVuIHRoZSB0YWJsZSBpcyBsb2FkaW5nIHN0YXRlIGZyb20gdGhlIHN0b3JlZFxuXHQgKiBkYXRhLCBidXQgcHJpb3IgdG8gdGhlIHNldHRpbmdzIG9iamVjdCBiZWluZyBtb2RpZmllZCBieSB0aGUgc2F2ZWQgc3RhdGVcblx0ICogLSBhbGxvd2luZyBtb2RpZmljYXRpb24gb2YgdGhlIHNhdmVkIHN0YXRlIGlzIHJlcXVpcmVkIG9yIGxvYWRpbmcgb2Zcblx0ICogc3RhdGUgZm9yIGEgcGx1Zy1pbi5cblx0ICogIEBuYW1lIERhdGFUYWJsZSNzdGF0ZUxvYWRQYXJhbXMuZHRcblx0ICogIEBldmVudFxuXHQgKiAgQHBhcmFtIHtldmVudH0gZSBqUXVlcnkgZXZlbnQgb2JqZWN0XG5cdCAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcGFyYW0ge29iamVjdH0ganNvbiBUaGUgc2F2ZWQgc3RhdGUgaW5mb3JtYXRpb25cblx0ICovXG5cblx0LyoqXG5cdCAqIFN0YXRlIGxvYWRlZCBldmVudCwgZmlyZWQgd2hlbiBzdGF0ZSBoYXMgYmVlbiBsb2FkZWQgZnJvbSBzdG9yZWQgZGF0YSBhbmRcblx0ICogdGhlIHNldHRpbmdzIG9iamVjdCBoYXMgYmVlbiBtb2RpZmllZCBieSB0aGUgbG9hZGVkIGRhdGEuXG5cdCAqICBAbmFtZSBEYXRhVGFibGUjc3RhdGVMb2FkZWQuZHRcblx0ICogIEBldmVudFxuXHQgKiAgQHBhcmFtIHtldmVudH0gZSBqUXVlcnkgZXZlbnQgb2JqZWN0XG5cdCAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcGFyYW0ge29iamVjdH0ganNvbiBUaGUgc2F2ZWQgc3RhdGUgaW5mb3JtYXRpb25cblx0ICovXG5cblx0LyoqXG5cdCAqIFByb2Nlc3NpbmcgZXZlbnQsIGZpcmVkIHdoZW4gRGF0YVRhYmxlcyBpcyBkb2luZyBzb21lIGtpbmQgb2YgcHJvY2Vzc2luZ1xuXHQgKiAoYmUgaXQsIG9yZGVyLCBzZWFyY2ggb3IgYW55dGhpbmcgZWxzZSkuIEl0IGNhbiBiZSB1c2VkIHRvIGluZGljYXRlIHRvXG5cdCAqIHRoZSBlbmQgdXNlciB0aGF0IHRoZXJlIGlzIHNvbWV0aGluZyBoYXBwZW5pbmcsIG9yIHRoYXQgc29tZXRoaW5nIGhhc1xuXHQgKiBmaW5pc2hlZC5cblx0ICogIEBuYW1lIERhdGFUYWJsZSNwcm9jZXNzaW5nLmR0XG5cdCAqICBAZXZlbnRcblx0ICogIEBwYXJhbSB7ZXZlbnR9IGUgalF1ZXJ5IGV2ZW50IG9iamVjdFxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHtib29sZWFufSBiU2hvdyBGbGFnIGZvciBpZiBEYXRhVGFibGVzIGlzIGRvaW5nIHByb2Nlc3Npbmcgb3Igbm90XG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBBamF4IChYSFIpIGV2ZW50LCBmaXJlZCB3aGVuZXZlciBhbiBBamF4IHJlcXVlc3QgaXMgY29tcGxldGVkIGZyb20gYVxuXHQgKiByZXF1ZXN0IHRvIG1hZGUgdG8gdGhlIHNlcnZlciBmb3IgbmV3IGRhdGEuIFRoaXMgZXZlbnQgaXMgY2FsbGVkIGJlZm9yZVxuXHQgKiBEYXRhVGFibGVzIHByb2Nlc3NlZCB0aGUgcmV0dXJuZWQgZGF0YSwgc28gaXQgY2FuIGFsc28gYmUgdXNlZCB0byBwcmUtXG5cdCAqIHByb2Nlc3MgdGhlIGRhdGEgcmV0dXJuZWQgZnJvbSB0aGUgc2VydmVyLCBpZiBuZWVkZWQuXG5cdCAqXG5cdCAqIE5vdGUgdGhhdCB0aGlzIHRyaWdnZXIgaXMgY2FsbGVkIGluIGBmblNlcnZlckRhdGFgLCBpZiB5b3Ugb3ZlcnJpZGVcblx0ICogYGZuU2VydmVyRGF0YWAgYW5kIHdoaWNoIHRvIHVzZSB0aGlzIGV2ZW50LCB5b3UgbmVlZCB0byB0cmlnZ2VyIGl0IGluIHlvdVxuXHQgKiBzdWNjZXNzIGZ1bmN0aW9uLlxuXHQgKiAgQG5hbWUgRGF0YVRhYmxlI3hoci5kdFxuXHQgKiAgQGV2ZW50XG5cdCAqICBAcGFyYW0ge2V2ZW50fSBlIGpRdWVyeSBldmVudCBvYmplY3Rcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0IHtAbGluayBEYXRhVGFibGUubW9kZWxzLm9TZXR0aW5nc31cblx0ICogIEBwYXJhbSB7b2JqZWN0fSBqc29uIEpTT04gcmV0dXJuZWQgZnJvbSB0aGUgc2VydmVyXG5cdCAqXG5cdCAqICBAZXhhbXBsZVxuXHQgKiAgICAgLy8gVXNlIGEgY3VzdG9tIHByb3BlcnR5IHJldHVybmVkIGZyb20gdGhlIHNlcnZlciBpbiBhbm90aGVyIERPTSBlbGVtZW50XG5cdCAqICAgICAkKCcjdGFibGUnKS5kYXRhVGFibGUoKS5vbigneGhyLmR0JywgZnVuY3Rpb24gKGUsIHNldHRpbmdzLCBqc29uKSB7XG5cdCAqICAgICAgICQoJyNzdGF0dXMnKS5odG1sKCBqc29uLnN0YXR1cyApO1xuXHQgKiAgICAgfSApO1xuXHQgKlxuXHQgKiAgQGV4YW1wbGVcblx0ICogICAgIC8vIFByZS1wcm9jZXNzIHRoZSBkYXRhIHJldHVybmVkIGZyb20gdGhlIHNlcnZlclxuXHQgKiAgICAgJCgnI3RhYmxlJykuZGF0YVRhYmxlKCkub24oJ3hoci5kdCcsIGZ1bmN0aW9uIChlLCBzZXR0aW5ncywganNvbikge1xuXHQgKiAgICAgICBmb3IgKCB2YXIgaT0wLCBpZW49anNvbi5hYURhdGEubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdCAqICAgICAgICAganNvbi5hYURhdGFbaV0uc3VtID0ganNvbi5hYURhdGFbaV0ub25lICsganNvbi5hYURhdGFbaV0udHdvO1xuXHQgKiAgICAgICB9XG5cdCAqICAgICAgIC8vIE5vdGUgbm8gcmV0dXJuIC0gbWFuaXB1bGF0ZSB0aGUgZGF0YSBkaXJlY3RseSBpbiB0aGUgSlNPTiBvYmplY3QuXG5cdCAqICAgICB9ICk7XG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBEZXN0cm95IGV2ZW50LCBmaXJlZCB3aGVuIHRoZSBEYXRhVGFibGUgaXMgZGVzdHJveWVkIGJ5IGNhbGxpbmcgZm5EZXN0cm95XG5cdCAqIG9yIHBhc3NpbmcgdGhlIGJEZXN0cm95OnRydWUgcGFyYW1ldGVyIGluIHRoZSBpbml0aWFsaXNhdGlvbiBvYmplY3QuIFRoaXNcblx0ICogY2FuIGJlIHVzZWQgdG8gcmVtb3ZlIGJvdW5kIGV2ZW50cywgYWRkZWQgRE9NIG5vZGVzLCBldGMuXG5cdCAqICBAbmFtZSBEYXRhVGFibGUjZGVzdHJveS5kdFxuXHQgKiAgQGV2ZW50XG5cdCAqICBAcGFyYW0ge2V2ZW50fSBlIGpRdWVyeSBldmVudCBvYmplY3Rcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0IHtAbGluayBEYXRhVGFibGUubW9kZWxzLm9TZXR0aW5nc31cblx0ICovXG5cblx0LyoqXG5cdCAqIFBhZ2UgbGVuZ3RoIGNoYW5nZSBldmVudCwgZmlyZWQgd2hlbiBudW1iZXIgb2YgcmVjb3JkcyB0byBzaG93IG9uIGVhY2hcblx0ICogcGFnZSAodGhlIGxlbmd0aCkgaXMgY2hhbmdlZC5cblx0ICogIEBuYW1lIERhdGFUYWJsZSNsZW5ndGguZHRcblx0ICogIEBldmVudFxuXHQgKiAgQHBhcmFtIHtldmVudH0gZSBqUXVlcnkgZXZlbnQgb2JqZWN0XG5cdCAqICBAcGFyYW0ge29iamVjdH0gbyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdCB7QGxpbmsgRGF0YVRhYmxlLm1vZGVscy5vU2V0dGluZ3N9XG5cdCAqICBAcGFyYW0ge2ludGVnZXJ9IGxlbiBOZXcgbGVuZ3RoXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBDb2x1bW4gc2l6aW5nIGhhcyBjaGFuZ2VkLlxuXHQgKiAgQG5hbWUgRGF0YVRhYmxlI2NvbHVtbi1zaXppbmcuZHRcblx0ICogIEBldmVudFxuXHQgKiAgQHBhcmFtIHtldmVudH0gZSBqUXVlcnkgZXZlbnQgb2JqZWN0XG5cdCAqICBAcGFyYW0ge29iamVjdH0gbyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdCB7QGxpbmsgRGF0YVRhYmxlLm1vZGVscy5vU2V0dGluZ3N9XG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBDb2x1bW4gdmlzaWJpbGl0eSBoYXMgY2hhbmdlZC5cblx0ICogIEBuYW1lIERhdGFUYWJsZSNjb2x1bW4tdmlzaWJpbGl0eS5kdFxuXHQgKiAgQGV2ZW50XG5cdCAqICBAcGFyYW0ge2V2ZW50fSBlIGpRdWVyeSBldmVudCBvYmplY3Rcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0IHtAbGluayBEYXRhVGFibGUubW9kZWxzLm9TZXR0aW5nc31cblx0ICogIEBwYXJhbSB7aW50fSBjb2x1bW4gQ29sdW1uIGluZGV4XG5cdCAqICBAcGFyYW0ge2Jvb2x9IHZpcyBgZmFsc2VgIGlmIGNvbHVtbiBub3cgaGlkZGVuLCBvciBgdHJ1ZWAgaWYgdmlzaWJsZVxuXHQgKi9cblxuXHRyZXR1cm4gJC5mbi5kYXRhVGFibGU7XG59KSk7XG4iXSwic291cmNlUm9vdCI6IiJ9